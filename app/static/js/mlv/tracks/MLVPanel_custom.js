/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lanceotron/src/lanceotron_tracks_index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../MLVPanel/css/mlv_panel.css":
/*!********************************!*\
  !*** .Panel/css/mlv_panel.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../MLV/node_modules/css-loader!./mlv_panel.css */ \"./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../MLV/node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvY3NzL21sdl9wYW5lbC5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLlBhbmVsL2Nzcy9tbHZfcGFuZWwuY3NzPzNmNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL01MVi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21sdl9wYW5lbC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL01MVi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9NTFYvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tbHZfcGFuZWwuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vTUxWL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbWx2X3BhbmVsLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/css/mlv_panel.css\n");

/***/ }),

/***/ "../MLVPanel/src/bam.js":
/*!*************************!*\
  !*** .Panel/src/bam.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.bgzBlockSize = exports.PairedAlignment = exports.BamAlignment = exports.BamFilter = exports.BamSource = exports.BamReader = exports.loadBamIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"../MLVPanel/src/vendor/inflate.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"../MLVPanel/src/feature.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BAI_MAGIC = 21578050;\nvar TABIX_MAGIC = 21578324;\nvar MAX_HEADER_SIZE = 100000000; // IF the header is larger than this we can't read it !\nvar B_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * @param indexURL\r\n * @param config\r\n * @param tabix\r\n *\r\n * @returns a Promised for the bam or tabix index.  The fulfill function takes the index as an argument.\r\n */\nvar loadBamIndex = function loadBamIndex(indexURL, config, tabix) {\n\n    return new Promise(function (fulfill, reject) {\n\n        var genome = null;\n\n        _igvxhr.igvxhr.loadArrayBuffer(indexURL, {\n            headers: config.headers,\n            withCredentials: config.withCredentials\n        }).then(function (arrayBuffer) {\n\n            var indices = [],\n                magic,\n                nbin,\n                nintv,\n                nref,\n                parser,\n                blockMin = Number.MAX_VALUE,\n                blockMax = 0,\n                binIndex,\n                linearIndex,\n                binNumber,\n                cs,\n                ce,\n                b,\n                i,\n                ref,\n                sequenceIndexMap;\n\n            if (!arrayBuffer) {\n                fulfill(null);\n                return;\n            }\n\n            if (tabix) {\n                var inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arrayBuffer));\n                arrayBuffer = inflate.decompress().buffer;\n            }\n\n            parser = new _bigwig.BinaryParser(new DataView(arrayBuffer));\n\n            magic = parser.getInt();\n\n            if (magic === BAI_MAGIC || tabix && magic === TABIX_MAGIC) {\n\n                nref = parser.getInt();\n\n                if (tabix) {\n                    // Tabix header parameters aren't used, but they must be read to advance the pointer\n                    var format = parser.getInt();\n                    var col_seq = parser.getInt();\n                    var col_beg = parser.getInt();\n                    var col_end = parser.getInt();\n                    var meta = parser.getInt();\n                    var skip = parser.getInt();\n                    var l_nm = parser.getInt();\n\n                    sequenceIndexMap = {};\n                    for (i = 0; i < nref; i++) {\n                        var seq_name = parser.getString();\n\n                        // Translate to \"official\" chr name.\n                        if (genome) seq_name = genome.getChromosomeName(seq_name);\n\n                        sequenceIndexMap[seq_name] = i;\n                    }\n                }\n\n                for (ref = 0; ref < nref; ++ref) {\n\n                    binIndex = {};\n                    linearIndex = [];\n\n                    nbin = parser.getInt();\n\n                    for (b = 0; b < nbin; ++b) {\n\n                        binNumber = parser.getInt();\n\n                        if (binNumber == 37450) {\n                            // This is a psuedo bin, not used but we have to consume the bytes\n                            nchnk = parser.getInt(); // # of chunks for this bin\n                            cs = parser.getVPointer(); // unmapped beg\n                            ce = parser.getVPointer(); // unmapped end\n                            var n_maped = parser.getLong();\n                            var nUnmapped = parser.getLong();\n                        } else {\n\n                            binIndex[binNumber] = [];\n                            var nchnk = parser.getInt(); // # of chunks for this bin\n\n                            for (i = 0; i < nchnk; i++) {\n                                cs = parser.getVPointer();\n                                ce = parser.getVPointer();\n                                if (cs && ce) {\n                                    if (cs.block < blockMin) {\n                                        blockMin = cs.block; // Block containing first alignment\n                                    }\n                                    if (ce.block > blockMax) {\n                                        blockMax = ce.block;\n                                    }\n                                    binIndex[binNumber].push([cs, ce]);\n                                }\n                            }\n                        }\n                    }\n\n                    nintv = parser.getInt();\n                    for (i = 0; i < nintv; i++) {\n                        cs = parser.getVPointer();\n                        linearIndex.push(cs); // Might be null\n                    }\n\n                    if (nbin > 0) {\n                        indices[ref] = {\n                            binIndex: binIndex,\n                            linearIndex: linearIndex\n                        };\n                    }\n                }\n            } else {\n                throw new Error(indexURL + \" is not a \" + (tabix ? \"tabix\" : \"bai\") + \" file\");\n            }\n            fulfill(new BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix));\n        }).catch(reject);\n    });\n};\n\nvar BamIndex = function () {\n    function BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix) {\n        _classCallCheck(this, BamIndex);\n\n        this.firstAlignmentBlock = blockMin;\n        this.indices = indices;\n        this.lastAlignmentBlock = blockMax;\n        this.sequenceIndexMap = sequenceIndexMap;\n        this.tabix = tabix;\n    }\n\n    /**\r\n     * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.\r\n     *\r\n     * @param refId  the sequence dictionary index of the chromosome\r\n     * @param min  genomic start position\r\n     * @param max  genomic end position\r\n     * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}\r\n     */\n\n\n    _createClass(BamIndex, [{\n        key: \"blocksForRange\",\n        value: function blocksForRange(refId, min, max) {\n\n            var bam = this,\n                ba = bam.indices[refId],\n                overlappingBins,\n                chunks,\n                nintv,\n                lowest,\n                minLin,\n                maxLin,\n                vp,\n                i;\n\n            if (!ba) {\n                return [];\n            } else {\n                overlappingBins = BamIndex.reg2bins(min, max);\n                chunks = []; // List of bin #s that might overlap min, max\n\n\n                overlappingBins.forEach(function (bin) {\n\n                    if (ba.binIndex[bin]) {\n                        var binChunks = ba.binIndex[bin],\n                            nchnk = binChunks.length;\n\n                        for (var c = 0; c < nchnk; ++c) {\n                            var cs = binChunks[c][0];\n                            var ce = binChunks[c][1];\n                            chunks.push({ minv: cs, maxv: ce, bin: bin });\n                        }\n                    }\n                });\n\n                // Use the linear index to find the lowest chunk that could contain alignments in the region\n                nintv = ba.linearIndex.length;\n                lowest = null;\n                minLin = Math.min(min >> 14, nintv - 1), maxLin = Math.min(max >> 14, nintv - 1);\n                for (i = minLin; i <= maxLin; ++i) {\n                    vp = ba.linearIndex[i];\n                    if (vp) {\n\n                        if (!lowest || vp.isLessThan(lowest)) {\n                            lowest = vp;\n                        }\n                    }\n                }\n                // Prune chunks that end before the lowest chunk\n                return optimizeChunks(chunks, lowest);\n            }\n        }\n    }], [{\n        key: \"reg2bins\",\n\n\n        /**\r\n         * Calculate the list of bins that may overlap with region [beg, end]\r\n         *\r\n         */\n        value: function reg2bins(beg, end) {\n            var i = 0,\n                k,\n                list = [];\n            if (end >= 1 << 29) end = 1 << 29;\n            --end;\n            list.push(0);\n            for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {\n                list.push(k);\n            }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {\n                list.push(k);\n            }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {\n                list.push(k);\n            }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {\n                list.push(k);\n            }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {\n                list.push(k);\n            }return list;\n        }\n    }]);\n\n    return BamIndex;\n}();\n\nfunction optimizeChunks(chunks, lowest) {\n\n    var mergedChunks = [],\n        lastChunk = null;\n\n    if (chunks.length === 0) return chunks;\n\n    chunks.sort(function (c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n\n    chunks.forEach(function (chunk) {\n\n        if (!lowest || chunk.maxv.isGreaterThan(lowest)) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            } else {\n                if (chunk.minv.block - lastChunk.maxv.block < 65000) {\n                    // Merge chunks that are withing 65k of each other\n                    if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                } else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    });\n\n    return mergedChunks;\n}\n\nvar BGZFile = function () {\n    function BGZFile(config) {\n        _classCallCheck(this, BGZFile);\n\n        this.filePosition = 0;\n        this.config = config;\n    }\n\n    _createClass(BGZFile, [{\n        key: \"nextBlock\",\n        value: function nextBlock() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                    headers: self.config.headers,\n                    range: { start: self.filePosition, size: BLOCK_HEADER_LENGTH },\n                    withCredentials: self.config.withCredentials\n\n                }).then(function (arrayBuffer) {\n\n                    var ba = new Uint8Array(arrayBuffer);\n                    var xlen = ba[11] << 8 | ba[10];\n                    var si1 = ba[12];\n                    var si2 = ba[13];\n                    var slen = ba[15] << 8 | ba[14];\n                    var bsize = ba[17] << 8 | ba[16] + 1;\n\n                    self.filePosition += BLOCK_HEADER_LENGTH;\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                        headers: self.config.headers,\n                        range: { start: self.filePosition, size: bsize },\n                        withCredentials: self.config.withCredentials\n\n                    }).then(function (arrayBuffer) {\n\n                        var unc = (0, _inflate.jszlib_inflate_buffer)(arrayBuffer);\n\n                        self.filePosition += bsize + 8; // \"8\" for CRC-32 and size of uncompressed data\n\n                        fulfill(unc);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BGZFile;\n}();\n\nvar BAM_MAGIC = 21840194;\nvar SECRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\nvar READ_STRAND_FLAG = 0x10;\nvar MATE_STRAND_FLAG = 0x20;\nvar FIRST_OF_PAIR_FLAG = 0x40;\nvar SECOND_OF_PAIR_FLAG = 0x80;\nvar READ_UNMAPPED_FLAG = 0x4;\nvar MATE_UNMAPPED_FLAG = 0x8;\nvar READ_PAIRED_FLAG = 0x1;\nvar PROPER_PAIR_FLAG = 0x2;\nvar SECONDARY_ALIGNMNET_FLAG = 0x100;\nvar SUPPLEMENTARY_ALIGNMENT_FLAG = 0x800;\n\nvar NOT_PRIMARY_ALIGNMENT_FLAG = 0x100;\nvar READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 0x200;\nvar DUPLICATE_READ_FLAG = 0x400;\nvar SUPPLEMENTARY_FLAG = 0x800;\n\nvar MAX_GZIP_BLOCK_SIZE = 65536; //  APPARENTLY.  Where is this documented???\nvar DEFAULT_SAMPLING_WINDOW_SIZE = 100;\nvar DEFAULT_SAMPLING_DEPTH = 50;\nvar MAXIMUM_SAMPLING_DEPTH = 2500;\n\n/**\r\n * Class for reading a bam file\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar BamReader = function () {\n    function BamReader(config) {\n        _classCallCheck(this, BamReader);\n\n        this.config = config;\n\n        this.filter = config.filter || new BamFilter();\n\n        this.bamPath = config.url;\n        // Todo - deal with Picard convention.  WHY DOES THERE HAVE TO BE 2?\n        this.baiPath = config.indexURL || this.bamPath + \".bai\"; // If there is an indexURL provided, use it!\n        this.headPath = config.headURL || this.bamPath;\n\n        this.samplingWindowSize = config.samplingWindowSize === undefined ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;\n        this.samplingDepth = config.samplingDepth === undefined ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;\n        if (this.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {\n            igv.log(\"Warning: attempt to set sampling depth > maximum value of 2500\");\n            this.samplingDepth = MAXIMUM_SAMPLING_DEPTH;\n        }\n\n        if (config.viewAsPairs) {\n            this.pairsSupported = true;\n        } else {\n            this.pairsSupported = config.pairsSupported === undefined ? true : config.pairsSupported;\n        }\n    }\n\n    _createClass(BamReader, [{\n        key: \"readAlignments\",\n        value: function readAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getChrIndex(self).then(function (chrToIndex) {\n\n                    var chrId = chrToIndex[chr],\n                        alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, self.samplingWindowSize, self.samplingDepth, self.pairsSupported);\n\n                    if (chrId === undefined) {\n                        fulfill(alignmentContainer);\n                    } else {\n\n                        getIndex(self).then(function (bamIndex) {\n\n                            var chunks = bamIndex.blocksForRange(chrId, bpStart, bpEnd),\n                                promises = [];\n\n                            if (!chunks) {\n                                fulfill(null);\n                                reject(\"Error reading bam index\");\n                                return;\n                            }\n                            if (chunks.length === 0) {\n                                fulfill(alignmentContainer);\n                                return;\n                            }\n\n                            chunks.forEach(function (c) {\n\n                                promises.push(new Promise(function (fulfill, reject) {\n\n                                    var fetchMin = c.minv.block,\n                                        fetchMax = c.maxv.block + MAX_GZIP_BLOCK_SIZE,\n                                        // Make sure we get the whole block.\n                                    range = { start: fetchMin, size: fetchMax - fetchMin + 1 };\n\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                                        headers: self.config.headers,\n                                        range: range,\n                                        withCredentials: self.config.withCredentials\n                                    }).then(function (compressed) {\n\n                                        var ba = new Uint8Array(new unbgzf(compressed)); //new Uint8Array(igv.unbgzf(compressed)); //, c.maxv.block - c.minv.block + 1));\n                                        decodeBamRecords(ba, c.minv.offset, alignmentContainer, bpStart, bpEnd, chrId, self.filter);\n\n                                        fulfill(alignmentContainer);\n                                    }).catch(function (obj) {\n                                        reject(obj);\n                                    });\n                                }));\n                            });\n\n                            Promise.all(promises).then(function (ignored) {\n                                alignmentContainer.finish();\n                                fulfill(alignmentContainer);\n                            }).catch(function (obj) {\n                                reject(obj);\n                            });\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n\n            function decodeBamRecords(ba, offset, alignmentContainer, min, max, chrId, filter) {\n\n                var blockSize, blockEnd, alignment, blocks, refID, pos, bmn, bin, mq, nl, flag_nc, flag, nc, lseq, mateRefID, matePos, readName, j, p, lengthOnRef, cigar, c, cigarArray, seq, seqBytes;\n\n                while (true) {\n\n                    blockSize = readInt(ba, offset);\n                    blockEnd = offset + blockSize + 4;\n\n                    if (blockEnd > ba.length) {\n                        return;\n                    }\n\n                    alignment = new BamAlignment();\n\n                    refID = readInt(ba, offset + 4);\n                    pos = readInt(ba, offset + 8);\n\n                    if (refID < 0) {\n                        return; // unmapped reads\n                    } else if (refID > chrId || pos > max) {\n                        return; // off right edge, we're done\n                    } else if (refID < chrId) {\n                        continue; // to left of start, not sure this is possible\n                    }\n\n                    bmn = readInt(ba, offset + 12);\n                    bin = (bmn & 0xffff0000) >> 16;\n                    mq = (bmn & 0xff00) >> 8;\n                    nl = bmn & 0xff;\n\n                    flag_nc = readInt(ba, offset + 16);\n                    flag = (flag_nc & 0xffff0000) >> 16;\n                    nc = flag_nc & 0xffff;\n\n                    alignment.flags = flag;\n                    alignment.strand = !(flag & READ_STRAND_FLAG);\n\n                    lseq = readInt(ba, offset + 20);\n\n                    mateRefID = readInt(ba, offset + 24);\n                    matePos = readInt(ba, offset + 28);\n                    alignment.fragmentLength = readInt(ba, offset + 32);\n\n                    readName = '';\n                    for (j = 0; j < nl - 1; ++j) {\n                        readName += String.fromCharCode(ba[offset + 36 + j]);\n                    }\n\n                    p = offset + 36 + nl;\n\n                    lengthOnRef = 0;\n                    cigar = '';\n\n                    cigarArray = [];\n                    for (c = 0; c < nc; ++c) {\n                        var cigop = readInt(ba, p);\n                        var opLen = cigop >> 4;\n                        var opLtr = CIGAR_DECODER[cigop & 0xf];\n                        if (opLtr == 'M' || opLtr == 'EQ' || opLtr == 'X' || opLtr == 'D' || opLtr == 'N' || opLtr == '=') lengthOnRef += opLen;\n                        cigar = cigar + opLen + opLtr;\n                        p += 4;\n\n                        cigarArray.push({ len: opLen, ltr: opLtr });\n                    }\n                    alignment.cigar = cigar;\n                    alignment.lengthOnRef = lengthOnRef;\n\n                    if (alignment.start + alignment.lengthOnRef < min) continue; // Record out-of-range \"to the left\", skip to next one\n\n\n                    seq = '';\n                    seqBytes = lseq + 1 >> 1;\n                    for (j = 0; j < seqBytes; ++j) {\n                        var sb = ba[p + j];\n                        seq += SECRET_DECODER[(sb & 0xf0) >> 4];\n                        seq += SECRET_DECODER[sb & 0x0f];\n                    }\n                    seq = seq.substring(0, lseq); // seq might have one extra character (if lseq is an odd number)\n\n                    p += seqBytes;\n                    alignment.seq = seq;\n\n                    if (lseq === 1 && String.fromCharCode(ba[p + j] + 33) === \"*\") {\n                        // TODO == how to represent this?\n                    } else {\n                        alignment.qual = [];\n                        for (j = 0; j < lseq; ++j) {\n                            alignment.qual.push(ba[p + j]);\n                        }\n                    }\n                    p += lseq;\n\n                    alignment.start = pos;\n                    alignment.mq = mq;\n                    alignment.readName = readName;\n                    alignment.chr = self.indexToChr[refID];\n\n                    if (mateRefID >= 0) {\n                        alignment.mate = {\n                            chr: self.indexToChr[mateRefID],\n                            position: matePos,\n                            strand: !(flag & MATE_STRAND_FLAG)\n                        };\n                    }\n\n                    alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd)); // decode thiese on demand\n                    p += blockEnd;\n\n                    if (!min || alignment.start <= max && alignment.start + alignment.lengthOnRef >= min && filter.pass(alignment)) {\n                        if (chrId === undefined || refID == chrId) {\n                            blocks = makeBlocks(alignment, cigarArray);\n                            alignment.blocks = blocks.blocks;\n                            alignment.insertions = blocks.insertions;\n                            alignmentContainer.push(alignment);\n                        }\n                    }\n                    offset = blockEnd;\n                }\n                // Exits via top of loop.\n            }\n\n            /**\r\n             * Split the alignment record into blocks as specified in the cigarArray.  Each aligned block contains\r\n             * its portion of the read sequence and base quality strings.  A read sequence or base quality string\r\n             * of \"*\" indicates the value is not recorded.  In all other cases the length of the block sequence (block.seq)\r\n             * and quality string (block.qual) must == the block length.\r\n             *\r\n             * NOTE: Insertions are not yet treated // TODO\r\n             *\r\n             * @param record\r\n             * @param cigarArray\r\n             * @returns array of blocks\r\n             */\n            function makeBlocks(record, cigarArray) {\n\n                var blocks = [],\n                    insertions,\n                    seqOffset = 0,\n                    pos = record.start,\n                    len = cigarArray.length,\n                    blockSeq,\n                    blockQuals,\n                    gapType,\n                    minQ = 5,\n                    //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN)\n                maxQ = 20; //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX)\n\n                for (var i = 0; i < len; i++) {\n\n                    var c = cigarArray[i];\n\n                    switch (c.ltr) {\n                        case 'H':\n                            break; // ignore hard clips\n                        case 'P':\n                            break; // ignore pads\n                        case 'S':\n                            seqOffset += c.len;\n                            gapType = 'S';\n                            break; // soft clip read bases\n                        case 'N':\n                            pos += c.len;\n                            gapType = 'N';\n                            break; // reference skip\n                        case 'D':\n                            pos += c.len;\n                            gapType = 'D';\n                            break;\n                        case 'I':\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            if (insertions === undefined) insertions = [];\n                            insertions.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals });\n                            seqOffset += c.len;\n                            break;\n                        case 'M':\n                        case 'EQ':\n                        case '=':\n                        case 'X':\n\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            blocks.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals, gapType: gapType });\n                            seqOffset += c.len;\n                            pos += c.len;\n\n                            break;\n\n                        default:\n                            console.log(\"Error processing cigar element: \" + c.len + c.ltr);\n                    }\n                }\n\n                return { blocks: blocks, insertions: insertions };\n            }\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getIndex(self).then(function (index) {\n\n                    var len = index.firstAlignmentBlock + MAX_GZIP_BLOCK_SIZE; // Insure we get the complete compressed block containing the header\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                        headers: self.config.headers,\n\n                        range: { start: 0, size: len },\n\n                        withCredentials: self.config.withCredentials\n                    }).then(function (compressedBuffer) {\n\n                        var unc = new unbgzf(compressedBuffer, len),\n                            uncba = new Uint8Array(unc),\n                            magic = readInt(uncba, 0),\n                            samHeaderLen = readInt(uncba, 4),\n                            samHeader = '',\n                            genome = null;\n\n                        for (var i = 0; i < samHeaderLen; ++i) {\n                            samHeader += String.fromCharCode(uncba[i + 8]);\n                        }\n\n                        var nRef = readInt(uncba, samHeaderLen + 8);\n                        var p = samHeaderLen + 12;\n\n                        self.chrToIndex = {};\n                        self.indexToChr = [];\n                        for (var i = 0; i < nRef; ++i) {\n                            var lName = readInt(uncba, p);\n                            var name = '';\n                            for (var j = 0; j < lName - 1; ++j) {\n                                name += String.fromCharCode(uncba[p + 4 + j]);\n                            }\n                            var lRef = readInt(uncba, p + lName + 4);\n                            //dlog(name + ': ' + lRef);\n\n                            if (genome && genome.getChromosomeName) {\n                                name = genome.getChromosomeName(name);\n                            }\n\n                            self.chrToIndex[name] = i;\n                            self.indexToChr.push(name);\n\n                            p = p + 8 + lName;\n                        }\n\n                        fulfill();\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BamReader;\n}();\n\nfunction getIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.index) {\n            fulfill(bam.index);\n        } else {\n            loadBamIndex(bam.baiPath, bam.config).then(function (index) {\n                bam.index = index;\n\n                fulfill(bam.index);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction getChrIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.chrToIndex) {\n            fulfill(bam.chrToIndex);\n        } else {\n            bam.readHeader().then(function () {\n                fulfill(bam.chrToIndex);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction readInt(ba, offset) {\n    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];\n}\n\nfunction readShort(ba, offset) {\n    return ba[offset + 1] << 8 | ba[offset];\n}\n\nvar BamSource = function () {\n    function BamSource(config) {\n        _classCallCheck(this, BamSource);\n\n        this.config = config;\n        this.alignmentContainer = undefined;\n        this.maxRows = config.maxRows || 1000;\n        if (config.seq_url) {\n            this.sequence_source = new _feature.FastaSequence(config.seq_url);\n        }\n\n        if (config.sourceType === \"ga4gh\") {\n            this.bamReader = new igv.Ga4ghAlignmentReader(config);\n        } else {\n            this.bamReader = new BamReader(config);\n        }\n\n        this.viewAsPairs = true;\n    }\n\n    _createClass(BamSource, [{\n        key: \"setViewAsPairs\",\n        value: function setViewAsPairs(bool) {\n            var self = this;\n\n            if (this.viewAsPairs !== bool) {\n                this.viewAsPairs = bool;\n                // TODO -- repair alignments\n                if (this.alignmentContainer) {\n                    var alignmentContainer = this.alignmentContainer,\n                        alignments;\n\n                    if (bool) {\n                        alignments = pairAlignments(alignmentContainer.packedAlignmentRows);\n                    } else {\n                        alignments = unpairAlignments(alignmentContainer.packedAlignmentRows);\n                    }\n                    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, self.maxRows);\n                }\n            }\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n\n                if (self.alignmentContainer && self.alignmentContainer.contains(chr, bpStart, bpEnd)) {\n                    fulfill(self.alignmentContainer);\n                } else {\n\n                    self.bamReader.readAlignments(chr, bpStart, bpEnd).then(function (alignmentContainer) {\n\n                        var maxRows = self.config.maxRows || 500,\n                            alignments = alignmentContainer.alignments;\n\n                        if (!self.viewAsPairs) {\n                            alignments = unpairAlignments([{ alignments: alignments }]);\n                        }\n\n                        alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, maxRows);\n\n                        alignmentContainer.alignments = undefined; // Don't need to hold onto these anymore\n                        self.alignmentContainer = alignmentContainer;\n                        if (self.sequence_source) {\n                            self.sequence_source.getSequence(alignmentContainer.chr, alignmentContainer.start, alignmentContainer.end).then(function (sequence) {\n\n                                if (sequence) {\n\n                                    alignmentContainer.coverageMap.refSeq = sequence; // TODO -- fix this\n                                    alignmentContainer.sequence = sequence; // TODO -- fix this\n\n\n                                    fulfill(alignmentContainer);\n                                }\n                            }).catch(reject);\n                        } else {\n                            fulfill(alignmentContainer);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BamSource;\n}();\n\nfunction pairAlignments(rows) {\n\n    var pairCache = {},\n        result = [];\n\n    rows.forEach(function (row) {\n\n        row.alignments.forEach(function (alignment) {\n\n            var pairedAlignment;\n\n            if (canBePaired(alignment)) {\n\n                pairedAlignment = pairCache[alignment.readName];\n                if (pairedAlignment) {\n                    pairedAlignment.setSecondAlignment(alignment);\n                    pairCache[alignment.readName] = undefined; // Don't need to track this anymore.\n                } else {\n                    pairedAlignment = new igv.PairedAlignment(alignment);\n                    pairCache[alignment.readName] = pairedAlignment;\n                    result.push(pairedAlignment);\n                }\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction unpairAlignments(rows) {\n    var result = [];\n    rows.forEach(function (row) {\n        row.alignments.forEach(function (alignment) {\n            if (alignment instanceof PairedAlignment) {\n                if (alignment.firstAlignment) result.push(alignment.firstAlignment); // shouldn't need the null test\n                if (alignment.secondAlignment) result.push(alignment.secondAlignment);\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction canBePaired(alignment) {\n    return alignment.isPaired() && alignment.isMateMapped() && alignment.chr === alignment.mate.chr && (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());\n}\n\nfunction packAlignmentRows(alignments, start, end, maxRows) {\n\n    if (!alignments) return;\n\n    alignments.sort(function (a, b) {\n        return a.start - b.start;\n    });\n\n    if (alignments.length === 0) {\n\n        return [];\n    } else {\n\n        var bucketList = [],\n            allocatedCount = 0,\n            lastAllocatedCount = 0,\n            nextStart = start,\n            alignmentRow,\n            index,\n            bucket,\n            alignment,\n            alignmentSpace = 4 * 2,\n            packedAlignmentRows = [],\n            bucketStart = Math.max(start, alignments[0].start);\n\n        alignments.forEach(function (alignment) {\n\n            var buckListIndex = Math.max(0, alignment.start - bucketStart);\n            if (bucketList[buckListIndex] === undefined) {\n                bucketList[buckListIndex] = [];\n            }\n            bucketList[buckListIndex].push(alignment);\n        });\n\n        while (allocatedCount < alignments.length && packedAlignmentRows.length < maxRows) {\n\n            alignmentRow = new BamAlignmentRow();\n\n            while (nextStart <= end) {\n\n                bucket = undefined;\n\n                while (!bucket && nextStart <= end) {\n\n                    index = nextStart - bucketStart;\n                    if (bucketList[index] === undefined) {\n                        ++nextStart; // No alignments at this index\n                    } else {\n                        bucket = bucketList[index];\n                    }\n                } // while (bucket)\n\n                if (!bucket) {\n                    break;\n                }\n                alignment = bucket.pop();\n                if (0 === bucket.length) {\n                    bucketList[index] = undefined;\n                }\n\n                alignmentRow.alignments.push(alignment);\n                nextStart = alignment.start + alignment.lengthOnRef + alignmentSpace;\n                ++allocatedCount;\n            } // while (nextStart)\n\n            if (alignmentRow.alignments.length > 0) {\n                packedAlignmentRows.push(alignmentRow);\n            }\n\n            nextStart = bucketStart;\n\n            if (allocatedCount === lastAllocatedCount) break; // Protect from infinite loops\n\n            lastAllocatedCount = allocatedCount;\n        } // while (allocatedCount)\n\n        return packedAlignmentRows;\n    }\n}\n\nvar BamAlignment = function () {\n    function BamAlignment() {\n        _classCallCheck(this, BamAlignment);\n\n        this.hidden = false;\n    }\n\n    _createClass(BamAlignment, [{\n        key: \"isMapped\",\n        value: function isMapped() {\n            return (this.flags & READ_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return (this.flags & READ_PAIRED_FLAG) != 0;\n        }\n    }, {\n        key: \"isProperPair\",\n        value: function isProperPair() {\n            return (this.flags & PROPER_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isFirstOfPair\",\n        value: function isFirstOfPair() {\n            return (this.flags & FIRST_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondOfPair\",\n        value: function isSecondOfPair() {\n            return (this.flags & SECOND_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondary\",\n        value: function isSecondary() {\n            return (this.flags & SECONDARY_ALIGNMNET_FLAG) != 0;\n        }\n    }, {\n        key: \"isSupplementary\",\n        value: function isSupplementary() {\n            return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) != 0;\n        }\n    }, {\n        key: \"isFailsVendorQualityCheck\",\n        value: function isFailsVendorQualityCheck() {\n            return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) != 0;\n        }\n    }, {\n        key: \"isDuplicate\",\n        value: function isDuplicate() {\n            return (this.flags & DUPLICATE_READ_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateMapped\",\n        value: function isMateMapped() {\n            return (this.flags & MATE_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isNegativeStrand\",\n        value: function isNegativeStrand() {\n            return (this.flags & READ_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateNegativeStrand\",\n        value: function isMateNegativeStrand() {\n            return (this.flags & MATE_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"tags\",\n        value: function tags() {\n\n            function decodeTags(ba) {\n\n                var p = 0,\n                    len = ba.length,\n                    tags = {};\n\n                while (p < len) {\n                    var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\n                    var type = String.fromCharCode(ba[p + 2]);\n                    var value;\n\n                    if (type == 'A') {\n                        value = String.fromCharCode(ba[p + 3]);\n                        p += 4;\n                    } else if (type === 'i' || type === 'I') {\n                        value = readInt(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'c' || type === 'C') {\n                        value = ba[p + 3];\n                        p += 4;\n                    } else if (type === 's' || type === 'S') {\n                        value = readShort(ba, p + 3);\n                        p += 5;\n                    } else if (type === 'f') {\n                        // TODO 'FIXME need floats';\n                        value = readFloat(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'Z') {\n                        p += 3;\n                        value = '';\n                        for (;;) {\n                            var cc = ba[p++];\n                            if (cc === 0) {\n                                break;\n                            } else {\n                                value += String.fromCharCode(cc);\n                            }\n                        }\n                    } else {\n                        //'Unknown type ' + type;\n                        value = 'Error unknown type: ' + type;\n                        tags[tag] = value;\n                        break;\n                    }\n                    tags[tag] = value;\n                }\n                return tags;\n            }\n\n            if (!this.tagDict) {\n                if (this.tagBA) {\n                    this.tagDict = decodeTags(this.tagBA);\n                    this.tagBA = undefined;\n                } else {\n                    this.tagDict = {}; // Mark so we don't try again.  The record has not tags\n                }\n            }\n            return this.tagDict;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            // if the user clicks on a base next to an insertion, show just the\n            // inserted bases in a popup (like in desktop IGV).\n            var nameValues = [],\n                isFirst,\n                tagDict;\n\n            if (this.insertions) {\n                for (var i = 0; i < this.insertions.length; i += 1) {\n                    var ins_start = this.insertions[i].start;\n                    if (genomicLocation == ins_start || genomicLocation == ins_start - 1) {\n                        nameValues.push({ name: 'Insertion', value: this.insertions[i].seq });\n                        nameValues.push({ name: 'Location', value: ins_start });\n                        return nameValues;\n                    }\n                }\n            }\n\n            nameValues.push({ name: 'Read Name', value: this.readName });\n\n            // Sample\n            // Read group\n            nameValues.push(\"<hr>\");\n\n            // Add 1 to genomic location to map from 0-based computer units to user-based units\n            nameValues.push({ name: 'Alignment Start', value: igv.numberFormatter(1 + this.start), borderTop: true });\n\n            nameValues.push({ name: 'Read Strand', value: true === this.strand ? '(+)' : '(-)', borderTop: true });\n            nameValues.push({ name: 'Cigar', value: this.cigar });\n            nameValues.push({ name: 'Mapped', value: yesNo(this.isMapped()) });\n            nameValues.push({ name: 'Mapping Quality', value: this.mq });\n            nameValues.push({ name: 'Secondary', value: yesNo(this.isSecondary()) });\n            nameValues.push({ name: 'Supplementary', value: yesNo(this.isSupplementary()) });\n            nameValues.push({ name: 'Duplicate', value: yesNo(this.isDuplicate()) });\n            nameValues.push({ name: 'Failed QC', value: yesNo(this.isFailsVendorQualityCheck()) });\n\n            if (this.isPaired()) {\n                nameValues.push(\"<hr>\");\n                nameValues.push({ name: 'First in Pair', value: !this.isSecondOfPair(), borderTop: true });\n                nameValues.push({ name: 'Mate is Mapped', value: yesNo(this.isMateMapped()) });\n                if (this.isMateMapped()) {\n                    nameValues.push({ name: 'Mate Chromosome', value: this.mate.chr });\n                    nameValues.push({ name: 'Mate Start', value: this.mate.position + 1 });\n                    nameValues.push({ name: 'Mate Strand', value: true === this.mate.strand ? '(+)' : '(-)' });\n                    nameValues.push({ name: 'Insert Size', value: this.fragmentLength });\n                    // Mate Start\n                    // Mate Strand\n                    // Insert Size\n                }\n                // First in Pair\n                // Pair Orientation\n            }\n\n            nameValues.push(\"<hr>\");\n            tagDict = this.tags();\n            isFirst = true;\n            for (var key in tagDict) {\n\n                if (tagDict.hasOwnProperty(key)) {\n\n                    if (isFirst) {\n                        nameValues.push({ name: key, value: tagDict[key], borderTop: true });\n                        isFirst = false;\n                    } else {\n                        nameValues.push({ name: key, value: tagDict[key] });\n                    }\n                }\n            }\n\n            return nameValues;\n\n            function yesNo(bool) {\n                return bool ? 'Yes' : 'No';\n            }\n        }\n    }]);\n\n    return BamAlignment;\n}();\n\nfunction readFloat(ba, offset) {\n\n    var dataView = new DataView(ba.buffer),\n        littleEndian = true;\n\n    return dataView.getFloat32(offset, littleEndian);\n}\n\nvar BamFilter = function () {\n    function BamFilter(options) {\n        _classCallCheck(this, BamFilter);\n\n        if (!options) options = {};\n        this.vendorFailed = options.vendorFailed === undefined ? true : options.vendorFailed;\n        this.duplicates = options.duplicates === undefined ? true : options.duplicates;\n        this.secondary = options.secondary || false;\n        this.supplementary = options.supplementary || false;\n        this.mqThreshold = options.mqThreshold === undefined ? 0 : options.mqThreshold;\n    }\n\n    _createClass(BamFilter, [{\n        key: \"pass\",\n        value: function pass(alignment) {\n\n            if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;\n            if (this.duplicates && alignment.isDuplicate()) return false;\n            if (this.secondary && alignment.isSecondary()) return false;\n            if (this.supplementary && alignment.isSupplementary()) return false;\n            if (alignment.mq < this.mqThreshold) return false;\n\n            return true;\n        }\n    }]);\n\n    return BamFilter;\n}();\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\n\nvar unbgzf = function unbgzf(data, lim) {\n    _classCallCheck(this, unbgzf);\n\n    for (var a in data) {\n        console.log(a);\n    }\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nvar AlignmentContainer = function () {\n    function AlignmentContainer(chr, start, end, samplingWindowSize, samplingDepth, pairsSupported) {\n        _classCallCheck(this, AlignmentContainer);\n\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.length = end - start;\n\n        this.coverageMap = new CoverageMap(chr, start, end);\n        this.alignments = [];\n        this.downsampledIntervals = [];\n\n        this.samplingWindowSize = samplingWindowSize === undefined ? 100 : samplingWindowSize;\n        this.samplingDepth = samplingDepth === undefined ? 50 : samplingDepth;\n\n        this.pairsSupported = pairsSupported;\n        this.paired = false; // false until proven otherwise\n        this.pairsCache = {}; // working cache of paired alignments by read name\n\n        this.downsampledReads = new Set();\n\n        this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);\n\n        this.filter = function filter(alignment) {\n            // TODO -- pass this in\n            return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();\n        };\n    }\n\n    _createClass(AlignmentContainer, [{\n        key: \"push\",\n        value: function push(alignment) {\n\n            if (this.filter(alignment) === false) return;\n\n            this.coverageMap.incCounts(alignment); // Count coverage before any downsampling\n\n            if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {\n                return; // Mate already downsampled -- pairs are treated as a single alignment for downsampling\n            }\n\n            if (alignment.start >= this.currentBucket.end) {\n                finishBucket.call(this);\n                this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);\n            }\n\n            this.currentBucket.addAlignment(alignment);\n        }\n    }, {\n        key: \"forEach\",\n        value: function forEach(callback) {\n            this.alignments.forEach(callback);\n        }\n    }, {\n        key: \"finish\",\n        value: function finish() {\n\n            if (this.currentBucket !== undefined) {\n                finishBucket.call(this);\n            }\n\n            // Need to remove partial pairs whose mate was downsampled\n            if (this.pairsSupported) {\n                var tmp = [],\n                    ds = this.downsampledReads;\n\n                this.alignments.forEach(function (a) {\n                    if (!ds.has(a.readName)) {\n                        tmp.push(a);\n                    }\n                });\n                this.alignments = tmp;\n            }\n\n            this.alignments.sort(function (a, b) {\n                return a.start - b.start;\n            });\n\n            this.pairsCache = undefined;\n            this.downsampledReads = undefined;\n        }\n    }, {\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"hasDownsampledIntervals\",\n        value: function hasDownsampledIntervals() {\n            return this.downsampledIntervals && this.downsampledIntervals.length > 0;\n        }\n    }]);\n\n    return AlignmentContainer;\n}();\n\nfunction finishBucket() {\n    this.alignments = this.alignments.concat(this.currentBucket.alignments);\n    if (this.currentBucket.downsampledCount > 0) {\n        this.downsampledIntervals.push(new DownsampledInterval(this.currentBucket.start, this.currentBucket.end, this.currentBucket.downsampledCount));\n    }\n    this.paired = this.paired || this.currentBucket.paired;\n}\n\nvar DownsampleBucket = function () {\n    function DownsampleBucket(start, end, alignmentContainer) {\n        _classCallCheck(this, DownsampleBucket);\n\n        this.start = start;\n        this.end = end;\n        this.alignments = [];\n        this.downsampledCount = 0;\n        this.samplingDepth = alignmentContainer.samplingDepth;\n        this.pairsSupported = alignmentContainer.pairsSupported;\n        this.downsampledReads = alignmentContainer.downsampledReads;\n        this.pairsCache = alignmentContainer.pairsCache;\n    }\n\n    _createClass(DownsampleBucket, [{\n        key: \"addAlignment\",\n        value: function addAlignment(alignment) {\n\n            var samplingProb, idx, replacedAlignment, pairedAlignment;\n\n            if (this.alignments.length < this.samplingDepth) {\n\n                if (this.pairsSupported && canBePaired(alignment)) {\n                    pairedAlignment = this.pairsCache[alignment.readName];\n                    if (pairedAlignment) {\n                        //Not subject to downsampling, just update the existing alignment\n                        pairedAlignment.setSecondAlignment(alignment);\n                        this.pairsCache[alignment.readName] = undefined; // Don't need to track this anymore. NOTE: Don't \"delete\", causes runtime performance issues\n                    } else {\n                        // First alignment in a pair\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments.push(pairedAlignment);\n                    }\n                } else {\n                    this.alignments.push(alignment);\n                }\n            } else {\n\n                samplingProb = this.samplingDepth / (this.samplingDepth + this.downsampledCount + 1);\n\n                if (Math.random() < samplingProb) {\n\n                    idx = Math.floor(Math.random() * (this.alignments.length - 1));\n                    replacedAlignment = this.alignments[idx]; // To be replaced\n\n                    if (this.pairsSupported && canBePaired(alignment)) {\n\n                        if (this.pairsCache[replacedAlignment.readName] !== undefined) {\n                            this.pairsCache[replacedAlignment.readName] = undefined;\n                        }\n\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments[idx] = pairedAlignment;\n                    } else {\n                        this.alignments[idx] = alignment;\n                    }\n                    this.downsampledReads.add(replacedAlignment.readName);\n                } else {\n                    this.downsampledReads.add(alignment.readName);\n                }\n\n                this.downsampledCount++;\n            }\n        }\n    }]);\n\n    return DownsampleBucket;\n}();\n\n// TODO -- refactor this to use an object, rather than an array,  if end-start is > some threshold\n\n\nvar CoverageMap = function () {\n    function CoverageMap(chr, start, end) {\n        _classCallCheck(this, CoverageMap);\n\n        this.chr = chr;\n        this.bpStart = start;\n        this.length = end - start;\n\n        this.coverage = new Array(this.length);\n\n        this.maximum = 0;\n    }\n\n    _createClass(CoverageMap, [{\n        key: \"incCounts\",\n        value: function incCounts(alignment) {\n\n            var self = this;\n\n            if (alignment.blocks === undefined) {\n\n                incBlockCount(alignment);\n            } else {\n                alignment.blocks.forEach(function (block) {\n                    incBlockCount(block);\n                });\n            }\n\n            function incBlockCount(block) {\n\n                var key, base, i, j, q;\n\n                for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\n\n                    if (!self.coverage[i]) {\n                        self.coverage[i] = new Coverage();\n                    }\n\n                    base = block.seq.charAt(j);\n                    key = alignment.strand ? \"pos\" + base : \"neg\" + base;\n                    q = block.qual[j];\n\n                    self.coverage[i][key] += 1;\n                    self.coverage[i][\"qual\" + base] += q;\n\n                    self.coverage[i].total += 1;\n                    self.coverage[i].qual += q;\n\n                    self.maximum = Math.max(self.coverage[i].total, self.maximum);\n                }\n            }\n        }\n    }]);\n\n    return CoverageMap;\n}();\n\nCoverageMap.threshold = 0.2;\nCoverageMap.qualityWeight = true;\n\nvar Coverage = function () {\n    function Coverage() {\n        _classCallCheck(this, Coverage);\n\n        this.posA = 0;\n        this.negA = 0;\n\n        this.posT = 0;\n        this.negT = 0;\n\n        this.posC = 0;\n        this.negC = 0;\n        this.posG = 0;\n\n        this.negG = 0;\n\n        this.posN = 0;\n        this.negN = 0;\n\n        this.pos = 0;\n        this.neg = 0;\n\n        this.qualA = 0;\n        this.qualT = 0;\n        this.qualC = 0;\n        this.qualG = 0;\n        this.qualN = 0;\n\n        this.qual = 0;\n\n        this.total = 0;\n    }\n\n    _createClass(Coverage, [{\n        key: \"isMismatch\",\n        value: function isMismatch(refBase) {\n\n            var myself = this,\n                mismatchQualitySum,\n                threshold = CoverageMap.threshold * (CoverageMap.qualityWeight && this.qual ? this.qual : this.total);\n\n            mismatchQualitySum = 0;\n            [\"A\", \"T\", \"C\", \"G\"].forEach(function (base) {\n\n                if (base !== refBase) {\n                    mismatchQualitySum += CoverageMap.qualityWeight && myself.qual ? myself[\"qual\" + base] : myself[\"pos\" + base] + myself[\"neg\" + base];\n                }\n            });\n\n            return mismatchQualitySum >= threshold;\n        }\n    }]);\n\n    return Coverage;\n}();\n\nvar DownsampledInterval = function () {\n    function DownsampledInterval(start, end, counts) {\n        _classCallCheck(this, DownsampledInterval);\n\n        this.start = start;\n        this.end = end;\n        this.counts = counts;\n    }\n\n    _createClass(DownsampledInterval, [{\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n            return [{ name: \"start\", value: this.start + 1 }, { name: \"end\", value: this.end }, { name: \"# downsampled:\", value: this.counts }];\n        }\n    }]);\n\n    return DownsampledInterval;\n}();\n\nvar PairedAlignment = function () {\n    function PairedAlignment(firstAlignment) {\n        _classCallCheck(this, PairedAlignment);\n\n        this.firstAlignment = firstAlignment;\n        this.chr = firstAlignment.chr;\n        this.readName = firstAlignment.readName;\n\n        if (firstAlignment.start < firstAlignment.mate.position) {\n            this.start = firstAlignment.start;\n            this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef); // Approximate\n            this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingEnd = firstAlignment.mate.position;\n        } else {\n            this.start = firstAlignment.mate.position;\n            this.end = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingStart = firstAlignment.mate.position;\n            this.connectingEnd = firstAlignment.start;\n        }\n        this.lengthOnRef = this.end - this.start;\n    }\n\n    _createClass(PairedAlignment, [{\n        key: \"setSecondAlignment\",\n        value: function setSecondAlignment(alignment) {\n\n            // TODO -- check the chrs are equal,  error otherwise\n            this.secondAlignment = alignment;\n\n            if (alignment.start > this.firstAlignment.start) {\n                this.end = alignment.start + alignment.lengthOnRef;\n                this.connectingEnd = alignment.start;\n            } else {\n                this.start = alignment.start;\n                this.connectingStart = alignment.start + alignment.lengthOnRef;\n            }\n            this.lengthOnRef = this.end - this.start;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            var nameValues = [];\n\n            nameValues = nameValues.concat(this.firstAlignment.popupData(genomicLocation));\n\n            if (this.secondAlignment) {\n                nameValues.push(\"-------------------------------\");\n                nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));\n            }\n            return nameValues;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return true; // By definition\n        }\n    }, {\n        key: \"firstOfPairStrand\",\n        value: function firstOfPairStrand() {\n            if (this.firstAlignment.isFirstOfPair()) {\n                return this.firstAlignment.strand;\n            } else if (this.secondAlignment) {\n                return this.secondAlignment.strand;\n            } else {\n                return this.firstAlignment.strand; // This assumes inward pointing pairs\n            }\n        }\n    }]);\n\n    return PairedAlignment;\n}();\n\nvar BamAlignmentRow = function () {\n    function BamAlignmentRow() {\n        _classCallCheck(this, BamAlignmentRow);\n\n        this.alignments = [];\n        this.score = undefined;\n    }\n\n    _createClass(BamAlignmentRow, [{\n        key: \"findCenterAlignment\",\n        value: function findCenterAlignment(bpStart, bpEnd) {\n\n            var centerAlignment = undefined;\n\n            // find single alignment that overlaps sort location\n            this.alignments.forEach(function (a) {\n\n                if (undefined === centerAlignment) {\n\n                    if (a.start + a.lengthOnRef < bpStart || a.start > bpEnd) {\n                        // do nothing\n                    } else {\n                        centerAlignment = a;\n                    }\n                }\n            });\n\n            return centerAlignment;\n        }\n    }, {\n        key: \"updateScore\",\n        value: function updateScore(genomicLocation, genomicInterval, sortOption) {\n\n            this.score = this.caculateScore(genomicLocation, 1 + genomicLocation, genomicInterval, sortOption);\n        }\n    }, {\n        key: \"caculateScore\",\n        value: function caculateScore(bpStart, bpEnd, genomicInterval, sortOption) {\n\n            var baseScore, alignment;\n\n            alignment = this.findCenterAlignment(bpStart, bpEnd);\n            if (undefined === alignment) {\n                return Number.MAX_VALUE;\n            }\n\n            if (\"NUCLEOTIDE\" === sortOption.sort) {\n\n                baseScore = undefined;\n\n                alignment.blocks.forEach(function (block) {\n\n                    var sequence = genomicInterval.sequence,\n                        coverageMap = genomicInterval.coverageMap,\n                        reference,\n                        base,\n                        coverage,\n                        count,\n                        phred;\n\n                    if (\"*\" !== block.seq) {\n\n                        for (var i = 0, indexReferenceSequence = block.start - genomicInterval.start, bpBlockSequence = block.start, lengthBlockSequence = block.seq.length; i < lengthBlockSequence; i++, indexReferenceSequence++, bpBlockSequence++) {\n\n                            if (bpStart === bpBlockSequence) {\n\n                                reference = sequence.charAt(indexReferenceSequence);\n                                base = block.seq.charAt(i);\n\n                                if (base === \"=\") {\n                                    base = reference;\n                                }\n\n                                if (base === 'N') {\n                                    baseScore = 2;\n                                } else if (base === reference) {\n                                    baseScore = 3;\n                                } else if (base === \"X\" || base !== reference) {\n\n                                    coverage = coverageMap.coverage[bpBlockSequence - coverageMap.bpStart];\n                                    count = coverage[\"pos\" + base] + coverage[\"neg\" + base];\n                                    phred = coverage.qual ? coverage.qual : 0;\n                                    baseScore = -(count + phred / 1000.0);\n                                } else {\n                                    console.log(\"BamAlignmentRow.caculateScore - huh?\");\n                                }\n                            } // bpStart === bpBlockSequence\n                        } // block.seq.length\n                    } else {\n                        baseScore = 3;\n                    }\n                });\n\n                return undefined === baseScore ? Number.MAX_VALUE : baseScore;\n            } else if (\"STRAND\" === sortOption.sort) {\n\n                return alignment.strand ? 1 : -1;\n            } else if (\"START\" === sortOption.sort) {\n\n                return alignment.start;\n            }\n\n            return Number.MAX_VALUE;\n        }\n    }]);\n\n    return BamAlignmentRow;\n}();\n\nvar bgzBlockSize = function bgzBlockSize(data) {\n    var ba = new Uint8Array(data);\n    var bsize = ba[17] << 8 | ba[16] + 1;\n    return bsize;\n};\n\nexports.loadBamIndex = loadBamIndex;\nexports.BamReader = BamReader;\nexports.BamSource = BamSource;\nexports.BamFilter = BamFilter;\nexports.BamAlignment = BamAlignment;\nexports.PairedAlignment = PairedAlignment;\nexports.bgzBlockSize = bgzBlockSize;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! .Panel/src/vendor/zlib_and_gzip.min.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JhbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmFtLmpzP2YzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge2lndnhocn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcbmltcG9ydCB7QmluYXJ5UGFyc2VyfSBmcm9tIFwiLi9iaWd3aWcuanNcIjtcclxuaW1wb3J0IHtqc3psaWJfaW5mbGF0ZV9idWZmZXIsYXJyYXlDb3B5fSBmcm9tIFwiLi92ZW5kb3IvaW5mbGF0ZS5qc1wiO1xyXG5pbXBvcnQge0Zhc3RhU2VxdWVuY2V9IGZyb20gXCIuL2ZlYXR1cmUuanNcIlxyXG5cclxuXHJcbmNvbnN0IEJBSV9NQUdJQyA9IDIxNTc4MDUwO1xyXG5jb25zdCBUQUJJWF9NQUdJQyA9IDIxNTc4MzI0O1xyXG5jb25zdCBNQVhfSEVBREVSX1NJWkUgPSAxMDAwMDAwMDA7ICAgLy8gSUYgdGhlIGhlYWRlciBpcyBsYXJnZXIgdGhhbiB0aGlzIHdlIGNhbid0IHJlYWQgaXQgIVxyXG5jb25zdCBCX01BWF9HWklQX0JMT0NLX1NJWkUgPSAoMSA8PCAxNik7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGluZGV4VVJMXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAcGFyYW0gdGFiaXhcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2VkIGZvciB0aGUgYmFtIG9yIHRhYml4IGluZGV4LiAgVGhlIGZ1bGZpbGwgZnVuY3Rpb24gdGFrZXMgdGhlIGluZGV4IGFzIGFuIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbmxldCBsb2FkQmFtSW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVUkwsIGNvbmZpZywgdGFiaXgpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihpbmRleFVSTCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBjb25maWcuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBtYWdpYywgbmJpbiwgbmludHYsIG5yZWYsIHBhcnNlcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja01pbiA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tNYXggPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGJpbkluZGV4LCBsaW5lYXJJbmRleCwgYmluTnVtYmVyLCBjcywgY2UsIGIsIGksIHJlZiwgc2VxdWVuY2VJbmRleE1hcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhYml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGUgPSBuZXcgWmxpYi5abGliLkd1bnppcChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID0gaW5mbGF0ZS5kZWNvbXByZXNzKCkuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFnaWMgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCQUlfTUFHSUMgfHwgKHRhYml4ICYmIG1hZ2ljID09PSBUQUJJWF9NQUdJQykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbnJlZiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJpeCBoZWFkZXIgcGFyYW1ldGVycyBhcmVuJ3QgdXNlZCwgYnV0IHRoZXkgbXVzdCBiZSByZWFkIHRvIGFkdmFuY2UgdGhlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbF9zZXEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xfYmVnID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sX2VuZCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbF9ubSA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSW5kZXhNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5yZWY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcV9uYW1lID0gcGFyc2VyLmdldFN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBcIm9mZmljaWFsXCIgY2hyIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lKSBzZXFfbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShzZXFfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJbmRleE1hcFtzZXFfbmFtZV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHJlZiA9IDA7IHJlZiA8IG5yZWY7ICsrcmVmKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmJpbiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBuYmluOyArK2IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5OdW1iZXIgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbk51bWJlciA9PSAzNzQ1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwc3VlZG8gYmluLCBub3QgdXNlZCBidXQgd2UgaGF2ZSB0byBjb25zdW1lIHRoZSBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5jaG5rID0gcGFyc2VyLmdldEludCgpOyAvLyAjIG9mIGNodW5rcyBmb3IgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpOyAgIC8vIHVubWFwcGVkIGJlZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlID0gcGFyc2VyLmdldFZQb2ludGVyKCk7ICAgLy8gdW5tYXBwZWQgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5fbWFwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVW5tYXBwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmNobmsgPSBwYXJzZXIuZ2V0SW50KCk7IC8vICMgb2YgY2h1bmtzIGZvciB0aGlzIGJpblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmNobms7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZSA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3MgJiYgY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcy5ibG9jayA8IGJsb2NrTWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNaW4gPSBjcy5ibG9jazsgICAgLy8gQmxvY2sgY29udGFpbmluZyBmaXJzdCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZS5ibG9jayA+IGJsb2NrTWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNYXggPSBjZS5ibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0ucHVzaChbY3MsIGNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaW50diA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5pbnR2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gcGFyc2VyLmdldFZQb2ludGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleC5wdXNoKGNzKTsgICAvLyBNaWdodCBiZSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYmluID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1tyZWZdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4OiBiaW5JbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleDogbGluZWFySW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmRleFVSTCArIFwiIGlzIG5vdCBhIFwiICsgKHRhYml4ID8gXCJ0YWJpeFwiIDogXCJiYWlcIikgKyBcIiBmaWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChuZXcgQmFtSW5kZXgoaW5kaWNlcywgYmxvY2tNaW4sIGJsb2NrTWF4LCBzZXF1ZW5jZUluZGV4TWFwLCB0YWJpeCkpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuY2xhc3MgQmFtSW5kZXh7XHJcbiAgICBjb25zdHJ1Y3RvciAoaW5kaWNlcywgYmxvY2tNaW4sYmxvY2tNYXgsIHNlcXVlbmNlSW5kZXhNYXAsIHRhYml4KSB7XHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudEJsb2NrID0gYmxvY2tNaW47XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB0aGlzLmxhc3RBbGlnbm1lbnRCbG9jayA9IGJsb2NrTWF4O1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleE1hcCA9IHNlcXVlbmNlSW5kZXhNYXA7XHJcbiAgICAgICAgdGhpcy50YWJpeCA9IHRhYml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2ggYmxvY2tzIGZvciBhIHBhcnRpY3VsYXIgZ2Vub21pYyByYW5nZS4gIFRoaXMgbWV0aG9kIGlzIHB1YmxpYyBzbyBpdCBjYW4gYmUgdW5pdC10ZXN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlZklkICB0aGUgc2VxdWVuY2UgZGljdGlvbmFyeSBpbmRleCBvZiB0aGUgY2hyb21vc29tZVxyXG4gICAgICogQHBhcmFtIG1pbiAgZ2Vub21pYyBzdGFydCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIG1heCAgZ2Vub21pYyBlbmQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSByZXR1cm4gYW4gYXJyYXkgb2Yge21pbnY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fSwge21heHY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fX1cclxuICAgICAqL1xyXG4gICAgYmxvY2tzRm9yUmFuZ2UocmVmSWQsIG1pbiwgbWF4KSB7XHJcblxyXG4gICAgICAgIHZhciBiYW0gPSB0aGlzLFxyXG4gICAgICAgICAgICBiYSA9IGJhbS5pbmRpY2VzW3JlZklkXSxcclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zLFxyXG4gICAgICAgICAgICBjaHVua3MsXHJcbiAgICAgICAgICAgIG5pbnR2LFxyXG4gICAgICAgICAgICBsb3dlc3QsXHJcbiAgICAgICAgICAgIG1pbkxpbixcclxuICAgICAgICAgICAgbWF4TGluLFxyXG4gICAgICAgICAgICB2cCxcclxuICAgICAgICAgICAgaVxyXG5cclxuICAgICAgICBpZiAoIWJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyA9IEJhbUluZGV4LnJlZzJiaW5zKG1pbiwgbWF4KTtcclxuICAgICAgICAgICAgY2h1bmtzPVtdICAgICAgICAvLyBMaXN0IG9mIGJpbiAjcyB0aGF0IG1pZ2h0IG92ZXJsYXAgbWluLCBtYXhcclxuICAgICAgICAgICBcclxuXHJcblxyXG4gICAgICAgICAgICBvdmVybGFwcGluZ0JpbnMuZm9yRWFjaChmdW5jdGlvbiAoYmluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmNobmsgPSBiaW5DaHVua3MubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5jaG5rOyArK2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzID0gYmluQ2h1bmtzW2NdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2UgPSBiaW5DaHVua3NbY11bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHttaW52OiBjcywgbWF4djogY2UsIGJpbjogYmlufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGxpbmVhciBpbmRleCB0byBmaW5kIHRoZSBsb3dlc3QgY2h1bmsgdGhhdCBjb3VsZCBjb250YWluIGFsaWdubWVudHMgaW4gdGhlIHJlZ2lvblxyXG4gICAgICAgICAgICBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDtcclxuICAgICAgICAgICAgbG93ZXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgbWluTGluID0gTWF0aC5taW4obWluID4+IDE0LCBuaW50diAtIDEpLCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdnAgPSBiYS5saW5lYXJJbmRleFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh2cCkge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuaXNMZXNzVGhhbihsb3dlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdCA9IHZwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQcnVuZSBjaHVua3MgdGhhdCBlbmQgYmVmb3JlIHRoZSBsb3dlc3QgY2h1bmtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsgXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGxpc3Qgb2YgYmlucyB0aGF0IG1heSBvdmVybGFwIHdpdGggcmVnaW9uIFtiZWcsIGVuZF1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWcyYmlucyhiZWcsIGVuZCkge1xyXG4gICAgICAgIHZhciBpID0gMCwgaywgbGlzdCA9IFtdO1xyXG4gICAgICAgIGlmIChlbmQgPj0gMSA8PCAyOSkgICBlbmQgPSAxIDw8IDI5O1xyXG4gICAgICAgIC0tZW5kO1xyXG4gICAgICAgIGxpc3QucHVzaCgwKTtcclxuICAgICAgICBmb3IgKGsgPSAxICsgKGJlZyA+PiAyNik7IGsgPD0gMSArIChlbmQgPj4gMjYpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA5ICsgKGJlZyA+PiAyMyk7IGsgPD0gOSArIChlbmQgPj4gMjMpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA3MyArIChiZWcgPj4gMjApOyBrIDw9IDczICsgKGVuZCA+PiAyMCk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDU4NSArIChiZWcgPj4gMTcpOyBrIDw9IDU4NSArIChlbmQgPj4gMTcpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA0NjgxICsgKGJlZyA+PiAxNCk7IGsgPD0gNDY4MSArIChlbmQgPj4gMTQpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkge1xyXG5cclxuICAgIHZhciBtZXJnZWRDaHVua3MgPSBbXSxcclxuICAgICAgICBsYXN0Q2h1bmsgPSBudWxsO1xyXG5cclxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSByZXR1cm4gY2h1bmtzO1xyXG5cclxuICAgIGNodW5rcy5zb3J0KGZ1bmN0aW9uIChjMCwgYzEpIHtcclxuICAgICAgICB2YXIgZGlmID0gYzAubWludi5ibG9jayAtIGMxLm1pbnYuYmxvY2s7XHJcbiAgICAgICAgaWYgKGRpZiAhPSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMwLm1pbnYub2Zmc2V0IC0gYzEubWludi5vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XHJcblxyXG4gICAgICAgIGlmICghbG93ZXN0IHx8IGNodW5rLm1heHYuaXNHcmVhdGVyVGhhbihsb3dlc3QpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjaHVuay5taW52LmJsb2NrIC0gbGFzdENodW5rLm1heHYuYmxvY2spIDwgNjUwMDApIHsgLy8gTWVyZ2UgY2h1bmtzIHRoYXQgYXJlIHdpdGhpbmcgNjVrIG9mIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubWF4di5pc0dyZWF0ZXJUaGFuKGxhc3RDaHVuay5tYXh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2h1bmsubWF4diA9IGNodW5rLm1heHY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCR1pGaWxle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChjb25maWcpIHtcclxuICAgICAgICB0aGlzLmZpbGVQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgbmV4dEJsb2NrKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHNlbGYuZmlsZVBvc2l0aW9uLCBzaXplOiBCTE9DS19IRUFERVJfTEVOR1RIfSxcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG5cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHhsZW4gPSAoYmFbMTFdIDw8IDgpIHwgKGJhWzEwXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kxID0gYmFbMTJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGVuID0gKGJhWzE1XSA8PCA4KSB8IChiYVsxNF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmZpbGVQb3NpdGlvbiArPSBCTE9DS19IRUFERVJfTEVOR1RIO1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzZWxmLmZpbGVQb3NpdGlvbiwgc2l6ZTogYnNpemV9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuYyA9IGpzemxpYl9pbmZsYXRlX2J1ZmZlcihhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlsZVBvc2l0aW9uICs9IChic2l6ZSArIDgpOyAgLy8gXCI4XCIgZm9yIENSQy0zMiBhbmQgc2l6ZSBvZiB1bmNvbXByZXNzZWQgZGF0YVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiAgICB2YXIgQkFNX01BR0lDID0gMjE4NDAxOTQ7XHJcbiAgICB2YXIgU0VDUkVUX0RFQ09ERVIgPSBbJz0nLCAnQScsICdDJywgJ3gnLCAnRycsICd4JywgJ3gnLCAneCcsICdUJywgJ3gnLCAneCcsICd4JywgJ3gnLCAneCcsICd4JywgJ04nXTtcclxuICAgIHZhciBDSUdBUl9ERUNPREVSID0gWydNJywgJ0knLCAnRCcsICdOJywgJ1MnLCAnSCcsICdQJywgJz0nLCAnWCcsICc/JywgJz8nLCAnPycsICc/JywgJz8nLCAnPycsICc/J107XHJcbiAgICB2YXIgUkVBRF9TVFJBTkRfRkxBRyA9IDB4MTA7XHJcbiAgICB2YXIgTUFURV9TVFJBTkRfRkxBRyA9IDB4MjA7XHJcbiAgICB2YXIgRklSU1RfT0ZfUEFJUl9GTEFHID0gMHg0MDtcclxuICAgIHZhciBTRUNPTkRfT0ZfUEFJUl9GTEFHID0gMHg4MDtcclxuICAgIHZhciBSRUFEX1VOTUFQUEVEX0ZMQUcgPSAweDQ7XHJcbiAgICB2YXIgTUFURV9VTk1BUFBFRF9GTEFHID0gMHg4O1xyXG4gICAgdmFyIFJFQURfUEFJUkVEX0ZMQUcgPSAweDE7XHJcbiAgICB2YXIgUFJPUEVSX1BBSVJfRkxBRyA9IDB4MjtcclxuICAgIHZhciBTRUNPTkRBUllfQUxJR05NTkVUX0ZMQUcgPSAweDEwMDtcclxuICAgIHZhciBTVVBQTEVNRU5UQVJZX0FMSUdOTUVOVF9GTEFHID0gMHg4MDA7XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIE5PVF9QUklNQVJZX0FMSUdOTUVOVF9GTEFHID0gMHgxMDA7XHJcbiAgICB2YXIgUkVBRF9GQUlMU19WRU5ET1JfUVVBTElUWV9DSEVDS19GTEFHID0gMHgyMDA7XHJcbiAgICB2YXIgRFVQTElDQVRFX1JFQURfRkxBRyA9IDB4NDAwO1xyXG4gICAgdmFyIFNVUFBMRU1FTlRBUllfRkxBRyA9IDB4ODAwO1xyXG5cclxuICAgIGNvbnN0IE1BWF9HWklQX0JMT0NLX1NJWkUgPSA2NTUzNjsgICAvLyAgQVBQQVJFTlRMWS4gIFdoZXJlIGlzIHRoaXMgZG9jdW1lbnRlZD8/P1xyXG4gICAgY29uc3QgREVGQVVMVF9TQU1QTElOR19XSU5ET1dfU0laRSA9IDEwMDtcclxuICAgIGNvbnN0IERFRkFVTFRfU0FNUExJTkdfREVQVEggPSA1MDtcclxuICAgIGNvbnN0IE1BWElNVU1fU0FNUExJTkdfREVQVEggPSAyNTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgZm9yIHJlYWRpbmcgYSBiYW0gZmlsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiBjbGFzcyBCYW1SZWFkZXJ7XHJcbiAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cclxuICAgICAgICB0aGlzLmZpbHRlciA9IGNvbmZpZy5maWx0ZXIgfHwgbmV3IEJhbUZpbHRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmJhbVBhdGggPSBjb25maWcudXJsO1xyXG4gICAgICAgIC8vIFRvZG8gLSBkZWFsIHdpdGggUGljYXJkIGNvbnZlbnRpb24uICBXSFkgRE9FUyBUSEVSRSBIQVZFIFRPIEJFIDI/XHJcbiAgICAgICAgdGhpcy5iYWlQYXRoID0gY29uZmlnLmluZGV4VVJMIHx8IHRoaXMuYmFtUGF0aCArIFwiLmJhaVwiOyAvLyBJZiB0aGVyZSBpcyBhbiBpbmRleFVSTCBwcm92aWRlZCwgdXNlIGl0IVxyXG4gICAgICAgIHRoaXMuaGVhZFBhdGggPSBjb25maWcuaGVhZFVSTCB8fCB0aGlzLmJhbVBhdGg7XHJcblxyXG5cclxuICAgICAgICB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSA9IGNvbmZpZy5zYW1wbGluZ1dpbmRvd1NpemUgPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfU0FNUExJTkdfV0lORE9XX1NJWkUgOiBjb25maWcuc2FtcGxpbmdXaW5kb3dTaXplO1xyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IGNvbmZpZy5zYW1wbGluZ0RlcHRoID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1NBTVBMSU5HX0RFUFRIIDogY29uZmlnLnNhbXBsaW5nRGVwdGg7XHJcbiAgICAgICAgaWYodGhpcy5zYW1wbGluZ0RlcHRoID4gTUFYSU1VTV9TQU1QTElOR19ERVBUSCkge1xyXG4gICAgICAgICAgICBpZ3YubG9nKFwiV2FybmluZzogYXR0ZW1wdCB0byBzZXQgc2FtcGxpbmcgZGVwdGggPiBtYXhpbXVtIHZhbHVlIG9mIDI1MDBcIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IE1BWElNVU1fU0FNUExJTkdfREVQVEg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnZpZXdBc1BhaXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnNTdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IGNvbmZpZy5wYWlyc1N1cHBvcnRlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNvbmZpZy5wYWlyc1N1cHBvcnRlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJlYWRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGdldENockluZGV4KHNlbGYpLnRoZW4oZnVuY3Rpb24gKGNoclRvSW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hySWQgPSBjaHJUb0luZGV4W2Nocl0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lciA9IG5ldyBBbGlnbm1lbnRDb250YWluZXIoY2hyLCBicFN0YXJ0LCBicEVuZCwgc2VsZi5zYW1wbGluZ1dpbmRvd1NpemUsIHNlbGYuc2FtcGxpbmdEZXB0aCwgc2VsZi5wYWlyc1N1cHBvcnRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hySWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdldEluZGV4KHNlbGYpLnRoZW4oZnVuY3Rpb24gKGJhbUluZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtzID0gYmFtSW5kZXguYmxvY2tzRm9yUmFuZ2UoY2hySWQsIGJwU3RhcnQsIGJwRW5kKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVua3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvciByZWFkaW5nIGJhbSBpbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmV0Y2hNaW4gPSBjLm1pbnYuYmxvY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTWF4ID0gYy5tYXh2LmJsb2NrICsgTUFYX0daSVBfQkxPQ0tfU0laRSwgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IHRoZSB3aG9sZSBibG9jay5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB7c3RhcnQ6IGZldGNoTWluLCBzaXplOiBmZXRjaE1heCAtIGZldGNoTWluICsgMX07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5iYW1QYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkobmV3IHVuYmd6Zihjb21wcmVzc2VkKSk7IC8vbmV3IFVpbnQ4QXJyYXkoaWd2LnVuYmd6Zihjb21wcmVzc2VkKSk7IC8vLCBjLm1heHYuYmxvY2sgLSBjLm1pbnYuYmxvY2sgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZUJhbVJlY29yZHMoYmEsIGMubWludi5vZmZzZXQsIGFsaWdubWVudENvbnRhaW5lciwgYnBTdGFydCwgYnBFbmQsIGNocklkLCBzZWxmLmZpbHRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuZmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlQmFtUmVjb3JkcyhiYSwgb2Zmc2V0LCBhbGlnbm1lbnRDb250YWluZXIsIG1pbiwgbWF4LCBjaHJJZCwgZmlsdGVyKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tFbmQsXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBibG9ja3MsXHJcbiAgICAgICAgICAgICAgICByZWZJRCxcclxuICAgICAgICAgICAgICAgIHBvcyxcclxuICAgICAgICAgICAgICAgIGJtbixcclxuICAgICAgICAgICAgICAgIGJpbixcclxuICAgICAgICAgICAgICAgIG1xLFxyXG4gICAgICAgICAgICAgICAgbmwsXHJcbiAgICAgICAgICAgICAgICBmbGFnX25jLFxyXG4gICAgICAgICAgICAgICAgZmxhZyxcclxuICAgICAgICAgICAgICAgIG5jLFxyXG4gICAgICAgICAgICAgICAgbHNlcSxcclxuICAgICAgICAgICAgICAgIG1hdGVSZWZJRCxcclxuICAgICAgICAgICAgICAgIG1hdGVQb3MsXHJcbiAgICAgICAgICAgICAgICByZWFkTmFtZSxcclxuICAgICAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgICAgICBwLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoT25SZWYsXHJcbiAgICAgICAgICAgICAgICBjaWdhcixcclxuICAgICAgICAgICAgICAgIGMsXHJcbiAgICAgICAgICAgICAgICBjaWdhckFycmF5LFxyXG4gICAgICAgICAgICAgICAgc2VxLFxyXG4gICAgICAgICAgICAgICAgc2VxQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGJsb2NrU2l6ZSA9IHJlYWRJbnQoYmEsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBibG9ja0VuZCA9IG9mZnNldCArIGJsb2NrU2l6ZSArIDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrRW5kID4gYmEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IG5ldyBCYW1BbGlnbm1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZJRCA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDQpO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVhZEludChiYSwgb2Zmc2V0ICsgOCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocmVmSUQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgIC8vIHVubWFwcGVkIHJlYWRzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZJRCA+IGNocklkIHx8IHBvcyA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgLy8gb2ZmIHJpZ2h0IGVkZ2UsIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZklEIDwgY2hySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgICAvLyB0byBsZWZ0IG9mIHN0YXJ0LCBub3Qgc3VyZSB0aGlzIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYm1uID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMTIpO1xyXG4gICAgICAgICAgICAgICAgYmluID0gKGJtbiAmIDB4ZmZmZjAwMDApID4+IDE2O1xyXG4gICAgICAgICAgICAgICAgbXEgPSAoYm1uICYgMHhmZjAwKSA+PiA4O1xyXG4gICAgICAgICAgICAgICAgbmwgPSBibW4gJiAweGZmO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsYWdfbmMgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAxNik7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gKGZsYWdfbmMgJiAweGZmZmYwMDAwKSA+PiAxNjtcclxuICAgICAgICAgICAgICAgIG5jID0gZmxhZ19uYyAmIDB4ZmZmZjtcclxuXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuZmxhZ3MgPSBmbGFnO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnN0cmFuZCA9ICEoZmxhZyAmIFJFQURfU1RSQU5EX0ZMQUcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxzZXEgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWF0ZVJlZklEID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjQpO1xyXG4gICAgICAgICAgICAgICAgbWF0ZVBvcyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDI4KTtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5mcmFnbWVudExlbmd0aCA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDMyKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZWFkTmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5sIC0gMTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZE5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtvZmZzZXQgKyAzNiArIGpdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwID0gb2Zmc2V0ICsgMzYgKyBubDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZW5ndGhPblJlZiA9IDA7XHJcbiAgICAgICAgICAgICAgICBjaWdhciA9ICcnO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjaWdhckFycmF5ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBjIDwgbmM7ICsrYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaWdvcCA9IHJlYWRJbnQoYmEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcExlbiA9IChjaWdvcCA+PiA0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BMdHIgPSBDSUdBUl9ERUNPREVSW2NpZ29wICYgMHhmXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BMdHIgPT0gJ00nIHx8IG9wTHRyID09ICdFUScgfHwgb3BMdHIgPT0gJ1gnIHx8IG9wTHRyID09ICdEJyB8fCBvcEx0ciA9PSAnTicgfHwgb3BMdHIgPT0gJz0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhPblJlZiArPSBvcExlbjtcclxuICAgICAgICAgICAgICAgICAgICBjaWdhciA9IGNpZ2FyICsgb3BMZW4gKyBvcEx0cjtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXkucHVzaCh7bGVuOiBvcExlbiwgbHRyOiBvcEx0cn0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmNpZ2FyID0gY2lnYXI7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQubGVuZ3RoT25SZWYgPSBsZW5ndGhPblJlZjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmIDwgbWluKSBjb250aW51ZTsgIC8vIFJlY29yZCBvdXQtb2YtcmFuZ2UgXCJ0byB0aGUgbGVmdFwiLCBza2lwIHRvIG5leHQgb25lXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHNlcSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc2VxQnl0ZXMgPSAobHNlcSArIDEpID4+IDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VxQnl0ZXM7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzYiA9IGJhW3AgKyBqXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXEgKz0gU0VDUkVUX0RFQ09ERVJbKHNiICYgMHhmMCkgPj4gNF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VxICs9IFNFQ1JFVF9ERUNPREVSWyhzYiAmIDB4MGYpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlcSA9IHNlcS5zdWJzdHJpbmcoMCwgbHNlcSk7ICAvLyBzZXEgbWlnaHQgaGF2ZSBvbmUgZXh0cmEgY2hhcmFjdGVyIChpZiBsc2VxIGlzIGFuIG9kZCBudW1iZXIpXHJcblxyXG4gICAgICAgICAgICAgICAgcCArPSBzZXFCeXRlcztcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5zZXEgPSBzZXE7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsc2VxID09PSAxICYmIFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIGpdICsgMzMpID09PSBcIipcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gPT0gaG93IHRvIHJlcHJlc2VudCB0aGlzP1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LnF1YWwgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbHNlcTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5xdWFsLnB1c2goYmFbcCArIGpdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwICs9IGxzZXE7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5zdGFydCA9IHBvcztcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5tcSA9IG1xO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnJlYWROYW1lID0gcmVhZE5hbWU7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuY2hyID0gc2VsZi5pbmRleFRvQ2hyW3JlZklEXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0ZVJlZklEID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQubWF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyOiBzZWxmLmluZGV4VG9DaHJbbWF0ZVJlZklEXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG1hdGVQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmFuZDogIShmbGFnICYgTUFURV9TVFJBTkRfRkxBRylcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQudGFnQkEgPSBuZXcgVWludDhBcnJheShiYS5idWZmZXIuc2xpY2UocCwgYmxvY2tFbmQpKTsgIC8vIGRlY29kZSB0aGllc2Ugb24gZGVtYW5kXHJcbiAgICAgICAgICAgICAgICBwICs9IGJsb2NrRW5kO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghbWluIHx8IGFsaWdubWVudC5zdGFydCA8PSBtYXggJiZcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgPj0gbWluICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnBhc3MoYWxpZ25tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkIHx8IHJlZklEID09IGNocklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrcyA9IG1ha2VCbG9ja3MoYWxpZ25tZW50LCBjaWdhckFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LmJsb2NrcyA9IGJsb2Nrcy5ibG9ja3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5pbnNlcnRpb25zID0gYmxvY2tzLmluc2VydGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wdXNoKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYmxvY2tFbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXhpdHMgdmlhIHRvcCBvZiBsb29wLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BsaXQgdGhlIGFsaWdubWVudCByZWNvcmQgaW50byBibG9ja3MgYXMgc3BlY2lmaWVkIGluIHRoZSBjaWdhckFycmF5LiAgRWFjaCBhbGlnbmVkIGJsb2NrIGNvbnRhaW5zXHJcbiAgICAgICAgICogaXRzIHBvcnRpb24gb2YgdGhlIHJlYWQgc2VxdWVuY2UgYW5kIGJhc2UgcXVhbGl0eSBzdHJpbmdzLiAgQSByZWFkIHNlcXVlbmNlIG9yIGJhc2UgcXVhbGl0eSBzdHJpbmdcclxuICAgICAgICAgKiBvZiBcIipcIiBpbmRpY2F0ZXMgdGhlIHZhbHVlIGlzIG5vdCByZWNvcmRlZC4gIEluIGFsbCBvdGhlciBjYXNlcyB0aGUgbGVuZ3RoIG9mIHRoZSBibG9jayBzZXF1ZW5jZSAoYmxvY2suc2VxKVxyXG4gICAgICAgICAqIGFuZCBxdWFsaXR5IHN0cmluZyAoYmxvY2sucXVhbCkgbXVzdCA9PSB0aGUgYmxvY2sgbGVuZ3RoLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTk9URTogSW5zZXJ0aW9ucyBhcmUgbm90IHlldCB0cmVhdGVkIC8vIFRPRE9cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSByZWNvcmRcclxuICAgICAgICAgKiBAcGFyYW0gY2lnYXJBcnJheVxyXG4gICAgICAgICAqIEByZXR1cm5zIGFycmF5IG9mIGJsb2Nrc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VCbG9ja3MocmVjb3JkLCBjaWdhckFycmF5KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmxvY2tzID0gW10sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zLFxyXG4gICAgICAgICAgICAgICAgc2VxT2Zmc2V0ID0gMCxcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJlY29yZC5zdGFydCxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGNpZ2FyQXJyYXkubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tTZXEsXHJcbiAgICAgICAgICAgICAgICBibG9ja1F1YWxzLFxyXG4gICAgICAgICAgICAgICAgZ2FwVHlwZSxcclxuICAgICAgICAgICAgICAgIG1pblEgPSA1LCAgLy9wcmVmcy5nZXRBc0ludChQcmVmZXJlbmNlTWFuYWdlci5TQU1fQkFTRV9RVUFMSVRZX01JTilcclxuICAgICAgICAgICAgICAgIG1heFEgPSAyMDsgLy9wcmVmcy5nZXRBc0ludChQcmVmZXJlbmNlTWFuYWdlci5TQU1fQkFTRV9RVUFMSVRZX01BWClcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNpZ2FyQXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjLmx0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlnbm9yZSBoYXJkIGNsaXBzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWdub3JlIHBhZHNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcU9mZnNldCArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwVHlwZSA9ICdTJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHNvZnQgY2xpcCByZWFkIGJhc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTicgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcFR5cGUgPSAnTic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgLy8gcmVmZXJlbmNlIHNraXBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwVHlwZSA9ICdEJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSScgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NlcSA9IHJlY29yZC5zZXEgPT09IFwiKlwiID8gXCIqXCIgOiByZWNvcmQuc2VxLnN1YnN0cihzZXFPZmZzZXQsIGMubGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tRdWFscyA9IHJlY29yZC5xdWFsID8gcmVjb3JkLnF1YWwuc2xpY2Uoc2VxT2Zmc2V0LCBjLmxlbikgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRpb25zID09PSB1bmRlZmluZWQpIGluc2VydGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0aW9ucy5wdXNoKHtzdGFydDogcG9zLCBsZW46IGMubGVuLCBzZXE6IGJsb2NrU2VxLCBxdWFsOiBibG9ja1F1YWxzfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcU9mZnNldCArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTScgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VRJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPScgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU2VxID0gcmVjb3JkLnNlcSA9PT0gXCIqXCIgPyBcIipcIiA6IHJlY29yZC5zZXEuc3Vic3RyKHNlcU9mZnNldCwgYy5sZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1F1YWxzID0gcmVjb3JkLnF1YWwgPyByZWNvcmQucXVhbC5zbGljZShzZXFPZmZzZXQsIGMubGVuKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goe3N0YXJ0OiBwb3MsIGxlbjogYy5sZW4sIHNlcTogYmxvY2tTZXEsIHF1YWw6IGJsb2NrUXVhbHMsIGdhcFR5cGU6IGdhcFR5cGV9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYy5sZW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgcHJvY2Vzc2luZyBjaWdhciBlbGVtZW50OiBcIiArIGMubGVuICsgYy5sdHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge2Jsb2NrczogYmxvY2tzLCBpbnNlcnRpb25zOiBpbnNlcnRpb25zfTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlYWRIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGdldEluZGV4KHNlbGYpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGluZGV4LmZpcnN0QWxpZ25tZW50QmxvY2sgKyBNQVhfR1pJUF9CTE9DS19TSVpFOyAgIC8vIEluc3VyZSB3ZSBnZXQgdGhlIGNvbXBsZXRlIGNvbXByZXNzZWQgYmxvY2sgY29udGFpbmluZyB0aGUgaGVhZGVyXHJcblxyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLmJhbVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogMCwgc2l6ZTogbGVufSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tcHJlc3NlZEJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5jID0gbmV3IHVuYmd6Zihjb21wcmVzc2VkQnVmZmVyLCBsZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNiYSA9IG5ldyBVaW50OEFycmF5KHVuYyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hZ2ljID0gcmVhZEludCh1bmNiYSwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlckxlbiA9IHJlYWRJbnQodW5jYmEsIDQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1IZWFkZXIgPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2Vub21lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1IZWFkZXJMZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1IZWFkZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtpICsgOF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5SZWYgPSByZWFkSW50KHVuY2JhLCBzYW1IZWFkZXJMZW4gKyA4KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHNhbUhlYWRlckxlbiArIDEyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoclRvSW5kZXggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4VG9DaHIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5SZWY7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbE5hbWUgPSByZWFkSW50KHVuY2JhLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsTmFtZSAtIDE7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuY2JhW3AgKyA0ICsgal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsUmVmID0gcmVhZEludCh1bmNiYSwgcCArIGxOYW1lICsgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGxvZyhuYW1lICsgJzogJyArIGxSZWYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSAmJiBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyVG9JbmRleFtuYW1lXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhUb0Noci5wdXNoKG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyA4ICsgbE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuICAgIGZ1bmN0aW9uIGdldEluZGV4KGJhbSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhbS5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChiYW0uaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9hZEJhbUluZGV4KGJhbS5iYWlQYXRoLCBiYW0uY29uZmlnKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhbS5pbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENockluZGV4KGJhbSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhbS5jaHJUb0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5jaHJUb0luZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJhbS5yZWFkSGVhZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChiYW0uY2hyVG9JbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEludChiYSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIChiYVtvZmZzZXQgKyAzXSA8PCAyNCkgfCAoYmFbb2Zmc2V0ICsgMl0gPDwgMTYpIHwgKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRTaG9ydChiYSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIChiYVtvZmZzZXQgKyAxXSA8PCA4KSB8IChiYVtvZmZzZXRdKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEJhbVNvdXJjZXtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmFsaWdubWVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1heFJvd3MgPSBjb25maWcubWF4Um93cyB8fCAxMDAwO1xyXG4gICAgICAgIGlmIChjb25maWcuc2VxX3VybCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2Vfc291cmNlPW5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy5zZXFfdXJsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJnYTRnaFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFtUmVhZGVyID0gbmV3IGlndi5HYTRnaEFsaWdubWVudFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYW1SZWFkZXIgPSBuZXcgQmFtUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIHRoaXMudmlld0FzUGFpcnMgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXRWaWV3QXNQYWlycyhib29sKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy52aWV3QXNQYWlycyAhPT0gYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gYm9vbDtcclxuICAgICAgICAgICAgLy8gVE9ETyAtLSByZXBhaXIgYWxpZ25tZW50c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGlnbm1lbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb250YWluZXIgPSB0aGlzLmFsaWdubWVudENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IHBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSB1bnBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzID0gcGFja0FsaWdubWVudFJvd3MoYWxpZ25tZW50cywgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kLCBzZWxmLm1heFJvd3MpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5hbGlnbm1lbnRDb250YWluZXIgJiYgc2VsZi5hbGlnbm1lbnRDb250YWluZXIuY29udGFpbnMoY2hyLCBicFN0YXJ0LCBicEVuZCkpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5hbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuYmFtUmVhZGVyLnJlYWRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpLnRoZW4oZnVuY3Rpb24gKGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Um93cyA9IHNlbGYuY29uZmlnLm1heFJvd3MgfHwgNTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gYWxpZ25tZW50Q29udGFpbmVyLmFsaWdubWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gdW5wYWlyQWxpZ25tZW50cyhbe2FsaWdubWVudHM6IGFsaWdubWVudHN9XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyA9IHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIGFsaWdubWVudENvbnRhaW5lci5zdGFydCwgYWxpZ25tZW50Q29udGFpbmVyLmVuZCwgbWF4Um93cyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuYWxpZ25tZW50cyA9IHVuZGVmaW5lZDsgIC8vIERvbid0IG5lZWQgdG8gaG9sZCBvbnRvIHRoZXNlIGFueW1vcmVcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsaWdubWVudENvbnRhaW5lciA9IGFsaWdubWVudENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXF1ZW5jZV9zb3VyY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZV9zb3VyY2UuZ2V0U2VxdWVuY2UoYWxpZ25tZW50Q29udGFpbmVyLmNociwgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5jb3ZlcmFnZU1hcC5yZWZTZXEgPSBzZXF1ZW5jZTsgICAgLy8gVE9ETyAtLSBmaXggdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5zZXF1ZW5jZSA9IHNlcXVlbmNlOyAgICAgICAgICAgLy8gVE9ETyAtLSBmaXggdGhpc1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4gICAgZnVuY3Rpb24gcGFpckFsaWdubWVudHMocm93cykge1xyXG5cclxuICAgICAgICB2YXIgcGFpckNhY2hlID0ge30sXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG5cclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVQYWlyZWQoYWxpZ25tZW50KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudC5zZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7ICAgLy8gRG9uJ3QgbmVlZCB0byB0cmFjayB0aGlzIGFueW1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgaWd2LlBhaXJlZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXSA9IHBhaXJlZEFsaWdubWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFpcmVkQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bnBhaXJBbGlnbm1lbnRzKHJvd3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50IGluc3RhbmNlb2YgUGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5maXJzdEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KTsgIC8vIHNob3VsZG4ndCBuZWVkIHRoZSBudWxsIHRlc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYW5CZVBhaXJlZChhbGlnbm1lbnQpIHtcclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50LmlzUGFpcmVkKCkgJiZcclxuICAgICAgICAgICAgYWxpZ25tZW50LmlzTWF0ZU1hcHBlZCgpICYmXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPT09IGFsaWdubWVudC5tYXRlLmNociAmJlxyXG4gICAgICAgICAgICAoYWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSB8fCBhbGlnbm1lbnQuaXNTZWNvbmRPZlBhaXIoKSkgJiYgIShhbGlnbm1lbnQuaXNTZWNvbmRhcnkoKSB8fCBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBwYWNrQWxpZ25tZW50Um93cyhhbGlnbm1lbnRzLCBzdGFydCwgZW5kLCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgIGlmICghYWxpZ25tZW50cykgcmV0dXJuO1xyXG5cclxuICAgICAgICBhbGlnbm1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBidWNrZXRMaXN0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSAwLFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRSb3csXHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGJ1Y2tldCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFNwYWNlID0gNCAqIDIsXHJcbiAgICAgICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRSb3dzID0gW10sXHJcbiAgICAgICAgICAgICAgICBidWNrZXRTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBhbGlnbm1lbnRzWzBdLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tMaXN0SW5kZXggPSBNYXRoLm1heCgwLCBhbGlnbm1lbnQuc3RhcnQgLSBidWNrZXRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XS5wdXNoKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChhbGxvY2F0ZWRDb3VudCA8IGFsaWdubWVudHMubGVuZ3RoICYmIHBhY2tlZEFsaWdubWVudFJvd3MubGVuZ3RoIDwgbWF4Um93cykge1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdyA9IG5ldyBCYW1BbGlnbm1lbnRSb3coKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dFN0YXJ0IDw9IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghYnVja2V0ICYmIG5leHRTdGFydCA8PSBlbmQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dFN0YXJ0IC0gYnVja2V0U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXRMaXN0W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25leHRTdGFydDsgICAgICAgICAgICAgICAgICAgICAvLyBObyBhbGlnbm1lbnRzIGF0IHRoaXMgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IGJ1Y2tldExpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKGJ1Y2tldClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWNrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IGJ1Y2tldC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYnVja2V0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgKyBhbGlnbm1lbnRTcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICArK2FsbG9jYXRlZENvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKG5leHRTdGFydClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50Um93LmFsaWdubWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MucHVzaChhbGlnbm1lbnRSb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IGJ1Y2tldFN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGxvY2F0ZWRDb3VudCA9PT0gbGFzdEFsbG9jYXRlZENvdW50KSBicmVhazsgICAvLyBQcm90ZWN0IGZyb20gaW5maW5pdGUgbG9vcHNcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSBhbGxvY2F0ZWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgIH0gLy8gd2hpbGUgKGFsbG9jYXRlZENvdW50KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhY2tlZEFsaWdubWVudFJvd3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnR7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXBwZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUkVBRF9VTk1BUFBFRF9GTEFHKSA9PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGFpcmVkICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1BBSVJFRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUHJvcGVyUGFpciAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUFJPUEVSX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZpcnN0T2ZQYWlyKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIEZJUlNUX09GX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1NlY29uZE9mUGFpcigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBTRUNPTkRfT0ZfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2Vjb25kYXJ5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFNFQ09OREFSWV9BTElHTk1ORVRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1N1cHBsZW1lbnRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgU1VQUExFTUVOVEFSWV9BTElHTk1FTlRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfRkFJTFNfVkVORE9SX1FVQUxJVFlfQ0hFQ0tfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0R1cGxpY2F0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBEVVBMSUNBVEVfUkVBRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU1hcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBNQVRFX1VOTUFQUEVEX0ZMQUcpID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNOZWdhdGl2ZVN0cmFuZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1NUUkFORF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU5lZ2F0aXZlU3RyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIE1BVEVfU1RSQU5EX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGFncygpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlVGFncyhiYSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHAgPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYmEubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdGFncyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHAgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3BdKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDFdKTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdBJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2knIHx8IHR5cGUgPT09ICdJJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZEludChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2MnIHx8IHR5cGUgPT09ICdDJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFbcCArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3MnIHx8IHR5cGUgPT09ICdTJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFNob3J0KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA1O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPICdGSVhNRSBuZWVkIGZsb2F0cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkRmxvYXQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYyA9IGJhW3ArK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8nVW5rbm93biB0eXBlICcgKyB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ0Vycm9yIHVua25vd24gdHlwZTogJyArIHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnc1t0YWddID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFncztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50YWdEaWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ0JBKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0RpY3QgPSBkZWNvZGVUYWdzKHRoaXMudGFnQkEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdCQSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRGljdCA9IHt9OyAgLy8gTWFyayBzbyB3ZSBkb24ndCB0cnkgYWdhaW4uICBUaGUgcmVjb3JkIGhhcyBub3QgdGFnc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0RpY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgY2xpY2tzIG9uIGEgYmFzZSBuZXh0IHRvIGFuIGluc2VydGlvbiwgc2hvdyBqdXN0IHRoZVxyXG4gICAgICAgIC8vIGluc2VydGVkIGJhc2VzIGluIGEgcG9wdXAgKGxpa2UgaW4gZGVza3RvcCBJR1YpLlxyXG4gICAgICAgIHZhciBuYW1lVmFsdWVzID0gW10sIGlzRmlyc3QsIHRhZ0RpY3Q7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnNlcnRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zX3N0YXJ0ID0gdGhpcy5pbnNlcnRpb25zW2ldLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYoZ2Vub21pY0xvY2F0aW9uID09IGluc19zdGFydCB8fCBnZW5vbWljTG9jYXRpb24gPT0gaW5zX3N0YXJ0IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0luc2VydGlvbicsIHZhbHVlOiB0aGlzLmluc2VydGlvbnNbaV0uc2VxIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0xvY2F0aW9uJywgdmFsdWU6IGluc19zdGFydCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1JlYWQgTmFtZScsIHZhbHVlOiB0aGlzLnJlYWROYW1lIH0pO1xyXG5cclxuICAgICAgICAvLyBTYW1wbGVcclxuICAgICAgICAvLyBSZWFkIGdyb3VwXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIDEgdG8gZ2Vub21pYyBsb2NhdGlvbiB0byBtYXAgZnJvbSAwLWJhc2VkIGNvbXB1dGVyIHVuaXRzIHRvIHVzZXItYmFzZWQgdW5pdHNcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnQWxpZ25tZW50IFN0YXJ0JywgdmFsdWU6IGlndi5udW1iZXJGb3JtYXR0ZXIoMSArIHRoaXMuc3RhcnQpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdSZWFkIFN0cmFuZCcsIHZhbHVlOiAodHJ1ZSA9PT0gdGhpcy5zdHJhbmQgPyAnKCspJyA6ICcoLSknKSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdDaWdhcicsIHZhbHVlOiB0aGlzLmNpZ2FyIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXBwZWQnLCB2YWx1ZTogeWVzTm8odGhpcy5pc01hcHBlZCgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnTWFwcGluZyBRdWFsaXR5JywgdmFsdWU6IHRoaXMubXEgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1NlY29uZGFyeScsIHZhbHVlOiB5ZXNObyh0aGlzLmlzU2Vjb25kYXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdTdXBwbGVtZW50YXJ5JywgdmFsdWU6IHllc05vKHRoaXMuaXNTdXBwbGVtZW50YXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdEdXBsaWNhdGUnLCB2YWx1ZTogeWVzTm8odGhpcy5pc0R1cGxpY2F0ZSgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmFpbGVkIFFDJywgdmFsdWU6IHllc05vKHRoaXMuaXNGYWlsc1ZlbmRvclF1YWxpdHlDaGVjaygpKSB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNQYWlyZWQoKSkge1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmlyc3QgaW4gUGFpcicsIHZhbHVlOiAhdGhpcy5pc1NlY29uZE9mUGFpcigpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIGlzIE1hcHBlZCcsIHZhbHVlOiB5ZXNObyh0aGlzLmlzTWF0ZU1hcHBlZCgpKSB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXRlTWFwcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIENocm9tb3NvbWUnLCB2YWx1ZTogdGhpcy5tYXRlLmNociB9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIFN0YXJ0JywgdmFsdWU6ICh0aGlzLm1hdGUucG9zaXRpb24gKyAxKX0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgU3RyYW5kJywgdmFsdWU6ICh0cnVlID09PSB0aGlzLm1hdGUuc3RyYW5kID8gJygrKScgOiAnKC0pJyl9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdJbnNlcnQgU2l6ZScsIHZhbHVlOiB0aGlzLmZyYWdtZW50TGVuZ3RoIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdHJhbmRcclxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBTaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmlyc3QgaW4gUGFpclxyXG4gICAgICAgICAgICAvLyBQYWlyIE9yaWVudGF0aW9uXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuICAgICAgICB0YWdEaWN0ID0gdGhpcy50YWdzKCk7XHJcbiAgICAgICAgaXNGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhZ0RpY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWdEaWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6IGtleSwgdmFsdWU6IHRhZ0RpY3Rba2V5XSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdGFnRGljdFtrZXldIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB5ZXNObyhib29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBib29sID8gJ1llcycgOiAnTm8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbiAgIFxyXG5cclxuICAgXHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEZsb2F0KGJhLCBvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJhLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1GaWx0ZXJ7XHJcblxyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy52ZW5kb3JGYWlsZWQgPSBvcHRpb25zLnZlbmRvckZhaWxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMudmVuZG9yRmFpbGVkO1xyXG4gICAgICAgIHRoaXMuZHVwbGljYXRlcyA9IG9wdGlvbnMuZHVwbGljYXRlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuZHVwbGljYXRlcztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeSA9IG9wdGlvbnMuc2Vjb25kYXJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3VwcGxlbWVudGFyeSA9IG9wdGlvbnMuc3VwcGxlbWVudGFyeSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLm1xVGhyZXNob2xkID0gb3B0aW9ucy5tcVRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMubXFUaHJlc2hvbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgcGFzcyhhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmVuZG9yRmFpbGVkICYmIGFsaWdubWVudC5pc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5kdXBsaWNhdGVzICYmIGFsaWdubWVudC5pc0R1cGxpY2F0ZSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5ICYmIGFsaWdubWVudC5pc1NlY29uZGFyeSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudGFyeSAmJiBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoYWxpZ25tZW50Lm1xIDwgdGhpcy5tcVRocmVzaG9sZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG4gICAgdmFyIEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuICAgIHZhciBCTE9DS19MRU5HVEhfT0ZGU0VUID0gMTY7ICAvLyBMb2NhdGlvbiBpbiB0aGUgZ3ppcCBibG9jayBvZiB0aGUgdG90YWwgYmxvY2sgc2l6ZSAoYWN0dWFsbHkgdG90YWwgYmxvY2sgc2l6ZSAtIDEpXHJcbiAgICB2YXIgQkxPQ0tfRk9PVEVSX0xFTkdUSCA9IDg7IC8vIE51bWJlciBvZiBieXRlcyB0aGF0IGZvbGxvdyB0aGUgZGVmbGF0ZWQgZGF0YVxyXG4gICAgdmFyIE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuICAgIHZhciBHWklQX09WRVJIRUFEID0gQkxPQ0tfSEVBREVSX0xFTkdUSCArIEJMT0NLX0ZPT1RFUl9MRU5HVEggKyAyOyAvLyBHemlwIG92ZXJoZWFkIGlzIHRoZSBoZWFkZXIsIHRoZSBmb290ZXIsIGFuZCB0aGUgYmxvY2sgc2l6ZSAoZW5jb2RlZCBhcyBhIHNob3J0KS5cclxuICAgIHZhciBHWklQX0lEMSA9IDMxOyAgIC8vIE1hZ2ljIG51bWJlclxyXG4gICAgdmFyIEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbiAgICB2YXIgR1pJUF9GTEcgPSA0OyAvLyBGRVhUUkEgZmxhZyBtZWFucyB0aGVyZSBhcmUgb3B0aW9uYWwgZmllbGRzXHJcblxyXG5cclxuICAgIC8vIFVuY29tcHJlc3MgZGF0YSwgIGFzc3VtZWQgdG8gYmUgc2VyaWVzIG9mIGJnemlwcGVkIGJsb2Nrc1xyXG4gICAgLy8gQ29kZSBpcyBiYXNlZCBoZWF2aWx5IG9uIGJhbS5qcywgcGFydCBvZiB0aGUgRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlciwgIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMDEuXHJcbmNsYXNzIHVuYmd6ZntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGxpbSkge1xyXG4gICAgICAgIGZvciAobGV0IGEgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coYSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEFsaWdubWVudENvbnRhaW5lcntcclxuICAgIGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgc2FtcGxpbmdXaW5kb3dTaXplLCBzYW1wbGluZ0RlcHRoLCBwYWlyc1N1cHBvcnRlZCkge1xyXG5cclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoZW5kIC0gc3RhcnQpO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwID0gbmV3IENvdmVyYWdlTWFwKGNociwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSA9IHNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gMTAwIDogc2FtcGxpbmdXaW5kb3dTaXplO1xyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IHNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IDUwIDogc2FtcGxpbmdEZXB0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIHRoaXMucGFpcmVkID0gZmFsc2U7ICAvLyBmYWxzZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0ge307ICAvLyB3b3JraW5nIGNhY2hlIG9mIHBhaXJlZCBhbGlnbm1lbnRzIGJ5IHJlYWQgbmFtZVxyXG5cclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFsaWdubWVudCkgeyAgICAgICAgIC8vIFRPRE8gLS0gcGFzcyB0aGlzIGluXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNNYXBwZWQoKSAmJiAhYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1c2goYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcihhbGlnbm1lbnQpID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwLmluY0NvdW50cyhhbGlnbm1lbnQpOyAgIC8vIENvdW50IGNvdmVyYWdlIGJlZm9yZSBhbnkgZG93bnNhbXBsaW5nXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIHRoaXMuZG93bnNhbXBsZWRSZWFkcy5oYXMoYWxpZ25tZW50LnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm47ICAgLy8gTWF0ZSBhbHJlYWR5IGRvd25zYW1wbGVkIC0tIHBhaXJzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIGFsaWdubWVudCBmb3IgZG93bnNhbXBsaW5nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50LnN0YXJ0ID49IHRoaXMuY3VycmVudEJ1Y2tldC5lbmQpIHtcclxuICAgICAgICAgICAgZmluaXNoQnVja2V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KGFsaWdubWVudC5zdGFydCwgYWxpZ25tZW50LnN0YXJ0ICsgdGhpcy5zYW1wbGluZ1dpbmRvd1NpemUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmFkZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzLmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEJ1Y2tldC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmVlZCB0byByZW1vdmUgcGFydGlhbCBwYWlycyB3aG9zZSBtYXRlIHdhcyBkb3duc2FtcGxlZFxyXG4gICAgICAgIGlmKHRoaXMucGFpcnNTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IFtdLCBkcyA9IHRoaXMuZG93bnNhbXBsZWRSZWFkcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRzLmhhcyhhLnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudHMgPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFsaWdubWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRSZWFkcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWlucyhjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzICYmIHRoaXMuZG93bnNhbXBsZWRJbnRlcnZhbHMubGVuZ3RoID4gMDtcclxuICAgIH1cclxufVxyXG4gICAgZnVuY3Rpb24gZmluaXNoQnVja2V0KCkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IHRoaXMuYWxpZ25tZW50cy5jb25jYXQodGhpcy5jdXJyZW50QnVja2V0LmFsaWdubWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCdWNrZXQuZG93bnNhbXBsZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscy5wdXNoKG5ldyBEb3duc2FtcGxlZEludGVydmFsKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmVuZCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldC5kb3duc2FtcGxlZENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcmVkID0gdGhpcy5wYWlyZWQgfHwgdGhpcy5jdXJyZW50QnVja2V0LnBhaXJlZDtcclxuICAgIH1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVCdWNrZXR7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBhbGlnbm1lbnRDb250YWluZXIpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gYWxpZ25tZW50Q29udGFpbmVyLnNhbXBsaW5nRGVwdGg7XHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IGFsaWdubWVudENvbnRhaW5lci5wYWlyc1N1cHBvcnRlZDtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRSZWFkcztcclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSBhbGlnbm1lbnRDb250YWluZXIucGFpcnNDYWNoZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBzYW1wbGluZ1Byb2IsIGlkeCwgcmVwbGFjZWRBbGlnbm1lbnQsIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpZ25tZW50cy5sZW5ndGggPCB0aGlzLnNhbXBsaW5nRGVwdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTm90IHN1YmplY3QgdG8gZG93bnNhbXBsaW5nLCBqdXN0IHVwZGF0ZSB0aGUgZXhpc3RpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gdW5kZWZpbmVkOyAgIC8vIERvbid0IG5lZWQgdG8gdHJhY2sgdGhpcyBhbnltb3JlLiBOT1RFOiBEb24ndCBcImRlbGV0ZVwiLCBjYXVzZXMgcnVudGltZSBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFsaWdubWVudCBpbiBhIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5wdXNoKHBhaXJlZEFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBzYW1wbGluZ1Byb2IgPSB0aGlzLnNhbXBsaW5nRGVwdGggLyAodGhpcy5zYW1wbGluZ0RlcHRoICsgdGhpcy5kb3duc2FtcGxlZENvdW50ICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHNhbXBsaW5nUHJvYikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLmFsaWdubWVudHMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRBbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudHNbaWR4XTsgICAvLyBUbyBiZSByZXBsYWNlZFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wYWlyc0NhY2hlW3JlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVtyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gYWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChhbGlnbm1lbnQucmVhZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkQ291bnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgIC8vIFRPRE8gLS0gcmVmYWN0b3IgdGhpcyB0byB1c2UgYW4gb2JqZWN0LCByYXRoZXIgdGhhbiBhbiBhcnJheSwgIGlmIGVuZC1zdGFydCBpcyA+IHNvbWUgdGhyZXNob2xkXHJcbmNsYXNzIENvdmVyYWdlTWFwe1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2hyID0gY2hyO1xyXG4gICAgICAgIHRoaXMuYnBTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gKGVuZCAtIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jb3ZlcmFnZSA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHRoaXMubWF4aW11bSA9IDA7XHJcblxyXG4gICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgaW5jQ291bnRzKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuYmxvY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYmxvY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluY0Jsb2NrQ291bnQoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXksXHJcbiAgICAgICAgICAgICAgICBiYXNlLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgICAgICBxO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gYmxvY2suc3RhcnQgLSBzZWxmLmJwU3RhcnQsIGogPSAwOyBqIDwgYmxvY2subGVuOyBpKyssIGorKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb3ZlcmFnZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0gPSBuZXcgQ292ZXJhZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgIGtleSA9IChhbGlnbm1lbnQuc3RyYW5kKSA/IFwicG9zXCIgKyBiYXNlIDogXCJuZWdcIiArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICBxID0gYmxvY2sucXVhbFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldW2tleV0gKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV1bXCJxdWFsXCIgKyBiYXNlXSArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0udG90YWwgKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0ucXVhbCArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubWF4aW11bSA9IE1hdGgubWF4KHNlbGYuY292ZXJhZ2VbaV0udG90YWwsIHNlbGYubWF4aW11bSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5Db3ZlcmFnZU1hcC50aHJlc2hvbGQgPSAwLjI7XHJcbkNvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgPSB0cnVlO1xyXG5cclxuY2xhc3MgQ292ZXJhZ2V7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvc0EgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnQSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zVCA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdUID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NDID0gMDtcclxuICAgICAgICB0aGlzLm5lZ0MgPSAwO1xyXG4gICAgICAgIHRoaXMucG9zRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMubmVnRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zTiA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdOID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5xdWFsQSA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsVCA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsQyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsRyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsTiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucXVhbCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWlzbWF0Y2gocmVmQmFzZSkge1xyXG5cclxuICAgICAgICB2YXIgbXlzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgbWlzbWF0Y2hRdWFsaXR5U3VtLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBDb3ZlcmFnZU1hcC50aHJlc2hvbGQgKiAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgdGhpcy5xdWFsKSA/IHRoaXMucXVhbCA6IHRoaXMudG90YWwpO1xyXG5cclxuICAgICAgICBtaXNtYXRjaFF1YWxpdHlTdW0gPSAwO1xyXG4gICAgICAgIFtcIkFcIiwgXCJUXCIsIFwiQ1wiLCBcIkdcIl0uZm9yRWFjaChmdW5jdGlvbiAoYmFzZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhc2UgIT09IHJlZkJhc2UpIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoUXVhbGl0eVN1bSArPSAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgbXlzZWxmLnF1YWwpID8gbXlzZWxmW1wicXVhbFwiICsgYmFzZV0gOiAobXlzZWxmW1wicG9zXCIgKyBiYXNlXSArIG15c2VsZltcIm5lZ1wiICsgYmFzZV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbWlzbWF0Y2hRdWFsaXR5U3VtID49IHRocmVzaG9sZDtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVkSW50ZXJ2YWx7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBjb3VudHMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5jb3VudHMgPSBjb3VudHM7XHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInN0YXJ0XCIsIHZhbHVlOiB0aGlzLnN0YXJ0ICsgMX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImVuZFwiLCB2YWx1ZTogdGhpcy5lbmR9LFxyXG4gICAgICAgICAgICB7bmFtZTogXCIjIGRvd25zYW1wbGVkOlwiLCB2YWx1ZTogdGhpcy5jb3VudHN9XVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUGFpcmVkQWxpZ25tZW50e1xyXG4gICAgY29uc3RydWN0b3IoZmlyc3RBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudCA9IGZpcnN0QWxpZ25tZW50O1xyXG4gICAgICAgIHRoaXMuY2hyID0gZmlyc3RBbGlnbm1lbnQuY2hyO1xyXG4gICAgICAgIHRoaXMucmVhZE5hbWUgPSBmaXJzdEFsaWdubWVudC5yZWFkTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGZpcnN0QWxpZ25tZW50LnN0YXJ0IDwgZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgoZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbiwgZmlyc3RBbGlnbm1lbnQuc3RhcnQgKyBmaXJzdEFsaWdubWVudC5sZW5ndGhPblJlZik7ICAvLyBBcHByb3hpbWF0ZVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0ICsgZmlyc3RBbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaXJzdEFsaWdubWVudC5zdGFydCArIGZpcnN0QWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aE9uUmVmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gLS0gY2hlY2sgdGhlIGNocnMgYXJlIGVxdWFsLCAgZXJyb3Igb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5zZWNvbmRBbGlnbm1lbnQgPSBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPiB0aGlzLmZpcnN0QWxpZ25tZW50LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdFbmQgPSBhbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGhPblJlZiA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIG5hbWVWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuZmlyc3RBbGlnbm1lbnQucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuc2Vjb25kQWxpZ25tZW50LnBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYWlyZWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBCeSBkZWZpbml0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RPZlBhaXJTdHJhbmQgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0QWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Vjb25kQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7ICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyBpbndhcmQgcG9pbnRpbmcgcGFpcnNcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnRSb3cge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnNjb3JlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDZW50ZXJBbGlnbm1lbnQoYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIGNlbnRlckFsaWdubWVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gZmluZCBzaW5nbGUgYWxpZ25tZW50IHRoYXQgb3ZlcmxhcHMgc29ydCBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cclxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2VudGVyQWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChhLnN0YXJ0ICsgYS5sZW5ndGhPblJlZikgPCBicFN0YXJ0IHx8IGEuc3RhcnQgPiBicEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyQWxpZ25tZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjZW50ZXJBbGlnbm1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2NvcmUoZ2Vub21pY0xvY2F0aW9uLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdGhpcy5zY29yZSA9IHRoaXMuY2FjdWxhdGVTY29yZShnZW5vbWljTG9jYXRpb24sICgxICsgZ2Vub21pY0xvY2F0aW9uKSwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGNhY3VsYXRlU2NvcmUoYnBTdGFydCwgYnBFbmQsIGdlbm9taWNJbnRlcnZhbCwgc29ydE9wdGlvbikge1xyXG5cclxuICAgICAgICB2YXIgYmFzZVNjb3JlLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGFsaWdubWVudCA9IHRoaXMuZmluZENlbnRlckFsaWdubWVudChicFN0YXJ0LCBicEVuZCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFwiTlVDTEVPVElERVwiID09PSBzb3J0T3B0aW9uLnNvcnQpIHtcclxuXHJcbiAgICAgICAgICAgIGJhc2VTY29yZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBnZW5vbWljSW50ZXJ2YWwuc2VxdWVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2VNYXAgPSBnZW5vbWljSW50ZXJ2YWwuY292ZXJhZ2VNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGhyZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiICE9PSBibG9jay5zZXEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UgPSBibG9jay5zdGFydCAtIGdlbm9taWNJbnRlcnZhbC5zdGFydCwgYnBCbG9ja1NlcXVlbmNlID0gYmxvY2suc3RhcnQsIGxlbmd0aEJsb2NrU2VxdWVuY2UgPSBibG9jay5zZXEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGxlbmd0aEJsb2NrU2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpKyssIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UrKywgYnBCbG9ja1NlcXVlbmNlKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicFN0YXJ0ID09PSBicEJsb2NrU2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSBzZXF1ZW5jZS5jaGFyQXQoaW5kZXhSZWZlcmVuY2VTZXF1ZW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gcmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSAnTicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2UgPT09IFwiWFwiIHx8IGJhc2UgIT09IHJlZmVyZW5jZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyYWdlID0gY292ZXJhZ2VNYXAuY292ZXJhZ2VbIChicEJsb2NrU2VxdWVuY2UgLSBjb3ZlcmFnZU1hcC5icFN0YXJ0KSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gY292ZXJhZ2VbIFwicG9zXCIgKyBiYXNlIF0gKyBjb3ZlcmFnZVsgXCJuZWdcIiArIGJhc2UgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHJlZCA9IChjb3ZlcmFnZS5xdWFsKSA/IGNvdmVyYWdlLnF1YWwgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IC0oY291bnQgKyAocGhyZWQgLyAxMDAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCYW1BbGlnbm1lbnRSb3cuY2FjdWxhdGVTY29yZSAtIGh1aD9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGJwU3RhcnQgPT09IGJwQmxvY2tTZXF1ZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IC8vIGJsb2NrLnNlcS5sZW5ndGhcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHVuZGVmaW5lZCA9PT0gYmFzZVNjb3JlKSA/IE51bWJlci5NQVhfVkFMVUUgOiBiYXNlU2NvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RSQU5EXCIgPT09IHNvcnRPcHRpb24uc29ydCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdHJhbmQgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RBUlRcIiA9PT0gc29ydE9wdGlvbi5zb3J0KSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgYmd6QmxvY2tTaXplID1mdW5jdGlvbihkYXRhKSB7XHJcbiAgICBjb25zdCBiYSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgY29uc3QgYnNpemUgPSAoYmFbMTddIDw8IDgpIHwgKGJhWzE2XSkgKyAxO1xyXG4gICAgcmV0dXJuIGJzaXplO1xyXG59XHJcblxyXG5leHBvcnQge2xvYWRCYW1JbmRleCxCYW1SZWFkZXIsQmFtU291cmNlLEJhbUZpbHRlcixCYW1BbGlnbm1lbnQsUGFpcmVkQWxpZ25tZW50LGJnekJsb2NrU2l6ZX07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0Q0E7QUF3Q0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUlBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/bam.js\n");

/***/ }),

/***/ "../MLVPanel/src/bam_track.js":
/*!*******************************!*\
  !*** .Panel/src/bam_track.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BAMTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nvar _bam = __webpack_require__(/*! ./bam.js */ \"../MLVPanel/src/bam.js\");\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar alignmentRowYInset = 0;\nvar alignmentStartGap = 5;\nvar downsampleRowHeight = 5;\nvar DEFAULT_COVERAGE_TRACK_HEIGHT = 50;\n\nvar BAMTrack = function (_MLVTrack) {\n    _inherits(BAMTrack, _MLVTrack);\n\n    function BAMTrack(config) {\n        _classCallCheck(this, BAMTrack);\n\n        if (!config.color) {\n            config.color = \"#D3D3D3\";\n        }\n\n        var _this = _possibleConstructorReturn(this, (BAMTrack.__proto__ || Object.getPrototypeOf(BAMTrack)).call(this, config));\n\n        _this._setFeatureSource();\n        if (_this.config.bigwig) {\n            _this.bigwig_track = new _tracks.MLVWigTrack({\n                url: _this.config.bigwig,\n                type: \"bigwig\",\n                discrete: true,\n                color: \"#D3D3D3\",\n                scale: \"dynamic\",\n                height: 100\n            });\n        }\n\n        _this.config = config;\n\n        if (config.coverageTrackHeight === undefined) {\n            config.coverageTrackHeight = DEFAULT_COVERAGE_TRACK_HEIGHT;\n        }\n\n        _this.visibilityWindow = config.visibilityWindow || 30000; // 30kb default\n\n        _this.viewAsPairs = true; //config.viewAsPairs;\n\n        _this.pairsSupported = config.pairsSupported === undefined ? true : false;\n\n        _this.color = config.color || \"rgb(185, 185, 185)\";\n\n        // sort alignment rows\n        _this.sortOption = config.sortOption || { sort: \"NUCLEOTIDE\" };\n        _this.sortDirection = true;\n\n        // filter alignments\n        _this.filterOption = config.filterOption || { name: \"mappingQuality\", params: [30, undefined] };\n\n        return _this;\n    }\n\n    _createClass(BAMTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _bam.BamSource(this.config);\n            this.feature_source.setViewAsPairs(true);\n\n            this.coverageTrack = new CoverageTrack(this.config, this);\n            this.alignmentTrack = new AlignmentTrack(this.config, this);\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n            if (bpEnd - bpStart > 500000 && this.bigwig_track) {\n                this.draw_bigwig = true;\n                return this.bigwig_track.getFeatures(chr, bpStart, bpEnd, force, data);\n            }\n            this.draw_bigwig = false;\n            return this.feature_source.getAlignments(chr, bpStart, bpEnd);\n        }\n\n        // Alt - Click to Sort alignment rows\n\n    }, {\n        key: \"altClick\",\n        value: function altClick(genomicLocation, event) {\n\n            this.alignmentTrack.sortAlignmentRows(genomicLocation, this.sortOption);\n\n            this.trackView.redrawTile(this.featureSource.alignmentContainer);\n            $(this.trackView.viewportDiv).scrollTop(0);\n\n            this.sortDirection = !this.sortDirection;\n        }\n    }, {\n        key: \"computePixelHeight\",\n\n\n        /**\r\n         * Optional method to compute pixel height to accomodate the list of features.  The implementation below\r\n         * has side effects (modifiying the samples hash).  This is unfortunate, but harmless.\r\n         *\r\n         * @param features\r\n         * @returns {number}\r\n         */\n        value: function computePixelHeight(alignmentContainer) {\n\n            return this.coverageTrack.computePixelHeight(alignmentContainer) + this.alignmentTrack.computePixelHeight(alignmentContainer);\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n            this.top = options.top;\n            if (this.draw_bigwig) {\n                this.bottom = this.bigwig_track.drawFeatures(options);\n                return;\n            }\n            if (this.coverageTrack.height > 0) {\n                this.coverageTrack.draw(options);\n            }\n\n            this.bottom = this.alignmentTrack.draw(options);\n            return this.bottom;\n        }\n    }, {\n        key: \"paintAxis\",\n        value: function paintAxis(ctx, pixelWidth, pixelHeight) {\n\n            this.coverageTrack.paintAxis(ctx, pixelWidth, this.coverageTrackHeight);\n        }\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(genomicLocation, chr, offset, bpPerPixel) {\n            var packedAlignmentRows = this.feature_source.alignmentContainer.packedAlignmentRows,\n                downsampledIntervals = this.feature_source.alignmentContainer.downsampledIntervals,\n                packedAlignmentsIndex,\n                alignmentRow,\n                clickedObject,\n                i,\n                len,\n                tmp;\n\n            packedAlignmentsIndex = Math.floor((offset.y - this.top - this.coverageTrack.height - alignmentRowYInset) / this.config.featureHeight);\n\n            if (packedAlignmentsIndex < 0) {\n\n                for (i = 0, len = downsampledIntervals.length; i < len; i++) {\n\n                    if (downsampledIntervals[i].start <= genomicLocation && downsampledIntervals[i].end >= genomicLocation) {\n                        clickedObject = downsampledIntervals[i];\n                        break;\n                    }\n                }\n            } else if (packedAlignmentsIndex < packedAlignmentRows.length) {\n\n                alignmentRow = packedAlignmentRows[packedAlignmentsIndex];\n\n                clickedObject = undefined;\n\n                for (i = 0, len = alignmentRow.alignments.length, tmp; i < len; i++) {\n\n                    tmp = alignmentRow.alignments[i];\n\n                    if (tmp.start <= genomicLocation && tmp.start + tmp.lengthOnRef >= genomicLocation) {\n                        clickedObject = tmp;\n                        break;\n                    }\n                }\n            }\n\n            return clickedObject;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            if (yOffset >= this.coverageTrack.top && yOffset < this.coverageTrack.height) {\n                return this.coverageTrack.popupData(genomicLocation, xOffset, this.coverageTrack.top);\n            } else {\n                return this.alignmentTrack.popupData(genomicLocation, xOffset, yOffset - this.alignmentTrack.top);\n            }\n        }\n    }, {\n        key: \"popupMenuItems\",\n        value: function popupMenuItems(popover) {\n\n            var self = this,\n                html,\n                menuItems = [],\n                colorByMenuItems = [],\n                tagLabel = 'tag' + (self.alignmentTrack.colorByTag ? ' (' + self.alignmentTrack.colorByTag + ')' : ''),\n                selected;\n\n            colorByMenuItems.push({ key: 'none', label: 'track color' });\n\n            if (!self.viewAsPairs) {\n                colorByMenuItems.push({ key: 'strand', label: 'read strand' });\n            }\n            if (self.pairsSupported && self.alignmentTrack.hasPairs) {\n                colorByMenuItems.push({ key: 'firstOfPairStrand', label: 'first-of-pair strand' });\n            }\n            colorByMenuItems.push({ key: 'tag', label: tagLabel });\n\n            menuItems.push(igv.colorPickerMenuItem(popover, this.trackView));\n\n            menuItems.push('<div class=\"igv-track-menu-category igv-track-menu-border-top\">Color by</div>');\n\n            colorByMenuItems.forEach(function (item) {\n                selected = self.alignmentTrack.colorBy === item.key;\n                menuItems.push(colorByMarkup(item, selected));\n            });\n\n            html = [];\n            if (self.pairsSupported && self.alignmentTrack.hasPairs) {\n                html.push('<div class=\"igv-track-menu-item igv-track-menu-border-top\">');\n                html.push(true === self.viewAsPairs ? '<i class=\"fa fa-check fa-check-shim\">' : '<i class=\"fa fa-check fa-check-shim fa-check-hidden\">');\n                html.push('</i>');\n                html.push('View as pairs');\n                html.push('</div>');\n                menuItems.push({\n                    object: $(html.join('')),\n                    click: function click() {\n                        var $fa = $(this).find('i');\n\n                        popover.hide();\n\n                        self.viewAsPairs = !self.viewAsPairs;\n\n                        if (true === self.viewAsPairs) {\n                            $fa.removeClass('fa-check-hidden');\n                        } else {\n                            $fa.addClass('fa-check-hidden');\n                        }\n\n                        self.featureSource.setViewAsPairs(self.viewAsPairs);\n                        self.trackView.update();\n                    }\n                });\n            }\n\n            return menuItems;\n\n            function colorByMarkup(menuItem, showCheck, index) {\n\n                var parts = [],\n                    item = {};\n\n                //parts.push((0 === index) ? '<div class=\\\"igv-track-menu-item igv-track-menu-border-top\\\">' : '<div class=\"igv-track-menu-item\">');\n                parts.push('<div class=\"igv-track-menu-item\">');\n\n                parts.push(showCheck ? '<i class=\"fa fa-check fa-check-shim\"></i>' : '<i class=\"fa fa-check fa-check-shim fa-check-hidden\"></i>');\n\n                //parts.push('<span>');\n                //parts.push('Color by: ');\n                //parts.push('</span>');\n\n                if (menuItem.key === 'tag') {\n                    parts.push('<span id=\"color-by-tag\">');\n                } else {\n                    parts.push('<span>');\n                }\n                parts.push(menuItem.label);\n                parts.push('</span>');\n\n                parts.push('</div>');\n\n                item.object = $(parts.join(''));\n\n                item.click = function () {\n\n                    igv.popover.hide();\n\n                    if ('tag' === menuItem.key) {\n\n                        igv.dialog.configure(function () {\n                            return \"Tag Name\";\n                        }, self.alignmentTrack.colorByTag ? self.alignmentTrack.colorByTag : '', function () {\n                            var tag = igv.dialog.$dialogInput.val().trim();\n                            self.alignmentTrack.colorBy = 'tag';\n\n                            if (tag !== self.alignmentTrack.colorByTag) {\n                                self.alignmentTrack.colorByTag = igv.dialog.$dialogInput.val().trim();\n                                self.alignmentTrack.tagColors = new igv.PaletteColorTable(\"Set1\");\n                                $('#color-by-tag').text(self.alignmentTrack.colorByTag);\n                            }\n\n                            self.trackView.update();\n                        });\n\n                        igv.dialog.show($(self.trackView.trackDiv));\n                    } else {\n                        self.alignmentTrack.colorBy = menuItem.key;\n                        self.trackView.update();\n                    }\n                };\n\n                return item;\n            }\n        }\n    }]);\n\n    return BAMTrack;\n}(_tracks.MLVTrack);\n\nfunction shadedBaseColor(qual, nucleotide, genomicLocation) {\n\n    var color,\n        alpha,\n        minQ = 5,\n        //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN),\n    maxQ = 20,\n        //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX);\n    foregroundColor = [0, 255, 255],\n        //nucleotideColorComponents[nucleotide],\n    backgroundColor = [255, 255, 255]; // White\n\n\n    //if (171167156 === genomicLocation) {\n    //    // NOTE: Add 1 when presenting genomic location\n    //    console.log(\"shadedBaseColor - locus \" + igv.numberFormatter(1 + genomicLocation) + \" qual \" + qual);\n    //}\n\n    if (!foregroundColor) return;\n\n    if (qual < minQ) {\n        alpha = 0.1;\n    } else {\n        alpha = Math.max(0.1, Math.min(1.0, 0.1 + 0.9 * (qual - minQ) / (maxQ - minQ)));\n    }\n    // Round alpha to nearest 0.1\n    alpha = Math.round(alpha * 10) / 10.0;\n\n    if (alpha >= 1) {\n        color = _tracks.Graphics.nucleotideColors[nucleotide];\n    } else {\n        color = \"rgba(\" + foregroundColor[0] + \",\" + foregroundColor[1] + \",\" + foregroundColor[2] + \",\" + alpha + \")\"; //igv.getCompositeColor(backgroundColor, foregroundColor, alpha);\n    }\n    return color;\n}\n\nvar CoverageTrack = function () {\n    function CoverageTrack(config, parent) {\n        _classCallCheck(this, CoverageTrack);\n\n        this.parent = parent;\n        this.featureSource = parent.featureSource;\n\n        this.height = 20; //config.coverageTrackHeight;\n        this.dataRange = { min: 0 }; // Leav max undefined\n    }\n\n    _createClass(CoverageTrack, [{\n        key: \"computePixelHeight\",\n        value: function computePixelHeight(alignmentContainer) {\n            return this.height;\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(options) {\n\n            var self = this,\n                alignmentContainer = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                coverageMap = alignmentContainer.coverageMap,\n                bp,\n                x,\n                y,\n                w,\n                h,\n                refBase,\n                i,\n                len,\n                item,\n                accumulatedHeight,\n                sequence;\n\n            if (coverageMap.refSeq) sequence = coverageMap.refSeq.toUpperCase();\n\n            this.dataRange.max = coverageMap.maximum;\n            var top = options.top;\n            options.top += this.height;\n            // paint backdrop color for all coverage buckets\n            w = Math.max(1, Math.ceil(1.0 / bpPerPixel));\n            for (i = 0, len = coverageMap.coverage.length; i < len; i++) {\n\n                bp = coverageMap.bpStart + i;\n                if (bp < bpStart) continue;\n                if (bp > bpEnd) break;\n\n                item = coverageMap.coverage[i];\n                if (!item) continue;\n\n                h = Math.round(item.total / this.dataRange.max * this.height);\n                y = this.height - h;\n                x = Math.floor((bp - bpStart) / bpPerPixel);\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: this.parent.config.color, strokeStyle: this.color });\n                _tracks.Graphics.fillRect(ctx, x, y + top, w, h);\n            }\n\n            // coverage mismatch coloring -- don't try to do this in above loop, color bar will be overwritten when w<1\n            if (sequence) {\n                for (i = 0, len = coverageMap.coverage.length; i < len; i++) {\n\n                    bp = coverageMap.bpStart + i;\n                    if (bp < bpStart) continue;\n                    if (bp > bpEnd) break;\n\n                    item = coverageMap.coverage[i];\n                    if (!item) continue;\n\n                    h = item.total / this.dataRange.max * this.height;\n                    y = this.height - h;\n                    x = Math.floor((bp - bpStart) / bpPerPixel);\n\n                    refBase = sequence[i];\n                    if (item.isMismatch(refBase)) {\n\n                        _tracks.Graphics.setProperties(ctx, { fillStyle: _tracks.Graphics.nucleotideColors[refBase] });\n                        _tracks.Graphics.fillRect(ctx, x, y + top, w, h);\n\n                        accumulatedHeight = 0.0;\n                        [\"A\", \"C\", \"T\", \"G\"].forEach(function (nucleotide) {\n\n                            var count, hh;\n\n                            count = item[\"pos\" + nucleotide] + item[\"neg\" + nucleotide];\n\n                            // non-logoritmic\n                            hh = count / self.dataRange.max * self.height;\n\n                            y = self.height - hh - accumulatedHeight;\n                            accumulatedHeight += hh;\n\n                            _tracks.Graphics.setProperties(ctx, { fillStyle: _tracks.Graphics.nucleotideColors[nucleotide] });\n                            _tracks.Graphics.fillRect(ctx, x, y + top, w, hh);\n                        });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            var coverageMap = this.featureSource.alignmentContainer.coverageMap,\n                coverageMapIndex,\n                coverage,\n                nameValues = [];\n\n            coverageMapIndex = genomicLocation - coverageMap.bpStart;\n            coverage = coverageMap.coverage[coverageMapIndex];\n\n            if (coverage) {\n\n                nameValues.push(igv.browser.referenceFrame.chr + \":\" + igv.numberFormatter(1 + genomicLocation));\n\n                nameValues.push({ name: 'Total Count', value: coverage.total });\n\n                // A\n                tmp = coverage.posA + coverage.negA;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor((coverage.posA + coverage.negA) / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'A', value: tmp });\n\n                // C\n                tmp = coverage.posC + coverage.negC;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'C', value: tmp });\n\n                // G\n                tmp = coverage.posG + coverage.negG;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'G', value: tmp });\n\n                // T\n                tmp = coverage.posT + coverage.negT;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'T', value: tmp });\n\n                // N\n                tmp = coverage.posN + coverage.negN;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'N', value: tmp });\n            }\n\n            return nameValues;\n        }\n    }]);\n\n    return CoverageTrack;\n}();\n\nvar AlignmentTrack = function () {\n    function AlignmentTrack(config, parent) {\n        _classCallCheck(this, AlignmentTrack);\n\n        this.config = config;\n\n        this.parent = parent;\n        this.featureSource = parent.feature_source;\n\n        this.alignmentRowHeight = config.alignmentRowHeight || 6;\n\n        this.negStrandColor = config.negStrandColor || \"rgba(150, 150, 230, 0.75)\";\n        this.posStrandColor = config.posStrandColor || \"rgba(230, 150, 150, 0.75)\";\n        this.insertionColor = config.insertionColor || \"rgb(138, 94, 161)\";\n        this.deletionColor = config.deletionColor || \"black\";\n        this.skippedColor = config.skippedColor || \"rgb(150, 170, 170)\";\n\n        this.colorBy = config.colorBy || \"none\";\n        this.colorByTag = config.colorByTag;\n        this.bamColorTag = config.bamColorTag === undefined ? \"YC\" : config.bamColorTag;\n\n        // sort alignment rows\n        this.sortOption = config.sortOption || { sort: \"NUCLEOTIDE\" };\n\n        this.sortDirection = true;\n\n        this.hasPairs = false; // Until proven otherwise\n    }\n\n    _createClass(AlignmentTrack, [{\n        key: \"computePixelHeight\",\n        value: function computePixelHeight(alignmentContainer) {\n\n            if (alignmentContainer.packedAlignmentRows) {\n                var h = 0;\n                if (alignmentContainer.hasDownsampledIntervals()) {\n                    h += downsampleRowHeight + alignmentStartGap;\n                }\n                return h + this.config.featureHeight * alignmentContainer.packedAlignmentRows.length + 5;\n            } else {\n                return this.height;\n            }\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(options) {\n\n            var self = this,\n                alignmentContainer = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                packedAlignmentRows = alignmentContainer.packedAlignmentRows,\n                sequence = alignmentContainer.sequence,\n                base_text = \"normal \" + (this.config.featureHeight - 2) + \"px Arial\";\n\n            var top = options.top;\n            if (sequence) {\n                sequence = sequence.toUpperCase();\n            }\n\n            if (false /*alignmentContainer.hasDownsampledIntervals()*/) {} else {\n                alignmentRowYInset = 3;\n            }\n\n            if (packedAlignmentRows) {\n\n                packedAlignmentRows.forEach(function renderAlignmentRow(alignmentRow, i) {\n\n                    var yRect = alignmentRowYInset + self.config.featureHeight * i + top,\n                        alignmentHeight = self.config.featureHeight - 2,\n                        i,\n                        b,\n                        alignment;\n\n                    for (i = 0; i < alignmentRow.alignments.length; i++) {\n\n                        alignment = alignmentRow.alignments[i];\n\n                        self.hasPairs = self.hasPairs || alignment.isPaired();\n\n                        if (alignment.start + alignment.lengthOnRef < bpStart) continue;\n                        if (alignment.start > bpEnd) break;\n\n                        if (true === alignment.hidden) {\n                            continue;\n                        }\n\n                        if (alignment instanceof _bam.PairedAlignment) {\n\n                            drawPairConnector(alignment, yRect, alignmentHeight);\n\n                            drawSingleAlignment(alignment.firstAlignment, yRect, alignmentHeight);\n\n                            if (alignment.secondAlignment) {\n                                drawSingleAlignment(alignment.secondAlignment, yRect, alignmentHeight);\n                            }\n                        } else {\n                            drawSingleAlignment(alignment, yRect, alignmentHeight);\n                        }\n                    }\n                });\n            }\n\n            // alignment is a PairedAlignment\n            function drawPairConnector(alignment, yRect, alignmentHeight) {\n\n                var alignmentColor = self.getAlignmentColor(alignment.firstAlignment),\n                    outlineColor = alignmentColor,\n                    xBlockStart = (alignment.connectingStart - bpStart) / bpPerPixel,\n                    xBlockEnd = (alignment.connectingEnd - bpStart) / bpPerPixel,\n                    yStrokedLine = yRect + alignmentHeight / 2;\n\n                if (alignment.connectingEnd < bpStart || alignment.connectingStart > bpEnd) return;\n\n                if (alignment.mq <= 0) {\n                    alignmentColor = _utils.Utils.addAlphaToRGB(alignmentColor, \"0.15\");\n                }\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: alignmentColor, strokeStyle: outlineColor });\n\n                _tracks.Graphics.strokeLine(ctx, xBlockStart, yStrokedLine, xBlockEnd, yStrokedLine);\n            }\n\n            function drawSingleAlignment(alignment, yRect, alignmentHeight) {\n\n                var alignmentColor = self.getAlignmentColor(alignment),\n                    outlineColor = alignmentColor,\n                    lastBlockEnd,\n                    blocks = alignment.blocks,\n                    block,\n                    b;\n\n                if (alignment.start + alignment.lengthOnRef < bpStart || alignment.start > bpEnd) return;\n\n                if (alignment.mq <= 0) {\n                    alignmentColor = _utils.Utils.addAlphaToRGB(alignmentColor, \"0.15\");\n                }\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: alignmentColor, strokeStyle: outlineColor });\n\n                for (b = 0; b < blocks.length; b++) {\n                    // Can't use forEach here -- we need ability to break\n\n                    block = blocks[b];\n\n                    if (block.start + block.len < bpStart) continue;\n\n                    drawBlock(block);\n\n                    if (block.start + block.len > bpEnd) break; // Do this after drawBlock to insure gaps are drawn\n\n\n                    if (alignment.insertions) {\n                        alignment.insertions.forEach(function (block) {\n                            var refOffset = block.start - bpStart,\n                                xBlockStart = refOffset / bpPerPixel - 1,\n                                widthBlock = 3;\n                            _tracks.Graphics.fillRect(ctx, xBlockStart, yRect - 1, widthBlock, alignmentHeight + 2, { fillStyle: self.insertionColor });\n                        });\n                    }\n                }\n\n                function drawBlock(block) {\n                    var seqOffset = block.start - alignmentContainer.start,\n                        xBlockStart = (block.start - bpStart) / bpPerPixel,\n                        xBlockEnd = (block.start + block.len - bpStart) / bpPerPixel,\n                        widthBlock = Math.max(1, xBlockEnd - xBlockStart),\n                        widthArrowHead = self.config.featureHeight / 2.0,\n                        blockSeq = block.seq.toUpperCase(),\n                        skippedColor = self.skippedColor,\n                        deletionColor = self.deletionColor,\n                        refChar,\n                        readChar,\n                        readQual,\n                        xBase,\n                        widthBase,\n                        colorBase,\n                        x,\n                        y,\n                        i,\n                        yStrokedLine = yRect + alignmentHeight / 2;\n\n                    if (block.gapType !== undefined && xBlockEnd !== undefined && lastBlockEnd !== undefined) {\n                        if (\"D\" === block.gapType) {\n                            _tracks.Graphics.strokeLine(ctx, lastBlockEnd, yStrokedLine, xBlockStart, yStrokedLine, { strokeStyle: deletionColor });\n                        } else {\n                            _tracks.Graphics.strokeLine(ctx, lastBlockEnd, yStrokedLine, xBlockStart, yStrokedLine, { strokeStyle: skippedColor });\n                        }\n                    }\n                    lastBlockEnd = xBlockEnd;\n\n                    if (true === alignment.strand && b === blocks.length - 1) {\n                        // Last block on + strand\n                        x = [xBlockStart, xBlockEnd, xBlockEnd + widthArrowHead, xBlockEnd, xBlockStart, xBlockStart];\n                        y = [yRect, yRect, yRect + alignmentHeight / 2.0, yRect + alignmentHeight, yRect + alignmentHeight, yRect];\n                        _tracks.Graphics.fillPolygon(ctx, x, y, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            _tracks.Graphics.strokePolygon(ctx, x, y, { strokeStyle: outlineColor });\n                        }\n                    } else if (false === alignment.strand && b === 0) {\n                        // First block on - strand\n                        x = [xBlockEnd, xBlockStart, xBlockStart - widthArrowHead, xBlockStart, xBlockEnd, xBlockEnd];\n                        y = [yRect, yRect, yRect + alignmentHeight / 2.0, yRect + alignmentHeight, yRect + alignmentHeight, yRect];\n                        _tracks.Graphics.fillPolygon(ctx, x, y, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            _tracks.Graphics.strokePolygon(ctx, x, y, { strokeStyle: outlineColor });\n                        }\n                    } else {\n                        //      igv.graphics.fillRect(ctx, xBlockStart, yRect, widthBlock, height, {fillStyle: \"white\"});\n                        _tracks.Graphics.fillRect(ctx, xBlockStart, yRect, widthBlock, alignmentHeight, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            ctx.save();\n                            ctx.strokeStyle = outlineColor;\n                            ctx.strokeRect(xBlockStart, yRect, widthBlock, alignmentHeight);\n                            ctx.restore();\n                        }\n                    }\n                    // Only do mismatch coloring if a refseq exists to do the comparison\n                    if (sequence && blockSeq !== \"*\") {\n                        for (var i = 0, len = blockSeq.length; i < len; i++) {\n                            readChar = blockSeq.charAt(i);\n                            refChar = sequence.charAt(seqOffset + i);\n                            if (readChar === \"=\") {\n                                readChar = refChar;\n                            }\n                            if (readChar === \"X\" || refChar !== readChar) {\n                                if (block.qual && block.qual.length > i) {\n                                    readQual = block.qual[i];\n                                    colorBase = shadedBaseColor(readQual, readChar, i + block.start);\n                                } else {\n                                    colorBase = _tracks.Graphics.nucleotideColors[readChar];\n                                }\n                                if (colorBase) {\n                                    xBase = (block.start + i - bpStart) / bpPerPixel;\n                                    widthBase = Math.max(1, 1 / bpPerPixel);\n                                    if (bpPerPixel < 0.15) {\n                                        _tracks.Graphics.strokeText(ctx, readChar, xBase + widthBase / 2, yRect + 2, {\n                                            strokeStyle: colorBase,\n                                            font: base_text,\n                                            textAlign: 'center',\n                                            textBaseline: 'hanging'\n                                        });\n                                    } else {\n                                        _tracks.Graphics.fillRect(ctx, xBase, yRect, widthBase, alignmentHeight, { fillStyle: colorBase });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return alignmentRowYInset + self.config.featureHeight * packedAlignmentRows.length + top;\n        }\n    }, {\n        key: \"sortAlignmentRows\",\n        value: function sortAlignmentRows(genomicLocation, sortOption) {\n\n            var self = this,\n                alignmentContainer = this.featureSource.alignmentContainer,\n                alignmentRows = alignmentContainer.packedAlignmentRows;\n\n            alignmentRows.forEach(function (alignmentRow) {\n                alignmentRow.updateScore(genomicLocation, alignmentContainer, sortOption);\n            });\n\n            alignmentRows.sort(function (a, b) {\n                return self.sortDirection ? a.score - b.score : b.score - a.score;\n            });\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            var packedAlignmentRows = this.featureSource.alignmentContainer.packedAlignmentRows,\n                downsampledIntervals = this.featureSource.alignmentContainer.downsampledIntervals,\n                packedAlignmentsIndex,\n                alignmentRow,\n                clickedObject,\n                i,\n                len,\n                tmp;\n\n            packedAlignmentsIndex = Math.floor((yOffset - alignmentRowYInset) / this.config.featureHeight);\n\n            if (packedAlignmentsIndex < 0) {\n\n                for (i = 0, len = downsampledIntervals.length; i < len; i++) {\n\n                    if (downsampledIntervals[i].start <= genomicLocation && downsampledIntervals[i].end >= genomicLocation) {\n                        clickedObject = downsampledIntervals[i];\n                        break;\n                    }\n                }\n            } else if (packedAlignmentsIndex < packedAlignmentRows.length) {\n\n                alignmentRow = packedAlignmentRows[packedAlignmentsIndex];\n\n                clickedObject = undefined;\n\n                for (i = 0, len = alignmentRow.alignments.length, tmp; i < len; i++) {\n\n                    tmp = alignmentRow.alignments[i];\n\n                    if (tmp.start <= genomicLocation && tmp.start + tmp.lengthOnRef >= genomicLocation) {\n                        clickedObject = tmp;\n                        break;\n                    }\n                }\n            }\n\n            if (clickedObject) {\n                return clickedObject.popupData(genomicLocation);\n            } else {\n                return [];\n            }\n        }\n    }, {\n        key: \"getAlignmentColor\",\n        value: function getAlignmentColor(alignment) {\n\n            var alignmentTrack = this,\n                option = alignmentTrack.colorBy,\n                tagValue,\n                color,\n                strand;\n\n            color = alignmentTrack.parent.config.color; // default\n\n            switch (option) {\n\n                case \"strand\":\n                    color = alignment.strand ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                    break;\n                case \"firstOfPairStrand\":\n\n                    if (alignment instanceof _bam.PairedAlignment) {\n                        color = alignment.firstOfPairStrand() ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                    } else if (alignment.isPaired()) {\n\n                        if (alignment.isFirstOfPair()) {\n                            color = alignment.strand ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                        } else if (alignment.isSecondOfPair()) {\n                            color = alignment.strand ? alignmentTrack.negStrandColor : alignmentTrack.posStrandColor;\n                        } else {\n                            console.log(\"ERROR. Paired alignments are either first or second.\");\n                        }\n                    }\n                    break;\n\n                case \"tag\":\n\n                    tagValue = alignment.tags()[alignmentTrack.colorByTag];\n                    if (tagValue !== undefined) {\n\n                        if (alignmentTrack.bamColorTag === alignmentTrack.colorByTag) {\n                            // UCSC style color option\n                            color = \"rgb(\" + tagValue + \")\";\n                        } else {\n                            color = alignmentTrack.tagColors.getColor(tagValue);\n                        }\n                    }\n                    break;\n                default:\n                    color = alignmentTrack.parent.config.color;\n            }\n            return color;\n        }\n    }], [{\n        key: \"doSortAlignmentRows\",\n        value: function doSortAlignmentRows(genomicLocation, genomicInterval, sortOption, sortDirection) {\n\n            var alignmentRows = genomicInterval.packedAlignmentRows,\n                sequence = genomicInterval.sequence;\n\n            if (sequence) {\n                sequence = sequence.toUpperCase();\n            } else {\n                console.log(\"No sequence, no traversal. No discussion!\");\n                return;\n            }\n\n            alignmentRows.forEach(function (alignmentRow) {\n                alignmentRow.updateScore(genomicLocation, genomicInterval, sortOption);\n            });\n\n            alignmentRows.sort(function (a, b) {\n                return sortDirection ? a.score - b.score : b.score - a.score;\n            });\n        }\n    }]);\n\n    return AlignmentTrack;\n}();\n\nBAMTrack.filters = {\n\n    noop: function noop() {\n        return function (alignment) {\n            return false;\n        };\n    },\n\n    strand: function strand(_strand) {\n        return function (alignment) {\n            return alignment.strand === _strand;\n        };\n    },\n\n    mappingQuality: function mappingQuality(lower, upper) {\n        return function (alignment) {\n\n            if (lower && alignment.mq < lower) {\n                return true;\n            }\n\n            if (upper && alignment.mq > upper) {\n                return true;\n            }\n\n            return false;\n        };\n    }\n};\n\n_tracks.MLVTrack.custom_tracks[\"bam\"] = BAMTrack;\n\n_tracks.MLVTrack.track_types[\"bam\"] = {\n    \"class\": BAMTrack,\n    name: \"BAM\"\n};\n\nexports.BAMTrack = BAMTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JhbV90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmFtX3RyYWNrLmpzPzljM2EiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7TUxWVHJhY2ssR3JhcGhpY3MsTUxWV2lnVHJhY2t9IGZyb20gXCIuL3RyYWNrcy5qc1wiO1xyXG5pbXBvcnQge0JhbVNvdXJjZSxQYWlyZWRBbGlnbm1lbnR9IGZyb20gXCIuL2JhbS5qc1wiO1xyXG5pbXBvcnQge1V0aWxzfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG5cclxudmFyIGFsaWdubWVudFJvd1lJbnNldCA9IDA7XHJcbnZhciBhbGlnbm1lbnRTdGFydEdhcCA9IDU7XHJcbnZhciBkb3duc2FtcGxlUm93SGVpZ2h0ID0gNTtcclxuY29uc3QgREVGQVVMVF9DT1ZFUkFHRV9UUkFDS19IRUlHSFQgPSA1MDtcclxuXHJcbmNsYXNzIEJBTVRyYWNrIGV4dGVuZHMgTUxWVHJhY2t7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKCFjb25maWcuY29sb3Ipe1xyXG4gICAgICAgICAgICBjb25maWcuY29sb3I9XCIjRDNEM0QzXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5iaWd3aWcpe1xyXG4gICAgICAgICAgICB0aGlzLmJpZ3dpZ190cmFjayA9IG5ldyBNTFZXaWdUcmFjayh7XHJcbiAgICAgICAgICAgICAgICB1cmw6dGhpcy5jb25maWcuYmlnd2lnLFxyXG4gICAgICAgICAgICAgICAgdHlwZTpcImJpZ3dpZ1wiLFxyXG4gICAgICAgICAgICAgICAgZGlzY3JldGU6dHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOlwiI0QzRDNEM1wiLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6XCJkeW5hbWljXCIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6MTAwXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWc9Y29uZmlnO1xyXG5cclxuICAgICAgICBpZihjb25maWcuY292ZXJhZ2VUcmFja0hlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5jb3ZlcmFnZVRyYWNrSGVpZ2h0ID0gREVGQVVMVF9DT1ZFUkFHRV9UUkFDS19IRUlHSFQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5V2luZG93ID0gY29uZmlnLnZpc2liaWxpdHlXaW5kb3cgfHwgMzAwMDA7ICAgICAvLyAzMGtiIGRlZmF1bHRcclxuXHJcbiAgICAgICAgdGhpcy52aWV3QXNQYWlycyA9IHRydWU7Ly9jb25maWcudmlld0FzUGFpcnM7XHJcblxyXG4gICAgICAgIHRoaXMucGFpcnNTdXBwb3J0ZWQgPSBjb25maWcucGFpcnNTdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbmZpZy5jb2xvciB8fCBcInJnYigxODUsIDE4NSwgMTg1KVwiO1xyXG5cclxuICAgICAgICAvLyBzb3J0IGFsaWdubWVudCByb3dzXHJcbiAgICAgICAgdGhpcy5zb3J0T3B0aW9uID0gY29uZmlnLnNvcnRPcHRpb24gfHwge3NvcnQ6IFwiTlVDTEVPVElERVwifTtcclxuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb24gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBmaWx0ZXIgYWxpZ25tZW50c1xyXG4gICAgICAgIHRoaXMuZmlsdGVyT3B0aW9uID0gY29uZmlnLmZpbHRlck9wdGlvbiB8fCB7bmFtZTogXCJtYXBwaW5nUXVhbGl0eVwiLCBwYXJhbXM6IFszMCwgdW5kZWZpbmVkXX07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIF9zZXRGZWF0dXJlU291cmNlKCl7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQmFtU291cmNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLmZlYXR1cmVfc291cmNlLnNldFZpZXdBc1BhaXJzKHRydWUpO1xyXG5cclxuXHQgICB0aGlzLmNvdmVyYWdlVHJhY2sgPSBuZXcgQ292ZXJhZ2VUcmFjayh0aGlzLmNvbmZpZywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRUcmFjayA9IG5ldyBBbGlnbm1lbnRUcmFjayh0aGlzLmNvbmZpZywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgaWYgKGJwRW5kLSBicFN0YXJ0PjUwMDAwMCAmJiB0aGlzLmJpZ3dpZ190cmFjayl7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd19iaWd3aWc9dHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmlnd2lnX3RyYWNrLmdldEZlYXR1cmVzKGNociwgYnBTdGFydCwgYnBFbmQsZm9yY2UsZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhd19iaWd3aWc9ZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0QWxpZ25tZW50cyhjaHIsIGJwU3RhcnQsIGJwRW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbHQgLSBDbGljayB0byBTb3J0IGFsaWdubWVudCByb3dzXHJcbiAgICBhbHRDbGljayhnZW5vbWljTG9jYXRpb24sIGV2ZW50KSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50VHJhY2suc29ydEFsaWdubWVudFJvd3MoZ2Vub21pY0xvY2F0aW9uLCB0aGlzLnNvcnRPcHRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLnRyYWNrVmlldy5yZWRyYXdUaWxlKHRoaXMuZmVhdHVyZVNvdXJjZS5hbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICQodGhpcy50cmFja1ZpZXcudmlld3BvcnREaXYpLnNjcm9sbFRvcCgwKTtcclxuXHJcbiAgICAgICAgdGhpcy5zb3J0RGlyZWN0aW9uID0gIXRoaXMuc29ydERpcmVjdGlvbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uYWwgbWV0aG9kIHRvIGNvbXB1dGUgcGl4ZWwgaGVpZ2h0IHRvIGFjY29tb2RhdGUgdGhlIGxpc3Qgb2YgZmVhdHVyZXMuICBUaGUgaW1wbGVtZW50YXRpb24gYmVsb3dcclxuICAgICAqIGhhcyBzaWRlIGVmZmVjdHMgKG1vZGlmaXlpbmcgdGhlIHNhbXBsZXMgaGFzaCkuICBUaGlzIGlzIHVuZm9ydHVuYXRlLCBidXQgaGFybWxlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVzXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBjb21wdXRlUGl4ZWxIZWlnaHQoYWxpZ25tZW50Q29udGFpbmVyKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvdmVyYWdlVHJhY2suY29tcHV0ZVBpeGVsSGVpZ2h0KGFsaWdubWVudENvbnRhaW5lcikgK1xyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudFRyYWNrLmNvbXB1dGVQaXhlbEhlaWdodChhbGlnbm1lbnRDb250YWluZXIpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRvcD1vcHRpb25zLnRvcDtcclxuICAgICAgICBpZiAodGhpcy5kcmF3X2JpZ3dpZyl7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tPXRoaXMuYmlnd2lnX3RyYWNrLmRyYXdGZWF0dXJlcyhvcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLmNvdmVyYWdlVHJhY2suaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdmVyYWdlVHJhY2suZHJhdyhvcHRpb25zKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmFsaWdubWVudFRyYWNrLmRyYXcob3B0aW9ucyk7XHJcbiAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbTtcclxuICAgIH07XHJcblxyXG4gICAgcGFpbnRBeGlzKGN0eCwgcGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb3ZlcmFnZVRyYWNrLnBhaW50QXhpcyhjdHgsIHBpeGVsV2lkdGgsIHRoaXMuY292ZXJhZ2VUcmFja0hlaWdodCk7XHJcblxyXG4gICAgfVxyXG4gICAgZ2V0RmVhdHVyZUF0KGdlbm9taWNMb2NhdGlvbixjaHIsb2Zmc2V0LGJwUGVyUGl4ZWwpe1xyXG4gICAgXHR2YXIgcGFja2VkQWxpZ25tZW50Um93cyA9IHRoaXMuZmVhdHVyZV9zb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MsXHJcbiAgICAgICAgICAgIGRvd25zYW1wbGVkSW50ZXJ2YWxzID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5hbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRJbnRlcnZhbHMsXHJcbiAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudHNJbmRleCxcclxuICAgICAgICAgICAgYWxpZ25tZW50Um93LFxyXG4gICAgICAgICAgICBjbGlja2VkT2JqZWN0LFxyXG4gICAgICAgICAgICBpLCBsZW4sIHRtcDtcclxuICAgICAgICBcclxuICAgICAgICBwYWNrZWRBbGlnbm1lbnRzSW5kZXggPSBNYXRoLmZsb29yKCgob2Zmc2V0LnkgLXRoaXMudG9wLXRoaXMuY292ZXJhZ2VUcmFjay5oZWlnaHQpIC0gKGFsaWdubWVudFJvd1lJbnNldCkpIC8gdGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmIChwYWNrZWRBbGlnbm1lbnRzSW5kZXggPCAwKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkb3duc2FtcGxlZEludGVydmFscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZG93bnNhbXBsZWRJbnRlcnZhbHNbaV0uc3RhcnQgPD0gZ2Vub21pY0xvY2F0aW9uICYmIChkb3duc2FtcGxlZEludGVydmFsc1tpXS5lbmQgPj0gZ2Vub21pY0xvY2F0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRPYmplY3QgPSBkb3duc2FtcGxlZEludGVydmFsc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFja2VkQWxpZ25tZW50c0luZGV4IDwgcGFja2VkQWxpZ25tZW50Um93cy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdyA9IHBhY2tlZEFsaWdubWVudFJvd3NbcGFja2VkQWxpZ25tZW50c0luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIGNsaWNrZWRPYmplY3QgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50cy5sZW5ndGgsIHRtcDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdG1wID0gYWxpZ25tZW50Um93LmFsaWdubWVudHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRtcC5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gJiYgKHRtcC5zdGFydCArIHRtcC5sZW5ndGhPblJlZiA+PSBnZW5vbWljTG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IHRtcDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbGlja2VkT2JqZWN0O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbiwgeE9mZnNldCwgeU9mZnNldCkge1xyXG5cclxuICAgICAgICBpZiAoeU9mZnNldCA+PSB0aGlzLmNvdmVyYWdlVHJhY2sudG9wICYmIHlPZmZzZXQgPCB0aGlzLmNvdmVyYWdlVHJhY2suaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdmVyYWdlVHJhY2sucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbiwgeE9mZnNldCwgdGhpcy5jb3ZlcmFnZVRyYWNrLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRUcmFjay5wb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uLCB4T2Zmc2V0LCB5T2Zmc2V0IC0gdGhpcy5hbGlnbm1lbnRUcmFjay50b3ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBNZW51SXRlbXMocG9wb3Zlcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGh0bWwsXHJcbiAgICAgICAgICAgIG1lbnVJdGVtcyA9IFtdLFxyXG4gICAgICAgICAgICBjb2xvckJ5TWVudUl0ZW1zID0gW10sXHJcbiAgICAgICAgICAgIHRhZ0xhYmVsID0gJ3RhZycgKyAoc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnID8gJyAoJyArIHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeVRhZyArICcpJyA6ICcnKSxcclxuICAgICAgICAgICAgc2VsZWN0ZWQ7XHJcblxyXG5cclxuICAgICAgICBjb2xvckJ5TWVudUl0ZW1zLnB1c2goe2tleTogJ25vbmUnLCBsYWJlbDogJ3RyYWNrIGNvbG9yJ30pO1xyXG5cclxuICAgICAgICBpZighc2VsZi52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICBjb2xvckJ5TWVudUl0ZW1zLnB1c2goe2tleTogJ3N0cmFuZCcsIGxhYmVsOiAncmVhZCBzdHJhbmQnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLnBhaXJzU3VwcG9ydGVkICYmIHNlbGYuYWxpZ25tZW50VHJhY2suaGFzUGFpcnMpIHtcclxuICAgICAgICAgICAgY29sb3JCeU1lbnVJdGVtcy5wdXNoKHtrZXk6ICdmaXJzdE9mUGFpclN0cmFuZCcsIGxhYmVsOiAnZmlyc3Qtb2YtcGFpciBzdHJhbmQnfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbG9yQnlNZW51SXRlbXMucHVzaCh7a2V5OiAndGFnJywgbGFiZWw6IHRhZ0xhYmVsfSk7XHJcblxyXG4gICAgICAgIG1lbnVJdGVtcy5wdXNoKGlndi5jb2xvclBpY2tlck1lbnVJdGVtKHBvcG92ZXIsIHRoaXMudHJhY2tWaWV3KSk7XHJcblxyXG4gICAgICAgIG1lbnVJdGVtcy5wdXNoKCc8ZGl2IGNsYXNzPVwiaWd2LXRyYWNrLW1lbnUtY2F0ZWdvcnkgaWd2LXRyYWNrLW1lbnUtYm9yZGVyLXRvcFwiPkNvbG9yIGJ5PC9kaXY+Jyk7XHJcblxyXG4gICAgICAgIGNvbG9yQnlNZW51SXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeSA9PT0gaXRlbS5rZXk7XHJcbiAgICAgICAgICAgIG1lbnVJdGVtcy5wdXNoKGNvbG9yQnlNYXJrdXAoaXRlbSwgc2VsZWN0ZWQpKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGh0bWwgPSBbXTtcclxuICAgICAgICBpZiAoc2VsZi5wYWlyc1N1cHBvcnRlZCAmJiBzZWxmLmFsaWdubWVudFRyYWNrLmhhc1BhaXJzKSB7XHJcbiAgICAgICAgICAgIGh0bWwucHVzaCgnPGRpdiBjbGFzcz1cImlndi10cmFjay1tZW51LWl0ZW0gaWd2LXRyYWNrLW1lbnUtYm9yZGVyLXRvcFwiPicpO1xyXG4gICAgICAgICAgICBodG1sLnB1c2godHJ1ZSA9PT0gc2VsZi52aWV3QXNQYWlycyA/ICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrIGZhLWNoZWNrLXNoaW1cIj4nIDogJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2sgZmEtY2hlY2stc2hpbSBmYS1jaGVjay1oaWRkZW5cIj4nKTtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKCc8L2k+Jyk7XHJcbiAgICAgICAgICAgIGh0bWwucHVzaCgnVmlldyBhcyBwYWlycycpO1xyXG4gICAgICAgICAgICBodG1sLnB1c2goJzwvZGl2PicpO1xyXG4gICAgICAgICAgICBtZW51SXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6ICQoaHRtbC5qb2luKCcnKSksXHJcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkZmEgPSAkKHRoaXMpLmZpbmQoJ2knKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9wb3Zlci5oaWRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmlld0FzUGFpcnMgPSAhc2VsZi52aWV3QXNQYWlycztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWUgPT09IHNlbGYudmlld0FzUGFpcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGZhLnJlbW92ZUNsYXNzKCdmYS1jaGVjay1oaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZmEuYWRkQ2xhc3MoJ2ZhLWNoZWNrLWhpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlU291cmNlLnNldFZpZXdBc1BhaXJzKHNlbGYudmlld0FzUGFpcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJhY2tWaWV3LnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtZW51SXRlbXM7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbG9yQnlNYXJrdXAobWVudUl0ZW0sIHNob3dDaGVjaywgaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgaXRlbSA9IHt9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vcGFydHMucHVzaCgoMCA9PT0gaW5kZXgpID8gJzxkaXYgY2xhc3M9XFxcImlndi10cmFjay1tZW51LWl0ZW0gaWd2LXRyYWNrLW1lbnUtYm9yZGVyLXRvcFxcXCI+JyA6ICc8ZGl2IGNsYXNzPVwiaWd2LXRyYWNrLW1lbnUtaXRlbVwiPicpO1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCc8ZGl2IGNsYXNzPVwiaWd2LXRyYWNrLW1lbnUtaXRlbVwiPicpO1xyXG5cclxuICAgICAgICAgICAgcGFydHMucHVzaChzaG93Q2hlY2sgPyAnPGkgY2xhc3M9XCJmYSBmYS1jaGVjayBmYS1jaGVjay1zaGltXCI+PC9pPicgOiAnPGkgY2xhc3M9XCJmYSBmYS1jaGVjayBmYS1jaGVjay1zaGltIGZhLWNoZWNrLWhpZGRlblwiPjwvaT4nKTtcclxuXHJcbiAgICAgICAgICAgIC8vcGFydHMucHVzaCgnPHNwYW4+Jyk7XHJcbiAgICAgICAgICAgIC8vcGFydHMucHVzaCgnQ29sb3IgYnk6ICcpO1xyXG4gICAgICAgICAgICAvL3BhcnRzLnB1c2goJzwvc3Bhbj4nKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtZW51SXRlbS5rZXkgPT09ICd0YWcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3BhbiBpZD1cImNvbG9yLWJ5LXRhZ1wiPicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCgnPHNwYW4+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFydHMucHVzaChtZW51SXRlbS5sYWJlbCk7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJzwvc3Bhbj4nKTtcclxuXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJzwvZGl2PicpO1xyXG5cclxuICAgICAgICAgICAgaXRlbS5vYmplY3QgPSAkKHBhcnRzLmpvaW4oJycpKTtcclxuXHJcbiAgICAgICAgICAgIGl0ZW0uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWd2LnBvcG92ZXIuaGlkZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgndGFnJyA9PT0gbWVudUl0ZW0ua2V5KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlndi5kaWFsb2cuY29uZmlndXJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlRhZyBOYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeVRhZyA/IHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeVRhZyA6ICcnLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IGlndi5kaWFsb2cuJGRpYWxvZ0lucHV0LnZhbCgpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeSA9ICd0YWcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRhZyAhPT0gc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnID0gaWd2LmRpYWxvZy4kZGlhbG9nSW5wdXQudmFsKCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50VHJhY2sudGFnQ29sb3JzID0gbmV3IGlndi5QYWxldHRlQ29sb3JUYWJsZShcIlNldDFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI2NvbG9yLWJ5LXRhZycpLnRleHQoc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRyYWNrVmlldy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlndi5kaWFsb2cuc2hvdygkKHNlbGYudHJhY2tWaWV3LnRyYWNrRGl2KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsaWdubWVudFRyYWNrLmNvbG9yQnkgPSBtZW51SXRlbS5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmFja1ZpZXcudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgXHJcbn1cclxuXHJcbiBmdW5jdGlvbiBzaGFkZWRCYXNlQ29sb3IocXVhbCwgbnVjbGVvdGlkZSwgZ2Vub21pY0xvY2F0aW9uKSB7XHJcblxyXG4gICAgICAgIHZhciBjb2xvcixcclxuICAgICAgICAgICAgYWxwaGEsXHJcbiAgICAgICAgICAgIG1pblEgPSA1LCAgIC8vcHJlZnMuZ2V0QXNJbnQoUHJlZmVyZW5jZU1hbmFnZXIuU0FNX0JBU0VfUVVBTElUWV9NSU4pLFxyXG4gICAgICAgICAgICBtYXhRID0gMjAsICAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUFYKTtcclxuICAgICAgICAgICAgZm9yZWdyb3VuZENvbG9yID1bMCwyNTUsMjU1XSwgLy9udWNsZW90aWRlQ29sb3JDb21wb25lbnRzW251Y2xlb3RpZGVdLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBbMjU1LCAyNTUsIDI1NV07ICAgLy8gV2hpdGVcclxuXHJcblxyXG4gICAgICAgIC8vaWYgKDE3MTE2NzE1NiA9PT0gZ2Vub21pY0xvY2F0aW9uKSB7XHJcbiAgICAgICAgLy8gICAgLy8gTk9URTogQWRkIDEgd2hlbiBwcmVzZW50aW5nIGdlbm9taWMgbG9jYXRpb25cclxuICAgICAgICAvLyAgICBjb25zb2xlLmxvZyhcInNoYWRlZEJhc2VDb2xvciAtIGxvY3VzIFwiICsgaWd2Lm51bWJlckZvcm1hdHRlcigxICsgZ2Vub21pY0xvY2F0aW9uKSArIFwiIHF1YWwgXCIgKyBxdWFsKTtcclxuICAgICAgICAvL31cclxuXHJcbiAgICAgICAgaWYgKCFmb3JlZ3JvdW5kQ29sb3IpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHF1YWwgPCBtaW5RKSB7XHJcbiAgICAgICAgICAgIGFscGhhID0gMC4xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFscGhhID0gTWF0aC5tYXgoMC4xLCBNYXRoLm1pbigxLjAsIDAuMSArIDAuOSAqIChxdWFsIC0gbWluUSkgLyAobWF4USAtIG1pblEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJvdW5kIGFscGhhIHRvIG5lYXJlc3QgMC4xXHJcbiAgICAgICAgYWxwaGEgPSBNYXRoLnJvdW5kKGFscGhhICogMTApIC8gMTAuMDtcclxuXHJcbiAgICAgICAgaWYgKGFscGhhID49IDEpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBHcmFwaGljcy5udWNsZW90aWRlQ29sb3JzW251Y2xlb3RpZGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29sb3IgPSBcInJnYmEoXCIgKyBmb3JlZ3JvdW5kQ29sb3JbMF0gKyBcIixcIiArIGZvcmVncm91bmRDb2xvclsxXSArIFwiLFwiICsgZm9yZWdyb3VuZENvbG9yWzJdICsgXCIsXCIgKyBhbHBoYSArIFwiKVwiOyAgICAvL2lndi5nZXRDb21wb3NpdGVDb2xvcihiYWNrZ3JvdW5kQ29sb3IsIGZvcmVncm91bmRDb2xvciwgYWxwaGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcblxyXG5cclxuY2xhc3MgQ292ZXJhZ2VUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBhcmVudCkge1xyXG5cclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmZlYXR1cmVTb3VyY2UgPSBwYXJlbnQuZmVhdHVyZVNvdXJjZTtcclxuICAgICAgIFxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAyMDsvL2NvbmZpZy5jb3ZlcmFnZVRyYWNrSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZGF0YVJhbmdlID0ge21pbjogMH07ICAgLy8gTGVhdiBtYXggdW5kZWZpbmVkXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZVBpeGVsSGVpZ2h0KGFsaWdubWVudENvbnRhaW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIgPSBvcHRpb25zLmZlYXR1cmVzLFxyXG4gICAgICAgICAgICBjdHggPSBvcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgICAgIGJwUGVyUGl4ZWwgPSBvcHRpb25zLmJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgIGJwU3RhcnQgPSBvcHRpb25zLmJwU3RhcnQsXHJcbiAgICAgICAgICAgIHBpeGVsV2lkdGggPSBvcHRpb25zLnBpeGVsV2lkdGgsXHJcbiAgICAgICAgICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuICAgICAgICAgICAgY292ZXJhZ2VNYXAgPSBhbGlnbm1lbnRDb250YWluZXIuY292ZXJhZ2VNYXAsXHJcbiAgICAgICAgICAgIGJwLFxyXG4gICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICB3LFxyXG4gICAgICAgICAgICBoLFxyXG4gICAgICAgICAgICByZWZCYXNlLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBsZW4sXHJcbiAgICAgICAgICAgIGl0ZW0sXHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkSGVpZ2h0LFxyXG4gICAgICAgICAgICBzZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGlmIChjb3ZlcmFnZU1hcC5yZWZTZXEpIHNlcXVlbmNlID0gY292ZXJhZ2VNYXAucmVmU2VxLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGF0YVJhbmdlLm1heCA9IGNvdmVyYWdlTWFwLm1heGltdW07XHJcbiAgICAgICAgdmFyIHRvcCA9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgb3B0aW9ucy50b3ArPXRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIC8vIHBhaW50IGJhY2tkcm9wIGNvbG9yIGZvciBhbGwgY292ZXJhZ2UgYnVja2V0c1xyXG4gICAgICAgIHcgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoMS4wIC8gYnBQZXJQaXhlbCkpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvdmVyYWdlTWFwLmNvdmVyYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBicCA9IChjb3ZlcmFnZU1hcC5icFN0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgIGlmIChicCA8IGJwU3RhcnQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoYnAgPiBicEVuZCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBpdGVtID0gY292ZXJhZ2VNYXAuY292ZXJhZ2VbaV07XHJcbiAgICAgICAgICAgIGlmICghaXRlbSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBoID0gTWF0aC5yb3VuZCgoaXRlbS50b3RhbCAvIHRoaXMuZGF0YVJhbmdlLm1heCkgKiB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLmhlaWdodCAtIGg7XHJcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChicCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCk7XHJcblxyXG4gICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwge2ZpbGxTdHlsZTogdGhpcy5wYXJlbnQuY29uZmlnLmNvbG9yLCBzdHJva2VTdHlsZTogdGhpcy5jb2xvcn0pO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHkrdG9wLCB3LCBoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvdmVyYWdlIG1pc21hdGNoIGNvbG9yaW5nIC0tIGRvbid0IHRyeSB0byBkbyB0aGlzIGluIGFib3ZlIGxvb3AsIGNvbG9yIGJhciB3aWxsIGJlIG92ZXJ3cml0dGVuIHdoZW4gdzwxXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvdmVyYWdlTWFwLmNvdmVyYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYnAgPSAoY292ZXJhZ2VNYXAuYnBTdGFydCArIGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJwIDwgYnBTdGFydCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnAgPiBicEVuZCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvdmVyYWdlTWFwLmNvdmVyYWdlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBoID0gKGl0ZW0udG90YWwgLyB0aGlzLmRhdGFSYW5nZS5tYXgpICogdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5oZWlnaHQgLSBoO1xyXG4gICAgICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoKGJwIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZWZCYXNlID0gc2VxdWVuY2VbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc01pc21hdGNoKHJlZkJhc2UpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiBHcmFwaGljcy5udWNsZW90aWRlQ29sb3JzW3JlZkJhc2VdfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5K3RvcCwgdywgaCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkSGVpZ2h0ID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIFtcIkFcIiwgXCJDXCIsIFwiVFwiLCBcIkdcIl0uZm9yRWFjaChmdW5jdGlvbiAobnVjbGVvdGlkZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IGl0ZW1bXCJwb3NcIiArIG51Y2xlb3RpZGVdICsgaXRlbVtcIm5lZ1wiICsgbnVjbGVvdGlkZV07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWxvZ29yaXRtaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGggPSAoY291bnQgLyBzZWxmLmRhdGFSYW5nZS5tYXgpICogc2VsZi5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gKHNlbGYuaGVpZ2h0IC0gaGgpIC0gYWNjdW11bGF0ZWRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkSGVpZ2h0ICs9IGhoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHtmaWxsU3R5bGU6IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbbnVjbGVvdGlkZV19KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5K3RvcCwgdywgaGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbiwgeE9mZnNldCwgeU9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgY292ZXJhZ2VNYXAgPSB0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwLFxyXG4gICAgICAgICAgICBjb3ZlcmFnZU1hcEluZGV4LFxyXG4gICAgICAgICAgICBjb3ZlcmFnZSxcclxuICAgICAgICAgICAgbmFtZVZhbHVlcyA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgY292ZXJhZ2VNYXBJbmRleCA9IGdlbm9taWNMb2NhdGlvbiAtIGNvdmVyYWdlTWFwLmJwU3RhcnQ7XHJcbiAgICAgICAgY292ZXJhZ2UgPSBjb3ZlcmFnZU1hcC5jb3ZlcmFnZVtjb3ZlcmFnZU1hcEluZGV4XTtcclxuXHJcbiAgICAgICAgaWYgKGNvdmVyYWdlKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKGlndi5icm93c2VyLnJlZmVyZW5jZUZyYW1lLmNociArIFwiOlwiICsgaWd2Lm51bWJlckZvcm1hdHRlcigxICsgZ2Vub21pY0xvY2F0aW9uKSk7XHJcblxyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goe25hbWU6ICdUb3RhbCBDb3VudCcsIHZhbHVlOiBjb3ZlcmFnZS50b3RhbH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQVxyXG4gICAgICAgICAgICB0bXAgPSBjb3ZlcmFnZS5wb3NBICsgY292ZXJhZ2UubmVnQTtcclxuICAgICAgICAgICAgaWYgKHRtcCA+IDApICB0bXAgPSB0bXAudG9TdHJpbmcoKSArIFwiIChcIiArIE1hdGguZmxvb3IoKChjb3ZlcmFnZS5wb3NBICsgY292ZXJhZ2UubmVnQSkgLyBjb3ZlcmFnZS50b3RhbCkgKiAxMDAuMCkgKyBcIiUpXCI7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0EnLCB2YWx1ZTogdG1wfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gQ1xyXG4gICAgICAgICAgICB0bXAgPSBjb3ZlcmFnZS5wb3NDICsgY292ZXJhZ2UubmVnQztcclxuICAgICAgICAgICAgaWYgKHRtcCA+IDApICB0bXAgPSB0bXAudG9TdHJpbmcoKSArIFwiIChcIiArIE1hdGguZmxvb3IoKHRtcCAvIGNvdmVyYWdlLnRvdGFsKSAqIDEwMC4wKSArIFwiJSlcIjtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnQycsIHZhbHVlOiB0bXB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdcclxuICAgICAgICAgICAgdG1wID0gY292ZXJhZ2UucG9zRyArIGNvdmVyYWdlLm5lZ0c7XHJcbiAgICAgICAgICAgIGlmICh0bXAgPiAwKSAgdG1wID0gdG1wLnRvU3RyaW5nKCkgKyBcIiAoXCIgKyBNYXRoLmZsb29yKCh0bXAgLyBjb3ZlcmFnZS50b3RhbCkgKiAxMDAuMCkgKyBcIiUpXCI7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0cnLCB2YWx1ZTogdG1wfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUXHJcbiAgICAgICAgICAgIHRtcCA9IGNvdmVyYWdlLnBvc1QgKyBjb3ZlcmFnZS5uZWdUO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMCkgIHRtcCA9IHRtcC50b1N0cmluZygpICsgXCIgKFwiICsgTWF0aC5mbG9vcigodG1wIC8gY292ZXJhZ2UudG90YWwpICogMTAwLjApICsgXCIlKVwiO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goe25hbWU6ICdUJywgdmFsdWU6IHRtcH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTlxyXG4gICAgICAgICAgICB0bXAgPSBjb3ZlcmFnZS5wb3NOICsgY292ZXJhZ2UubmVnTjtcclxuICAgICAgICAgICAgaWYgKHRtcCA+IDApICB0bXAgPSB0bXAudG9TdHJpbmcoKSArIFwiIChcIiArIE1hdGguZmxvb3IoKHRtcCAvIGNvdmVyYWdlLnRvdGFsKSAqIDEwMC4wKSArIFwiJSlcIjtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnTicsIHZhbHVlOiB0bXB9KTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBBbGlnbm1lbnRUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBhcmVudCkge1xyXG5cdCAgICB0aGlzLmNvbmZpZz1jb25maWc7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZSA9IHBhcmVudC5mZWF0dXJlX3NvdXJjZTtcclxuICAgICBcclxuICAgICAgICB0aGlzLmFsaWdubWVudFJvd0hlaWdodCA9IGNvbmZpZy5hbGlnbm1lbnRSb3dIZWlnaHQgfHwgNjtcclxuXHJcbiAgICAgICAgdGhpcy5uZWdTdHJhbmRDb2xvciA9IGNvbmZpZy5uZWdTdHJhbmRDb2xvciB8fCBcInJnYmEoMTUwLCAxNTAsIDIzMCwgMC43NSlcIjtcclxuICAgICAgICB0aGlzLnBvc1N0cmFuZENvbG9yID0gY29uZmlnLnBvc1N0cmFuZENvbG9yIHx8IFwicmdiYSgyMzAsIDE1MCwgMTUwLCAwLjc1KVwiO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQ29sb3IgPSBjb25maWcuaW5zZXJ0aW9uQ29sb3IgfHwgXCJyZ2IoMTM4LCA5NCwgMTYxKVwiO1xyXG4gICAgICAgIHRoaXMuZGVsZXRpb25Db2xvciA9IGNvbmZpZy5kZWxldGlvbkNvbG9yIHx8IFwiYmxhY2tcIjtcclxuICAgICAgICB0aGlzLnNraXBwZWRDb2xvciA9IGNvbmZpZy5za2lwcGVkQ29sb3IgfHwgXCJyZ2IoMTUwLCAxNzAsIDE3MClcIjtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvckJ5ID0gY29uZmlnLmNvbG9yQnkgfHwgXCJub25lXCI7XHJcbiAgICAgICAgdGhpcy5jb2xvckJ5VGFnID0gY29uZmlnLmNvbG9yQnlUYWc7XHJcbiAgICAgICAgdGhpcy5iYW1Db2xvclRhZyA9IGNvbmZpZy5iYW1Db2xvclRhZyA9PT0gdW5kZWZpbmVkID8gXCJZQ1wiIDogY29uZmlnLmJhbUNvbG9yVGFnO1xyXG5cclxuICAgICAgICAvLyBzb3J0IGFsaWdubWVudCByb3dzXHJcbiAgICAgICAgdGhpcy5zb3J0T3B0aW9uID0gY29uZmlnLnNvcnRPcHRpb24gfHwge3NvcnQ6IFwiTlVDTEVPVElERVwifTtcclxuXHJcbiAgICAgICAgdGhpcy5zb3J0RGlyZWN0aW9uID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5oYXNQYWlycyA9IGZhbHNlOyAgIC8vIFVudGlsIHByb3ZlbiBvdGhlcndpc2VcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZVBpeGVsSGVpZ2h0KGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MpIHtcclxuICAgICAgICAgICAgdmFyIGggPSAwO1xyXG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50Q29udGFpbmVyLmhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkpIHtcclxuICAgICAgICAgICAgICAgIGggKz0gZG93bnNhbXBsZVJvd0hlaWdodCArIGFsaWdubWVudFN0YXJ0R2FwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoICsgKHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQgKiBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cy5sZW5ndGgpICsgNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXcob3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lciA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxLFxyXG4gICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRSb3dzID0gYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MsXHJcbiAgICAgICAgICAgIHNlcXVlbmNlID0gYWxpZ25tZW50Q29udGFpbmVyLnNlcXVlbmNlLFxyXG4gICAgICAgICAgICBiYXNlX3RleHQ9XCJub3JtYWwgXCIrKHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQtMikrXCJweCBBcmlhbFwiO1xyXG5cclxuICAgICAgICBsZXQgdG9wID0gb3B0aW9ucy50b3A7XHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIHNlcXVlbmNlID0gc2VxdWVuY2UudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmYWxzZS8qYWxpZ25tZW50Q29udGFpbmVyLmhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkqLykge1xyXG4gICAgICAgICAgICBhbGlnbm1lbnRSb3dZSW5zZXQgPSBkb3duc2FtcGxlUm93SGVpZ2h0ICsgYWxpZ25tZW50U3RhcnRHYXA7XHJcblxyXG4gICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRJbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4QmxvY2tTdGFydCA9IChpbnRlcnZhbC5zdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQgPSAoaW50ZXJ2YWwuZW5kIC0gYnBTdGFydCkgLyBicFBlclBpeGVsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4QmxvY2tFbmQgLSB4QmxvY2tTdGFydCA+IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHhCbG9ja0VuZCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4QmxvY2tTdGFydCwgMiwgKHhCbG9ja0VuZCAtIHhCbG9ja1N0YXJ0KSwgZG93bnNhbXBsZVJvd0hlaWdodCAtIDIsIHtmaWxsU3R5bGU6IFwiYmxhY2tcIn0pO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvd1lJbnNldCA9IDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFja2VkQWxpZ25tZW50Um93cykge1xyXG5cclxuICAgICAgICAgICAgcGFja2VkQWxpZ25tZW50Um93cy5mb3JFYWNoKGZ1bmN0aW9uIHJlbmRlckFsaWdubWVudFJvdyhhbGlnbm1lbnRSb3csIGkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeVJlY3QgPSBhbGlnbm1lbnRSb3dZSW5zZXQgKyAoc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodCAqIGkpK3RvcCxcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRIZWlnaHQgPSBzZWxmLmNvbmZpZy5mZWF0dXJlSGVpZ2h0IC0gMixcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGlnbm1lbnRSb3cuYWxpZ25tZW50cy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oYXNQYWlycyA9IHNlbGYuaGFzUGFpcnMgfHwgYWxpZ25tZW50LmlzUGFpcmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmKSA8IGJwU3RhcnQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPiBicEVuZCkgYnJlYWs7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gYWxpZ25tZW50LmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgaW5zdGFuY2VvZiBQYWlyZWRBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdQYWlyQ29ubmVjdG9yKGFsaWdubWVudCwgeVJlY3QsIGFsaWdubWVudEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3U2luZ2xlQWxpZ25tZW50KGFsaWdubWVudC5maXJzdEFsaWdubWVudCwgeVJlY3QsIGFsaWdubWVudEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1NpbmdsZUFsaWdubWVudChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50LCB5UmVjdCwgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTaW5nbGVBbGlnbm1lbnQoYWxpZ25tZW50LCB5UmVjdCwgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBhbGlnbm1lbnQgaXMgYSBQYWlyZWRBbGlnbm1lbnRcclxuICAgICAgICBmdW5jdGlvbiBkcmF3UGFpckNvbm5lY3RvcihhbGlnbm1lbnQsIHlSZWN0LCBhbGlnbm1lbnRIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb2xvciA9IHNlbGYuZ2V0QWxpZ25tZW50Q29sb3IoYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KSxcclxuICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvciA9IGFsaWdubWVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgeEJsb2NrU3RhcnQgPSAoYWxpZ25tZW50LmNvbm5lY3RpbmdTdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgIHhCbG9ja0VuZCA9IChhbGlnbm1lbnQuY29ubmVjdGluZ0VuZCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgIHlTdHJva2VkTGluZSA9IHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LmNvbm5lY3RpbmdFbmQpIDwgYnBTdGFydCB8fCBhbGlnbm1lbnQuY29ubmVjdGluZ1N0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Q29sb3IgPSBVdGlscy5hZGRBbHBoYVRvUkdCKGFsaWdubWVudENvbG9yLCBcIjAuMTVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvciwgc3Ryb2tlU3R5bGU6IG91dGxpbmVDb2xvcn0pO1xyXG5cclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHhCbG9ja1N0YXJ0LCB5U3Ryb2tlZExpbmUsIHhCbG9ja0VuZCwgeVN0cm9rZWRMaW5lKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd1NpbmdsZUFsaWdubWVudChhbGlnbm1lbnQsIHlSZWN0LCBhbGlnbm1lbnRIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb2xvciA9IHNlbGYuZ2V0QWxpZ25tZW50Q29sb3IoYWxpZ25tZW50KSxcclxuICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvciA9IGFsaWdubWVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgbGFzdEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tzID0gYWxpZ25tZW50LmJsb2NrcyxcclxuICAgICAgICAgICAgICAgIGJsb2NrLFxyXG4gICAgICAgICAgICAgICAgYjtcclxuXHJcbiAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmKSA8IGJwU3RhcnQgfHwgYWxpZ25tZW50LnN0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Q29sb3IgPSBVdGlscy5hZGRBbHBoYVRvUkdCKGFsaWdubWVudENvbG9yLCBcIjAuMTVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvciwgc3Ryb2tlU3R5bGU6IG91dGxpbmVDb2xvcn0pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChiID0gMDsgYiA8IGJsb2Nrcy5sZW5ndGg7IGIrKykgeyAgIC8vIENhbid0IHVzZSBmb3JFYWNoIGhlcmUgLS0gd2UgbmVlZCBhYmlsaXR5IHRvIGJyZWFrXHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2sgPSBibG9ja3NbYl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChibG9jay5zdGFydCArIGJsb2NrLmxlbikgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBkcmF3QmxvY2soYmxvY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYmxvY2suc3RhcnQgKyBibG9jay5sZW4pID4gYnBFbmQpIGJyZWFrOyAgLy8gRG8gdGhpcyBhZnRlciBkcmF3QmxvY2sgdG8gaW5zdXJlIGdhcHMgYXJlIGRyYXduXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5pbnNlcnRpb25zLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZPZmZzZXQgPSBibG9jay5zdGFydCAtIGJwU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCA9IHJlZk9mZnNldCAvIGJwUGVyUGl4ZWwgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhCbG9jayA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxSZWN0KGN0eCwgeEJsb2NrU3RhcnQsIHlSZWN0IC0gMSwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0ICsgMiwge2ZpbGxTdHlsZTogc2VsZi5pbnNlcnRpb25Db2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0Jsb2NrKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxT2Zmc2V0ID0gYmxvY2suc3RhcnQgLSBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJsb2NrU3RhcnQgPSAoYmxvY2suc3RhcnQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kID0gKChibG9jay5zdGFydCArIGJsb2NrLmxlbikgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhCbG9jayA9IE1hdGgubWF4KDEsIHhCbG9ja0VuZCAtIHhCbG9ja1N0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aEFycm93SGVhZCA9IHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQgLyAyLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSBibG9jay5zZXEudG9VcHBlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkQ29sb3IgPSBzZWxmLnNraXBwZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGlvbkNvbG9yID0gc2VsZi5kZWxldGlvbkNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZkNoYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZENoYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFF1YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhCYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQmFzZSxcclxuICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICB5U3Ryb2tlZExpbmUgPSB5UmVjdCArIGFsaWdubWVudEhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrLmdhcFR5cGUgIT09IHVuZGVmaW5lZCAmJiB4QmxvY2tFbmQgIT09IHVuZGVmaW5lZCAmJiBsYXN0QmxvY2tFbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIkRcIiA9PT0gYmxvY2suZ2FwVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgbGFzdEJsb2NrRW5kLCB5U3Ryb2tlZExpbmUsIHhCbG9ja1N0YXJ0LCB5U3Ryb2tlZExpbmUsIHtzdHJva2VTdHlsZTogZGVsZXRpb25Db2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIGxhc3RCbG9ja0VuZCwgeVN0cm9rZWRMaW5lLCB4QmxvY2tTdGFydCwgeVN0cm9rZWRMaW5lLCB7c3Ryb2tlU3R5bGU6IHNraXBwZWRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RCbG9ja0VuZCA9IHhCbG9ja0VuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gYWxpZ25tZW50LnN0cmFuZCAmJiBiID09PSBibG9ja3MubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgYmxvY2sgb24gKyBzdHJhbmRcclxuICAgICAgICAgICAgICAgICAgICB4ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQgKyB3aWR0aEFycm93SGVhZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrU3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyAoYWxpZ25tZW50SGVpZ2h0IC8gMi4wKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyBhbGlnbm1lbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdF07XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFBvbHlnb24oY3R4LCB4LCB5LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwge3N0cm9rZVN0eWxlOiBvdXRsaW5lQ29sb3J9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSA9PT0gYWxpZ25tZW50LnN0cmFuZCAmJiBiID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgYmxvY2sgb24gLSBzdHJhbmRcclxuICAgICAgICAgICAgICAgICAgICB4ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhCbG9ja1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCAtIHdpZHRoQXJyb3dIZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyAoYWxpZ25tZW50SGVpZ2h0IC8gMi4wKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyBhbGlnbm1lbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdF07XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFBvbHlnb24oY3R4LCB4LCB5LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwge3N0cm9rZVN0eWxlOiBvdXRsaW5lQ29sb3J9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGlndi5ncmFwaGljcy5maWxsUmVjdChjdHgsIHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBcIndoaXRlXCJ9KTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIG1pc21hdGNoIGNvbG9yaW5nIGlmIGEgcmVmc2VxIGV4aXN0cyB0byBkbyB0aGUgY29tcGFyaXNvblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlICYmIGJsb2NrU2VxICE9PSBcIipcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBibG9ja1NlcS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQ2hhciA9IGJsb2NrU2VxLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQ2hhciA9IHNlcXVlbmNlLmNoYXJBdChzZXFPZmZzZXQgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRDaGFyID09PSBcIj1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZENoYXIgPSByZWZDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQ2hhciA9PT0gXCJYXCIgfHwgcmVmQ2hhciAhPT0gcmVhZENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5xdWFsICYmIGJsb2NrLnF1YWwubGVuZ3RoID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRRdWFsID0gYmxvY2sucXVhbFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckJhc2UgPSBzaGFkZWRCYXNlQ29sb3IocmVhZFF1YWwsIHJlYWRDaGFyLCBpICsgYmxvY2suc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JCYXNlID0gR3JhcGhpY3MubnVjbGVvdGlkZUNvbG9yc1tyZWFkQ2hhcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEJhc2UgPSAoKGJsb2NrLnN0YXJ0ICsgaSkgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhCYXNlID0gTWF0aC5tYXgoMSwgMSAvIGJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsPDAuMTUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIHJlYWRDaGFyLCB4QmFzZSt3aWR0aEJhc2UvMiwgeVJlY3QrMiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogY29sb3JCYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBiYXNlX3RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTonaGFuZ2luZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHhCYXNlLCB5UmVjdCwgd2lkdGhCYXNlLCBhbGlnbm1lbnRIZWlnaHQsIHtmaWxsU3R5bGU6IGNvbG9yQmFzZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50Um93WUluc2V0ICsgKHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQgKiBwYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkrdG9wO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzb3J0QWxpZ25tZW50Um93cyhnZW5vbWljTG9jYXRpb24sIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIgPSB0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnRSb3dzID0gYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3M7XHJcblxyXG4gICAgICAgIGFsaWdubWVudFJvd3MuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50Um93KSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdy51cGRhdGVTY29yZShnZW5vbWljTG9jYXRpb24sIGFsaWdubWVudENvbnRhaW5lciwgc29ydE9wdGlvbik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFsaWdubWVudFJvd3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zb3J0RGlyZWN0aW9uID8gYS5zY29yZSAtIGIuc2NvcmUgOiBiLnNjb3JlIC0gYS5zY29yZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRvU29ydEFsaWdubWVudFJvd3MoZ2Vub21pY0xvY2F0aW9uLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24sIHNvcnREaXJlY3Rpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIGFsaWdubWVudFJvd3MgPSBnZW5vbWljSW50ZXJ2YWwucGFja2VkQWxpZ25tZW50Um93cyxcclxuICAgICAgICAgICAgc2VxdWVuY2UgPSBnZW5vbWljSW50ZXJ2YWwuc2VxdWVuY2U7XHJcblxyXG4gICAgICAgIGlmIChzZXF1ZW5jZSkge1xyXG4gICAgICAgICAgICBzZXF1ZW5jZSA9IHNlcXVlbmNlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZXF1ZW5jZSwgbm8gdHJhdmVyc2FsLiBObyBkaXNjdXNzaW9uIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxpZ25tZW50Um93cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnRSb3cpIHtcclxuICAgICAgICAgICAgYWxpZ25tZW50Um93LnVwZGF0ZVNjb3JlKGdlbm9taWNMb2NhdGlvbiwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYWxpZ25tZW50Um93cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0RGlyZWN0aW9uID8gYS5zY29yZSAtIGIuc2NvcmUgOiBiLnNjb3JlIC0gYS5zY29yZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbiwgeE9mZnNldCwgeU9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgcGFja2VkQWxpZ25tZW50Um93cyA9IHRoaXMuZmVhdHVyZVNvdXJjZS5hbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyxcclxuICAgICAgICAgICAgZG93bnNhbXBsZWRJbnRlcnZhbHMgPSB0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmRvd25zYW1wbGVkSW50ZXJ2YWxzLFxyXG4gICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRzSW5kZXgsXHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdyxcclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCxcclxuICAgICAgICAgICAgaSwgbGVuLCB0bXA7XHJcblxyXG4gICAgICAgIHBhY2tlZEFsaWdubWVudHNJbmRleCA9IE1hdGguZmxvb3IoKHlPZmZzZXQgLSAoYWxpZ25tZW50Um93WUluc2V0KSkgLyB0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKHBhY2tlZEFsaWdubWVudHNJbmRleCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb3duc2FtcGxlZEludGVydmFsc1tpXS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gJiYgKGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldLmVuZCA+PSBnZW5vbWljTG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYWNrZWRBbGlnbm1lbnRzSW5kZXggPCBwYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50Um93ID0gcGFja2VkQWxpZ25tZW50Um93c1twYWNrZWRBbGlnbm1lbnRzSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLmxlbmd0aCwgdG1wOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0bXAgPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG1wLnN0YXJ0IDw9IGdlbm9taWNMb2NhdGlvbiAmJiAodG1wLnN0YXJ0ICsgdG1wLmxlbmd0aE9uUmVmID49IGdlbm9taWNMb2NhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlja2VkT2JqZWN0ID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNsaWNrZWRPYmplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWNrZWRPYmplY3QucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIGdldEFsaWdubWVudENvbG9yKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB2YXIgYWxpZ25tZW50VHJhY2sgPSB0aGlzLFxyXG4gICAgICAgICAgICBvcHRpb24gPSBhbGlnbm1lbnRUcmFjay5jb2xvckJ5LFxyXG4gICAgICAgICAgICB0YWdWYWx1ZSwgY29sb3IsXHJcbiAgICAgICAgICAgIHN0cmFuZDtcclxuXHJcbiAgICAgICAgY29sb3IgPSBhbGlnbm1lbnRUcmFjay5wYXJlbnQuY29uZmlnLmNvbG9yOyAvLyBkZWZhdWx0XHJcblxyXG4gICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwic3RyYW5kXCI6XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGFsaWdubWVudC5zdHJhbmQgPyBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvciA6IGFsaWdubWVudFRyYWNrLm5lZ1N0cmFuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmaXJzdE9mUGFpclN0cmFuZFwiOlxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGFsaWdubWVudCBpbnN0YW5jZW9mIFBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50LmZpcnN0T2ZQYWlyU3RyYW5kKCkgPyBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvciA6IGFsaWdubWVudFRyYWNrLm5lZ1N0cmFuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ25tZW50LmlzUGFpcmVkKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5pc0ZpcnN0T2ZQYWlyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhbGlnbm1lbnQuc3RyYW5kID8gYWxpZ25tZW50VHJhY2sucG9zU3RyYW5kQ29sb3IgOiBhbGlnbm1lbnRUcmFjay5uZWdTdHJhbmRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ25tZW50LmlzU2Vjb25kT2ZQYWlyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhbGlnbm1lbnQuc3RyYW5kID8gYWxpZ25tZW50VHJhY2submVnU3RyYW5kQ29sb3IgOiBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IuIFBhaXJlZCBhbGlnbm1lbnRzIGFyZSBlaXRoZXIgZmlyc3Qgb3Igc2Vjb25kLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcInRhZ1wiOlxyXG5cclxuICAgICAgICAgICAgICAgIHRhZ1ZhbHVlID0gYWxpZ25tZW50LnRhZ3MoKVthbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnXTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnRUcmFjay5iYW1Db2xvclRhZyA9PT0gYWxpZ25tZW50VHJhY2suY29sb3JCeVRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVQ1NDIHN0eWxlIGNvbG9yIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFwicmdiKFwiICsgdGFnVmFsdWUgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50VHJhY2sudGFnQ29sb3JzLmdldENvbG9yKHRhZ1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50VHJhY2sucGFyZW50LmNvbmZpZy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuQkFNVHJhY2suZmlsdGVycyA9IHtcclxuXHJcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0cmFuZDogZnVuY3Rpb24gKHN0cmFuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdHJhbmQgPT09IHN0cmFuZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtYXBwaW5nUXVhbGl0eTogZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb3dlciAmJiBhbGlnbm1lbnQubXEgPCBsb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh1cHBlciAmJiBhbGlnbm1lbnQubXEgPiB1cHBlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5NTFZUcmFjay5jdXN0b21fdHJhY2tzW1wiYmFtXCJdPUJBTVRyYWNrO1xyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJiYW1cIl09e1xyXG5cdFwiY2xhc3NcIjpCQU1UcmFjayxcclxuXHRuYW1lOlwiQkFNXCJcclxufVxyXG5cclxuZXhwb3J0IHtCQU1UcmFja307XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUE1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7QUEwQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBL1JBO0FBQ0E7QUFvU0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFIQTtBQUlBO0FBSkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQWNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBd0JBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2Q0E7QUF5Q0E7QUFFQTs7O0FBN0hBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQStHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQUNBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/bam_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/bigwig.js":
/*!****************************!*\
  !*** .Panel/src/bigwig.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BinaryParser = exports.BWSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//***********js/bigwig/bufferedReader.js*****************\nvar BufferedReader = function () {\n    function BufferedReader(config, contentLength, bufferSize) {\n        _classCallCheck(this, BufferedReader);\n\n        this.path = config.url;\n        this.contentLength = contentLength;\n        this.bufferSize = bufferSize ? bufferSize : 512000;\n        this.range = { start: -1, size: -1 };\n        this.config = config;\n    }\n\n    /**\r\n     *\r\n     * @param requestedRange - byte rangeas {start, size}\r\n     * @param fulfill - function to receive result\r\n     * @param asUint8 - optional flag to return result as an UInt8Array\r\n     */\n\n\n    _createClass(BufferedReader, [{\n        key: \"dataViewForRange\",\n        value: function dataViewForRange(requestedRange, asUint8) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var hasData = self.data && self.range.start <= requestedRange.start && self.range.start + self.range.size >= requestedRange.start + requestedRange.size,\n                    bufferSize,\n                    loadRange;\n\n                if (hasData) {\n                    subbuffer(self, requestedRange, asUint8);\n                } else {\n                    // Expand buffer size if needed, but not beyond content length\n                    bufferSize = Math.max(self.bufferSize, requestedRange.size);\n\n                    if (self.contentLength > 0 && requestedRange.start + bufferSize > self.contentLength) {\n                        loadRange = { start: requestedRange.start };\n                    } else {\n                        loadRange = { start: requestedRange.start, size: bufferSize };\n                    }\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: loadRange })).then(function (arrayBuffer) {\n                        self.data = arrayBuffer;\n                        self.range = loadRange;\n                        subbuffer(self, requestedRange, asUint8);\n                    }).catch(reject);\n                }\n\n                function subbuffer(bufferedReader, requestedRange, asUint8) {\n\n                    var len = bufferedReader.data.byteLength,\n                        bufferStart = requestedRange.start - bufferedReader.range.start,\n                        result = asUint8 ? new Uint8Array(bufferedReader.data, bufferStart, len - bufferStart) : new DataView(bufferedReader.data, bufferStart, len - bufferStart);\n                    fulfill(result);\n                }\n            });\n        }\n    }]);\n\n    return BufferedReader;\n}();\n\n//**********js/bigwig/bwSource.js***************\n\n\nvar BWSource = function () {\n    function BWSource(config, create_feature_function) {\n        _classCallCheck(this, BWSource);\n\n        this.reader = new BWReader(config);\n        this.bufferedReader = new BufferedReader(config);\n        if (!create_feature_function) {\n            this.create_feature = BWSource.createFeature;\n        } else {\n            this.create_feature = create_feature_function;\n        }\n    }\n\n    /**\r\n    * Creates a panel\r\n    * @param {string} chr - The chromosome\r\n    * @param {int} bpStart The starting postition \r\n    * @param {int} bpEnd - The end of the region to show\r\n    * @param {boolean} use_existing - If true then the cached feature will be used- only used\r\n    * if the co-oridinates have not changed. Although, the BWreader has a cache, it is sometimes\r\n    * ignored and features are re-fetched for the same region\r\n    * @param {object} data - Should contain pixelWidth- the width of the entire canvas and \r\n    * bpPerPixel.\r\n    */\n\n\n    _createClass(BWSource, [{\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, use_existing, data) {\n            this.st = new Date().getTime();\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                if (self.features && use_existing) {\n                    fulfill(self.features);\n                    return;\n                }\n                self.reader.getZoomHeaders().then(function (zoomLevelHeaders) {\n\n                    // Select a biwig \"zoom level\" appropriate for the current resolution\n                    var bwReader = self.reader,\n                        bufferedReader = self.bufferedReader,\n                        bpp = data.bpPerPixel,\n                        zoomLevelHeader = BWSource.zoomLevelForScale(bpp, zoomLevelHeaders),\n                        treeOffset;\n\n                    if (zoomLevelHeader && bwReader.type === \"BigWig\") {\n                        treeOffset = zoomLevelHeader.indexOffset;\n                        self.decodeFunction = BWSource.decodeZoomData;\n                    } else {\n                        treeOffset = bwReader.header.fullIndexOffset;\n                        if (bwReader.type === \"BigWig\") {\n                            self.decodeFunction = BWSource.decodeWigData;\n                        } else {\n                            self.decodeFunction = self.decodeBedData;\n                        }\n                    }\n\n                    bwReader.loadRPTree(treeOffset).then(function (rpTree) {\n\n                        var chrIdx = self.reader.chromTree.dictionary[chr];\n                        if (chrIdx === undefined) {\n                            fulfill(null);\n                        } else {\n\n                            rpTree.findLeafItemsOverlapping(chrIdx, bpStart, bpEnd).then(function (leafItems) {\n\n                                var promises = [];\n\n                                if (!leafItems || leafItems.length == 0) fulfill([]);\n\n                                leafItems.forEach(function (item) {\n\n                                    promises.push(new Promise(function (fulfill, reject) {\n                                        var features = [];\n\n                                        bufferedReader.dataViewForRange({\n                                            start: item.dataOffset,\n                                            size: item.dataSize\n                                        }, true).then(function (uint8Array) {\n\n                                            var inflate = new Zlib.Zlib.Inflate(uint8Array);\n                                            var plain = inflate.decompress();\n                                            //var inflate = new pako.Inflate();\n                                            //inflate.push(uint8Array, true);\n                                            //var plain = inflate.result;\n                                            self.decodeFunction(new DataView(plain.buffer), chr, chrIdx, bpStart, bpEnd, features);\n\n                                            fulfill(features);\n                                        }).catch(reject);\n                                    }));\n                                });\n\n                                Promise.all(promises).then(function (featureArrays) {\n                                    var en = new Date().getTime();\n                                    var e = en - self.st;\n                                    var a = bpp;\n                                    //console.log(e);\n                                    var i,\n                                        allFeatures = featureArrays[0];\n                                    if (featureArrays.length > 1) {\n                                        for (i = 1; i < featureArrays.length; i++) {\n                                            allFeatures = allFeatures.concat(featureArrays[i]);\n                                        }\n                                    }\n                                    allFeatures.sort(function (a, b) {\n                                        return a.start - b.start;\n                                    });\n                                    self.features = allFeatures;\n                                    fulfill(allFeatures);\n                                }).catch(reject);\n                            }).catch(function (error) {\n                                reject(error);\n                            });\n                        }\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"getDefaultRange\",\n        value: function getDefaultRange() {\n\n            if (this.reader.totalSummary != undefined) {\n                return this.reader.totalSummary.defaultRange;\n            } else {\n                return undefined;\n            }\n        }\n    }, {\n        key: \"decodeBedData\",\n        value: function decodeBedData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 3 * 4 + 1,\n                // Minimum # of bytes required for a bed record\n            chromId,\n                chromStart,\n                chromEnd,\n                rest,\n                tokens,\n                feature,\n                exonCount,\n                exonSizes,\n                exonStarts,\n                exons,\n                eStart,\n                eEnd;\n\n            while (binaryParser.remLength() >= minSize) {\n\n                chromId = binaryParser.getInt();\n                if (chromId != chrIdx) continue;\n\n                chromStart = binaryParser.getInt();\n                chromEnd = binaryParser.getInt();\n                rest = binaryParser.getString();\n\n                feature = { chr: chr, start: chromStart, end: chromEnd };\n\n                if (chromStart < bpEnd && chromEnd >= bpStart) {\n                    featureArray.push(feature);\n\n                    tokens = rest.split(\"\\t\");\n                    this.create_feature(tokens, feature);\n                }\n            }\n        }\n    }], [{\n        key: \"zoomLevelForScale\",\n        value: function zoomLevelForScale(bpPerPixel, zoomLevelHeaders) {\n\n            var level = null,\n                i,\n                zl;\n\n            for (i = 0; i < zoomLevelHeaders.length; i++) {\n\n                zl = zoomLevelHeaders[i];\n\n                if (zl.reductionLevel > bpPerPixel) {\n                    level = zl;\n                    break;\n                }\n            }\n\n            if (null == level) {\n                level = zoomLevelHeaders[zoomLevelHeaders.length - 1];\n            }\n\n            return level && level.reductionLevel < 4 * bpPerPixel ? level : null;\n        }\n    }, {\n        key: \"decodeWigData\",\n        value: function decodeWigData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                chromId = binaryParser.getInt(),\n                chromStart = binaryParser.getInt(),\n                chromEnd = binaryParser.getInt(),\n                itemStep = binaryParser.getInt(),\n                itemSpan = binaryParser.getInt(),\n                type = binaryParser.getByte(),\n                reserved = binaryParser.getByte(),\n                itemCount = binaryParser.getUShort(),\n                value;\n\n            if (chromId === chrIdx) {\n\n                while (itemCount-- > 0) {\n\n                    switch (type) {\n                        case 1:\n                            chromStart = binaryParser.getInt();\n                            chromEnd = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            break;\n                        case 2:\n                            chromStart = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            break;\n                        case 3:\n                            // Fixed step\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            chromStart += itemStep;\n                            break;\n\n                    }\n\n                    if (chromStart >= bpEnd) {\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"decodeZoomData\",\n        value: function decodeZoomData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 8 * 4,\n                // Minimum # of bytes required for a zoom record\n            chromId,\n                chromStart,\n                chromEnd,\n                validCount,\n                minVal,\n                maxVal,\n                sumData,\n                sumSquares,\n                value;\n\n            while (binaryParser.remLength() >= minSize) {\n                chromId = binaryParser.getInt();\n                if (chromId === chrIdx) {\n\n                    chromStart = binaryParser.getInt();\n                    chromEnd = binaryParser.getInt();\n                    validCount = binaryParser.getInt();\n                    minVal = binaryParser.getFloat();\n                    maxVal = binaryParser.getFloat();\n                    sumData = binaryParser.getFloat();\n                    sumSquares = binaryParser.getFloat();\n                    value = validCount == 0 ? 0 : sumData / validCount;\n\n                    if (chromStart >= bpEnd && chromStart < 1000000000) {\n                        console.log(\"should have broken\");\n\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"createFeature\",\n        value: function createFeature(tokens, feature) {\n            if (tokens.length > 0) {\n                feature.name = tokens[0];\n            }\n\n            if (tokens.length > 1) {\n                feature.score = parseFloat(tokens[1]);\n            }\n            if (tokens.length > 2) {\n                feature.strand = tokens[2];\n            }\n            if (tokens.length > 3) {\n                feature.cdStart = parseInt(tokens[3]);\n            }\n            if (tokens.length > 4) {\n                feature.cdEnd = parseInt(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                //if (tokens[5] !== \".\" && tokens[5] !== \"0\")\n                //feature.color = igv.createColorString(tokens[5]);\n            }\n            if (tokens.length > 8) {\n                exonCount = parseInt(tokens[6]);\n                exonSizes = tokens[7].split(',');\n                exonStarts = tokens[8].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    exons.push({ start: eStart, end: eEnd });\n                }\n\n                feature.exons = exons;\n            }\n        }\n    }]);\n\n    return BWSource;\n}();\n\n//************js/bigwig/bwReader.js*****************\n\n\nvar BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High\nvar BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low\nvar BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High\nvar BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low\nvar BBFILE_HEADER_SIZE = 64;\n\nvar BWReader = function () {\n    function BWReader(config) {\n        _classCallCheck(this, BWReader);\n\n        this.path = config.url;\n        this.headPath = config.headURL || this.path;\n        this.rpTreeCache = {};\n        this.config = $.extend({}, config, true);\n    }\n\n    _createClass(BWReader, [{\n        key: \"getZoomHeaders\",\n        value: function getZoomHeaders() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                if (self.zoomLevelHeaders) {\n                    fulfill(self.zoomLevelHeaders);\n                } else {\n                    self.loadHeader().then(function () {\n                        fulfill(self.zoomLevelHeaders);\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }\n            });\n        }\n    }, {\n        key: \"loadHeader\",\n        value: function loadHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: { start: 0, size: BBFILE_HEADER_SIZE } })).then(function (data) {\n\n                    if (!data) return;\n\n                    // Assume low-to-high unless proven otherwise\n                    self.littleEndian = true;\n\n                    var binaryParser = new BinaryParser(new DataView(data));\n\n                    var magic = binaryParser.getUInt();\n\n                    if (magic === BIGWIG_MAGIC_LTH) {\n                        self.type = \"BigWig\";\n                    } else if (magic == BIGBED_MAGIC_LTH) {\n                        self.type = \"BigBed\";\n                    } else {\n                        //Try big endian order\n                        self.littleEndian = false;\n\n                        binaryParser.littleEndian = false;\n                        binaryParser.position = 0;\n                        var magic = binaryParser.getUInt();\n\n                        if (magic === BIGWIG_MAGIC_HTL) {\n                            self.type = \"BigWig\";\n                        } else if (magic == BIGBED_MAGIC_HTL) {\n                            self.type = \"BigBed\";\n                        } else {\n                            // TODO -- error, unknown file type  or BE\n                        }\n                    }\n                    // Table 5  \"Common header for BigWig and BigBed files\"\n                    self.header = {};\n                    self.header.bwVersion = binaryParser.getUShort();\n                    self.header.nZoomLevels = binaryParser.getUShort();\n                    self.header.chromTreeOffset = binaryParser.getLong();\n                    self.header.fullDataOffset = binaryParser.getLong();\n                    self.header.fullIndexOffset = binaryParser.getLong();\n                    self.header.fieldCount = binaryParser.getUShort();\n                    self.header.definedFieldCount = binaryParser.getUShort();\n                    self.header.autoSqlOffset = binaryParser.getLong();\n                    self.header.totalSummaryOffset = binaryParser.getLong();\n                    self.header.uncompressBuffSize = binaryParser.getInt();\n                    self.header.reserved = binaryParser.getLong();\n\n                    self.loadZoomHeadersAndChrTree().then(fulfill).catch(reject);\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"loadZoomHeadersAndChrTree\",\n        value: function loadZoomHeadersAndChrTree() {\n\n            var startOffset = BBFILE_HEADER_SIZE,\n                self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var range = { start: startOffset, size: self.header.fullDataOffset - startOffset + 5 };\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: range })).then(function (data) {\n\n                    var nZooms = self.header.nZoomLevels,\n                        binaryParser = new BinaryParser(new DataView(data)),\n                        i,\n                        len,\n                        zoomNumber,\n                        zlh;\n\n                    self.zoomLevelHeaders = [];\n\n                    self.firstZoomDataOffset = Number.MAX_VALUE;\n                    for (i = 0; i < nZooms; i++) {\n                        zoomNumber = nZooms - i;\n                        zlh = new ZoomLevelHeader(zoomNumber, binaryParser);\n                        self.firstZoomDataOffset = Math.min(zlh.dataOffset, self.firstZoomDataOffset);\n                        self.zoomLevelHeaders.push(zlh);\n                    }\n\n                    // Autosql\n                    if (self.header.autoSqlOffset > 0) {\n                        binaryParser.position = self.header.autoSqlOffset - startOffset;\n                        self.autoSql = binaryParser.getString();\n                    }\n\n                    // Total summary\n                    if (self.header.totalSummaryOffset > 0) {\n                        binaryParser.position = self.header.totalSummaryOffset - startOffset;\n                        self.totalSummary = new BWTotalSummary(binaryParser);\n                    }\n\n                    // Chrom data index\n                    if (self.header.chromTreeOffset > 0) {\n                        binaryParser.position = self.header.chromTreeOffset - startOffset;\n                        self.chromTree = new BPTree(binaryParser, startOffset);\n                    } else {}\n                    // TODO -- this is an error, not expected\n\n\n                    //Finally total data count\n                    binaryParser.position = self.header.fullDataOffset - startOffset;\n                    self.dataCount = binaryParser.getInt();\n\n                    fulfill();\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"loadRPTree\",\n        value: function loadRPTree(offset) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rpTree = self.rpTreeCache[offset];\n                if (rpTree) {\n                    fulfill(rpTree);\n                } else {\n                    rpTree = new RPTree(offset, self.contentLength, self.config, self.littleEndian);\n                    self.rpTreeCache[offset] = rpTree;\n                    rpTree.load().then(function () {\n                        fulfill(rpTree);\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BWReader;\n}();\n\nvar ZoomLevelHeader = function ZoomLevelHeader(index, byteBuffer) {\n    _classCallCheck(this, ZoomLevelHeader);\n\n    this.index = index;\n    this.reductionLevel = byteBuffer.getInt();\n    this.reserved = byteBuffer.getInt();\n    this.dataOffset = byteBuffer.getLong();\n    this.indexOffset = byteBuffer.getLong();\n};\n\nvar RPTREE_MAGIC_LTH = 0x2468ACE0;\nvar RPTREE_MAGIC_HTL = 0xE0AC6824;\nvar RPTREE_HEADER_SIZE = 48;\nvar RPTREE_NODE_LEAF_ITEM_SIZE = 32; // leaf item size\nvar RPTREE_NODE_CHILD_ITEM_SIZE = 24; // child item size\nvar BUFFER_SIZE = 512000;\n\n//***********js/bigwig/RPTree*******************\n\n\n//  buffer\n\nvar RPTree = function () {\n    function RPTree(fileOffset, contentLength, config, littleEndian) {\n        _classCallCheck(this, RPTree);\n\n        this.config = config;\n        this.filesize = contentLength;\n        this.fileOffset = fileOffset; // File offset to beginning of tree\n        this.path = config.url;\n        this.littleEndian = littleEndian;\n    }\n\n    _createClass(RPTree, [{\n        key: \"load\",\n        value: function load() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rootNodeOffset = self.fileOffset + RPTREE_HEADER_SIZE,\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                self.readNode(rootNodeOffset, bufferedReader).then(function (node) {\n                    self.rootNode = node;\n                    fulfill(self);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"readNode\",\n        value: function readNode(filePosition, bufferedReader) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                bufferedReader.dataViewForRange({ start: filePosition, size: 4 }, false).then(function (dataView) {\n                    var binaryParser = new BinaryParser(dataView, self.littleEndian);\n\n                    var type = binaryParser.getByte();\n                    var isLeaf = type === 1 ? true : false;\n                    var reserved = binaryParser.getByte();\n                    var count = binaryParser.getUShort();\n\n                    filePosition += 4;\n\n                    var bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);\n                    var range2 = { start: filePosition, size: bytesRequired };\n\n                    bufferedReader.dataViewForRange(range2, false).then(function (dataView) {\n\n                        var i,\n                            items = new Array(count),\n                            binaryParser = new BinaryParser(dataView);\n\n                        if (isLeaf) {\n                            for (i = 0; i < count; i++) {\n                                var item = {\n                                    isLeaf: true,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    dataOffset: binaryParser.getLong(),\n                                    dataSize: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n                            fulfill(new RPTreeNode(items));\n                        } else {\n                            // non-leaf\n                            for (i = 0; i < count; i++) {\n\n                                var item = {\n                                    isLeaf: false,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    childOffset: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n\n                            fulfill(new RPTreeNode(items));\n                        }\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"findLeafItemsOverlapping\",\n        value: function findLeafItemsOverlapping(chrIdx, startBase, endBase) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var leafItems = [],\n                    processing = new Set(),\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                processing.add(0); // Zero represents the root node\n                findLeafItems(self.rootNode, 0);\n\n                function findLeafItems(node, nodeId) {\n\n                    if (RPTree.overlaps(node, chrIdx, startBase, endBase)) {\n\n                        var items = node.items;\n\n                        items.forEach(function (item) {\n\n                            if (RPTree.overlaps(item, chrIdx, startBase, endBase)) {\n\n                                if (item.isLeaf) {\n                                    leafItems.push(item);\n                                } else {\n                                    if (item.childNode) {\n                                        findLeafItems(item.childNode);\n                                    } else {\n                                        processing.add(item.childOffset); // Represent node to-be-loaded by its file position\n                                        self.readNode(item.childOffset, bufferedReader).then(function (node) {\n                                            item.childNode = node;\n                                            findLeafItems(node, item.childOffset);\n                                        }).catch(reject);\n                                    }\n                                }\n                            }\n                        });\n                    }\n\n                    if (nodeId != undefined) processing.delete(nodeId);\n\n                    // Wait until all nodes are processed\n                    if (processing.size === 0) {\n                        fulfill(leafItems);\n                    }\n                }\n            });\n        }\n\n        /**\r\n         * Return true if {chrIdx:startBase-endBase} overlaps item's interval\r\n         * @returns {boolean}\r\n         */\n\n    }], [{\n        key: \"overlaps\",\n        value: function overlaps(item, chrIdx, startBase, endBase) {\n\n            //  if (chrIdx > item.endChrom || chrIdx < item.startChrom) return false;\n\n            if (!item) {\n                console.log(\"null item\");\n                return false;\n            }\n\n            return (chrIdx > item.startChrom || chrIdx == item.startChrom && endBase >= item.startBase) && (chrIdx < item.endChrom || chrIdx == item.endChrom && startBase < item.endBase);\n        }\n    }]);\n\n    return RPTree;\n}();\n\nvar RPTreeNode = function RPTreeNode(items) {\n    _classCallCheck(this, RPTreeNode);\n\n    this.items = items;\n\n    var minChromId = Number.MAX_VALUE,\n        maxChromId = 0,\n        minStartBase = Number.MAX_VALUE,\n        maxEndBase = 0,\n        i,\n        item;\n\n    for (i = 0; i < items.length; i++) {\n        item = items[i];\n        minChromId = Math.min(minChromId, item.startChrom);\n        maxChromId = Math.max(maxChromId, item.endChrom);\n        minStartBase = Math.min(minStartBase, item.startBase);\n        maxEndBase = Math.max(maxEndBase, item.endBase);\n    }\n\n    this.startChrom = minChromId;\n    this.endChrom = maxChromId;\n    this.startBase = minStartBase;\n    this.endBase = maxEndBase;\n};\n\n//*******************js/binary.js******************\n\n\nvar BinaryParser = function () {\n    function BinaryParser(dataView, littleEndian) {\n        _classCallCheck(this, BinaryParser);\n\n        this.littleEndian = littleEndian ? littleEndian : true;\n        this.position = 0;\n        this.view = dataView;\n        this.length = dataView.byteLength;\n    }\n\n    _createClass(BinaryParser, [{\n        key: \"available\",\n        value: function available() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"remLength\",\n        value: function remLength() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"hasNext\",\n        value: function hasNext() {\n            return this.position < this.length - 1;\n        }\n    }, {\n        key: \"getByte\",\n        value: function getByte() {\n            var retValue = this.view.getUint8(this.position, this.littleEndian);\n            this.position++;\n            return retValue;\n        }\n    }, {\n        key: \"getShort\",\n        value: function getShort() {\n\n            var retValue = this.view.getInt16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getUShort\",\n        value: function getUShort() {\n\n            // var byte1 = this.getByte(),\n            //     byte2 = this.getByte(),\n            //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\n            //     return retValue;\n\n            //\n            var retValue = this.view.getUint16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getInt\",\n        value: function getInt() {\n\n            var retValue = this.view.getInt32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getUInt\",\n        value: function getUInt() {\n            var retValue = this.view.getUint32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getLong\",\n        value: function getLong() {\n\n            // DataView doesn't support long. So we'll try manually\n\n            var b = [];\n            b[0] = this.view.getUint8(this.position);\n            b[1] = this.view.getUint8(this.position + 1);\n            b[2] = this.view.getUint8(this.position + 2);\n            b[3] = this.view.getUint8(this.position + 3);\n            b[4] = this.view.getUint8(this.position + 4);\n            b[5] = this.view.getUint8(this.position + 5);\n            b[6] = this.view.getUint8(this.position + 6);\n            b[7] = this.view.getUint8(this.position + 7);\n\n            var value = 0;\n            if (this.littleEndian) {\n                for (var i = b.length - 1; i >= 0; i--) {\n                    value = value * 256 + b[i];\n                }\n            } else {\n                for (var i = 0; i < b.length; i++) {\n                    value = value * 256 + b[i];\n                }\n            }\n\n            this.position += 8;\n            return value;\n        }\n    }, {\n        key: \"getString\",\n        value: function getString(len) {\n\n            var s = \"\";\n            var c;\n            while ((c = this.view.getUint8(this.position++)) != 0) {\n                s += String.fromCharCode(c);\n                if (len && s.length == len) break;\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthString\",\n        value: function getFixedLengthString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 0) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthTrimmedString\",\n        value: function getFixedLengthTrimmedString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 32) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFloat\",\n        value: function getFloat() {\n\n            var retValue = this.view.getFloat32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getDouble\",\n        value: function getDouble() {\n\n            var retValue = this.view.getFloat64(this.position, this.littleEndian);\n            this.position += 8;\n            return retValue;\n        }\n    }, {\n        key: \"skip\",\n        value: function skip(n) {\n\n            this.position += n;\n            return this.position;\n        }\n\n        /**\r\n         * Return a bgzip (bam and tabix) virtual pointer\r\n         * TODO -- why isn't 8th byte used ?\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"getVPointer\",\n        value: function getVPointer() {\n\n            var position = this.position,\n                offset = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position),\n                byte6 = (this.view.getUint8(position + 6) & 0xff) * 0x100000000,\n                byte5 = (this.view.getUint8(position + 5) & 0xff) * 0x1000000,\n                byte4 = (this.view.getUint8(position + 4) & 0xff) * 0x10000,\n                byte3 = (this.view.getUint8(position + 3) & 0xff) * 0x100,\n                byte2 = this.view.getUint8(position + 2) & 0xff,\n                block = byte6 + byte5 + byte4 + byte3 + byte2;\n            this.position += 8;\n\n            //       if (block == 0 && offset == 0) {\n            //           return null;\n            //       } else {\n            return new VPointer(block, offset);\n            //       }\n        }\n    }]);\n\n    return BinaryParser;\n}();\n\nvar VPointer = function () {\n    function VPointer(block, offset) {\n        _classCallCheck(this, VPointer);\n\n        this.block = block;\n        this.offset = offset;\n    }\n\n    _createClass(VPointer, [{\n        key: \"isLessThan\",\n        value: function isLessThan(vp) {\n            return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;\n        }\n    }, {\n        key: \"isGreaterThan\",\n        value: function isGreaterThan(vp) {\n            return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;\n        }\n    }, {\n        key: \"print\",\n        value: function print() {\n            return \"\" + this.block + \":\" + this.offset;\n        }\n    }]);\n\n    return VPointer;\n}();\n\n//*******js/bigwig/bwTotalSummary.js*************\n\n\nvar BWTotalSummary = function () {\n    function BWTotalSummary(byteBuffer) {\n        _classCallCheck(this, BWTotalSummary);\n\n        if (byteBuffer) {\n\n            this.basesCovered = byteBuffer.getLong();\n            this.minVal = byteBuffer.getDouble();\n            this.maxVal = byteBuffer.getDouble();\n            this.sumData = byteBuffer.getDouble();\n            this.sumSquares = byteBuffer.getDouble();\n\n            this.computeStats();\n        } else {\n            this.basesCovered = 0;\n            this.minVal = 0;\n            this.maxVal = 0;\n            this.sumData = 0;\n            this.sumSquares = 0;\n            this.mean = 0;\n            this.stddev = 0;\n        }\n    }\n\n    _createClass(BWTotalSummary, [{\n        key: \"computeStats\",\n        value: function computeStats() {\n            var n = this.basesCovered;\n            if (n > 0) {\n                this.mean = this.sumData / n;\n                this.stddev = Math.sqrt(this.sumSquares / (n - 1));\n\n                var min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,\n                    max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;\n\n                this.defaultRange = {\n                    min: 0,\n                    max: this.mean + 3 * this.stddev\n                };\n            }\n        }\n    }, {\n        key: \"updateStats\",\n        value: function updateStats(stats) {\n\n            this.basesCovered += stats.count;\n            this.sumData += status.sumData;\n            this.sumSquares += sumSquares;\n            this.minVal = MIN(_minVal, min);\n            this.maxVal = MAX(_maxVal, max);\n\n            computeStats.call(this);\n        }\n    }]);\n\n    return BWTotalSummary;\n}();\n\n//***************js/bigwig/bwBPTree.js**************\n\n\nvar BPTREE_MAGIC_LTH = 0x78CA8C91;\nvar BPTREE_MAGIC_HTL = 0x918CCA78;\nvar BPTREE_HEADER_SIZE = 32;\n\nvar BPTree = function BPTree(binaryParser, startOffset) {\n    _classCallCheck(this, BPTree);\n\n    var self = this,\n        genome = null;\n\n    this.header = {};\n    this.header.magic = binaryParser.getInt();\n    this.header.blockSize = binaryParser.getInt();\n    this.header.keySize = binaryParser.getInt();\n    this.header.valSize = binaryParser.getInt();\n    this.header.itemCount = binaryParser.getLong();\n    this.header.reserved = binaryParser.getLong();\n\n    this.dictionary = {};\n\n    // Recursively walk tree to populate dictionary\n    readTreeNode(binaryParser, -1, this.header.keySize, this.dictionary);\n\n    var itemSize = 8 + this.header.keySize;\n    var minSize = 4 + itemSize; // Bytes for a node with 1 item\n\n    function readTreeNode(byteBuffer, offset, keySize, dictionary) {\n\n        if (offset >= 0) byteBuffer.position = offset;\n\n        var type = byteBuffer.getByte(),\n            reserved = byteBuffer.getByte(),\n            count = byteBuffer.getUShort(),\n            i,\n            key,\n            chromId,\n            chromSize,\n            childOffset,\n            bufferOffset,\n            currOffset;\n\n        if (type == 1) {\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                chromId = byteBuffer.getInt();\n                chromSize = byteBuffer.getInt();\n\n                if (genome) key = genome.getChromosomeName(key); // Translate to canonical chr name\n                dictionary[key] = chromId;\n            }\n        } else {\n            // non-leaf\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                childOffset = byteBuffer.getLong();\n                bufferOffset = childOffset - startOffset;\n                currOffset = byteBuffer.position;\n                readTreeNode(byteBuffer, bufferOffset, keySize, dictionary);\n                byteBuffer.position = currOffset;\n            }\n        }\n    }\n};\n\nexports.BWSource = BWSource;\nexports.BinaryParser = BinaryParser;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! .Panel/src/vendor/zlib_and_gzip.min.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JpZ3dpZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmlnd2lnLmpzPzExZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7aWd2eGhyfSBmcm9tIFwiLi9pZ3Z4aHIuanNcIjtcclxuXHJcblxyXG4vLyoqKioqKioqKioqanMvYmlnd2lnL2J1ZmZlcmVkUmVhZGVyLmpzKioqKioqKioqKioqKioqKipcclxuY2xhc3MgQnVmZmVyZWRSZWFkZXJ7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGNvbnRlbnRMZW5ndGgsIGJ1ZmZlclNpemUpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBjb25maWcudXJsO1xyXG4gICAgICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5idWZmZXJTaXplID0gYnVmZmVyU2l6ZSA/IGJ1ZmZlclNpemUgOiA1MTIwMDA7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHtzdGFydDogLTEsIHNpemU6IC0xfTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdGVkUmFuZ2UgLSBieXRlIHJhbmdlYXMge3N0YXJ0LCBzaXplfVxyXG4gICAgICogQHBhcmFtIGZ1bGZpbGwgLSBmdW5jdGlvbiB0byByZWNlaXZlIHJlc3VsdFxyXG4gICAgICogQHBhcmFtIGFzVWludDggLSBvcHRpb25hbCBmbGFnIHRvIHJldHVybiByZXN1bHQgYXMgYW4gVUludDhBcnJheVxyXG4gICAgICovXHJcbiAgICBkYXRhVmlld0ZvclJhbmdlKHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGhhc0RhdGEgPSAoc2VsZi5kYXRhICYmIChzZWxmLnJhbmdlLnN0YXJ0IDw9IHJlcXVlc3RlZFJhbmdlLnN0YXJ0KSAmJlxyXG4gICAgICAgICAgICAgICAgKChzZWxmLnJhbmdlLnN0YXJ0ICsgc2VsZi5yYW5nZS5zaXplKSA+PSAocmVxdWVzdGVkUmFuZ2Uuc3RhcnQgKyByZXF1ZXN0ZWRSYW5nZS5zaXplKSkpLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSxcclxuICAgICAgICAgICAgICAgIGxvYWRSYW5nZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoYXNEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJidWZmZXIoc2VsZiwgcmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGJ1ZmZlciBzaXplIGlmIG5lZWRlZCwgYnV0IG5vdCBiZXlvbmQgY29udGVudCBsZW5ndGhcclxuICAgICAgICAgICAgICAgIGJ1ZmZlclNpemUgPSBNYXRoLm1heChzZWxmLmJ1ZmZlclNpemUsIHJlcXVlc3RlZFJhbmdlLnNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3RlZFJhbmdlLnN0YXJ0ICsgYnVmZmVyU2l6ZSA+IHNlbGYuY29udGVudExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRSYW5nZSA9IHtzdGFydDogcmVxdWVzdGVkUmFuZ2Uuc3RhcnR9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZFJhbmdlID0ge3N0YXJ0OiByZXF1ZXN0ZWRSYW5nZS5zdGFydCwgc2l6ZTogYnVmZmVyU2l6ZX07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZTogbG9hZFJhbmdlfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhID0gYXJyYXlCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yYW5nZSA9IGxvYWRSYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJidWZmZXIoc2VsZiwgcmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdWJidWZmZXIoYnVmZmVyZWRSZWFkZXIsIHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlcmVkUmVhZGVyLmRhdGEuYnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJTdGFydCA9IHJlcXVlc3RlZFJhbmdlLnN0YXJ0IC0gYnVmZmVyZWRSZWFkZXIucmFuZ2Uuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXNVaW50OCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcmVkUmVhZGVyLmRhdGEsIGJ1ZmZlclN0YXJ0LCBsZW4gLSBidWZmZXJTdGFydCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyZWRSZWFkZXIuZGF0YSwgYnVmZmVyU3RhcnQsIGxlbiAtIGJ1ZmZlclN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKioqKipqcy9iaWd3aWcvYndTb3VyY2UuanMqKioqKioqKioqKioqKipcclxuY2xhc3MgQldTb3VyY2V7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLGNyZWF0ZV9mZWF0dXJlX2Z1bmN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgQldSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkUmVhZGVyID0gbmV3IEJ1ZmZlcmVkUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKCFjcmVhdGVfZmVhdHVyZV9mdW5jdGlvbil7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlX2ZlYXR1cmU9QldTb3VyY2UuY3JlYXRlRmVhdHVyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVfZmVhdHVyZT1jcmVhdGVfZmVhdHVyZV9mdW5jdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG5cdCogQ3JlYXRlcyBhIHBhbmVsXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gY2hyIC0gVGhlIGNocm9tb3NvbWVcclxuXHQqIEBwYXJhbSB7aW50fSBicFN0YXJ0IFRoZSBzdGFydGluZyBwb3N0aXRpb24gXHJcblx0KiBAcGFyYW0ge2ludH0gYnBFbmQgLSBUaGUgZW5kIG9mIHRoZSByZWdpb24gdG8gc2hvd1xyXG5cdCogQHBhcmFtIHtib29sZWFufSB1c2VfZXhpc3RpbmcgLSBJZiB0cnVlIHRoZW4gdGhlIGNhY2hlZCBmZWF0dXJlIHdpbGwgYmUgdXNlZC0gb25seSB1c2VkXHJcblx0KiBpZiB0aGUgY28tb3JpZGluYXRlcyBoYXZlIG5vdCBjaGFuZ2VkLiBBbHRob3VnaCwgdGhlIEJXcmVhZGVyIGhhcyBhIGNhY2hlLCBpdCBpcyBzb21ldGltZXNcclxuXHQqIGlnbm9yZWQgYW5kIGZlYXR1cmVzIGFyZSByZS1mZXRjaGVkIGZvciB0aGUgc2FtZSByZWdpb25cclxuXHQqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gU2hvdWxkIGNvbnRhaW4gcGl4ZWxXaWR0aC0gdGhlIHdpZHRoIG9mIHRoZSBlbnRpcmUgY2FudmFzIGFuZCBcclxuXHQqIGJwUGVyUGl4ZWwuXHJcblx0Ki9cclxuICAgIGdldEZlYXR1cmVzKGNociwgYnBTdGFydCwgYnBFbmQsdXNlX2V4aXN0aW5nLGRhdGEpIHtcclxuICAgICAgICB0aGlzLnN0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmZlYXR1cmVzICYmIHVzZV9leGlzdGluZyl7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmVhZGVyLmdldFpvb21IZWFkZXJzKCkudGhlbihmdW5jdGlvbiAoem9vbUxldmVsSGVhZGVycykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBhIGJpd2lnIFwiem9vbSBsZXZlbFwiIGFwcHJvcHJpYXRlIGZvciB0aGUgY3VycmVudCByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgYndSZWFkZXIgPSBzZWxmLnJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IHNlbGYuYnVmZmVyZWRSZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYnBwID1kYXRhLmJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsSGVhZGVyPUJXU291cmNlLnpvb21MZXZlbEZvclNjYWxlKGJwcCwgem9vbUxldmVsSGVhZGVycyksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZU9mZnNldFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHpvb21MZXZlbEhlYWRlciAmJiBid1JlYWRlci50eXBlPT09XCJCaWdXaWdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVPZmZzZXQgPSB6b29tTGV2ZWxIZWFkZXIuaW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVGdW5jdGlvbiA9IEJXU291cmNlLmRlY29kZVpvb21EYXRhO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlT2Zmc2V0ID0gYndSZWFkZXIuaGVhZGVyLmZ1bGxJbmRleE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYndSZWFkZXIudHlwZSA9PT0gXCJCaWdXaWdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uID1CV1NvdXJjZS5kZWNvZGVXaWdEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVGdW5jdGlvbiA9c2VsZi5kZWNvZGVCZWREYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBid1JlYWRlci5sb2FkUlBUcmVlKHRyZWVPZmZzZXQpLnRoZW4oZnVuY3Rpb24gKHJwVHJlZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hySWR4ID0gc2VsZi5yZWFkZXIuY2hyb21UcmVlLmRpY3Rpb25hcnlbY2hyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hySWR4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBycFRyZWUuZmluZExlYWZJdGVtc092ZXJsYXBwaW5nKGNocklkeCwgYnBTdGFydCwgYnBFbmQpLnRoZW4oZnVuY3Rpb24gKGxlYWZJdGVtcykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGVhZkl0ZW1zIHx8IGxlYWZJdGVtcy5sZW5ndGggPT0gMCkgZnVsZmlsbChbXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZkl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIuZGF0YVZpZXdGb3JSYW5nZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogaXRlbS5kYXRhT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogaXRlbS5kYXRhU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKS50aGVuKGZ1bmN0aW9uICh1aW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGUgPSBuZXcgWmxpYi5abGliLkluZmxhdGUodWludDhBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFpbj0gaW5mbGF0ZS5kZWNvbXByZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5mbGF0ZS5wdXNoKHVpbnQ4QXJyYXksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcGxhaW4gPSBpbmZsYXRlLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24obmV3IERhdGFWaWV3KHBsYWluLmJ1ZmZlciksIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVBcnJheXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW4gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGVuLXNlbGYuc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBicHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZlYXR1cmVBcnJheXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpPTE7IGk8ZmVhdHVyZUFycmF5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChmZWF0dXJlQXJyYXlzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVzPWFsbEZlYXR1cmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxsRmVhdHVyZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcil7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBnZXREZWZhdWx0UmFuZ2UoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5yZWFkZXIudG90YWxTdW1tYXJ5ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIudG90YWxTdW1tYXJ5LmRlZmF1bHRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzdGF0aWMgem9vbUxldmVsRm9yU2NhbGUoYnBQZXJQaXhlbCwgem9vbUxldmVsSGVhZGVycykge1xyXG5cclxuICAgICAgICB2YXIgbGV2ZWwgPSBudWxsLCBpLCB6bDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHpvb21MZXZlbEhlYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHpsID0gem9vbUxldmVsSGVhZGVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh6bC5yZWR1Y3Rpb25MZXZlbCA+IGJwUGVyUGl4ZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldmVsID0gemw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG51bGwgPT0gbGV2ZWwpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSB6b29tTGV2ZWxIZWFkZXJzW3pvb21MZXZlbEhlYWRlcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKGxldmVsICYmIGxldmVsLnJlZHVjdGlvbkxldmVsIDwgNCAqIGJwUGVyUGl4ZWwpID8gbGV2ZWwgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlV2lnRGF0YShkYXRhLCBjaHIsIGNocklkeCwgYnBTdGFydCwgYnBFbmQsIGZlYXR1cmVBcnJheSkge1xyXG5cclxuICAgICAgICB2YXIgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihkYXRhKSxcclxuICAgICAgICAgICAgY2hyb21JZCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGl0ZW1TdGVwID0gYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICBpdGVtU3BhbiA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgdHlwZSA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgIHJlc2VydmVkID0gYmluYXJ5UGFyc2VyLmdldEJ5dGUoKSxcclxuICAgICAgICAgICAgaXRlbUNvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpLFxyXG4gICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKGNocm9tSWQgPT09IGNocklkeCkge1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGl0ZW1Db3VudC0tID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiaW5hcnlQYXJzZXIuZ2V0RmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21FbmQgPSBjaHJvbVN0YXJ0ICsgaXRlbVNwYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogIC8vIEZpeGVkIHN0ZXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiaW5hcnlQYXJzZXIuZ2V0RmxvYXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21FbmQgPSBjaHJvbVN0YXJ0ICsgaXRlbVNwYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgKz0gaXRlbVN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyb21TdGFydCA+PSBicEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBPdXQgb2YgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyb21FbmQgPiBicFN0YXJ0ICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlQXJyYXkucHVzaCh7Y2hyOiBjaHIsIHN0YXJ0OiBjaHJvbVN0YXJ0LCBlbmQ6IGNocm9tRW5kLCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlWm9vbURhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIG1pblNpemUgPSA4ICogNCwgICAvLyBNaW5pbXVtICMgb2YgYnl0ZXMgcmVxdWlyZWQgZm9yIGEgem9vbSByZWNvcmRcclxuICAgICAgICAgICAgY2hyb21JZCxcclxuICAgICAgICAgICAgY2hyb21TdGFydCxcclxuICAgICAgICAgICAgY2hyb21FbmQsXHJcbiAgICAgICAgICAgIHZhbGlkQ291bnQsXHJcbiAgICAgICAgICAgIG1pblZhbCxcclxuICAgICAgICAgICAgbWF4VmFsLFxyXG4gICAgICAgICAgICBzdW1EYXRhLFxyXG4gICAgICAgICAgICBzdW1TcXVhcmVzLFxyXG4gICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGJpbmFyeVBhcnNlci5yZW1MZW5ndGgoKSA+PSBtaW5TaXplKSB7XHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIGlmIChjaHJvbUlkID09PSBjaHJJZHgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjaHJvbVN0YXJ0ID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICB2YWxpZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgbWluVmFsID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBtYXhWYWwgPSBiaW5hcnlQYXJzZXIuZ2V0RmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHN1bURhdGEgPSBiaW5hcnlQYXJzZXIuZ2V0RmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHN1bVNxdWFyZXMgPSBiaW5hcnlQYXJzZXIuZ2V0RmxvYXQoKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsaWRDb3VudCA9PSAwID8gMCA6IHN1bURhdGEgLyB2YWxpZENvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaHJvbVN0YXJ0ID49IGJwRW5kICYmIGNocm9tU3RhcnQ8MTAwMDAwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNob3VsZCBoYXZlIGJyb2tlblwiKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gT3V0IG9mIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyb21FbmQgPiBicFN0YXJ0ICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlQXJyYXkucHVzaCh7Y2hyOiBjaHIsIHN0YXJ0OiBjaHJvbVN0YXJ0LCBlbmQ6IGNocm9tRW5kLCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIGRlY29kZUJlZERhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIG1pblNpemUgPSAzICogNCArIDEsICAgLy8gTWluaW11bSAjIG9mIGJ5dGVzIHJlcXVpcmVkIGZvciBhIGJlZCByZWNvcmRcclxuICAgICAgICAgICAgY2hyb21JZCxcclxuICAgICAgICAgICAgY2hyb21TdGFydCxcclxuICAgICAgICAgICAgY2hyb21FbmQsXHJcbiAgICAgICAgICAgIHJlc3QsXHJcbiAgICAgICAgICAgIHRva2VucyxcclxuICAgICAgICAgICAgZmVhdHVyZSxcclxuICAgICAgICAgICAgZXhvbkNvdW50LCBleG9uU2l6ZXMsIGV4b25TdGFydHMsIGV4b25zLCBlU3RhcnQsIGVFbmQ7XHJcblxyXG5cclxuICAgICAgICB3aGlsZSAoYmluYXJ5UGFyc2VyLnJlbUxlbmd0aCgpID49IG1pblNpemUpIHtcclxuXHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIGlmIChjaHJvbUlkICE9IGNocklkeCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBjaHJvbVN0YXJ0ID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBjaHJvbUVuZCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgcmVzdCA9IGJpbmFyeVBhcnNlci5nZXRTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBjaHJvbVN0YXJ0LCBlbmQ6IGNocm9tRW5kfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaHJvbVN0YXJ0IDwgYnBFbmQgJiYgY2hyb21FbmQgPj0gYnBTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goZmVhdHVyZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdG9rZW5zID0gcmVzdC5zcGxpdChcIlxcdFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlX2ZlYXR1cmUodG9rZW5zLGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIFxyXG4gICAgc3RhdGljIGNyZWF0ZUZlYXR1cmUodG9rZW5zLGZlYXR1cmUpe1xyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubmFtZSA9IHRva2Vuc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdHJhbmQgPSB0b2tlbnNbMl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmNkU3RhcnQgPSBwYXJzZUludCh0b2tlbnNbM10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jZEVuZCA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmICh0b2tlbnNbNV0gIT09IFwiLlwiICYmIHRva2Vuc1s1XSAhPT0gXCIwXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmVhdHVyZS5jb2xvciA9IGlndi5jcmVhdGVDb2xvclN0cmluZyh0b2tlbnNbNV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzZdKTtcclxuICAgICAgICAgICAgICAgICAgICBleG9uU2l6ZXMgPSB0b2tlbnNbN10uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzhdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlU3RhcnQgPSBzdGFydCArIHBhcnNlSW50KGV4b25TdGFydHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlRW5kID0gZVN0YXJ0ICsgcGFyc2VJbnQoZXhvblNpemVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhvbnMucHVzaCh7c3RhcnQ6IGVTdGFydCwgZW5kOiBlRW5kfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmV4b25zID0gZXhvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbi8vKioqKioqKioqKioqanMvYmlnd2lnL2J3UmVhZGVyLmpzKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jb25zdCBCSUdXSUdfTUFHSUNfTFRIID0gMHg4ODhGRkMyNjsgLy8gQmlnV2lnIE1hZ2ljIExvdyB0byBIaWdoXHJcbmNvbnN0IEJJR1dJR19NQUdJQ19IVEwgPSAweDI2RkM4RjY2OyAvLyBCaWdXaWcgTWFnaWMgSGlnaCB0byBMb3dcclxuY29uc3QgQklHQkVEX01BR0lDX0xUSCA9IDB4ODc4OUYyRUI7IC8vIEJpZ0JlZCBNYWdpYyBMb3cgdG8gSGlnaFxyXG5jb25zdCBCSUdCRURfTUFHSUNfSFRMID0gMHhFQkYyODk4NzsgLy8gQmlnQmVkIE1hZ2ljIEhpZ2ggdG8gTG93XHJcbmNvbnN0IEJCRklMRV9IRUFERVJfU0laRSA9IDY0O1xyXG5cclxuXHJcbmNsYXNzIEJXUmVhZGVye1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmhlYWRQYXRoID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5wYXRoO1xyXG4gICAgICAgIHRoaXMucnBUcmVlQ2FjaGUgPSB7fTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9ICQuZXh0ZW5kKHt9LGNvbmZpZyx0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgZ2V0Wm9vbUhlYWRlcnMoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuem9vbUxldmVsSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLnpvb21MZXZlbEhlYWRlcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSGVhZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLnpvb21MZXZlbEhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiB7c3RhcnQ6IDAsIHNpemU6IEJCRklMRV9IRUFERVJfU0laRX19KSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIGxvdy10by1oaWdoIHVubGVzcyBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBzZWxmLmxpdHRsZUVuZGlhbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGRhdGEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0VUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpYyA9PT0gQklHV0lHX01BR0lDX0xUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnV2lnXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWdpYyA9PSBCSUdCRURfTUFHSUNfTFRIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdCZWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVHJ5IGJpZyBlbmRpYW4gb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIubGl0dGxlRW5kaWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0VUludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFnaWMgPT09IEJJR1dJR19NQUdJQ19IVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdXaWdcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnaWMgPT0gQklHQkVEX01BR0lDX0hUTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGUgPSBcIkJpZ0JlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBlcnJvciwgdW5rbm93biBmaWxlIHR5cGUgIG9yIEJFXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRhYmxlIDUgIFwiQ29tbW9uIGhlYWRlciBmb3IgQmlnV2lnIGFuZCBCaWdCZWQgZmlsZXNcIlxyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSB7fTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmJ3VmVyc2lvbiA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLm5ab29tTGV2ZWxzID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuY2hyb21UcmVlT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmZ1bGxJbmRleE9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5maWVsZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuZGVmaW5lZEZpZWxkQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5hdXRvU3FsT2Zmc2V0ID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci51bmNvbXByZXNzQnVmZlNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5yZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkWm9vbUhlYWRlcnNBbmRDaHJUcmVlKCkudGhlbihmdWxmaWxsKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgIGxvYWRab29tSGVhZGVyc0FuZENoclRyZWUoKSB7XHJcblxyXG5cclxuICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBCQkZJTEVfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0ge3N0YXJ0OiBzdGFydE9mZnNldCwgc2l6ZTogKHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0IC0gc3RhcnRPZmZzZXQgKyA1KX07XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiByYW5nZX0pKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgblpvb21zID0gc2VsZi5oZWFkZXIublpvb21MZXZlbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihuZXcgRGF0YVZpZXcoZGF0YSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21OdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgemxoO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuem9vbUxldmVsSGVhZGVycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblpvb21zOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tTnVtYmVyID0gblpvb21zIC0gaTtcclxuICAgICAgICAgICAgICAgICAgICB6bGggPSBuZXcgWm9vbUxldmVsSGVhZGVyKHpvb21OdW1iZXIsIGJpbmFyeVBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJzdFpvb21EYXRhT2Zmc2V0ID0gTWF0aC5taW4oemxoLmRhdGFPZmZzZXQsIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi56b29tTGV2ZWxIZWFkZXJzLnB1c2goemxoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdXRvc3FsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5hdXRvU3FsT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hdXRvU3FsID0gYmluYXJ5UGFyc2VyLmdldFN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRvdGFsIHN1bW1hcnlcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gc2VsZi5oZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50b3RhbFN1bW1hcnkgPSBuZXcgQldUb3RhbFN1bW1hcnkoYmluYXJ5UGFyc2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaHJvbSBkYXRhIGluZGV4XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIuY2hyb21UcmVlT2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21UcmVlID0gbmV3IEJQVHJlZShiaW5hcnlQYXJzZXIsIHN0YXJ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gdGhpcyBpcyBhbiBlcnJvciwgbm90IGV4cGVjdGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9GaW5hbGx5IHRvdGFsIGRhdGEgY291bnRcclxuICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLmZ1bGxEYXRhT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGFDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcil7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkUlBUcmVlKG9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBycFRyZWUgPSBzZWxmLnJwVHJlZUNhY2hlW29mZnNldF07XHJcbiAgICAgICAgICAgIGlmIChycFRyZWUpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocnBUcmVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJwVHJlZSA9IG5ldyBSUFRyZWUob2Zmc2V0LCBzZWxmLmNvbnRlbnRMZW5ndGgsIHNlbGYuY29uZmlnLCBzZWxmLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJwVHJlZUNhY2hlW29mZnNldF0gPSBycFRyZWU7XHJcbiAgICAgICAgICAgICAgICBycFRyZWUubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwocnBUcmVlKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuIGNsYXNzIFpvb21MZXZlbEhlYWRlcntcclxuICAgICBjb25zdHJ1Y3RvcihpbmRleCwgYnl0ZUJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLnJlZHVjdGlvbkxldmVsID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLnJlc2VydmVkID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmRhdGFPZmZzZXQgPSBieXRlQnVmZmVyLmdldExvbmcoKTtcclxuICAgICAgICB0aGlzLmluZGV4T2Zmc2V0ID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICB9XHJcbiB9XHJcblxyXG5cclxuY29uc3QgUlBUUkVFX01BR0lDX0xUSCA9IDB4MjQ2OEFDRTA7XHJcbmNvbnN0IFJQVFJFRV9NQUdJQ19IVEwgPSAweEUwQUM2ODI0O1xyXG5jb25zdCBSUFRSRUVfSEVBREVSX1NJWkUgPSA0ODtcclxuY29uc3QgUlBUUkVFX05PREVfTEVBRl9JVEVNX1NJWkUgPSAzMjsgICAvLyBsZWFmIGl0ZW0gc2l6ZVxyXG5jb25zdCBSUFRSRUVfTk9ERV9DSElMRF9JVEVNX1NJWkUgPSAyNDsgIC8vIGNoaWxkIGl0ZW0gc2l6ZVxyXG5jb25zdCBCVUZGRVJfU0laRSA9IDUxMjAwMDsgXHJcblxyXG4vLyoqKioqKioqKioqanMvYmlnd2lnL1JQVHJlZSoqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG4gICAgIC8vICBidWZmZXJcclxuXHJcbmNsYXNzIFJQVHJlZXtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoZmlsZU9mZnNldCwgY29udGVudExlbmd0aCwgY29uZmlnLCBsaXR0bGVFbmRpYW4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5maWxlc2l6ZSA9IGNvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5maWxlT2Zmc2V0ID0gZmlsZU9mZnNldDsgLy8gRmlsZSBvZmZzZXQgdG8gYmVnaW5uaW5nIG9mIHRyZWVcclxuICAgICAgICB0aGlzLnBhdGggPSBjb25maWcudXJsO1xyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBsb2FkKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByb290Tm9kZU9mZnNldCA9IHNlbGYuZmlsZU9mZnNldCArIFJQVFJFRV9IRUFERVJfU0laRSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyID0gbmV3IEJ1ZmZlcmVkUmVhZGVyKHNlbGYuY29uZmlnLCBzZWxmLmZpbGVzaXplLCBCVUZGRVJfU0laRSk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLnJlYWROb2RlKHJvb3ROb2RlT2Zmc2V0LCBidWZmZXJlZFJlYWRlcikudGhlbihmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb290Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZWFkTm9kZShmaWxlUG9zaXRpb24sIGJ1ZmZlcmVkUmVhZGVyKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyLmRhdGFWaWV3Rm9yUmFuZ2Uoe3N0YXJ0OiBmaWxlUG9zaXRpb24sIHNpemU6IDR9LCBmYWxzZSkudGhlbihmdW5jdGlvbiAoZGF0YVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGFWaWV3LCBzZWxmLmxpdHRsZUVuZGlhbik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzTGVhZiA9ICh0eXBlID09PSAxKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciByZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmlsZVBvc2l0aW9uICs9IDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVzUmVxdWlyZWQgPSBjb3VudCAqIChpc0xlYWYgPyBSUFRSRUVfTk9ERV9MRUFGX0lURU1fU0laRSA6IFJQVFJFRV9OT0RFX0NISUxEX0lURU1fU0laRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UyID0ge3N0YXJ0OiBmaWxlUG9zaXRpb24sIHNpemU6IGJ5dGVzUmVxdWlyZWR9O1xyXG5cclxuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyLmRhdGFWaWV3Rm9yUmFuZ2UocmFuZ2UyLCBmYWxzZSkudGhlbihmdW5jdGlvbiAoZGF0YVZpZXcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gbmV3IEFycmF5KGNvdW50KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihkYXRhVmlldyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlYWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogYmluYXJ5UGFyc2VyLmdldExvbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU2l6ZTogYmluYXJ5UGFyc2VyLmdldExvbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChuZXcgUlBUcmVlTm9kZShpdGVtcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gbm9uLWxlYWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWY6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEJhc2U6IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEJhc2U6IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE9mZnNldDogYmluYXJ5UGFyc2VyLmdldExvbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IFJQVHJlZU5vZGUoaXRlbXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmaW5kTGVhZkl0ZW1zT3ZlcmxhcHBpbmcoY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGxlYWZJdGVtcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZyA9IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyID0gbmV3IEJ1ZmZlcmVkUmVhZGVyKHNlbGYuY29uZmlnLCBzZWxmLmZpbGVzaXplLCBCVUZGRVJfU0laRSk7XHJcblxyXG4gICAgICAgICAgICBwcm9jZXNzaW5nLmFkZCgwKTsgIC8vIFplcm8gcmVwcmVzZW50cyB0aGUgcm9vdCBub2RlXHJcbiAgICAgICAgICAgIGZpbmRMZWFmSXRlbXMoc2VsZi5yb290Tm9kZSwgMCk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kTGVhZkl0ZW1zKG5vZGUsIG5vZGVJZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChSUFRyZWUub3ZlcmxhcHMobm9kZSwgY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IG5vZGUuaXRlbXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSUFRyZWUub3ZlcmxhcHMoaXRlbSwgY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNMZWFmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZkl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRMZWFmSXRlbXMoaXRlbS5jaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5hZGQoaXRlbS5jaGlsZE9mZnNldCk7ICAvLyBSZXByZXNlbnQgbm9kZSB0by1iZS1sb2FkZWQgYnkgaXRzIGZpbGUgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWFkTm9kZShpdGVtLmNoaWxkT2Zmc2V0LCBidWZmZXJlZFJlYWRlcikudGhlbihmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZExlYWZJdGVtcyhub2RlLCBpdGVtLmNoaWxkT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJZCAhPSB1bmRlZmluZWQpIHByb2Nlc3NpbmcuZGVsZXRlKG5vZGVJZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgbm9kZXMgYXJlIHByb2Nlc3NlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3Npbmcuc2l6ZT09PTApIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGxlYWZJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHtjaHJJZHg6c3RhcnRCYXNlLWVuZEJhc2V9IG92ZXJsYXBzIGl0ZW0ncyBpbnRlcnZhbFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvdmVybGFwcyhpdGVtLCBjaHJJZHgsIHN0YXJ0QmFzZSwgZW5kQmFzZSkge1xyXG5cclxuICAgICAgICAvLyAgaWYgKGNocklkeCA+IGl0ZW0uZW5kQ2hyb20gfHwgY2hySWR4IDwgaXRlbS5zdGFydENocm9tKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm51bGwgaXRlbVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgoY2hySWR4ID4gaXRlbS5zdGFydENocm9tKSB8fCAoY2hySWR4ID09IGl0ZW0uc3RhcnRDaHJvbSAmJiBlbmRCYXNlID49IGl0ZW0uc3RhcnRCYXNlKSkgJiZcclxuICAgICAgICAgICAgKChjaHJJZHggPCBpdGVtLmVuZENocm9tKSB8fCAoY2hySWR4ID09IGl0ZW0uZW5kQ2hyb20gJiYgc3RhcnRCYXNlIDwgaXRlbS5lbmRCYXNlKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5jbGFzcyBSUFRyZWVOb2Rle1xyXG4gICAgY29uc3RydWN0b3IoaXRlbXMpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XHJcblxyXG4gICAgICAgIHZhciBtaW5DaHJvbUlkID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgbWF4Q2hyb21JZCA9IDAsXHJcbiAgICAgICAgICAgIG1pblN0YXJ0QmFzZSA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIG1heEVuZEJhc2UgPSAwLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBpdGVtO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xyXG4gICAgICAgICAgICBtaW5DaHJvbUlkID0gTWF0aC5taW4obWluQ2hyb21JZCwgaXRlbS5zdGFydENocm9tKTtcclxuICAgICAgICAgICAgbWF4Q2hyb21JZCA9IE1hdGgubWF4KG1heENocm9tSWQsIGl0ZW0uZW5kQ2hyb20pO1xyXG4gICAgICAgICAgICBtaW5TdGFydEJhc2UgPSBNYXRoLm1pbihtaW5TdGFydEJhc2UsIGl0ZW0uc3RhcnRCYXNlKTtcclxuICAgICAgICAgICAgbWF4RW5kQmFzZSA9IE1hdGgubWF4KG1heEVuZEJhc2UsIGl0ZW0uZW5kQmFzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0Q2hyb20gPSBtaW5DaHJvbUlkO1xyXG4gICAgICAgIHRoaXMuZW5kQ2hyb20gPSBtYXhDaHJvbUlkO1xyXG4gICAgICAgIHRoaXMuc3RhcnRCYXNlID0gbWluU3RhcnRCYXNlO1xyXG4gICAgICAgIHRoaXMuZW5kQmFzZSA9IG1heEVuZEJhc2U7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG4vLyoqKioqKioqKioqKioqKioqKipqcy9iaW5hcnkuanMqKioqKioqKioqKioqKioqKipcclxuY2xhc3MgQmluYXJ5UGFyc2Vye1xyXG4gICAgY29uc3RydWN0b3IoZGF0YVZpZXcsIGxpdHRsZUVuZGlhbikge1xyXG5cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IChsaXR0bGVFbmRpYW4gPyBsaXR0bGVFbmRpYW4gOiB0cnVlKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBkYXRhVmlldztcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgYXZhaWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmVtTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA8IHRoaXMubGVuZ3RoIC0gMTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRCeXRlKCkge1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTaG9ydCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDJcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VVNob3J0KCl7XHJcblxyXG4gICAgICAgIC8vIHZhciBieXRlMSA9IHRoaXMuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgIC8vICAgICBieXRlMiA9IHRoaXMuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgIC8vICAgICByZXRWYWx1ZSA9ICgoYnl0ZTIgPDwgMjQgPj4+IDE2KSArIChieXRlMSA8PCAyNCA+Pj4gMjQpKTtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG5cclxuICAgICAgIC8vXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNiAodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMlxyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0SW50KCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldFVJbnQoKSB7XHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRMb25nKCkge1xyXG5cclxuICAgICAgICAvLyBEYXRhVmlldyBkb2Vzbid0IHN1cHBvcnQgbG9uZy4gU28gd2UnbGwgdHJ5IG1hbnVhbGx5XHJcblxyXG4gICAgICAgIHZhciBiID0gW107XHJcbiAgICAgICAgYlswXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBiWzFdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAxKTtcclxuICAgICAgICBiWzJdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAyKTtcclxuICAgICAgICBiWzNdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyAzKTtcclxuICAgICAgICBiWzRdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyA0KTtcclxuICAgICAgICBiWzVdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyA1KTtcclxuICAgICAgICBiWzZdID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyA2KTtcclxuICAgICAgICBiWzddID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24gKyA3KTtcclxuXHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlICogMjU2KSArIGJbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlICogMjU2KSArIGJbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDg7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFN0cmluZyhsZW4pIHtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIHdoaWxlICgoYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspKSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgaWYgKGxlbiAmJiBzLmxlbmd0aCA9PSBsZW4pIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaXhlZExlbmd0aFN0cmluZyhsZW4pIHtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24rKyk7XHJcbiAgICAgICAgICAgIGlmIChjID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpeGVkTGVuZ3RoVHJpbW1lZFN0cmluZyhsZW4pIHtcclxuXHJcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zaXRpb24rKyk7XHJcbiAgICAgICAgICAgIGlmIChjID4gMzIpIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGbG9hdCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXREb3VibGUoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDg7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHNraXAobikge1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IG47XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgYmd6aXAgKGJhbSBhbmQgdGFiaXgpIHZpcnR1YWwgcG9pbnRlclxyXG4gICAgICogVE9ETyAtLSB3aHkgaXNuJ3QgOHRoIGJ5dGUgdXNlZCA/XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZ2V0VlBvaW50ZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIG9mZnNldCA9ICh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAxKSA8PCA4KSB8ICh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24pKSxcclxuICAgICAgICAgICAgYnl0ZTYgPSAoKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDYpICYgMHhmZikgKiAweDEwMDAwMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGU1ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA1KSAmIDB4ZmYpICogMHgxMDAwMDAwKSxcclxuICAgICAgICAgICAgYnl0ZTQgPSAoKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDQpICYgMHhmZikgKiAweDEwMDAwKSxcclxuICAgICAgICAgICAgYnl0ZTMgPSAoKHRoaXMudmlldy5nZXRVaW50OChwb3NpdGlvbiArIDMpICYgMHhmZikgKiAweDEwMCksXHJcbiAgICAgICAgICAgIGJ5dGUyID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAyKSAmIDB4ZmYpKSxcclxuICAgICAgICAgICAgYmxvY2sgPSBieXRlNiArIGJ5dGU1ICsgYnl0ZTQgKyBieXRlMyArIGJ5dGUyO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gODtcclxuXHJcbiAgICAgICAgLy8gICAgICAgaWYgKGJsb2NrID09IDAgJiYgb2Zmc2V0ID09IDApIHtcclxuICAgICAgICAvLyAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZQb2ludGVyKGJsb2NrLCBvZmZzZXQpO1xyXG4gICAgICAgIC8vICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgVlBvaW50ZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihibG9jaywgb2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlzTGVzc1RoYW4odnApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA8IHZwLmJsb2NrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmJsb2NrID09PSB2cC5ibG9jayAmJiB0aGlzLm9mZnNldCA8IHZwLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNHcmVhdGVyVGhhbih2cCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrID4gdnAuYmxvY2sgfHxcclxuICAgICAgICAgICAgKHRoaXMuYmxvY2sgPT09IHZwLmJsb2NrICYmIHRoaXMub2Zmc2V0ID4gdnAub2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcmludCgpIHtcclxuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMuYmxvY2sgKyBcIjpcIiArIHRoaXMub2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8qKioqKioqanMvYmlnd2lnL2J3VG90YWxTdW1tYXJ5LmpzKioqKioqKioqKioqKlxyXG5cclxuXHJcblxyXG5jbGFzcyBCV1RvdGFsU3VtbWFyeXtcclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKGJ5dGVCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYmFzZXNDb3ZlcmVkID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluVmFsID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhWYWwgPSBieXRlQnVmZmVyLmdldERvdWJsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN1bURhdGEgPSBieXRlQnVmZmVyLmdldERvdWJsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN1bVNxdWFyZXMgPSBieXRlQnVmZmVyLmdldERvdWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlU3RhdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZXNDb3ZlcmVkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5taW5WYWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1heFZhbCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3VtRGF0YSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3VtU3F1YXJlcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWVhbiA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZGV2ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgICBjb21wdXRlU3RhdHMoKSB7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmJhc2VzQ292ZXJlZDtcclxuICAgICAgICBpZiAobiA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tZWFuID0gdGhpcy5zdW1EYXRhIC8gbjtcclxuICAgICAgICAgICAgdGhpcy5zdGRkZXYgPSBNYXRoLnNxcnQodGhpcy5zdW1TcXVhcmVzIC8gKG4gLSAxKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWluID0gdGhpcy5taW5WYWwgPCAwID8gdGhpcy5tZWFuIC0gMiAqIHRoaXMuc3RkZGV2IDogMCxcclxuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMubWF4VmFsID4gMCA/IHRoaXMubWVhbiArIDIgKiB0aGlzLnN0ZGRldiA6IDA7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tZWFuICsgMyAqIHRoaXMuc3RkZGV2XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU3RhdHMoc3RhdHMpIHtcclxuXHJcbiAgICAgICAgdGhpcy5iYXNlc0NvdmVyZWQgKz0gc3RhdHMuY291bnQ7XHJcbiAgICAgICAgdGhpcy5zdW1EYXRhICs9IHN0YXR1cy5zdW1EYXRhO1xyXG4gICAgICAgIHRoaXMuc3VtU3F1YXJlcyArPSBzdW1TcXVhcmVzO1xyXG4gICAgICAgIHRoaXMubWluVmFsID0gTUlOKF9taW5WYWwsIG1pbik7XHJcbiAgICAgICAgdGhpcy5tYXhWYWwgPSBNQVgoX21heFZhbCwgbWF4KTtcclxuXHJcbiAgICAgICAgY29tcHV0ZVN0YXRzLmNhbGwodGhpcyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKioqKioqKioqKmpzL2JpZ3dpZy9id0JQVHJlZS5qcyoqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQlBUUkVFX01BR0lDX0xUSCA9IDB4NzhDQThDOTE7XHJcbmNvbnN0IEJQVFJFRV9NQUdJQ19IVEwgPSAweDkxOENDQTc4O1xyXG5jb25zdCBCUFRSRUVfSEVBREVSX1NJWkUgPSAzMjtcclxuXHJcblxyXG4gY2xhc3MgQlBUcmVle1xyXG4gICAgIGNvbnN0cnVjdG9yKGJpbmFyeVBhcnNlciwgc3RhcnRPZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBnZW5vbWUgPSAgbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB7fTtcclxuICAgICAgICB0aGlzLmhlYWRlci5tYWdpYyA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5ibG9ja1NpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIua2V5U2l6ZSA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci52YWxTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLml0ZW1Db3VudCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIucmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICB0aGlzLmRpY3Rpb25hcnkgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgd2FsayB0cmVlIHRvIHBvcHVsYXRlIGRpY3Rpb25hcnlcclxuICAgICAgICByZWFkVHJlZU5vZGUoYmluYXJ5UGFyc2VyLCAtMSwgdGhpcy5oZWFkZXIua2V5U2l6ZSwgdGhpcy5kaWN0aW9uYXJ5KTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gOCArIHRoaXMuaGVhZGVyLmtleVNpemU7XHJcbiAgICAgICAgdmFyIG1pblNpemUgPSA0ICsgaXRlbVNpemU7ICAgLy8gQnl0ZXMgZm9yIGEgbm9kZSB3aXRoIDEgaXRlbVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkVHJlZU5vZGUoYnl0ZUJ1ZmZlciwgb2Zmc2V0LCBrZXlTaXplLCBkaWN0aW9uYXJ5KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IDApIGJ5dGVCdWZmZXIucG9zaXRpb24gPSBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGJ5dGVCdWZmZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICAgICAgcmVzZXJ2ZWQgPSBieXRlQnVmZmVyLmdldEJ5dGUoKSxcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gYnl0ZUJ1ZmZlci5nZXRVU2hvcnQoKSxcclxuICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBjaHJvbUlkLFxyXG4gICAgICAgICAgICAgICAgY2hyb21TaXplLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBidWZmZXJPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0O1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBieXRlQnVmZmVyLmdldEZpeGVkTGVuZ3RoVHJpbW1lZFN0cmluZyhrZXlTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHJvbUlkID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHJvbVNpemUgPSBieXRlQnVmZmVyLmdldEludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihnZW5vbWUpIGtleSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShrZXkpOyAgLy8gVHJhbnNsYXRlIHRvIGNhbm9uaWNhbCBjaHIgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IGNocm9tSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyAvLyBub24tbGVhZlxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGJ5dGVCdWZmZXIuZ2V0Rml4ZWRMZW5ndGhUcmltbWVkU3RyaW5nKGtleVNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0ID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyT2Zmc2V0ID0gY2hpbGRPZmZzZXQgLSBzdGFydE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyT2Zmc2V0ID0gYnl0ZUJ1ZmZlci5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByZWFkVHJlZU5vZGUoYnl0ZUJ1ZmZlciwgYnVmZmVyT2Zmc2V0LCBrZXlTaXplLCBkaWN0aW9uYXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBieXRlQnVmZmVyLnBvc2l0aW9uID0gY3Vyck9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7QldTb3VyY2UsQmluYXJ5UGFyc2VyfTtcclxuXHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBcUhBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBOzs7QUFwSkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFBQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/bigwig.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/simple_browser.js":
/*!******************************************!*\
  !*** .Panel/src/extra/simple_browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.SinglePanelBrowser = exports.BrowserControls = exports.SimpleBrowser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _panel = __webpack_require__(/*! ../panel.js */ \"../MLVPanel/src/panel.js\");\n\nvar _track_dialog = __webpack_require__(/*! ../track_dialog.js */ \"../MLVPanel/src/track_dialog.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BaseBrowser = function () {\n\tfunction BaseBrowser(parent_div, config) {\n\t\t_classCallCheck(this, BaseBrowser);\n\n\t\tthis.div = $(\"#\" + parent_div).css({ \"padding\": \"2px\", \"overflow\": \"hidden\" });\n\t\tthis.listeners = {};\n\t\tthis.width = this.div.width();\n\t\tif (config.tracks_proxy) {\n\t\t\tthis.tracks_proxy = config.tracks_proxy;\n\t\t}\n\t}\n\n\t_createClass(BaseBrowser, [{\n\t\tkey: \"addControls\",\n\t\tvalue: function addControls(control_config) {\n\t\t\tvar div = $(\"<div>\").attr(\"id\", \"mlv-iv-control-panel\").appendTo(this.div);\n\t\t\tthis.control_panel = new BrowserControls(\"mlv-iv-control-panel\", this, control_config);\n\t\t\tvar new_div = $(\"<div>\").css({ \"height\": \"calc(100% - 30px)\", \"width\": \"calc(100% - 5px)\", \"position\": \"absolute\", \"top\": \"30px\" }).appendTo(this.div);\n\t\t\tthis.div = new_div;\n\t\t}\n\t}, {\n\t\tkey: \"addToMenu\",\n\t\tvalue: function addToMenu(element) {\n\t\t\tthis.control_panel.container.append(element);\n\t\t}\n\t}, {\n\t\tkey: \"replaceWithProxy\",\n\t\tvalue: function replaceWithProxy(url) {\n\t\t\tvar tp = this.tracks_proxy;\n\t\t\tif (!tp) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\tfor (var name in tp) {\n\t\t\t\tif (url.includes(name)) {\n\t\t\t\t\treturn url.replace(name, tp[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\t}]);\n\n\treturn BaseBrowser;\n}();\n\nvar SinglePanelBrowser = function (_BaseBrowser) {\n\t_inherits(SinglePanelBrowser, _BaseBrowser);\n\n\tfunction SinglePanelBrowser(parent_div, track_config, config) {\n\t\t_classCallCheck(this, SinglePanelBrowser);\n\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\n\t\tvar _this = _possibleConstructorReturn(this, (SinglePanelBrowser.__proto__ || Object.getPrototypeOf(SinglePanelBrowser)).call(this, parent_div, config));\n\n\t\t_this.panel = new _panel.MLVPanel(track_config, {\n\t\t\tallow_user_zoom: true,\n\t\t\tallow_user_drag: true,\n\t\t\tfixed_height_mode: true,\n\t\t\tallow_user_range_selection: true\n\t\t});\n\t\tif (config.add_controls) {\n\t\t\t_this.addControls({ allowed_track_types: config.allowed_track_types });\n\t\t}\n\n\t\t_this.div.append(_this.panel.getDiv());\n\t\tvar self = _this;\n\t\t$(window).on(\"resize\", function (e) {\n\t\t\tif (!e.target.open) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.setSize();\n\t\t});\n\t\tif (config.add_ruler) {\n\t\t\t_this.panel.addRulerTrack();\n\t\t}\n\t\t_this.panel.addLegend();\n\t\t_this.setSize();\n\n\t\t_this.panel.addListener(\"range_selected\", function (chr, start, end) {\n\t\t\tself.panel.update(chr, start, end);\n\t\t});\n\n\t\treturn _this;\n\t}\n\n\t_createClass(SinglePanelBrowser, [{\n\t\tkey: \"setSize\",\n\t\tvalue: function setSize() {\n\t\t\tthis.panel.setWidth(this.div.width());\n\t\t\tthis.panel.setHeight(this.div.height());\n\t\t\tif (this.panel.chr) {\n\t\t\t\tthis.panel.update();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"zoom\",\n\t\tvalue: function zoom(amount) {\n\t\t\tvar range = this.panel.end - this.panel.start;\n\t\t\tvar middle = this.panel.start + range / 2;\n\t\t\tvar new_range = range / amount;\n\t\t\tvar st = Math.round(middle - new_range / 2);\n\t\t\tvar en = Math.round(middle + new_range / 2);\n\t\t\tthis.panel.update(this.panel.chr, st, en);\n\t\t}\n\t}, {\n\t\tkey: \"addTrackFromBrowser\",\n\t\tvalue: function addTrackFromBrowser(config, update, pos) {\n\t\t\tconfig.url = this.replaceWithProxy(config.url);\n\t\t\tconfig.allow_user_remove = true;\n\t\t\tthis.panel.addTrack(config);\n\t\t\tif (update) {\n\t\t\t\tthis.panel.repaint(true, true);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"goToPosition\",\n\t\tvalue: function goToPosition(chr, start, end) {\n\t\t\tthis.panel.update(chr, start, end);\n\t\t}\n\t}, {\n\t\tkey: \"getPosition\",\n\t\tvalue: function getPosition() {\n\t\t\treturn {\n\t\t\t\tchr: this.panel.chr,\n\t\t\t\tstart: Math.round(this.panel.start),\n\t\t\t\tend: Math.round(this.panel.end)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"addListener\",\n\t\tvalue: function addListener(type, func) {\n\n\t\t\tthis.panel.addListener(type, func);\n\t\t}\n\t}, {\n\t\tkey: \"setState\",\n\t\tvalue: function setState(state) {\n\t\t\tthis.panel.removeAllTracks();\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = state.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar conf = _step.value;\n\n\t\t\t\t\tthis.panel.addTrack(conf);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state.position) {\n\t\t\t\tthis.panel.update(state.position.chr, state.position.start, state.position.end);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setHighlightedRegion\",\n\t\tvalue: function setHighlightedRegion(chr, start, end) {\n\t\t\tthis.panel.removeHighlightedRegion(\"region_1\");\n\t\t\tif (!chr) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.panel.setHighlightedRegion({ chr: chr, start: start, end: end }, \"region_1\", \"blue\");\n\t\t}\n\t}]);\n\n\treturn SinglePanelBrowser;\n}(BaseBrowser);\n\nvar SimpleBrowser = function (_BaseBrowser2) {\n\t_inherits(SimpleBrowser, _BaseBrowser2);\n\n\t/**\r\n    * Creates a filter panel\r\n    * @param {string } parent_div- The id of the div element to house the browser\r\n    * @param {Object} [config] - config of how the browser is constructed\r\n    * <ul>\r\n    * <li>add_controls - if true then a control bar is added (default false)</li>\r\n    * <li>add_ruler - if true a ruler track will be added (default false)\r\n    * </ul>\r\n    */\n\tfunction SimpleBrowser(parent_div, config) {\n\t\t_classCallCheck(this, SimpleBrowser);\n\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\n\t\tvar _this2 = _possibleConstructorReturn(this, (SimpleBrowser.__proto__ || Object.getPrototypeOf(SimpleBrowser)).call(this, parent_div, config));\n\n\t\tif (config.add_controls) {\n\t\t\t_this2.addControls({ limit_chromosome: config.limit_chromosome, allowed_track_types: config.allowed_track_types });\n\t\t}\n\n\t\t_this2.panels = {};\n\t\t_this2.chr = \"\";\n\t\t_this2.start = 1;\n\t\t_this2.end = 10000;\n\t\tif (config.add_ruler) {\n\t\t\t_this2.addPanel(\"ruler\");\n\t\t}\n\n\t\tvar self = _this2;\n\t\t$(window).on(\"resize\", function (e) {\n\t\t\tif (!e.target.open) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.setWidth();\n\t\t});\n\n\t\t_this2._addHandlers();\n\t\treturn _this2;\n\t}\n\n\t_createClass(SimpleBrowser, [{\n\t\tkey: \"_addHandlers\",\n\t\tvalue: function _addHandlers() {\n\t\t\tvar self = this;\n\t\t\tthis.div.on('mousewheel.zoom  mouse.zoom DOMMouseScroll', function (event) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvar deltaY = event.originalEvent.deltaY;\n\t\t\t\tif (deltaY === undefined) {\n\t\t\t\t\tdeltaY = event.originalEvent.detail;\n\t\t\t\t}\n\t\t\t\tif (self._isLoading() || self.bp_per_pixel < 0.05 && deltaY > 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar canvasCoords = self._translateCoOrds(event.originalEvent);\n\t\t\t\tvar factor = deltaY < 0 ? 2 : 0.5;\n\t\t\t\tvar mbp = self.start + canvasCoords.x * self.bp_per_pixel;\n\t\t\t\tvar new_length = Math.round((self.end - self.start) * factor);\n\t\t\t\tvar new_start = Math.round(mbp - canvasCoords.x / self.width * new_length);\n\t\t\t\tself.goToPosition(self.chr, new_start, new_start + new_length);\n\t\t\t});\n\n\t\t\tthis.div.on(\"mousedown.draghandler\", function (e) {\n\t\t\t\tif (e.shiftKey) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar canvasCoords = self._translateCoOrds(e);\n\t\t\t\tself.isMouseDown = true;\n\t\t\t\tself.start_dragging = true;\n\t\t\t\tself.lastMouseX = canvasCoords.x;\n\t\t\t\tself.mouseDownX = self.lastMouseX;\n\t\t\t}).on(\"mousemove.draghandler\", function (e) {\n\t\t\t\tvar canvasCoords = self._translateCoOrds(e);\n\t\t\t\tif ($._no_drag) {\n\t\t\t\t\tself.is_dragging = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (self.is_dragging || self.start_dragging) {\n\t\t\t\t\tvar diff = canvasCoords.x - self.lastMouseX;\n\t\t\t\t\tif (self._isLoading()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar bp_diff = self.bp_per_pixel * diff;\n\t\t\t\t\tvar start = self.start -= bp_diff;\n\t\t\t\t\tvar end = self.end -= bp_diff;\n\t\t\t\t\tself.goToPosition(self.chr, start, end);\n\n\t\t\t\t\tself.lastMouseX = canvasCoords.x;\n\t\t\t\t\tif (self.start_dragging && diff > 30) {\n\t\t\t\t\t\tself.is_dragging = true;\n\t\t\t\t\t\tself.start_dragging = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).on(\"mouseup.draghandler\", function (e) {\n\t\t\t\tself.is_dragging = false;\n\t\t\t\tself.start_dragging = false;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"_translateCoOrds\",\n\t\tvalue: function _translateCoOrds(e) {\n\t\t\tvar x = e.pageX - this.div.offset().left;\n\t\t\tvar y = e.pageY - this.div.offset().top;\n\t\t\treturn { x: x, y: y };\n\t\t}\n\t}, {\n\t\tkey: \"_isLoading\",\n\t\tvalue: function _isLoading() {\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tif (this.panels[p_id].loading) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"setHighlightedRegion\",\n\t\tvalue: function setHighlightedRegion(location, name, color) {\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tif (id === \"ruler\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.panels[id].setHighlightedRegion(location, name, color);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removeHighlightedRegion\",\n\t\tvalue: function removeHighlightedRegion(name) {\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tthis.panels[id].removeHighlightedRegion(name);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getState\",\n\t\tvalue: function getState() {\n\t\t\tvar state = [];\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tvar p = this.panels[id];\n\t\t\t\tdelete p.pan_config.update;\n\t\t\t\tstate.push({\n\t\t\t\t\tconfig: p.getAllTrackConfigs(),\n\t\t\t\t\tpan_config: p.pan_config,\n\t\t\t\t\ttop: p.getDiv().css(\"top\").replace(\"px\", \"\"),\n\t\t\t\t\theight: p.getDiv().css(\"height\").replace(\"px\", \"\"),\n\t\t\t\t\tid: id\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t}, {\n\t\tkey: \"removePanel\",\n\t\tvalue: function removePanel(id) {\n\t\t\tvar pan = this.panels[id];\n\t\t\tpan.getDiv().remove();\n\t\t\tdelete this.panels[id];\n\t\t}\n\t}, {\n\t\tkey: \"setState\",\n\t\tvalue: function setState(state) {\n\t\t\tvar ids = Object.keys(this.panels);\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar id = _step2.value;\n\n\t\t\t\t\tthis.removePanel(id);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = state[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar item = _step3.value;\n\n\t\t\t\t\tthis.addPanel(item.id, item.config, item.top, item.height, item.pan_config);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n     * Adds a panel to the browser Creates a filter panel\r\n     * @param {string } id - The id of track \r\n     * @param {Object[]} track_config - The config describing the tracks in the panel\r\n     * @param {number} top - The position of the top of the panel(in pixels)\r\n     * @param {number} height- The height of the panel (in pixels)\r\n     */\n\n\t}, {\n\t\tkey: \"addPanel\",\n\t\tvalue: function addPanel(id, track_config, top, height, pan_config) {\n\t\t\tvar ruler = false;\n\t\t\tif (id === \"ruler\") {\n\t\t\t\ttrack_config = [];\n\t\t\t\truler = true;\n\t\t\t\ttop = 5;\n\t\t\t\theight = 40;\n\t\t\t}\n\t\t\tvar self = this;\n\t\t\tif (!pan_config) {\n\t\t\t\tpan_config = {};\n\t\t\t}\n\t\t\tvar panel_config = {\n\t\t\t\theight: height,\n\t\t\t\twidth: this.div.width(),\n\t\t\t\tallow_user_move: \"vertical\",\n\t\t\t\tallow_user_resize: \"vertical\"\n\n\t\t\t};\n\t\t\tif (pan_config.allow_user_close) {\n\t\t\t\tpanel_config.allow_user_close = true;\n\t\t\t}\n\n\t\t\tvar p = new _panel.MLVPanel(track_config, panel_config);\n\n\t\t\tif (pan_config.allow_user_close) {\n\t\t\t\tp.addListener(\"panel_closed\", function () {\n\t\t\t\t\tdelete self.panels[id];\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (ruler) {\n\t\t\t\tp.addRulerTrack();\n\t\t\t\tp.allowUserRangeSelection();\n\t\t\t\tp.addListener(\"range_selected\", function (chr, start, end) {\n\t\t\t\t\tself.goToPosition(chr, start, end);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tp.addLegend();\n\t\t\t}\n\t\t\tthis.panels[id] = p;\n\t\t\tp.pan_config = pan_config;\n\t\t\t//set panel position and add it to DOM\n\t\t\tvar div = p.getDiv();\n\t\t\tdiv.css({ top: top + \"px\", left: \"0px\" }).width(this.width);\n\t\t\tif (pan_config.move_to_back) {\n\t\t\t\tthis.div.prepend(div);\n\t\t\t} else {\n\t\t\t\tthis.div.append(div);\n\t\t\t}\n\t\t\tdiv.draggable(\"option\", \"containment\", \"parent\");\n\t\t\t$(\".track-handle\").removeClass(\"fa-arrows-alt-v\").addClass(\"fa-arrows-alt\");\n\t\t\tif (!ruler) {\n\t\t\t\tdiv.append($(\"<i class='fas fa-arrows-alt-v'></i>\").css({ \"position\": \"absolute\", \"bottom\": \"-5px\", \"right\": \"7px\", \"font-size\": \"12px\", \"opacity\": \"0.8\" }));\n\t\t\t}\n\t\t\tif (pan_config.update) {\n\t\t\t\tp.update(this.chr, this.start, this.end);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_positionChanged\",\n\t\tvalue: function _positionChanged(chr, start, end) {\n\t\t\tthis.chr = chr;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.bp_per_pixel = (this.end - this.start) / this.width;\n\t\t\tvar callback = this.listeners['view_changed'];\n\t\t\tif (callback) {\n\t\t\t\tcallback(chr + \":\" + Math.round(start) + \"-\" + Math.round(end));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getPosition\",\n\t\tvalue: function getPosition() {\n\t\t\treturn {\n\t\t\t\tchr: this.chr,\n\t\t\t\tstart: Math.round(this.start),\n\t\t\t\tend: Math.round(this.end)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"setWidth\",\n\t\tvalue: function setWidth() {\n\t\t\tthis.width = this.div.width();\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tthis.panels[p_id].setWidth(this.width);\n\t\t\t\tthis.panels[p_id].update();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"zoom\",\n\t\tvalue: function zoom(amount) {\n\t\t\tvar range = this.end - this.start;\n\t\t\tvar middle = this.start + range / 2;\n\t\t\tvar new_range = range / amount;\n\t\t\tvar st = Math.round(middle - new_range / 2);\n\t\t\tvar en = Math.round(middle + new_range / 2);\n\t\t\tthis.goToPosition(this.chr, st, en);\n\t\t}\n\n\t\t/**\r\n     * Displays the specified genomic location\r\n     * @param {string } chr - chromosome \r\n     * @param {number} start - The start of the genomic location\r\n     * @param {number} end - The end of the genomic location\r\n     */\n\n\t}, {\n\t\tkey: \"goToPosition\",\n\t\tvalue: function goToPosition(chr, start, end) {\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tthis.panels[p_id].update(chr, start, end);\n\t\t\t}\n\t\t\tthis._positionChanged(chr, start, end);\n\t\t}\n\t}, {\n\t\tkey: \"addListener\",\n\t\tvalue: function addListener(type, func) {\n\t\t\tthis.listeners[type] = func;\n\t\t}\n\t}, {\n\t\tkey: \"addTrackFromBrowser\",\n\t\tvalue: function addTrackFromBrowser(config, update) {\n\t\t\tconfig.url = this.replaceWithProxy(config.url);\n\t\t\tvar id = \"pan_\" + this.pan_id++;\n\t\t\tthis.addPanel(id, [config], 0, 200, { allow_user_close: true, move_to_back: true, update: update });\n\t\t}\n\t}]);\n\n\treturn SimpleBrowser;\n}(BaseBrowser);\n\nvar BrowserControls = function () {\n\tfunction BrowserControls(element_id, browser, config) {\n\t\tvar _this3 = this;\n\n\t\t_classCallCheck(this, BrowserControls);\n\n\t\tthis.browser = browser;\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\t\tthis.limit_chromosome = false;\n\t\tif (config.limit_chromosome) {\n\t\t\tthis.limit_chromosome = limit_chromosome;\n\t\t}\n\t\tthis.pan_id = 1;\n\t\tthis.container = $(\"#\" + element_id).css({ \"padding-left\": \"20px\" }).addClass(\"browser-menu-panel\");\n\t\tthis.container.append(\"<label>zoom</label>\");\n\t\tthis.zoom_level_input = $(\"<input>\").val(\"2\").width(15).appendTo(this.container);\n\t\tthis.zoom_level_input.spinner({ step: 1 });\n\t\tvar self = this;\n\t\tthis.zoom_in = $(\"<i>\").attr(\"class\", \"fa fa-search-plus mlv-click-icon \").appendTo(this.container).click(function () {\n\t\t\t_this3.browser.zoom(_this3.zoom_level_input.val());\n\t\t});\n\t\tthis.zoom_out = $(\"<i>\").attr(\"class\", \"fa fa-search-minus mlv-click-icon \").appendTo(this.container).click(function () {\n\t\t\t_this3.browser.zoom(1 / _this3.zoom_level_input.val());\n\t\t});\n\t\tvar l_l = this.limit_chromosome ? this.limit_chromosome : \"Location\";\n\n\t\tthis.container.append($(\"<label>\").text(l_l).css({ \"margin-left\": \"10px\" }));\n\t\tthis.location_input = $(\"<input>\").css(\"width\", \"200px\").appendTo(this.container).keypress(function (e) {\n\t\t\tif (e.keyCode === 13) {\n\t\t\t\tvar loc = self.calculatePosition($(this).val());\n\t\t\t\tself.browser.goToPosition(loc.chr, loc.start, loc.end);\n\t\t\t}\n\t\t});\n\n\t\tvar add_track = $(\"<button>\").html(\"<i class = 'fa fa-plus'></i>Add Track\").attr(\"class\", \"btn btn-sm btn-secondary\").css(\"margin-left\", \"3px\").click(function (e) {\n\t\t\tnew _track_dialog.AddTrackDialog(function (config) {\n\t\t\t\tself.browser.addTrackFromBrowser(config, true);\n\t\t\t}, { allowed_track_types: config.allowed_track_types });\n\t\t}).appendTo(this.container);\n\t\tthis.browser.addListener(\"view_changed\", function (location, start, end) {\n\t\t\tif (self.limit_chromosome) {\n\t\t\t\tlocation = location.split(\":\")[1];\n\t\t\t}\n\t\t\tif (start) {\n\t\t\t\tlocation = location + \":\" + start + \"-\" + end;\n\t\t\t}\n\t\t\tself.location_input.val(location);\n\t\t});\n\t}\n\n\t_createClass(BrowserControls, [{\n\t\tkey: \"calculatePosition\",\n\t\tvalue: function calculatePosition(text) {\n\t\t\ttext = text.replace(/,/g, \"\");\n\n\t\t\tvar arr = text.split(\":\");\n\t\t\tvar chr = null;\n\t\t\tvar pos = null;\n\t\t\tif (arr.length === 1) {\n\t\t\t\tchr = this.browser.getPosition().chr;\n\t\t\t\tpos = arr[0];\n\t\t\t} else {\n\t\t\t\tchr = arr[0];\n\t\t\t\tpos = arr[1];\n\t\t\t}\n\t\t\tvar arr2 = pos.split(\"-\");\n\t\t\treturn { chr: chr, start: parseInt(arr2[0]), end: parseInt(arr2[1]) };\n\t\t}\n\t}]);\n\n\treturn BrowserControls;\n}();\n\nexports.SimpleBrowser = SimpleBrowser;\nexports.BrowserControls = BrowserControls;\nexports.SinglePanelBrowser = SinglePanelBrowser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3NpbXBsZV9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9leHRyYS9zaW1wbGVfYnJvd3Nlci5qcz8wNzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWUGFuZWx9IGZyb20gXCIuLi9wYW5lbC5qc1wiO1xyXG5pbXBvcnQge0FkZFRyYWNrRGlhbG9nfSBmcm9tIFwiLi4vdHJhY2tfZGlhbG9nLmpzXCI7XHJcblxyXG5jbGFzcyBCYXNlQnJvd3NlcntcclxuXHJcblx0Y29uc3RydWN0b3IocGFyZW50X2Rpdixjb25maWcpe1xyXG5cdFx0dGhpcy5kaXYgPSAkKFwiI1wiK3BhcmVudF9kaXYpLmNzcyh7XCJwYWRkaW5nXCI6XCIycHhcIixcIm92ZXJmbG93XCI6XCJoaWRkZW5cIn0pO1xyXG5cdFx0dGhpcy5saXN0ZW5lcnM9IHt9O1xyXG5cdFx0dGhpcy53aWR0aD10aGlzLmRpdi53aWR0aCgpO1xyXG5cdFx0aWYgKGNvbmZpZy50cmFja3NfcHJveHkpe1xyXG5cdFx0XHR0aGlzLnRyYWNrc19wcm94eT1jb25maWcudHJhY2tzX3Byb3h5O1xyXG5cdFx0fVxyXG5cdFxyXG5cdH1cclxuXHJcblx0YWRkQ29udHJvbHMoY29udHJvbF9jb25maWcpe1xyXG5cdFx0bGV0IGRpdiA9JChcIjxkaXY+XCIpLmF0dHIoXCJpZFwiLFwibWx2LWl2LWNvbnRyb2wtcGFuZWxcIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5jb250cm9sX3BhbmVsID0gbmV3IEJyb3dzZXJDb250cm9scyhcIm1sdi1pdi1jb250cm9sLXBhbmVsXCIsdGhpcyxjb250cm9sX2NvbmZpZyk7XHJcblx0XHRsZXQgbmV3X2Rpdj0kKFwiPGRpdj5cIikuY3NzKHtcImhlaWdodFwiOlwiY2FsYygxMDAlIC0gMzBweClcIixcIndpZHRoXCI6XCJjYWxjKDEwMCUgLSA1cHgpXCIsXCJwb3NpdGlvblwiOlwiYWJzb2x1dGVcIixcInRvcFwiOlwiMzBweFwifSkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5kaXY9bmV3X2RpdjtcclxuXHR9XHJcblxyXG5cdGFkZFRvTWVudShlbGVtZW50KXtcclxuXHRcdHRoaXMuY29udHJvbF9wYW5lbC5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xyXG5cdH1cclxuXHJcblx0cmVwbGFjZVdpdGhQcm94eSh1cmwpe1xyXG5cdFx0bGV0IHRwID0gdGhpcy50cmFja3NfcHJveHk7XHJcblx0XHRpZiAoIXRwKXtcclxuXHRcdFx0cmV0dXJuIHVybDtcclxuXHRcdH1cclxuXHRcclxuXHRcdGZvciAobGV0IG5hbWUgaW4gdHApe1xyXG5cdFx0XHRpZiAodXJsLmluY2x1ZGVzKG5hbWUpKXtcclxuXHRcdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UobmFtZSx0cFtuYW1lXSlcclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdXJsO1x0XHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxufVxyXG5cclxuY2xhc3MgU2luZ2xlUGFuZWxCcm93c2VyIGV4dGVuZHMgQmFzZUJyb3dzZXJ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBhcmVudF9kaXYsdHJhY2tfY29uZmlnLGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHJcblx0XHRzdXBlcihwYXJlbnRfZGl2LGNvbmZpZyk7XHJcblxyXG5cdFx0dGhpcy5wYW5lbCA9IG5ldyBNTFZQYW5lbChcclxuXHRcdFx0dHJhY2tfY29uZmlnLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YWxsb3dfdXNlcl96b29tOnRydWUsXHJcblx0XHRcdFx0YWxsb3dfdXNlcl9kcmFnOnRydWUsXHJcblx0XHRcdFx0Zml4ZWRfaGVpZ2h0X21vZGU6dHJ1ZSxcclxuXHRcdFx0XHRhbGxvd191c2VyX3JhbmdlX3NlbGVjdGlvbjp0cnVlXHJcblx0XHRcdH1cclxuXHJcblx0XHQpXHJcblx0XHRpZiAoY29uZmlnLmFkZF9jb250cm9scyl7XHJcblx0XHRcdHRoaXMuYWRkQ29udHJvbHMoe2FsbG93ZWRfdHJhY2tfdHlwZXM6Y29uZmlnLmFsbG93ZWRfdHJhY2tfdHlwZXN9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRpdi5hcHBlbmQodGhpcy5wYW5lbC5nZXREaXYoKSk7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHQkKHdpbmRvdykub24oXCJyZXNpemVcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKCFlLnRhcmdldC5vcGVuKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5zZXRTaXplKCk7XHJcblx0XHR9KTtcclxuXHRcdGlmIChjb25maWcuYWRkX3J1bGVyKXtcclxuXHRcdFx0dGhpcy5wYW5lbC5hZGRSdWxlclRyYWNrKClcclxuXHRcdH1cclxuXHRcdHRoaXMucGFuZWwuYWRkTGVnZW5kKCk7XHJcblx0XHR0aGlzLnNldFNpemUoKTtcclxuXHJcblx0XHR0aGlzLnBhbmVsLmFkZExpc3RlbmVyKFwicmFuZ2Vfc2VsZWN0ZWRcIixmdW5jdGlvbihjaHIsc3RhcnQsZW5kKXtcclxuXHRcdFx0c2VsZi5wYW5lbC51cGRhdGUoY2hyLHN0YXJ0LGVuZCk7XHJcblx0XHR9KVxyXG5cdFxyXG5cclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cclxuXHRzZXRTaXplKCl7XHJcblx0XHR0aGlzLnBhbmVsLnNldFdpZHRoKHRoaXMuZGl2LndpZHRoKCkpO1xyXG5cdFx0dGhpcy5wYW5lbC5zZXRIZWlnaHQodGhpcy5kaXYuaGVpZ2h0KCkpO1xyXG5cdFx0aWYgKHRoaXMucGFuZWwuY2hyKXtcclxuXHRcdFx0dGhpcy5wYW5lbC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHpvb20oYW1vdW50KXtcclxuXHRcdGxldCByYW5nZSA9IHRoaXMucGFuZWwuZW5kLXRoaXMucGFuZWwuc3RhcnQ7XHJcblx0XHRsZXQgbWlkZGxlID10aGlzLnBhbmVsLnN0YXJ0K3JhbmdlLzI7XHJcblx0XHRsZXQgbmV3X3JhbmdlID0ocmFuZ2UvYW1vdW50KTtcclxuXHRcdGxldCBzdCA9IE1hdGgucm91bmQobWlkZGxlLW5ld19yYW5nZS8yKTtcclxuXHRcdGxldCBlbiA9IE1hdGgucm91bmQobWlkZGxlK25ld19yYW5nZS8yKTtcclxuXHRcdHRoaXMucGFuZWwudXBkYXRlKHRoaXMucGFuZWwuY2hyLHN0LGVuKTtcclxuXHR9XHJcblxyXG5cdGFkZFRyYWNrRnJvbUJyb3dzZXIoY29uZmlnLHVwZGF0ZSxwb3Mpe1xyXG5cdFx0Y29uZmlnLnVybCA9IHRoaXMucmVwbGFjZVdpdGhQcm94eShjb25maWcudXJsKTtcclxuXHRcdGNvbmZpZy5hbGxvd191c2VyX3JlbW92ZT10cnVlO1xyXG5cdFx0dGhpcy5wYW5lbC5hZGRUcmFjayhjb25maWcpO1xyXG5cdFx0aWYgKHVwZGF0ZSl7XHJcblx0XHRcdHRoaXMucGFuZWwucmVwYWludCh0cnVlLHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z29Ub1Bvc2l0aW9uKGNocixzdGFydCxlbmQpe1xyXG5cdFx0dGhpcy5wYW5lbC51cGRhdGUoY2hyLHN0YXJ0LGVuZCk7XHJcblx0fVxyXG5cclxuXHRnZXRQb3NpdGlvbigpe1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjaHI6dGhpcy5wYW5lbC5jaHIsXHJcblx0XHRcdFx0c3RhcnQ6TWF0aC5yb3VuZCh0aGlzLnBhbmVsLnN0YXJ0KSxcclxuXHRcdFx0XHRlbmQ6TWF0aC5yb3VuZCh0aGlzLnBhbmVsLmVuZClcclxuXHRcdFx0fTtcclxuXHR9XHJcblxyXG5cdGFkZExpc3RlbmVyKHR5cGUsZnVuYyl7XHJcblxyXG5cdFx0dGhpcy5wYW5lbC5hZGRMaXN0ZW5lcih0eXBlLGZ1bmMpO1xyXG5cdH1cclxuXHJcblx0c2V0U3RhdGUoc3RhdGUpe1xyXG5cdFx0dGhpcy5wYW5lbC5yZW1vdmVBbGxUcmFja3MoKTtcclxuXHRcdGZvciAobGV0IGNvbmYgb2Ygc3RhdGUuc3RhdGUpe1xyXG5cdFx0XHR0aGlzLnBhbmVsLmFkZFRyYWNrKGNvbmYpO1xyXG5cdFx0fVxyXG4gICAgICAgICAgIGlmIChzdGF0ZS5wb3NpdGlvbil7XHJcblx0XHQgICAgIHRoaXMucGFuZWwudXBkYXRlKHN0YXRlLnBvc2l0aW9uLmNocixzdGF0ZS5wb3NpdGlvbi5zdGFydCxzdGF0ZS5wb3NpdGlvbi5lbmQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2V0SGlnaGxpZ2h0ZWRSZWdpb24oY2hyLHN0YXJ0LGVuZCl7XHJcblx0XHR0aGlzLnBhbmVsLnJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKFwicmVnaW9uXzFcIik7XHJcblx0XHRpZiAoIWNocil7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMucGFuZWwuc2V0SGlnaGxpZ2h0ZWRSZWdpb24oXHJcblx0XHRcdHtjaHI6Y2hyLHN0YXJ0OnN0YXJ0LGVuZDplbmR9LFxyXG5cdFx0XHRcInJlZ2lvbl8xXCIsXHJcblx0XHRcdFwiYmx1ZVwiXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5jbGFzcyBTaW1wbGVCcm93c2VyIGV4dGVuZHMgQmFzZUJyb3dzZXJ7XHJcblx0IC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBwYW5lbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfSBwYXJlbnRfZGl2LSBUaGUgaWQgb2YgdGhlIGRpdiBlbGVtZW50IHRvIGhvdXNlIHRoZSBicm93c2VyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gLSBjb25maWcgb2YgaG93IHRoZSBicm93c2VyIGlzIGNvbnN0cnVjdGVkXHJcbiAgICAgKiA8dWw+XHJcbiAgICAgKiA8bGk+YWRkX2NvbnRyb2xzIC0gaWYgdHJ1ZSB0aGVuIGEgY29udHJvbCBiYXIgaXMgYWRkZWQgKGRlZmF1bHQgZmFsc2UpPC9saT5cclxuICAgICAqIDxsaT5hZGRfcnVsZXIgLSBpZiB0cnVlIGEgcnVsZXIgdHJhY2sgd2lsbCBiZSBhZGRlZCAoZGVmYXVsdCBmYWxzZSlcclxuICAgICAqIDwvdWw+XHJcbiAgICAgKi9cclxuXHRjb25zdHJ1Y3RvcihwYXJlbnRfZGl2LGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHJcblx0XHRzdXBlcihwYXJlbnRfZGl2LGNvbmZpZyk7XHJcblx0XHJcblx0XHRpZiAoY29uZmlnLmFkZF9jb250cm9scyl7XHJcblx0XHRcdHRoaXMuYWRkQ29udHJvbHMoe2xpbWl0X2Nocm9tb3NvbWU6Y29uZmlnLmxpbWl0X2Nocm9tb3NvbWUsYWxsb3dlZF90cmFja190eXBlczpjb25maWcuYWxsb3dlZF90cmFja190eXBlc30pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRcclxuXHRcdHRoaXMucGFuZWxzPXt9O1xyXG5cdFx0dGhpcy5jaHI9XCJcIjtcclxuXHRcdHRoaXMuc3RhcnQ9MTtcclxuXHRcdHRoaXMuZW5kPTEwMDAwO1xyXG5cdFx0aWYgKGNvbmZpZy5hZGRfcnVsZXIpe1xyXG5cdFx0XHR0aGlzLmFkZFBhbmVsKFwicnVsZXJcIik7XHJcblx0XHR9XHJcblx0XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHQkKHdpbmRvdykub24oXCJyZXNpemVcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKCFlLnRhcmdldC5vcGVuKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5zZXRXaWR0aCgpO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdHRoaXMuX2FkZEhhbmRsZXJzKCk7XHRcclxuXHR9XHJcblx0XHJcblx0X2FkZEhhbmRsZXJzKCl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLmRpdi5vbignbW91c2V3aGVlbC56b29tICBtb3VzZS56b29tIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdGxldCBkZWx0YVk9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFZO1xyXG5cdFx0XHRpZiAoZGVsdGFZID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRcdGRlbHRhWT1ldmVudC5vcmlnaW5hbEV2ZW50LmRldGFpbFxyXG5cdFx0XHR9XHJcbiAgICBcdCBcdGlmIChzZWxmLl9pc0xvYWRpbmcoKSB8fCAoc2VsZi5icF9wZXJfcGl4ZWw8MC4wNSAmJiBkZWx0YVk+MCkpe1xyXG4gICAgXHQgXHRcdHJldHVybjtcclxuICAgIFx0IFx0fVxyXG4gICAgXHQgXHRsZXQgY2FudmFzQ29vcmRzID0gc2VsZi5fdHJhbnNsYXRlQ29PcmRzKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZmFjdG9yID0gZGVsdGFZPDA/MjowLjU7XHJcbiAgICAgICAgICAgIGxldCBtYnA9IChzZWxmLnN0YXJ0KyBjYW52YXNDb29yZHMueCAqIHNlbGYuYnBfcGVyX3BpeGVsKVxyXG4gICAgICAgICAgICBsZXQgbmV3X2xlbmd0aCA9IE1hdGgucm91bmQoKHNlbGYuZW5kLXNlbGYuc3RhcnQpKmZhY3Rvcik7XHJcbiAgICAgICAgICAgIGxldCBuZXdfc3RhcnQgPSBNYXRoLnJvdW5kKG1icC0oKGNhbnZhc0Nvb3Jkcy54L3NlbGYud2lkdGgpKm5ld19sZW5ndGgpKTtcclxuICAgICAgICAgICAgc2VsZi5nb1RvUG9zaXRpb24oc2VsZi5jaHIsbmV3X3N0YXJ0LG5ld19zdGFydCtuZXdfbGVuZ3RoKVxyXG4gICAgICAgICB9KTtcclxuXHRcdFxyXG5cdFx0IHRoaXMuZGl2Lm9uKFwibW91c2Vkb3duLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgXHQgXHRpZiAoZS5zaGlmdEtleSl7XHJcblx0ICAgIFx0IFx0XHRyZXR1cm47XHJcblx0ICAgIFx0IFx0fVxyXG5cdCAgICAgICAgICAgIHZhciBjYW52YXNDb29yZHMgPXNlbGYuX3RyYW5zbGF0ZUNvT3JkcyhlKTtcclxuXHQgICAgICAgICAgICBzZWxmLmlzTW91c2VEb3duID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBzZWxmLnN0YXJ0X2RyYWdnaW5nPXRydWU7XHJcblx0ICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYID0gY2FudmFzQ29vcmRzLng7XHJcblx0ICAgICAgICAgICAgc2VsZi5tb3VzZURvd25YID0gc2VsZi5sYXN0TW91c2VYO1xyXG5cclxuXHQgICAgICAgIH0pXHJcblx0ICAgICAgIFx0Lm9uKFwibW91c2Vtb3ZlLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgY2FudmFzQ29vcmRzID1zZWxmLl90cmFuc2xhdGVDb09yZHMoZSk7XHJcblx0ICAgICAgICAgICAgaWYgKCQuX25vX2RyYWcpe1xyXG5cdCAgICAgICAgICAgIFx0c2VsZi5pc19kcmFnZ2luZz1mYWxzZTtcclxuXHQgICAgICAgICAgICBcdHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfZHJhZ2dpbmcgfHwgc2VsZi5zdGFydF9kcmFnZ2luZyl7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2FudmFzQ29vcmRzLngtc2VsZi5sYXN0TW91c2VYO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc2VsZi5faXNMb2FkaW5nKCkpe1xyXG5cdCAgICAgICAgICAgICAgICBcdHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgYnBfZGlmZj1zZWxmLmJwX3Blcl9waXhlbCpkaWZmO1xyXG5cdCAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPXNlbGYuc3RhcnQtPWJwX2RpZmY7XHJcblx0ICAgICAgICAgICAgICAgIGxldCBlbmQgPXNlbGYuZW5kLT1icF9kaWZmO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLmdvVG9Qb3NpdGlvbihzZWxmLmNocixzdGFydCxlbmQpO1xyXG5cdCAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYPWNhbnZhc0Nvb3Jkcy54O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdGFydF9kcmFnZ2luZyAmJiBkaWZmPjMwKXtcclxuXHQgICAgICAgICAgICAgICAgXHRzZWxmLmlzX2RyYWdnaW5nPXRydWU7XHJcblx0ICAgICAgICAgICAgICAgIFx0c2VsZi5zdGFydF9kcmFnZ2luZz1mYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0pXHJcblx0ICAgICAgICAub24oXCJtb3VzZXVwLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHsgICBcclxuXHQgICAgICAgICAgICAgIHNlbGYuaXNfZHJhZ2dpbmc9ZmFsc2U7XHJcblx0ICAgICAgICAgICAgICBzZWxmLnN0YXJ0X2RyYWdnaW5nPWZhbHNlO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgIFxyXG5cdH1cclxuXHRcclxuXHRfdHJhbnNsYXRlQ29PcmRzKGUpe1xyXG5cdFx0ICBsZXQgeCA9IGUucGFnZVggLSB0aGlzLmRpdi5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgbGV0IHkgPSBlLnBhZ2VZIC0gdGhpcy5kaXYub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgcmV0dXJuIHt4LHl9O1xyXG5cdH1cclxuXHRcclxuXHRfaXNMb2FkaW5nKCl7XHJcblx0XHRmb3IgKGxldCBwX2lkIGluIHRoaXMucGFuZWxzKXtcdFx0XHJcblx0XHRcdGlmICh0aGlzLnBhbmVsc1twX2lkXS5sb2FkaW5nKXtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0c2V0SGlnaGxpZ2h0ZWRSZWdpb24obG9jYXRpb24sbmFtZSxjb2xvcil7XHJcblx0XHRmb3IgKGxldCBpZCBpbiB0aGlzLnBhbmVscyl7XHJcblx0XHRcdGlmIChpZCA9PT0gXCJydWxlclwiKXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBhbmVsc1tpZF0uc2V0SGlnaGxpZ2h0ZWRSZWdpb24obG9jYXRpb24sbmFtZSxjb2xvcik7XHJcblx0XHRcdFxyXG5cclxuXHJcblx0XHR9XHJcblx0fVxyXG5cdHJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKG5hbWUpe1xyXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHR0aGlzLnBhbmVsc1tpZF0ucmVtb3ZlSGlnaGxpZ2h0ZWRSZWdpb24obmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGdldFN0YXRlKCl7XHJcblx0XHRsZXQgc3RhdGUgPVtdO1xyXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHRsZXQgcCA9IHRoaXMucGFuZWxzW2lkXTtcclxuXHRcdFx0ZGVsZXRlIHAucGFuX2NvbmZpZy51cGRhdGU7XHJcblx0XHRcdHN0YXRlLnB1c2goe1xyXG5cdFx0XHRcdGNvbmZpZzpwLmdldEFsbFRyYWNrQ29uZmlncygpLFxyXG5cdFx0XHRcdHBhbl9jb25maWc6cC5wYW5fY29uZmlnLFxyXG5cdFx0XHRcdHRvcDpwLmdldERpdigpLmNzcyhcInRvcFwiKS5yZXBsYWNlKFwicHhcIixcIlwiKSxcclxuXHRcdFx0XHRoZWlnaHQ6cC5nZXREaXYoKS5jc3MoXCJoZWlnaHRcIikucmVwbGFjZShcInB4XCIsXCJcIiksXHJcblx0XHRcdFx0aWQ6aWRcclxuXHRcdFx0fSlcclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RhdGU7XHJcblx0fVxyXG5cclxuXHRyZW1vdmVQYW5lbChpZCl7XHJcblx0XHRsZXQgcGFuID0gdGhpcy5wYW5lbHNbaWRdO1xyXG5cdFx0cGFuLmdldERpdigpLnJlbW92ZSgpO1xyXG5cdFx0ZGVsZXRlIHRoaXMucGFuZWxzW2lkXTtcclxuXHR9XHJcblxyXG5cdHNldFN0YXRlKHN0YXRlKXtcclxuXHRcdGxldCBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLnBhbmVscyk7XHJcblx0XHRmb3IgKGxldCBpZCBvZiBpZHMpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBhbmVsKGlkKTtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGl0ZW0gb2Ygc3RhdGUpe1xyXG5cdFx0XHR0aGlzLmFkZFBhbmVsKGl0ZW0uaWQsaXRlbS5jb25maWcsaXRlbS50b3AsaXRlbS5oZWlnaHQsaXRlbS5wYW5fY29uZmlnKVxyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHJcblx0IC8qKlxyXG4gICAgICogQWRkcyBhIHBhbmVsIHRvIHRoZSBicm93c2VyIENyZWF0ZXMgYSBmaWx0ZXIgcGFuZWxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIH0gaWQgLSBUaGUgaWQgb2YgdHJhY2sgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB0cmFja19jb25maWcgLSBUaGUgY29uZmlnIGRlc2NyaWJpbmcgdGhlIHRyYWNrcyBpbiB0aGUgcGFuZWxcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgcGFuZWwoaW4gcGl4ZWxzKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodC0gVGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgKGluIHBpeGVscylcclxuICAgICAqL1xyXG5cdGFkZFBhbmVsKGlkLHRyYWNrX2NvbmZpZyx0b3AsaGVpZ2h0LHBhbl9jb25maWcpe1xyXG5cdFx0bGV0IHJ1bGVyPWZhbHNlO1xyXG5cdFx0aWYgKGlkPT09XCJydWxlclwiKXtcclxuICAgIFx0XHR0cmFja19jb25maWc9W107XHJcbiAgICBcdFx0cnVsZXI9dHJ1ZTtcclxuICAgIFx0XHR0b3A9NTtcclxuICAgIFx0XHRoZWlnaHQ9NDA7XHJcbiAgICBcdH1cclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGlmICghcGFuX2NvbmZpZyl7XHJcblx0XHRcdHBhbl9jb25maWc9e307XHJcblx0XHR9XHJcbiAgICBcdGxldCBwYW5lbF9jb25maWc9e1xyXG5cdFx0XHRoZWlnaHQ6aGVpZ2h0LFxyXG5cdFx0XHR3aWR0aDp0aGlzLmRpdi53aWR0aCgpLFxyXG5cdFx0XHRhbGxvd191c2VyX21vdmU6XCJ2ZXJ0aWNhbFwiLFxyXG5cdFx0XHRhbGxvd191c2VyX3Jlc2l6ZTpcInZlcnRpY2FsXCIsXHJcblxyXG4gICAgXHR9XHJcbiAgICBcdGlmIChwYW5fY29uZmlnLmFsbG93X3VzZXJfY2xvc2Upe1xyXG4gICAgXHRcdHBhbmVsX2NvbmZpZy5hbGxvd191c2VyX2Nsb3NlPXRydWU7XHJcbiAgICBcdH1cclxuXHJcbiAgICBcdFxyXG4gICAgXHRcclxuICAgIFx0bGV0IHAgPSBuZXcgTUxWUGFuZWwodHJhY2tfY29uZmlnLHBhbmVsX2NvbmZpZyk7XHJcblxyXG4gICAgXHRpZiAocGFuX2NvbmZpZy5hbGxvd191c2VyX2Nsb3NlKXtcclxuICAgIFx0XHRwLmFkZExpc3RlbmVyKFwicGFuZWxfY2xvc2VkXCIsZnVuY3Rpb24oKXtcclxuICAgIFx0XHRcdGRlbGV0ZSBzZWxmLnBhbmVsc1tpZF1cclxuICAgIFx0XHR9KVxyXG4gICAgXHR9XHJcbiAgICBcdGlmIChydWxlcil7XHJcbiAgICBcdFx0cC5hZGRSdWxlclRyYWNrKCk7XHJcbiAgICBcdFx0cC5hbGxvd1VzZXJSYW5nZVNlbGVjdGlvbigpO1xyXG4gICAgXHRcdHAuYWRkTGlzdGVuZXIoXCJyYW5nZV9zZWxlY3RlZFwiLGZ1bmN0aW9uKGNocixzdGFydCxlbmQpe1xyXG4gICAgXHRcdFx0c2VsZi5nb1RvUG9zaXRpb24oY2hyLHN0YXJ0LGVuZCk7XHJcbiAgICAgICAgXHR9KTtcclxuICAgIFx0XHRcclxuICAgIFx0fVxyXG4gICAgXHRlbHNle1xyXG4gICAgXHRcdHAuYWRkTGVnZW5kKCk7XHJcbiAgICBcdH1cclxuICAgIFx0dGhpcy5wYW5lbHNbaWRdPXA7XHJcbiAgICBcdHAucGFuX2NvbmZpZz1wYW5fY29uZmlnO1xyXG4gICAgXHQvL3NldCBwYW5lbCBwb3NpdGlvbiBhbmQgYWRkIGl0IHRvIERPTVxyXG4gICAgXHRsZXQgZGl2ID0gcC5nZXREaXYoKTtcclxuICAgIFx0ZGl2LmNzcyh7dG9wOnRvcCtcInB4XCIsbGVmdDpcIjBweFwifSkud2lkdGgodGhpcy53aWR0aCk7XHJcbiAgICBcdGlmIChwYW5fY29uZmlnLm1vdmVfdG9fYmFjayl7XHJcbiAgICBcdFx0dGhpcy5kaXYucHJlcGVuZChkaXYpXHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZXtcclxuICAgIFx0XHR0aGlzLmRpdi5hcHBlbmQoZGl2KTtcclxuICAgIFx0fVxyXG4gICAgXHRkaXYuZHJhZ2dhYmxlKCBcIm9wdGlvblwiLCBcImNvbnRhaW5tZW50XCIsIFwicGFyZW50XCIgKTtcclxuICAgIFx0JChcIi50cmFjay1oYW5kbGVcIikucmVtb3ZlQ2xhc3MoXCJmYS1hcnJvd3MtYWx0LXZcIikuYWRkQ2xhc3MoXCJmYS1hcnJvd3MtYWx0XCIpO1xyXG4gICAgXHRpZiAoIXJ1bGVyKXtcclxuICAgIFx0XHRkaXYuYXBwZW5kKCQoXCI8aSBjbGFzcz0nZmFzIGZhLWFycm93cy1hbHQtdic+PC9pPlwiKS5jc3Moe1wicG9zaXRpb25cIjpcImFic29sdXRlXCIsXCJib3R0b21cIjpcIi01cHhcIixcInJpZ2h0XCI6XCI3cHhcIixcImZvbnQtc2l6ZVwiOlwiMTJweFwiLFwib3BhY2l0eVwiOlwiMC44XCJ9KSk7XHJcbiAgICBcdH1cclxuICAgIFx0aWYgKHBhbl9jb25maWcudXBkYXRlKXtcclxuICAgIFx0XHRwLnVwZGF0ZSh0aGlzLmNocix0aGlzLnN0YXJ0LHRoaXMuZW5kKVxyXG4gICAgXHR9XHJcbiAgICBcdFxyXG4gICAgXHRcclxuXHR9XHJcblxyXG5cclxuXHRcclxuXHRfcG9zaXRpb25DaGFuZ2VkKGNocixzdGFydCxlbmQpe1xyXG5cdFx0dGhpcy5jaHI9Y2hyO1xyXG5cdFx0dGhpcy5zdGFydD1zdGFydDtcclxuXHRcdHRoaXMuZW5kPWVuZDtcclxuXHRcdHRoaXMuYnBfcGVyX3BpeGVsPSh0aGlzLmVuZC10aGlzLnN0YXJ0KS90aGlzLndpZHRoO1xyXG5cdFx0bGV0IGNhbGxiYWNrID0gdGhpcy5saXN0ZW5lcnNbJ3ZpZXdfY2hhbmdlZCddO1xyXG5cdFx0aWYgKGNhbGxiYWNrKXtcclxuXHRcdFx0Y2FsbGJhY2soY2hyK1wiOlwiK01hdGgucm91bmQoc3RhcnQpK1wiLVwiK01hdGgucm91bmQoZW5kKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGdldFBvc2l0aW9uKCl7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNocjp0aGlzLmNocixcclxuXHRcdFx0XHRzdGFydDpNYXRoLnJvdW5kKHRoaXMuc3RhcnQpLFxyXG5cdFx0XHRcdGVuZDpNYXRoLnJvdW5kKHRoaXMuZW5kKVxyXG5cdFx0XHR9O1xyXG5cdH1cclxuXHJcblxyXG5cdHNldFdpZHRoKCl7XHJcblx0XHR0aGlzLndpZHRoID0gdGhpcy5kaXYud2lkdGgoKTtcclxuXHRcdGZvciAobGV0IHBfaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHR0aGlzLnBhbmVsc1twX2lkXS5zZXRXaWR0aCh0aGlzLndpZHRoKTtcclxuXHRcdFx0dGhpcy5wYW5lbHNbcF9pZF0udXBkYXRlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdHpvb20oYW1vdW50KXtcclxuXHRcdGxldCByYW5nZSA9IHRoaXMuZW5kLXRoaXMuc3RhcnQ7XHJcblx0XHRsZXQgbWlkZGxlID10aGlzLnN0YXJ0K3JhbmdlLzI7XHJcblx0XHRsZXQgbmV3X3JhbmdlID0ocmFuZ2UvYW1vdW50KTtcclxuXHRcdGxldCBzdCA9IE1hdGgucm91bmQobWlkZGxlLW5ld19yYW5nZS8yKTtcclxuXHRcdGxldCBlbiA9IE1hdGgucm91bmQobWlkZGxlK25ld19yYW5nZS8yKTtcclxuXHRcdHRoaXMuZ29Ub1Bvc2l0aW9uKHRoaXMuY2hyLHN0LGVuKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgKiBEaXNwbGF5cyB0aGUgc3BlY2lmaWVkIGdlbm9taWMgbG9jYXRpb25cclxuICAgICogQHBhcmFtIHtzdHJpbmcgfSBjaHIgLSBjaHJvbW9zb21lIFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIGdlbm9taWMgbG9jYXRpb25cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIFRoZSBlbmQgb2YgdGhlIGdlbm9taWMgbG9jYXRpb25cclxuICAgICovXHJcblx0Z29Ub1Bvc2l0aW9uKGNocixzdGFydCxlbmQpe1xyXG5cdFx0Zm9yIChsZXQgcF9pZCBpbiB0aGlzLnBhbmVscyl7XHJcblx0XHRcdHRoaXMucGFuZWxzW3BfaWRdLnVwZGF0ZShjaHIsc3RhcnQsZW5kKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChjaHIsc3RhcnQsZW5kKTtcclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHRhZGRMaXN0ZW5lcih0eXBlLGZ1bmMpe1xyXG5cdFx0dGhpcy5saXN0ZW5lcnNbdHlwZV09ZnVuYztcclxuXHR9XHJcblxyXG5cdGFkZFRyYWNrRnJvbUJyb3dzZXIoY29uZmlnLHVwZGF0ZSl7XHJcblx0XHRjb25maWcudXJsID0gdGhpcy5yZXBsYWNlV2l0aFByb3h5KGNvbmZpZy51cmwpO1xyXG5cdFx0bGV0IGlkID1cInBhbl9cIit0aGlzLnBhbl9pZCsrO1xyXG5cdFx0dGhpcy5hZGRQYW5lbChpZCxbY29uZmlnXSwwLDIwMCxcclxuXHRcdFx0e2FsbG93X3VzZXJfY2xvc2U6dHJ1ZSxtb3ZlX3RvX2JhY2s6dHJ1ZSx1cGRhdGU6dXBkYXRlfVxyXG5cdFx0KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQnJvd3NlckNvbnRyb2xze1xyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnRfaWQsYnJvd3Nlcixjb25maWcpe1xyXG5cdFx0dGhpcy5icm93c2VyPWJyb3dzZXI7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGltaXRfY2hyb21vc29tZT1mYWxzZTtcclxuXHRcdGlmIChjb25maWcubGltaXRfY2hyb21vc29tZSl7XHJcblx0XHRcdHRoaXMubGltaXRfY2hyb21vc29tZT1saW1pdF9jaHJvbW9zb21lO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5wYW5faWQ9MTtcclxuXHRcdHRoaXMuY29udGFpbmVyPSQoXCIjXCIrZWxlbWVudF9pZCkuY3NzKHtcInBhZGRpbmctbGVmdFwiOlwiMjBweFwifSkuYWRkQ2xhc3MoXCJicm93c2VyLW1lbnUtcGFuZWxcIik7XHJcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmQoXCI8bGFiZWw+em9vbTwvbGFiZWw+XCIpXHJcblx0XHR0aGlzLnpvb21fbGV2ZWxfaW5wdXQ9JChcIjxpbnB1dD5cIikudmFsKFwiMlwiKS53aWR0aCgxNSkuYXBwZW5kVG8odGhpcy5jb250YWluZXIpO1xyXG5cdFx0dGhpcy56b29tX2xldmVsX2lucHV0LnNwaW5uZXIoe3N0ZXA6MX0pO1xyXG5cdFx0bGV0IHNlbGY9IHRoaXM7XHJcblx0XHR0aGlzLnpvb21faW4gPSAkKFwiPGk+XCIpLmF0dHIoXCJjbGFzc1wiLFwiZmEgZmEtc2VhcmNoLXBsdXMgbWx2LWNsaWNrLWljb24gXCIpXHJcblx0XHQuYXBwZW5kVG8odGhpcy5jb250YWluZXIpXHJcblx0XHQuY2xpY2soKCk9PntcclxuXHRcdFx0dGhpcy5icm93c2VyLnpvb20odGhpcy56b29tX2xldmVsX2lucHV0LnZhbCgpKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy56b29tX291dCA9ICAkKFwiPGk+XCIpLmF0dHIoXCJjbGFzc1wiLFwiZmEgZmEtc2VhcmNoLW1pbnVzIG1sdi1jbGljay1pY29uIFwiKVxyXG5cdFx0LmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKVxyXG5cdFx0LmNsaWNrKCgpPT57XHJcblx0XHRcdHRoaXMuYnJvd3Nlci56b29tKDEvdGhpcy56b29tX2xldmVsX2lucHV0LnZhbCgpKTtcclxuXHRcdH0pO1xyXG5cdFx0bGV0IGxfbD10aGlzLmxpbWl0X2Nocm9tb3NvbWU/dGhpcy5saW1pdF9jaHJvbW9zb21lOlwiTG9jYXRpb25cIjtcclxuXHRcclxuXHJcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmQoJChcIjxsYWJlbD5cIikudGV4dChsX2wpLmNzcyh7XCJtYXJnaW4tbGVmdFwiOlwiMTBweFwifSkpXHJcblx0XHR0aGlzLmxvY2F0aW9uX2lucHV0PSQoXCI8aW5wdXQ+XCIpLmNzcyhcIndpZHRoXCIsXCIyMDBweFwiKVxyXG5cdFx0LmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKVxyXG5cdFx0LmtleXByZXNzKGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRpZiAoZS5rZXlDb2RlPT09MTMpe1xyXG5cdFx0XHRcdGxldCBsb2MgPXNlbGYuY2FsY3VsYXRlUG9zaXRpb24oJCh0aGlzKS52YWwoKSk7XHJcblx0XHRcdFx0c2VsZi5icm93c2VyLmdvVG9Qb3NpdGlvbihsb2MuY2hyLGxvYy5zdGFydCxsb2MuZW5kKVxyXG5cdFx0XHR9XHRcclxuXHRcdH0pO1xyXG5cclxuXHRcdGxldCBhZGRfdHJhY2sgPSQoXCI8YnV0dG9uPlwiKS5odG1sKFwiPGkgY2xhc3MgPSAnZmEgZmEtcGx1cyc+PC9pPkFkZCBUcmFja1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLXNtIGJ0bi1zZWNvbmRhcnlcIilcclxuXHRcdFx0LmNzcyhcIm1hcmdpbi1sZWZ0XCIsXCIzcHhcIilcclxuXHRcdFx0LmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0bmV3IEFkZFRyYWNrRGlhbG9nKGZ1bmN0aW9uKGNvbmZpZyl7XHJcblx0XHRcdFx0XHRcdHNlbGYuYnJvd3Nlci5hZGRUcmFja0Zyb21Ccm93c2VyKGNvbmZpZyx0cnVlKTtcclxuXHRcdFx0XHRcdH0se2FsbG93ZWRfdHJhY2tfdHlwZXM6Y29uZmlnLmFsbG93ZWRfdHJhY2tfdHlwZXN9KVxyXG5cdFx0XHR9KVx0XHQgXHJcblx0XHRcdC5hcHBlbmRUbyh0aGlzLmNvbnRhaW5lcik7XHJcblx0XHR0aGlzLmJyb3dzZXIuYWRkTGlzdGVuZXIoXCJ2aWV3X2NoYW5nZWRcIixmdW5jdGlvbihsb2NhdGlvbixzdGFydCxlbmQpe1xyXG5cdFx0XHRpZiAoc2VsZi5saW1pdF9jaHJvbW9zb21lKXtcclxuXHRcdFx0XHRsb2NhdGlvbiA9ICBsb2NhdGlvbi5zcGxpdChcIjpcIilbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHN0YXJ0KXtcclxuXHRcdFx0XHRsb2NhdGlvbj1sb2NhdGlvbitcIjpcIitzdGFydCtcIi1cIitlbmQ7XHJcblx0XHRcdH1cdFxyXG5cdFx0XHRzZWxmLmxvY2F0aW9uX2lucHV0LnZhbChsb2NhdGlvbik7XHJcblx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRjYWxjdWxhdGVQb3NpdGlvbih0ZXh0KXtcclxuXHRcdHRleHQ9dGV4dC5yZXBsYWNlKC8sL2csXCJcIik7XHJcblx0XHJcblx0XHRsZXQgYXJyID0gdGV4dC5zcGxpdChcIjpcIik7XHJcblx0XHRsZXQgY2hyID0gbnVsbDtcclxuXHRcdGxldCBwb3MgPSBudWxsO1xyXG5cdFx0aWYgKGFyci5sZW5ndGg9PT0xKXtcclxuXHRcdFx0Y2hyID0gdGhpcy5icm93c2VyLmdldFBvc2l0aW9uKCkuY2hyO1xyXG5cdFx0XHRwb3M9YXJyWzBdXHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHRjaHIgPWFyclswXTtcclxuXHRcdFx0cG9zPWFyclsxXTtcclxuXHRcdH1cclxuXHRcdGxldCBhcnIyPSBwb3Muc3BsaXQoXCItXCIpO1xyXG5cdFx0cmV0dXJuICh7Y2hyOmNocixzdGFydDpwYXJzZUludChhcnIyWzBdKSxlbmQ6cGFyc2VJbnQoYXJyMlsxXSl9KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7U2ltcGxlQnJvd3NlcixCcm93c2VyQ29udHJvbHMsU2luZ2xlUGFuZWxCcm93c2VyfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQXlDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7OztBQS9HQTtBQUNBO0FBc0hBOzs7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBNkJBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OztBQWhUQTtBQUNBO0FBdVRBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/simple_browser.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/tiled_image_track.js":
/*!*********************************************!*\
  !*** .Panel/src/extra/tiled_image_track.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.TiledImageTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TiledImageTrack = function (_MLVTrack) {\n\t_inherits(TiledImageTrack, _MLVTrack);\n\n\tfunction TiledImageTrack(config) {\n\t\t_classCallCheck(this, TiledImageTrack);\n\n\t\treturn _possibleConstructorReturn(this, (TiledImageTrack.__proto__ || Object.getPrototypeOf(TiledImageTrack)).call(this, config));\n\t}\n\n\t_createClass(TiledImageTrack, [{\n\t\tkey: 'getFeatures',\n\t\tvalue: function getFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar locations = this.config.images[chr];\n\t\t\tif (!locations) {\n\t\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\t\tfulfill([]);\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar promises = [];\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar loc = _step.value;\n\n\t\t\t\t\tif (loc[0] > bpEnd) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (loc[1] < bpStart) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpromises.push(getImagePromise(loc));\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.all(promises);\n\t\t}\n\t}, {\n\t\tkey: 'drawScale',\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\n\t\t\t//ctx.drawImage(this.image,0,0,this.legend_width,pixelHeight,0,0,this.legend_width,pixelHeight)\n\t\t}\n\t}, {\n\t\tkey: 'drawFeatures',\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar bpEnd = options.bpStart + options.pixelWidth * options.bpPerPixel + 1;\n\t\t\tvar height = 0;\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar image = _step2.value;\n\n\t\t\t\t\tvar x1 = (image.start - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\tx1 = x1 < 0 ? 0 : x1;\n\t\t\t\t\tvar x_clip = 0;\n\t\t\t\t\tif (options.bpStart > image.start) {\n\t\t\t\t\t\tx_clip = (options.bpStart - image.start) / (image.end - image.start) * image.width;\n\t\t\t\t\t}\n\t\t\t\t\tvar x_clip2 = image.width;\n\t\t\t\t\tif (image.end > bpEnd) {\n\t\t\t\t\t\tx_clip2 = image.width - (image.end - bpEnd) / (image.end - image.start) * image.width;\n\t\t\t\t\t}\n\t\t\t\t\tvar x2 = options.pixelWidth;\n\t\t\t\t\tif (image.end < bpEnd) {\n\t\t\t\t\t\tx2 = options.pixelWidth - (bpEnd - image.end) / options.bpPerPixel;\n\t\t\t\t\t}\n\t\t\t\t\tvar factor = this.config.y_scale_factor ? options.bpPerPixel / this.config.y_scale_factor : 1;\n\t\t\t\t\toptions.context.drawImage(image, x_clip, 0, x_clip2 - x_clip, image.height, x1, options.top, x2 - x1, image.height / factor);\n\t\t\t\t\theight = image.height;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.bottom = options.top + height;\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn TiledImageTrack;\n}(_tracks.MLVTrack);\n\nfunction getImagePromise(loc) {\n\treturn new Promise(function (fulfill, reject) {\n\t\tvar image = new Image();\n\t\timage.start = loc[0];\n\t\timage.end = loc[1];\n\t\timage.onload = function () {\n\t\t\tfulfill(image);\n\t\t};\n\t\timage.src = loc[2];\n\t});\n}\n\n_tracks.MLVTrack.track_types['tiled_image_track'] = {\n\t\"class\": TiledImageTrack,\n\tname: \"Tiled Image Track\"\n\n};\n\nexports.TiledImageTrack = TiledImageTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3RpbGVkX2ltYWdlX3RyYWNrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9leHRyYS90aWxlZF9pbWFnZV90cmFjay5qcz84YzBjIl0sInNvdXJjZXNDb250ZW50IjpbIiAgICBcdGltcG9ydCB7TUxWVHJhY2t9IGZyb20gJy4uL3RyYWNrcy5qcydcclxuXHJcbiAgICBcdGNsYXNzIFRpbGVkSW1hZ2VUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdFx0XHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0XHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRnZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmb3JjZSxkYXRhKXtcclxuXHRcdFx0XHRsZXQgbG9jYXRpb25zID0gdGhpcy5jb25maWcuaW1hZ2VzW2Nocl07XHJcblx0XHRcdFx0aWYgKCFsb2NhdGlvbnMpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGZ1bGZpbGwscmVqZWN0KXtcclxuXHRcdFx0XHRcdFx0ZnVsZmlsbChbXSk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgcHJvbWlzZXM9IFtdO1xyXG5cdFx0XHRcdGZvciAobGV0IGxvYyBvZiBsb2NhdGlvbnMpe1xyXG5cdFx0XHRcdFx0aWYgKGxvY1swXT5icEVuZCl7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGxvY1sxXTxicFN0YXJ0KXtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRwcm9taXNlcy5wdXNoKGdldEltYWdlUHJvbWlzZShsb2MpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZHJhd1NjYWxlKHBpeGVsSGVpZ2h0LGN0eCl7XHJcbiBcclxuXHRcdFx0XHQvL2N0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwwLDAsdGhpcy5sZWdlbmRfd2lkdGgscGl4ZWxIZWlnaHQsMCwwLHRoaXMubGVnZW5kX3dpZHRoLHBpeGVsSGVpZ2h0KVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkcmF3RmVhdHVyZXMob3B0aW9ucykge1xyXG5cdFx0XHRcdGxldCBicEVuZCA9IG9wdGlvbnMuYnBTdGFydCArIG9wdGlvbnMucGl4ZWxXaWR0aCAqIG9wdGlvbnMuYnBQZXJQaXhlbCArIDE7XHJcblx0XHRcdFx0bGV0IGhlaWdodD0wO1xyXG5cdFx0XHRcdGZvciAobGV0IGltYWdlIG9mIG9wdGlvbnMuZmVhdHVyZXMpe1xyXG5cdFx0XHRcdFx0bGV0IHgxPSAoaW1hZ2Uuc3RhcnQtb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFx0XHR4MT14MTwwPzA6eDE7XHJcblx0XHRcdFx0XHRsZXQgeF9jbGlwPTA7XHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5icFN0YXJ0PmltYWdlLnN0YXJ0KXtcclxuXHRcdFx0XHRcdFx0eF9jbGlwPSgob3B0aW9ucy5icFN0YXJ0LWltYWdlLnN0YXJ0KS8oaW1hZ2UuZW5kLWltYWdlLnN0YXJ0KSkqaW1hZ2Uud2lkdGg7XHJcbiBcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IHhfY2xpcDI9aW1hZ2Uud2lkdGhcclxuXHRcdFx0XHRcdGlmIChpbWFnZS5lbmQ+YnBFbmQpe1xyXG5cdFx0XHRcdFx0XHR4X2NsaXAyID0gaW1hZ2Uud2lkdGgtKCgoaW1hZ2UuZW5kLWJwRW5kKS8oaW1hZ2UuZW5kLWltYWdlLnN0YXJ0KSkqaW1hZ2Uud2lkdGgpO1xyXG5cdFx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeDIgPSBvcHRpb25zLnBpeGVsV2lkdGg7XHJcblx0XHRcdFx0XHRpZiAoaW1hZ2UuZW5kPGJwRW5kKXtcclxuXHRcdFx0XHRcdFx0eDIgID0gb3B0aW9ucy5waXhlbFdpZHRoLSgoYnBFbmQtaW1hZ2UuZW5kKS9vcHRpb25zLmJwUGVyUGl4ZWwpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGZhY3Rvcj10aGlzLmNvbmZpZy55X3NjYWxlX2ZhY3Rvcj9vcHRpb25zLmJwUGVyUGl4ZWwvdGhpcy5jb25maWcueV9zY2FsZV9mYWN0b3I6MTtcclxuXHRcdFx0XHRcdG9wdGlvbnMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseF9jbGlwLDAseF9jbGlwMi14X2NsaXAsaW1hZ2UuaGVpZ2h0LHgxLG9wdGlvbnMudG9wLHgyLXgxLGltYWdlLmhlaWdodC9mYWN0b3IpO1xyXG5cdFx0XHRcdFx0aGVpZ2h0PWltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBvcHRpb25zLnRvcCtoZWlnaHQ7XHJcbiAgICAgICAgICAgXHRcdHJldHVybiB0aGlzLmJvdHRvbTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0XHJcblxyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gZ2V0SW1hZ2VQcm9taXNlKGxvYyl7XHJcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdFx0XHRsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHRcdFx0XHRcdGltYWdlLnN0YXJ0PWxvY1swXTtcclxuXHRcdFx0XHRcdGltYWdlLmVuZD1sb2NbMV07XHJcblx0XHRcdFx0XHRpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0XHRcdFx0XHRmdWxmaWxsKGltYWdlKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRpbWFnZS5zcmMgPWxvY1syXTsgXHJcblx0XHRcdH0pOyAgICAgICBcclxuXHRcdH1cclxuXHRcdFxyXG5cclxuXHRcdE1MVlRyYWNrLnRyYWNrX3R5cGVzWyd0aWxlZF9pbWFnZV90cmFjayddPXtcclxuXHRcdFx0XCJjbGFzc1wiOlRpbGVkSW1hZ2VUcmFjayxcclxuXHRcdFx0bmFtZTpcIlRpbGVkIEltYWdlIFRyYWNrXCJcclxuXHJcblx0XHR9XHJcblxyXG5leHBvcnQge1RpbGVkSW1hZ2VUcmFja307XHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7Ozs7QUEzREE7QUFDQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/tiled_image_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/ucsc_track.js":
/*!**************************************!*\
  !*** .Panel/src/extra/ucsc_track.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.UCSCMLVTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UCSCMLVTrack = function (_MLVTrack) {\n\t_inherits(UCSCMLVTrack, _MLVTrack);\n\n\tfunction UCSCMLVTrack(config) {\n\t\t_classCallCheck(this, UCSCMLVTrack);\n\n\t\tconfig.url = config.url.replace(\"hgTracks\", \"hgRenderTracks\");\n\t\tif (config.url.includes(\"/s/\")) {\n\t\t\tconfig.url = UCSCMLVTrack._convertSessionURL(config.url);\n\t\t}\n\n\t\tvar _this = _possibleConstructorReturn(this, (UCSCMLVTrack.__proto__ || Object.getPrototypeOf(UCSCMLVTrack)).call(this, config));\n\n\t\t_this.image = null;\n\t\t_this.legend_width = 74;\n\t\treturn _this;\n\t}\n\n\t_createClass(UCSCMLVTrack, [{\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tdialog.div.append($(\"<label>\").text(\"Session Url\"));\n\t\t\tvar inp = $(\"<textarea>\").val(dialog.config.url).css({ width: \"100%\", height: \"70px\" });\n\t\t\tvar but = $(\"<i class='fas fa-download'></i>\").click(function (e) {\n\t\t\t\tvar url = self._convertURL(inp.val());\n\t\t\t\tdialog.config.url = url;\n\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"url\", url);\n\t\t\t\tdialog.panel.update();\n\t\t\t});\n\t\t\tdialog.div.append(but).append(inp);\n\t\t}\n\t}, {\n\t\tkey: \"_convertURL\",\n\t\tvalue: function _convertURL(url) {\n\t\t\turl = url.replace(\"hgTracks\", \"hgRenderTracks\");\n\t\t\treturn url;\n\t\t}\n\t}, {\n\t\tkey: \"getFeatures\",\n\t\tvalue: function getFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar self = this;\n\t\t\tvar width = data.pixelWidth + this.legend_width;\n\t\t\twidth = (bpEnd - bpStart) / data.bpPerPixel + this.legend_width;\n\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\tself.image = new Image();\n\t\t\t\tself.image.onload = function () {\n\t\t\t\t\tself.config.height = self.image.height;\n\t\t\t\t\tfulfill([]);\n\t\t\t\t};\n\t\t\t\tvar url = self.config.url;\n\t\t\t\tvar args = \"&position=\" + chr + \":\" + bpStart + \"-\" + bpEnd + \"&pix=\" + width + \"&hgt.labelWidth=10\";\n\t\t\t\tself.image.src = url + args;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\t\t\tctx.globalAlpha = this.config.opacity;\n\t\t\tctx.drawImage(this.image, -this.legend_width, options.top);\n\t\t\tctx.globalAlpha = 1.0;\n\t\t\tthis.bottom = options.top + this.image.height;\n\t\t\treturn this.bottom;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\t\t\tctx.globalAlpha = 0.7;\n\t\t\tctx.drawImage(this.image, 0, 0, this.legend_width, pixelHeight, 0, this.top, this.legend_width, pixelHeight);\n\t\t\tctx.globalAlpha = 1.0;\n\t\t}\n\t}], [{\n\t\tkey: \"_convertSessionURL\",\n\t\tvalue: function _convertSessionURL(url) {\n\t\t\tvar arr = url.split(\"/\");\n\t\t\tvar new_url = arr[0] + \"//\" + arr[2] + \"/cgi-bin/hgRenderTracks?hgS_doOtherUser=submit&hgS_otherUserName=\" + arr[4] + \"&hgS_otherUserSessionName=\" + arr[5];\n\t\t\treturn new_url;\n\t\t}\n\t}]);\n\n\treturn UCSCMLVTrack;\n}(_tracks.MLVTrack);\n\n_tracks.MLVTrack.track_types['ucsc_track'] = {\n\t\"class\": UCSCMLVTrack,\n\tname: \"UCSC Session\"\n};\n\nexports.UCSCMLVTrack = UCSCMLVTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanM/MzVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIgICAgXHRpbXBvcnQge01MVlRyYWNrfSBmcm9tICcuLi90cmFja3MuanMnXHJcblxyXG4gICAgXHRjbGFzcyBVQ1NDTUxWVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRcdFx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdFx0XHRjb25maWcudXJsPSBjb25maWcudXJsLnJlcGxhY2UoXCJoZ1RyYWNrc1wiLFwiaGdSZW5kZXJUcmFja3NcIik7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy51cmwuaW5jbHVkZXMoXCIvcy9cIikpe1xyXG5cdFx0XHRcdFx0Y29uZmlnLnVybD1VQ1NDTUxWVHJhY2suX2NvbnZlcnRTZXNzaW9uVVJMKGNvbmZpZy51cmwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0XHRcdHRoaXMuaW1hZ2U9bnVsbDtcclxuXHRcdFx0XHR0aGlzLmxlZ2VuZF93aWR0aD03NDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGljIF9jb252ZXJ0U2Vzc2lvblVSTCh1cmwpe1xyXG5cdFx0XHRcdGxldCBhcnI9dXJsLnNwbGl0KFwiL1wiKTtcclxuXHRcdFx0XHRsZXQgbmV3X3VybCA9IGFyclswXStcIi8vXCIrYXJyWzJdK1wiL2NnaS1iaW4vaGdSZW5kZXJUcmFja3M/aGdTX2RvT3RoZXJVc2VyPXN1Ym1pdCZoZ1Nfb3RoZXJVc2VyTmFtZT1cIithcnJbNF1cclxuXHRcdFx0XHRcdCtcIiZoZ1Nfb3RoZXJVc2VyU2Vzc2lvbk5hbWU9XCIrYXJyWzVdO1xyXG5cdFx0XHRcdHJldHVybiBuZXdfdXJsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWRkRXh0cmFDb250cm9scyhkaWFsb2cpe1xyXG5cdFx0XHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdFx0XHRkaWFsb2cuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcblx0XHRcdFx0ZGlhbG9nLmRpdi5hcHBlbmQoJChcIjxsYWJlbD5cIikudGV4dChcIlNlc3Npb24gVXJsXCIpKTtcclxuXHRcdFx0XHRsZXQgaW5wPSQoXCI8dGV4dGFyZWE+XCIpLnZhbChkaWFsb2cuY29uZmlnLnVybCkuY3NzKHt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCI3MHB4XCJ9KTtcclxuXHRcdFx0XHRsZXQgYnV0ID0gJChcIjxpIGNsYXNzPSdmYXMgZmEtZG93bmxvYWQnPjwvaT5cIikuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRsZXQgdXJsID0gc2VsZi5fY29udmVydFVSTChpbnAudmFsKCkpO1xyXG5cdFx0XHRcdFx0ZGlhbG9nLmNvbmZpZy51cmw9dXJsO1xyXG5cdFx0XHRcdFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwidXJsXCIsdXJsKTtcclxuXHRcdFx0XHRcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRkaWFsb2cuZGl2LmFwcGVuZChidXQpLmFwcGVuZChpbnApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY29udmVydFVSTCh1cmwpe1xyXG5cdFx0XHRcdHVybD11cmwucmVwbGFjZShcImhnVHJhY2tzXCIsXCJoZ1JlbmRlclRyYWNrc1wiKTtcclxuXHRcdFx0XHRyZXR1cm4gdXJsXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpe1xyXG5cdFx0XHRcdGxldCBzZWxmPXRoaXM7XHJcblx0XHRcdFx0bGV0IHdpZHRoID0gZGF0YS5waXhlbFdpZHRoK3RoaXMubGVnZW5kX3dpZHRoO1xyXG5cdFx0XHRcdHdpZHRoID0gKChicEVuZC1icFN0YXJ0KS9kYXRhLmJwUGVyUGl4ZWwpK3RoaXMubGVnZW5kX3dpZHRoO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdFx0XHRzZWxmLmltYWdlID0gbmV3IEltYWdlKCk7XHJcblx0XHRcdFx0XHRzZWxmLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5jb25maWcuaGVpZ2h0ID0gc2VsZi5pbWFnZS5oZWlnaHQ7XHJcbiAgICBcdFx0XHRcdFx0ZnVsZmlsbChbXSk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0bGV0IHVybCA9IHNlbGYuY29uZmlnLnVybDtcclxuXHRcdFx0XHRcdGxldCBhcmdzID1cIiZwb3NpdGlvbj1cIitjaHIrXCI6XCIrYnBTdGFydCtcIi1cIiticEVuZCtcIiZwaXg9XCIrKHdpZHRoKStcIiZoZ3QubGFiZWxXaWR0aD0xMFwiO1xyXG5cdFx0XHRcdFx0c2VsZi5pbWFnZS5zcmMgPXVybCthcmdzOyAgICAgICAgXHJcbiAgICAgICAgXHRcdH0pO1x0XHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuICAgICAgICAgIFx0XHRsZXQgY3R4ID0gb3B0aW9ucy5jb250ZXh0O1xyXG4gICAgICAgICAgXHRcdHRoaXMudG9wPW9wdGlvbnMudG9wO1xyXG4gICAgICAgICAgXHRcdGN0eC5nbG9iYWxBbHBoYT10aGlzLmNvbmZpZy5vcGFjaXR5O1xyXG4gICAgICAgICAgIFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsLXRoaXMubGVnZW5kX3dpZHRoLG9wdGlvbnMudG9wKTtcclxuICAgICAgICAgICBcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuICAgICAgICAgICBcdFx0dGhpcy5ib3R0b20gPSBvcHRpb25zLnRvcCt0aGlzLmltYWdlLmhlaWdodDtcclxuICAgICAgICAgICBcdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkcmF3U2NhbGUocGl4ZWxIZWlnaHQsY3R4KXtcclxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC43O1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwwLDAsdGhpcy5sZWdlbmRfd2lkdGgscGl4ZWxIZWlnaHQsMCx0aGlzLnRvcCx0aGlzLmxlZ2VuZF93aWR0aCxwaXhlbEhlaWdodCk7XHJcblx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRNTFZUcmFjay50cmFja190eXBlc1sndWNzY190cmFjayddPXtcclxuXHRcdFx0XCJjbGFzc1wiOlVDU0NNTFZUcmFjayxcclxuXHRcdFx0bmFtZTpcIlVDU0MgU2Vzc2lvblwiXHJcblx0XHR9XHJcblxyXG5leHBvcnQge1VDU0NNTFZUcmFja307XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQXpEQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7O0FBakJBO0FBQ0E7QUF1RUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/ucsc_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/feature.js":
/*!*****************************!*\
  !*** .Panel/src/feature.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TabixBedFeatureSource = exports.BigBedFeatureSource = exports.FastaSequence = exports.FeatureSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nvar _bam = __webpack_require__(/*! ./bam.js */ \"../MLVPanel/src/bam.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * feature source for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureSource = function () {\n    function FeatureSource(config) {\n        _classCallCheck(this, FeatureSource);\n\n        this.config = config || {};\n    }\n\n    _createClass(FeatureSource, [{\n        key: \"getFileHeader\",\n        value: function getFileHeader() {\n            this.is_indexed = true;\n            return new Promise(function (fulfill, reject) {\n                fulfill();\n            });\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, start, end, force, data) {\n\n            //no need to get header\n            if (this.is_indexed) {\n                return this._getFeatures(chr, start, end, force, data);\n            }\n            //get headers/index then get features\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                self.getFileHeader().then(function () {\n                    self._getFeatures(chr, start, end, force, data).then(function (features) {\n                        fulfill(features);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n\n        /**\r\n         * Required function fo all data source objects.  Fetches features for the\r\n         * range requested and passes them on to the success function.  Usually this is\r\n         * a function that renders the features on the canvas\r\n         *\r\n         * @param chr\r\n         * @param bpStart\r\n         * @param bpEnd\r\n         */\n\n    }, {\n        key: \"_getFeatures\",\n        value: function _getFeatures(chr, bpStart, bpEnd, force, data) {\n            if (bpStart === 0) {\n                bpStart = 1;\n            }\n            var self = this;\n            self.time = Date.now();\n            return new Promise(function (fulfill, reject) {\n                if (self.featureCache && chr !== self.featureCache.range.chr) {\n                    self.featureCache = null;\n                }\n                var genomicInterval = new GenomicInterval(chr, bpStart, bpEnd),\n                    featureCache = self.featureCache,\n                    maxRows = self.config.maxRows || 500;\n                var ranges_to_get = false;\n                if (!featureCache) {\n                    ranges_to_get = { all: [bpStart, bpEnd] };\n                } else {\n                    if (featureCache.range !== undefined) {\n                        ranges_to_get = featureCache.range.rangesToGet(genomicInterval);\n                    }\n                }\n                if (!ranges_to_get) {\n                    fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                } else {\n                    var promises = [];\n                    var p_types = [];\n                    for (var type in ranges_to_get) {\n                        var range = ranges_to_get[type];\n                        promises.push(self.retrieveFeatures(chr, range[0], range[1], force, data));\n                        p_types.push([type, ranges_to_get[type]]);\n                    }\n                    Promise.all(promises).then(function (all_features) {\n                        var existing_features = [];\n                        if (self.featureCache) {\n                            existing_features = self.featureCache.allFeatures(); //featureCache.allFeatures(chr,self.featureCache.range.start,self.featureCache.range.end);\n                        }\n                        var index = 0;\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = all_features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var featureList = _step.value;\n\n                                if (featureList === null) {\n                                    featureList = [];\n                                }\n                                if (p_types[index][0] === \"left\") {\n                                    var end = p_types[index][1][1];\n                                    //remove any already retieved  \n                                    var splice = 0;\n                                    for (var n = featureList.length - 1; n >= 0; n--) {\n                                        if (featureList[n].end < end) {\n                                            break;\n                                        }\n                                        splice++;\n                                    }\n                                    if (splice !== 0) {\n                                        featureList.splice(-splice);\n                                    }\n                                }\n                                if (p_types[index][0] === \"right\") {\n                                    var start = p_types[index][1][0];\n                                    //remove any already retieved\n                                    var i = 0;\n                                    for (i = 0; i < featureList.length; i++) {\n                                        if (featureList[i].start > start) {\n                                            break;\n                                        }\n                                    }\n                                    if (i !== 0) {\n                                        featureList.splice(0, i);\n                                    }\n                                }\n                                index++;\n                                existing_features = existing_features.concat(featureList);\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        var gi = self.featureCache ? self.featureCache.range : genomicInterval;\n                        self.featureCache = new FeatureCache(existing_features, gi);\n                        FeatureSource.packFeatures(existing_features, maxRows);\n                        fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }\n            });\n        }\n    }], [{\n        key: \"packFeatures\",\n        value: function packFeatures(features, maxRows) {\n\n            if (features == null || features.length === 0) {\n                return;\n            }\n\n            // Segregate by chromosome\n\n            var chrFeatureMap = {},\n                chrs = [];\n            features.forEach(function (feature) {\n\n                var chr = feature.chr,\n                    flist = chrFeatureMap[chr];\n\n                if (!flist) {\n                    flist = [];\n                    chrFeatureMap[chr] = flist;\n                    chrs.push(chr);\n                }\n\n                flist.push(feature);\n            });\n\n            // Loop through chrosomosomes and pack features;\n\n            chrs.forEach(function (chr) {\n\n                pack(chrFeatureMap[chr], maxRows);\n            });\n\n            // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no\n            // row number is assigned.\n            function pack(featureList, maxRows) {\n\n                var rows = [];\n\n                featureList.sort(function (a, b) {\n                    return a.start - b.start;\n                });\n\n                rows.push(-1000);\n                featureList.forEach(function (feature) {\n\n                    var i,\n                        r,\n                        len = Math.min(rows.length, maxRows),\n                        start = feature.start;\n\n                    for (r = 0; r < len; r++) {\n                        if (start >= rows[r]) {\n                            feature.row = r;\n                            rows[r] = feature.end;\n                            return;\n                        }\n                    }\n                    feature.row = r;\n                    rows[r] = feature.end;\n                });\n            }\n        }\n    }]);\n\n    return FeatureSource;\n}();\n\nvar TabixBedFeatureSource = function (_FeatureSource) {\n    _inherits(TabixBedFeatureSource, _FeatureSource);\n\n    function TabixBedFeatureSource(config, decode_function) {\n        _classCallCheck(this, TabixBedFeatureSource);\n\n        var _this = _possibleConstructorReturn(this, (TabixBedFeatureSource.__proto__ || Object.getPrototypeOf(TabixBedFeatureSource)).call(this, config));\n\n        _this.reader = new FeatureFileReader(config, decode_function);\n        return _this;\n    }\n\n    _createClass(TabixBedFeatureSource, [{\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, start, end) {\n            return this.reader.readFeatures(chr, start, end);\n        }\n    }, {\n        key: \"getFileHeader\",\n        value: function getFileHeader() {\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                self.reader.readHeader().then(function () {\n                    self.is_indexed = true;\n                    fulfill();\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return TabixBedFeatureSource;\n}(FeatureSource);\n\nvar BigBedFeatureSource = function (_FeatureSource2) {\n    _inherits(BigBedFeatureSource, _FeatureSource2);\n\n    function BigBedFeatureSource(config, decode_function) {\n        _classCallCheck(this, BigBedFeatureSource);\n\n        config.sourceType = \"gtex\";\n\n        var _this2 = _possibleConstructorReturn(this, (BigBedFeatureSource.__proto__ || Object.getPrototypeOf(BigBedFeatureSource)).call(this, config));\n\n        _this2.header = true;\n        _this2.feature_source = new _bigwig.BWSource(config, decode_function);\n        return _this2;\n    }\n\n    _createClass(BigBedFeatureSource, [{\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, bpStart, bpEnd, force, data) {\n            return this.feature_source.getFeatures(chr, bpStart, bpEnd, false, data);\n        }\n    }]);\n\n    return BigBedFeatureSource;\n}(FeatureSource);\n\n//********js/FeatureFileReader.js*****\n\n\nvar F_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * Reader for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureFileReader = function () {\n    function FeatureFileReader(config, dec_function) {\n        _classCallCheck(this, FeatureFileReader);\n\n        this.config = config || {};\n\n        if (config.localFile) {\n            this.localFile = config.localFile;\n            this.filename = config.localFile.name;\n        } else {\n            this.url = config.url;\n            this.indexURL = config.indexURL;\n            this.headURL = config.headURL || this.filename;\n\n            var uriParts = _utils.Utils.parseUri(config.url);\n            this.filename = uriParts.file;\n            this.path = uriParts.path;\n        }\n\n        this.format = config.format;\n\n        this.parser = this.getParser(this.format, dec_function);\n    }\n\n    _createClass(FeatureFileReader, [{\n        key: \"getParser\",\n        value: function getParser(format, decode) {\n            switch (format) {\n                case \"vcf\":\n                    return new VcfParser();\n                case \"seg\":\n                    return new SegParser();\n                default:\n                    return new FeatureParser(format, decode, this.config);\n            }\n        }\n\n        // seg files don't have an index\n\n    }, {\n        key: \"isIndexable\",\n        value: function isIndexable() {\n            var configIndexURL = this.config.indexURL,\n                type = this.type,\n                configIndexed = this.config.indexed;\n\n            return configIndexURL || type != \"wig\" && configIndexed != false;\n        }\n\n        /**\r\n         * Return a Promise for the async loaded index\r\n         */\n\n    }, {\n        key: \"loadIndex\",\n        value: function loadIndex() {\n            var idxFile = this.indexURL;\n            if (this.filename.endsWith(\".gz\")) {\n                if (!idxFile) idxFile = this.url + \".tbi\";\n                return (0, _bam.loadBamIndex)(idxFile, this.config, true);\n            } else {\n                if (!idxFile) idxFile = this.url + \".idx\";\n                return loadTribbleIndex(idxFile, this.config);\n            }\n        }\n    }, {\n        key: \"loadFeaturesNoIndex\",\n        value: function loadFeaturesNoIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var parser = self.parser,\n                    options = {\n                    headers: self.config.headers, // http headers, not file header\n                    withCredentials: self.config.withCredentials\n                };\n\n                if (self.localFile) {\n                    _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(parseData).catch(reject);\n                } else {\n                    _igvxhr.igvxhr.loadString(self.url, options).then(parseData).catch(reject);\n                }\n\n                function parseData(data) {\n                    self.header = parser.parseHeader(data);\n                    if (self.header instanceof String && self.header.startsWith(\"##gff-version 3\")) {\n                        self.format = 'gff3';\n                    }\n                    fulfill(parser.parseFeatures(data)); // <= PARSING DONE HERE\n                };\n            });\n        }\n    }, {\n        key: \"loadFeaturesWithIndex\",\n        value: function loadFeaturesWithIndex(chr, start, end) {\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var blocks,\n                    index = self.index,\n                    tabix = index && index.tabix,\n                    refId = tabix ? index.sequenceIndexMap[chr] : chr,\n                    promises = [];\n\n                blocks = index.blocksForRange(refId, start, end);\n\n                if (!blocks || blocks.length === 0) {\n                    fulfill(null); // TODO -- is this correct?  Should it return an empty array?\n                } else {\n\n                    blocks.forEach(function (block) {\n\n                        promises.push(new Promise(function (fulfill, reject) {\n\n                            var startPos = block.minv.block,\n                                startOffset = block.minv.offset,\n                                endPos = block.maxv.block + (index.tabix ? F_MAX_GZIP_BLOCK_SIZE : 0),\n                                options = {\n                                headers: self.config.headers, // http headers, not file header\n                                range: { start: startPos, size: endPos - startPos + 1 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success;\n\n                            success = function success(data) {\n\n                                var inflated, slicedData;\n\n                                if (index.tabix) {\n\n                                    inflated = _igvxhr.igvxhr.arrayBufferToString((0, _igvxhr.unbgzf)(data));\n                                    // need to decompress data\n                                } else {\n                                    inflated = data;\n                                }\n\n                                slicedData = startOffset ? inflated.slice(startOffset) : inflated;\n                                var f = self.parser.parseFeatures(slicedData, chr, start, end);\n                                fulfill(f);\n                            };\n\n                            // Async load\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success).catch(reject);\n                            } else {\n                                if (index.tabix) {\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.url, options).then(success).catch(reject);\n                                } else {\n                                    _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                                }\n                            }\n                        }));\n                    });\n\n                    Promise.all(promises).then(function (featureArrays) {\n\n                        var i, allFeatures;\n\n                        if (featureArrays.length === 1) {\n                            allFeatures = featureArrays[0];\n                        } else {\n                            allFeatures = featureArrays[0];\n\n                            for (i = 1; i < featureArrays.length; i++) {\n                                allFeatures = allFeatures.concat(featureArrays[i]);\n                            }\n\n                            allFeatures.sort(function (a, b) {\n                                return a.start - b.start;\n                            });\n                        }\n\n                        fulfill(allFeatures);\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this,\n                isIndeedIndexible = this.isIndexable();\n            return new Promise(function (fulfill, reject) {\n\n                if (self.indexed === undefined && isIndeedIndexible) {\n                    self.loadIndex().then(function (index) {\n                        if (index) {\n                            self.index = index;\n                            self.indexed = true;\n                        } else {\n                            self.indexed = false;\n                        }\n                        fulfill(self.index);\n                    }).catch(reject);\n                } else {\n                    fulfill(self.index); // Is either already loaded, or there isn't one\n                }\n            });\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.header) {\n                    fulfill(self.header);\n                } else {\n\n                    // We force a load of the index first\n\n                    self.getIndex().then(function (index) {\n\n                        if (index) {\n                            // Load the file header (not HTTP header) for an indexed file.\n                            // TODO -- note this will fail if the file header is > 65kb in size\n                            var options = {\n                                headers: self.config.headers, // http headers, not file header\n                                bgz: index.tabix,\n                                range: { start: 0, size: 65000 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success = function success(data) {\n                                self.header = self.parser.parseHeader(data);\n                                fulfill(self.header);\n                            };\n\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success);\n                            } else {\n                                _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                            }\n                        } else {\n                            self.loadFeaturesNoIndex(undefined).then(function (features) {\n                                var header = self.header || {};\n                                header.features = features;\n                                fulfill(header);\n                            }).catch(error);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n\n        /**\r\n         *\r\n         * @param fulfill\r\n         * @param range -- genomic range to load.  For use with indexed source (optional)\r\n         */\n\n    }, {\n        key: \"readFeatures\",\n        value: function readFeatures(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    self.loadFeaturesWithIndex(chr, start, end).then(packFeatures).catch(reject);\n                } else {\n                    self.loadFeaturesNoIndex().then(packFeatures);\n                }\n\n                function packFeatures(features) {\n                    // TODO pack\n                    fulfill(features);\n                }\n            });\n        }\n    }]);\n\n    return FeatureFileReader;\n}();\n\n//***js/feature/FeatureParsers.js**************\n\n\nvar maxFeatureCount = Number.MAX_VALUE; // For future use,  controls downsampling\n\nvar gffNameFields = [\"Name\", \"gene_name\", \"gene\", \"gene_id\", \"alias\", \"locus\"];\n\n/**\r\n * A factory function.  Return a parser for the given file format.\r\n */\n\nvar FeatureParser = function () {\n    function FeatureParser(format, decode_func, config) {\n        _classCallCheck(this, FeatureParser);\n\n        var customFormat;\n\n        this.format = format;\n        this.nameField = config ? config.nameField : undefined;\n        this.skipRows = 0; // The number of fixed header rows to skip.  Override for specific types as neede\n\n        if (decode_func) {\n            this.delimiter = /\\s+/;\n\n            this.decode = function (tokens, ignore) {\n                var feature = { chr: tokens[0], start: parseInt(tokens[1]), end: parseInt(tokens[2]) };\n                decode_func(tokens.slice(3), feature);\n                return feature;\n            };\n        } else if (config.decode_function === \"generic\") {\n            this.decode = function (tokens, ignore) {\n                var feature = { chr: tokens[0], start: parseInt(tokens[1]), end: parseInt(tokens[2]) };\n                feature.data = tokens.slice(3);\n                return feature;\n            };\n        } else {\n            this.decode = FeatureParser.decodeBed;\n            this.delimiter = /\\s+/;\n        }\n\n        /* switch (format) {\r\n             case \"narrowpeak\":\r\n             case \"broadpeak\":\r\n             case \"peaks\":\r\n                 this.decode = this.decodePeak;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"bedgraph\":\r\n                 this.decode = this.decodeBedGraph;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"wig\":\r\n                 this.decode = this.decodeWig;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"gff3\" :\r\n             case \"gff\" :\r\n             case \"gtf\" :\r\n                 this.decode = this.decodeGFF;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"aneu\":\r\n                 this.decode = this.decodeAneu;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"fusionjuncspan\":\r\n                 // bhaas, needed for FusionInspector view\r\n                 this.decode = this.decodeFusionJuncSpan;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"gtexgwas\":\r\n                 this.skipRows = 1;\r\n                 this.decode = this.decodeGtexGWAS;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"refflat\":\r\n                 this.decode = this.decodeRefflat;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             default:\r\n                  customFormat = igv.browser.getFormat(format);\r\n                 if (customFormat !== undefined) {\r\n                     this.decode = decodeCustom;\r\n                     this.format = customFormat;\r\n                     this.delimiter = customFormat.delimiter || \"\\t\";\r\n                 }\r\n                   else {\r\n                 \r\n                // }\r\n           }*/\n    }\n\n    _createClass(FeatureParser, [{\n        key: \"parseHeader\",\n        value: function parseHeader(data) {\n\n            var lines = data.split(\"\\n\"),\n                len = lines.length,\n                line,\n                i,\n                header;\n\n            for (i = 0; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    if (line.startsWith(\"track\")) {\n                        header = this.parseTrackLine(line);\n                    } else if (line.startsWith(\"##gff-version 3\")) {\n                        this.format = \"gff3\";\n                        if (!header) header = {};\n                        header[\"format\"] = \"gff3\";\n                    }\n                } else {\n                    header = {};\n                    break;\n                }\n            }\n            return header;\n        }\n    }, {\n        key: \"parseFeatures\",\n        value: function parseFeatures(data, chr, start, end) {\n\n            if (!data) return null;\n\n            var wig,\n                feature,\n                lines = data.split(\"\\n\"),\n                len = lines.length,\n                tokens,\n                allFeatures = [],\n                line,\n                i,\n                cnt = 0,\n                j,\n                decode = this.decode,\n                format = this.format,\n                delimiter = this.delimiter || \"\\t\";\n\n            for (i = this.skipRows; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"fixedStep\")) {\n                    wig = this.parseFixedStep(line);\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"variableStep\")) {\n                    wig = this.parseVariableStep(line);\n                    continue;\n                }\n\n                tokens = lines[i].split(delimiter);\n                if (tokens.length < 1 || format !== \"wig\" && tokens.length < 3) continue;\n\n                feature = this.decode(tokens, wig);\n\n                if (feature) {\n                    if (feature.chr !== chr || feature.end < start || feature.start > end) {\n                        continue;\n                    }\n                    if (allFeatures.length < maxFeatureCount) {\n                        allFeatures.push(feature);\n                    } else {\n                        // Reservoir sampling,  conditionally replace existing feature with new one.\n                        j = Math.floor(Math.random() * cnt);\n                        if (j < maxFeatureCount) {\n                            allFeatures[j] = feature;\n                        }\n                    }\n                    cnt++;\n                } else {\n                    console.log(null);\n                }\n            }\n\n            return allFeatures;\n        }\n    }, {\n        key: \"decodeCustom\",\n\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n        value: function decodeCustom(tokens, ignore) {\n\n            var feature,\n                chr,\n                start,\n                end,\n                format = this.format,\n                // \"this\" refers to FeatureParser instance\n            coords = format.coords || 0;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[format.chr];\n            start = parseInt(tokens[format.start]) - coords;\n            end = format.end !== undefined ? parseInt(tokens[format.end]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (format.fields) {\n                format.fields.forEach(function (field, index) {\n                    if (index != format.chr && index != format.start && index != format.end) {\n                        feature[field] = tokens[index];\n                    }\n                });\n            }\n\n            return feature;\n        }\n    }], [{\n        key: \"parseFixedStep\",\n        value: function parseFixedStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                ss = parseInt(tokens[2].split(\"=\")[1], 10),\n                step = parseInt(tokens[3].split(\"=\")[1], 10),\n                span = tokens.length > 4 ? parseInt(tokens[4].split(\"=\")[1], 10) : 1;\n\n            return { format: \"fixedStep\", chrom: cc, start: ss, step: step, span: span, index: 0 };\n        }\n    }, {\n        key: \"parseVariableStep\",\n        value: function parseVariableStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                span = tokens.length > 2 ? parseInt(tokens[2].split(\"=\")[1], 10) : 1;\n            return { format: \"variableStep\", chrom: cc, span: span };\n        }\n    }, {\n        key: \"parseTrackLine\",\n        value: function parseTrackLine(line) {\n            var properties = {},\n                tokens = line.split(/(?:\")([^\"]+)(?:\")|([^\\s\"]+)(?=\\s+|$)/g),\n                tmp = [],\n                i,\n                tk,\n                curr;\n\n            // Clean up tokens array\n            for (i = 1; i < tokens.length; i++) {\n                if (!tokens[i] || tokens[i].trim().length === 0) continue;\n\n                tk = tokens[i].trim();\n\n                if (tk.endsWith(\"=\") > 0) {\n                    curr = tk;\n                } else if (curr) {\n                    tmp.push(curr + tk);\n                    curr = undefined;\n                } else {\n                    tmp.push(tk);\n                }\n            }\n\n            tmp.forEach(function (str) {\n                if (!str) return;\n                var kv = str.split('=', 2);\n                if (kv.length == 2) {\n                    properties[kv[0]] = kv[1];\n                }\n            });\n\n            return properties;\n        }\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n\n    }, {\n        key: \"decodeBed\",\n        value: function decodeBed(tokens, ignore) {\n\n            var chr, start, end, id, name, tmp, idName, exonCount, exonSizes, exonStarts, exons, exon, feature, eStart, eEnd;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end, score: 1000 };\n\n            if (tokens.length > 3) {\n                // Note: these are very special rules for the gencode gene files.\n                tmp = tokens[3].replace(/\"/g, '');\n                idName = tmp.split(';');\n                for (var i = 0; i < idName.length; i++) {\n                    var kv = idName[i].split('=');\n                    if (kv[0] == \"gene_id\") {\n                        id = kv[1];\n                    }\n                    if (kv[0] == \"gene_name\") {\n                        name = kv[1];\n                    }\n                }\n                feature.id = id ? id : tmp;\n                feature.name = name ? name : tmp;\n            }\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                feature.strand = tokens[5];\n            }\n            if (tokens.length > 6) {\n                feature.cdStart = parseInt(tokens[6]);\n            }\n            if (tokens.length > 7) {\n                feature.cdEnd = parseInt(tokens[7]);\n            }\n            if (tokens.length > 8) {\n                if (tokens[8] !== \".\" && tokens[8] !== \"0\") feature.color = igv.createColorString(tokens[8]);\n            }\n            if (tokens.length > 11) {\n                exonCount = parseInt(tokens[9]);\n                exonSizes = tokens[10].split(',');\n                exonStarts = tokens[11].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    var exon = { start: eStart, end: eEnd };\n\n                    if (feature.cdStart > eEnd || feature.cdEnd < feature.cdStart) exon.utr = true; // Entire exon is UTR\n                    if (feature.cdStart >= eStart && feature.cdStart <= eEnd) exon.cdStart = feature.cdStart;\n                    if (feature.cdEnd >= eStart && feature.cdEnd <= eEnd) exon.cdEnd = feature.cdEnd;\n\n                    exons.push(exon);\n                }\n\n                feature.exons = exons;\n            }\n\n            feature.popupData = function () {\n                var data = [];\n                if (feature.name) data.push({ name: \"Name\", value: feature.name });\n                if (\"+\" === feature.strand || \"-\" === feature.strand) data.push({ name: \"Strand\", value: feature.strand });\n                return data;\n            };\n\n            return feature;\n        }\n\n        /**\r\n         * Decode a UCSC \"refflat\" record\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeRefflat\",\n        value: function decodeRefflat(tokens, ignore) {\n\n            if (tokens.length < 10) return null;\n\n            var feature = {\n                chr: tokens[2],\n                start: parseInt(tokens[4]),\n                end: parseInt(tokens[5]),\n                id: tokens[1],\n                name: tokens[0],\n                strand: tokens[3],\n                cdStart: parseInt(tokens[6]),\n                cdEnd: parseInt(tokens[7])\n            },\n                exonCount = parseInt(tokens[8]),\n                exonStarts = tokens[9].split(','),\n                exonEnds = tokens[10].split(','),\n                exons = [];\n\n            for (var i = 0; i < exonCount; i++) {\n                exons.push({ start: parseInt(exonStarts[i]), end: parseInt(exonEnds[i]) });\n            }\n\n            feature.exons = exons;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodePeak\",\n        value: function decodePeak(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n            name = tokens[3];\n            score = parseFloat(tokens[4]);\n            strand = tokens[5].trim();\n            signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[7]);\n            qValue = parseFloat(tokens[8]);\n\n            if (score === 0) score = signal;\n\n            return {\n                chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n                pValue: pValue, qValue: qValue\n            };\n        }\n    }, {\n        key: \"decodeBedGraph\",\n        value: function decodeBedGraph(tokens, ignore) {\n\n            var chr, start, end, value;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n\n            value = parseFloat(tokens[3]);\n\n            return { chr: chr, start: start, end: end, value: value };\n        }\n    }, {\n        key: \"decodeWig\",\n        value: function decodeWig(tokens, wig) {\n\n            var ss, ee, value;\n\n            if (wig.format === \"fixedStep\") {\n\n                ss = wig.index * wig.step + wig.start;\n                ee = ss + wig.span;\n                value = parseFloat(tokens[0]);\n                ++wig.index;\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else if (wig.format === \"variableStep\") {\n\n                if (tokens.length < 2) return null;\n\n                ss = parseInt(tokens[0], 10);\n                ee = ss + wig.span;\n                value = parseFloat(tokens[1]);\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else {\n                return decodeBedGraph(tokens);\n            }\n        }\n    }, {\n        key: \"decodeAneu\",\n        value: function decodeAneu(tokens, ignore) {\n\n            var chr, start, end, feature;\n\n            if (tokens.length < 4) return null;\n\n            chr = tokens[1];\n            start = parseInt(tokens[2]);\n            end = tokens.length > 3 ? parseInt(tokens[3]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n                feature.value = feature.score;\n            }\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeFusionJuncSpan\",\n        value: function decodeFusionJuncSpan(tokens, ignore) {\n\n            /*\r\n             Format:\r\n               0       #scaffold\r\n             1       fusion_break_name\r\n             2       break_left\r\n             3       break_right\r\n             4       num_junction_reads\r\n             5       num_spanning_frags\r\n             6       spanning_frag_coords\r\n               0       B3GNT1--NPSR1\r\n             1       B3GNT1--NPSR1|2203-10182\r\n             2       2203\r\n             3       10182\r\n             4       189\r\n             5       1138\r\n             6       1860-13757,1798-13819,1391-18127,1443-17174,...\r\n               */\n\n            var chr = tokens[0];\n            var fusion_name = tokens[1];\n            var junction_left = parseInt(tokens[2]);\n            var junction_right = parseInt(tokens[3]);\n            var num_junction_reads = parseInt(tokens[4]);\n            var num_spanning_frags = parseInt(tokens[5]);\n\n            var spanning_frag_coords_text = tokens[6];\n\n            var feature = {\n                chr: chr,\n                name: fusion_name,\n                junction_left: junction_left,\n                junction_right: junction_right,\n                num_junction_reads: num_junction_reads,\n                num_spanning_frags: num_spanning_frags,\n                spanning_frag_coords: [],\n\n                start: -1,\n                end: -1\n            }; // set start and end later based on min/max of span coords\n\n            var min_coord = junction_left;\n            var max_coord = junction_right;\n\n            if (num_spanning_frags > 0) {\n\n                var coord_pairs = spanning_frag_coords_text.split(',');\n\n                for (var i = 0; i < coord_pairs.length; i++) {\n                    var split_coords = coord_pairs[i].split('-');\n\n                    var span_left = split_coords[0];\n                    var span_right = split_coords[1];\n\n                    if (span_left < min_coord) {\n                        min_coord = span_left;\n                    }\n                    if (span_right > max_coord) {\n                        max_coord = span_right;\n                    }\n                    feature.spanning_frag_coords.push({ left: span_left, right: span_right });\n                }\n            }\n\n            feature.start = min_coord;\n            feature.end = max_coord;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeGtexGWAS\",\n        value: function decodeGtexGWAS(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 8) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]) - 1;\n            end = parseInt(tokens[3].split(':')[1]);\n            //name = tokens[3];\n            //score = parseFloat(tokens[4]);\n            //strand = tokens[5].trim();\n            //signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[5]);\n            //qValue = parseFloat(tokens[8]);\n\n            //return {chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n            //    pValue: pValue, qValue: qValue};\n            return { chr: chr, start: start, end: end, pvalue: pValue };\n        }\n\n        /**\r\n         * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.\r\n         *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeGFF\",\n        value: function decodeGFF(tokens, ignore) {\n\n            var tokenCount,\n                chr,\n                start,\n                end,\n                strand,\n                type,\n                score,\n                phase,\n                attributeString,\n                id,\n                parent,\n                color,\n                name,\n                transcript_id,\n                i,\n                format = this.format;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null; // Not a valid gff record\n            }\n\n            chr = tokens[0];\n            type = tokens[2];\n            start = parseInt(tokens[3]) - 1;\n            end = parseInt(tokens[4]);\n            score = \".\" === tokens[5] ? 0 : parseFloat(tokens[5]);\n            strand = tokens[6];\n            phase = \".\" === tokens[7] ? 0 : parseInt(tokens[7]);\n            attributeString = tokens[8];\n\n            // Find ID and Parent, or transcript_id\n            var delim = 'gff3' === format ? '=' : /\\s+/;\n            var attributes = {};\n            attributeString.split(';').forEach(function (kv) {\n                var t = kv.trim().split(delim, 2),\n                    key,\n                    value;\n                if (t.length == 2) {\n                    key = t[0].trim();\n                    value = t[1].trim();\n                    //Strip off quotes, if any\n                    if (value.startsWith('\"') && value.endsWith('\"')) {\n                        value = value.substr(1, value.length - 2);\n                    }\n                    if (\"ID\" === t[0]) id = t[1];else if (\"Parent\" === t[0]) parent = t[1];else if (\"color\" === t[0].toLowerCase()) color = igv.createColorString(t[1]);else if (\"transcript_id\" === t[0]) id = t[1]; // gtf format\n                    attributes[key] = value;\n                }\n            });\n\n            // Find name (label) property\n            if (this.nameField) {\n                name = attributes[this.nameField];\n            } else {\n                for (i = 0; i < gffNameFields.length; i++) {\n                    if (attributes.hasOwnProperty(gffNameFields[i])) {\n                        this.nameField = gffNameFields[i];\n                        name = attributes[this.nameField];\n\n                        break;\n                    }\n                }\n            }\n\n            return {\n                id: id,\n                parent: parent,\n                name: name,\n                type: type,\n                chr: chr,\n                start: start,\n                end: end,\n                score: score,\n                strand: strand,\n                color: color,\n                attributeString: attributeString,\n                popupData: function popupData() {\n                    var kvs = this.attributeString.split(';'),\n                        pd = [],\n                        key,\n                        value;\n                    kvs.forEach(function (kv) {\n                        var t = kv.trim().split(delim, 2);\n                        if (t.length === 2 && t[1] !== undefined) {\n                            key = t[0].trim();\n                            value = t[1].trim();\n                            //Strip off quotes, if any\n                            if (value.startsWith('\"') && value.endsWith('\"')) {\n                                value = value.substr(1, value.length - 2);\n                            }\n                            pd.push({ name: key, value: value });\n                        }\n                    });\n                    return pd;\n                }\n\n            };\n        }\n    }]);\n\n    return FeatureParser;\n}();\n\n//*******js/feature/featureCache.js**********************\n\n\n/**\r\n * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)\r\n *\r\n * @param featureList\r\n * @param The genomic range spanned by featureList (optional)\r\n * @constructor\r\n */\n\nvar FeatureCache = function () {\n    function FeatureCache(featureList, range) {\n        _classCallCheck(this, FeatureCache);\n\n        this.treeMap = FeatureCache.buildTreeMap(featureList);\n        this.range = range;\n    }\n\n    _createClass(FeatureCache, [{\n        key: \"queryFeatures\",\n        value: function queryFeatures(chr, start, end) {\n\n            var featureList, intervalFeatures, feature, len, i, tree, intervals;\n\n            tree = this.treeMap[chr];\n\n            if (!tree) return [];\n\n            intervals = tree.findOverlapping(start, end);\n\n            if (intervals.length == 0) {\n                return [];\n            } else {\n                // Trim the list of features in the intervals to those\n                // overlapping the requested range.\n                // Assumption: features are sorted by start position\n\n                featureList = [];\n\n                intervals.forEach(function (interval) {\n                    intervalFeatures = interval.value;\n                    len = intervalFeatures.length;\n                    for (i = 0; i < len; i++) {\n                        feature = intervalFeatures[i];\n                        if (feature.start > end) break;else if (feature.end >= start) {\n                            featureList.push(feature);\n                        }\n                    }\n                });\n                return featureList;\n            }\n        }\n    }, {\n        key: \"allFeatures\",\n        value: function allFeatures() {\n\n            var allFeatures = [];\n            var treeMap = this.treeMap;\n            if (treeMap) {\n                for (var key in treeMap) {\n                    if (treeMap.hasOwnProperty(key)) {\n\n                        var tree = treeMap[key];\n                        tree.mapIntervals(function (interval) {\n                            allFeatures = allFeatures.concat(interval.value);\n                        });\n                    }\n                }\n            }\n            return allFeatures;\n        }\n    }], [{\n        key: \"buildTreeMap\",\n        value: function buildTreeMap(featureList) {\n\n            var featureCache = {},\n                chromosomes = [],\n                treeMap = {},\n                genome = null;\n\n            if (featureList) {\n\n                featureList.forEach(function (feature) {\n\n                    var chr = feature.chr,\n                        geneList;\n\n                    // Translate to \"official\" name\n                    if (genome) chr = genome.getChromosomeName(chr);\n\n                    geneList = featureCache[chr];\n\n                    if (!geneList) {\n                        chromosomes.push(chr);\n                        geneList = [];\n                        featureCache[chr] = geneList;\n                    }\n\n                    geneList.push(feature);\n                });\n\n                // Now build interval tree for each chromosome\n\n                for (var i = 0; i < chromosomes.length; i++) {\n                    var chr = chromosomes[i];\n                    treeMap[chr] = FeatureCache.buildIntervalTree(featureCache[chr]);\n                }\n            }\n\n            return treeMap;\n        }\n    }, {\n        key: \"buildIntervalTree\",\n\n\n        /**\r\n         * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups\r\n         * of 10, or total size / 100,   to reduce size of the tree.\r\n         *\r\n         * @param featureList\r\n         */\n        value: function buildIntervalTree(featureList) {\n\n            var i, e, iStart, iEnd, tree, chunkSize, len, subArray;\n\n            tree = new IntervalTree();\n            len = featureList.length;\n\n            chunkSize = Math.max(10, Math.round(len / 100));\n\n            featureList.sort(function (f1, f2) {\n                return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;\n            });\n\n            for (i = 0; i < len; i += chunkSize) {\n                e = Math.min(len, i + chunkSize);\n                subArray = featureList.slice(i, e);\n                iStart = subArray[0].start;\n                //\n                iEnd = iStart;\n                subArray.forEach(function (feature) {\n                    iEnd = Math.max(iEnd, feature.end);\n                });\n                tree.insert(iStart, iEnd, subArray);\n            }\n\n            return tree;\n        }\n    }]);\n\n    return FeatureCache;\n}();\n\n//*****js/intervalTree.js************\n\n\nvar BLACK = 1;\nvar RED = 2;\n\nvar NIL = {};\nNIL.color = BLACK;\nNIL.parent = NIL;\nNIL.left = NIL;\nNIL.right = NIL;\n\nvar IntervalTree = function () {\n    function IntervalTree() {\n        _classCallCheck(this, IntervalTree);\n\n        this.root = NIL;\n    }\n\n    _createClass(IntervalTree, [{\n        key: \"insert\",\n        value: function insert(start, end, value) {\n\n            var interval = new Interval(start, end, value);\n            var x = new Node(interval);\n            this.treeInsert(x);\n            x.color = RED;\n            while (x != this.root && x.parent.color == RED) {\n                if (x.parent == x.parent.parent.left) {\n                    var y = x.parent.parent.right;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.right) {\n                            x = x.parent;\n                            this.leftRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.rightRotate(x.parent.parent);\n                    }\n                } else {\n                    var y = x.parent.parent.left;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.left) {\n                            x = x.parent;\n                            this.rightRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.leftRotate(x.parent.parent);\n                    }\n                }\n            }\n            this.root.color = BLACK;\n        }\n\n        /**\r\n         *\r\n         * @param start - query interval\r\n         * @param end - query interval\r\n         * @returns Array of all intervals overlapping the query region\r\n         */\n\n    }, {\n        key: \"findOverlapping\",\n        value: function findOverlapping(start, end) {\n\n            var searchInterval = new Interval(start, end, 0);\n\n            if (this.root === NIL) return [];\n\n            var intervals = this.searchAll(searchInterval, this.root, []);\n\n            if (intervals.length > 1) {\n                intervals.sort(function (i1, i2) {\n                    return i1.low - i2.low;\n                });\n            }\n\n            return intervals;\n        }\n\n        /**\r\n         * Dump info on intervals to console.  For debugging.\r\n         */\n\n    }, {\n        key: \"logIntervals\",\n        value: function logIntervals() {\n\n            logNode(this.root, 0);\n\n            function logNode(node, indent) {\n\n                var space = \"\";\n                for (var i = 0; i < indent; i++) {\n                    space += \" \";\n                }console.log(space + node.interval.low + \" \" + node.interval.high); // + \" \" + (node.interval.value ? node.interval.value : \" null\"));\n\n                indent += 5;\n\n                if (node.left != NIL) logNode(node.left, indent);\n                if (node.right != NIL) logNode(node.right, indent);\n            }\n        }\n    }, {\n        key: \"mapIntervals\",\n        value: function mapIntervals(func) {\n\n            applyInterval(this.root);\n\n            function applyInterval(node) {\n\n                func(node.interval);\n\n                if (node.left != NIL) applyInterval(node.left);\n                if (node.right != NIL) applyInterval(node.right);\n            }\n        }\n    }, {\n        key: \"searchAll\",\n        value: function searchAll(interval, node, results) {\n\n            if (node.interval.overlaps(interval)) {\n                results.push(node.interval);\n            }\n\n            if (node.left != NIL && node.left.max >= interval.low) {\n                this.searchAll(interval, node.left, results);\n            }\n\n            if (node.right != NIL && node.right.min <= interval.high) {\n                this.searchAll(interval, node.right, results);\n            }\n\n            return results;\n        }\n    }, {\n        key: \"leftRotate\",\n        value: function leftRotate(x) {\n            var y = x.right;\n            x.right = y.left;\n            if (y.left != NIL) {\n                y.left.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.left == x) {\n                    x.parent.left = y;\n                } else {\n                    x.parent.right = y;\n                }\n            }\n            y.left = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n    }, {\n        key: \"rightRotate\",\n        value: function rightRotate(x) {\n            var y = x.left;\n            x.left = y.right;\n            if (y.right != NIL) {\n                y.right.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.right == x) {\n                    x.parent.right = y;\n                } else {\n                    x.parent.left = y;\n                }\n            }\n            y.right = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n\n        /**\r\n         * Note:  Does not maintain RB constraints,  this is done post insert\r\n         *\r\n         * @param x  a Node\r\n         */\n\n    }, {\n        key: \"treeInsert\",\n        value: function treeInsert(x) {\n            var node = this.root;\n            var y = NIL;\n            while (node != NIL) {\n                y = node;\n                if (x.interval.low <= node.interval.low) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            }\n            x.parent = y;\n\n            if (y == NIL) {\n                this.root = x;\n                x.left = x.right = NIL;\n            } else {\n                if (x.interval.low <= y.interval.low) {\n                    y.left = x;\n                } else {\n                    y.right = x;\n                }\n            }\n\n            this.applyUpdate(x);\n        }\n\n        // Applies the statistic update on the node and its ancestors.\n\n    }, {\n        key: \"applyUpdate\",\n        value: function applyUpdate(node) {\n            while (node != NIL) {\n                var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;\n                var intervalHigh = node.interval.high;\n                node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;\n\n                var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;\n                var intervalLow = node.interval.low;\n                node.min = nodeMin < intervalLow ? nodeMin : intervalLow;\n\n                node = node.parent;\n            }\n        }\n    }]);\n\n    return IntervalTree;\n}();\n\nvar Interval = function () {\n    function Interval(low, high, value) {\n        _classCallCheck(this, Interval);\n\n        this.low = low;\n        this.high = high;\n        this.value = value;\n    }\n\n    _createClass(Interval, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!other) {\n                return false;\n            }\n            if (this == other) {\n                return true;\n            }\n            return this.low == otherInterval.low && this.high == otherInterval.high;\n        }\n    }, {\n        key: \"compareTo\",\n        value: function compareTo(other) {\n            if (this.low < other.low) return -1;\n            if (this.low > other.low) return 1;\n\n            if (this.high < other.high) return -1;\n            if (this.high > other.high) return 1;\n\n            return 0;\n        }\n\n        /**\r\n         * Returns true if this interval overlaps the other.\r\n         */\n\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(other) {\n            try {\n                return this.low <= other.high && other.low <= this.high;\n            } catch (e) {\n                //alert(e);\n                igv.presentAlert(e);\n            }\n        }\n    }]);\n\n    return Interval;\n}();\n\nvar Node = function Node(interval) {\n    _classCallCheck(this, Node);\n\n    this.parent = NIL;\n    this.left = NIL;\n    this.right = NIL;\n    this.interval = interval;\n    this.color = RED;\n};\n\nvar GenomicInterval = function () {\n    function GenomicInterval(chr, start, end, features) {\n        _classCallCheck(this, GenomicInterval);\n\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.features = features;\n    }\n\n    _createClass(GenomicInterval, [{\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"containsRange\",\n        value: function containsRange(range) {\n            return this.chr === range.chr && this.start <= range.start && this.end >= range.end;\n        }\n    }, {\n        key: \"rangesToGet\",\n        value: function rangesToGet(range) {\n            var needs_range = false;\n            var ranges = {};\n            if (this.chr !== range.chr) {\n                ranges.all = [range.start, range.end];\n                needs_range = true;\n                this.start = range.start;\n                this.end = range.end;\n            } else {\n                if (range.start < this.start) {\n                    ranges.left = [range.start, this.start];\n                    needs_range = true;\n                    this.start = range.start;\n                }\n                if (range.end > this.end) {\n                    ranges.right = [this.end, range.end];\n                    needs_range = true;\n                    this.end = range.end;\n                }\n            }\n            if (!needs_range) {\n                return false;\n            }\n            return ranges;\n        }\n    }]);\n\n    return GenomicInterval;\n}();\n\nvar FastaSequence = function () {\n    function FastaSequence(url) {\n        _classCallCheck(this, FastaSequence);\n\n        this.file = url;\n        this.indexed = true;\n        if (this.indexed) {\n            this.indexFile = this.file + \".fai\";\n        }\n    }\n\n    _createClass(FastaSequence, [{\n        key: \"init\",\n        value: function init() {\n\n            var self = this;\n\n            if (self.indexed) {\n\n                return new Promise(function (fulfill, reject) {\n\n                    self.getIndex().then(function (index) {\n                        var order = 0;\n                        self.chromosomes = {};\n                        self.chromosomeNames.forEach(function (chrName) {\n                            var bpLength = self.index[chrName].size;\n                            self.chromosomes[chrName] = new igv.Chromosome(chrName, order++, bpLength);\n                        });\n\n                        // Ignore index, getting chr names as a side effect.  Really bad practice\n                        fulfill();\n                    }).catch(reject);\n                });\n            } else {\n                return self.loadAll();\n            }\n        }\n    }, {\n        key: \"getSequence\",\n        value: function getSequence(chr, start, end) {\n\n            if (this.indexed) {\n                return this.getSequenceIndexed(chr, start, end);\n            } else {\n                return getSequenceNonIndexed.this(chr, start, end);\n            }\n        }\n    }, {\n        key: \"getSequenceIndexed\",\n        value: function getSequenceIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var interval = self.interval;\n\n                if (interval && interval.contains(chr, start, end)) {\n\n                    fulfill(getSequenceFromInterval(interval, start, end));\n                } else {\n\n                    //console.log(\"Cache miss: \" + (interval === undefined ? \"nil\" : interval.chr + \":\" + interval.start + \"-\" + interval.end));\n\n                    // Expand query, to minimum of 100kb\n                    var qstart = start;\n                    var qend = end;\n                    if (end - start < 100000) {\n                        var w = end - start;\n                        var center = Math.round(start + w / 2);\n                        qstart = Math.max(0, center - 50000);\n                        qend = center + 50000;\n                    }\n\n                    self.readSequence(chr, qstart, qend).then(function (seqBytes) {\n                        self.interval = new GenomicInterval(chr, qstart, qend, seqBytes);\n                        fulfill(getSequenceFromInterval(self.interval, start, end));\n                    }).catch(reject);\n                }\n\n                function getSequenceFromInterval(interval, start, end) {\n                    var offset = start - interval.start;\n                    var n = end - start;\n                    var seq = interval.features ? interval.features.substr(offset, n) : null;\n                    return seq;\n                }\n            });\n        }\n    }, {\n        key: \"getSequenceNonIndexed\",\n        value: function getSequenceNonIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var seq = self.sequences[chr];\n                if (seq && seq.length > end) {\n                    fulfill(seq.substring(start, end));\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    fulfill(self.index);\n                } else {\n                    _igvxhr.igvxhr.load(self.indexFile, {}).then(function (data) {\n                        var lines = data.split(\"\\n\");\n                        var len = lines.length;\n                        var lineNo = 0;\n\n                        self.chromosomeNames = []; // TODO -- eliminate this side effect !!!!\n                        self.index = {}; // TODO -- ditto\n                        while (lineNo < len) {\n\n                            var tokens = lines[lineNo++].split(\"\\t\");\n                            var nTokens = tokens.length;\n                            if (nTokens == 5) {\n                                // Parse the index line.\n                                var chr = tokens[0];\n                                var size = parseInt(tokens[1]);\n                                var position = parseInt(tokens[2]);\n                                var basesPerLine = parseInt(tokens[3]);\n                                var bytesPerLine = parseInt(tokens[4]);\n\n                                var indexEntry = {\n                                    size: size, position: position, basesPerLine: basesPerLine, bytesPerLine: bytesPerLine\n                                };\n\n                                self.chromosomeNames.push(chr);\n                                self.index[chr] = indexEntry;\n                            }\n                        }\n\n                        if (fulfill) {\n                            fulfill(self.index);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"loadAll\",\n        value: function loadAll() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.chromosomeNames = [];\n                self.chromosomes = {};\n                self.sequences = {};\n\n                _igvxhr.igvxhr.load(self.file, {\n                    withCredentials: self.withCredentials\n\n                }).then(function (data) {\n\n                    var lines = data.splitLines(),\n                        len = lines.length,\n                        lineNo = 0,\n                        nextLine,\n                        currentSeq = \"\",\n                        currentChr,\n                        order = 0;\n\n                    while (lineNo < len) {\n                        nextLine = lines[lineNo++].trim();\n                        if (nextLine.startsWith(\"#\") || nextLine.length === 0) {\n                            continue;\n                        } else if (nextLine.startsWith(\">\")) {\n                            if (currentSeq) {\n                                self.chromosomeNames.push(currentChr);\n                                self.sequences[currentChr] = currentSeq;\n                                self.chromosomes[currentChr] = new igv.Chromosome(currentChr, order++, currentSeq.length);\n                            }\n                            currentChr = nextLine.substr(1).split(\"\\\\s+\")[0];\n                            currentSeq = \"\";\n                        } else {\n                            currentSeq += nextLine;\n                        }\n                    }\n\n                    fulfill();\n                });\n            });\n        }\n    }, {\n        key: \"readSequence\",\n        value: function readSequence(chr, qstart, qend) {\n\n            //console.log(\"Read sequence \" + chr + \":\" + qstart + \"-\" + qend);\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.getIndex().then(function () {\n\n                    var idxEntry = self.index[chr];\n                    if (!idxEntry) {\n                        console.log(\"No index entry for chr: \" + chr);\n\n                        // Tag interval with null so we don't try again\n                        self.interval = new GenomicInterval(chr, qstart, qend, null);\n                        fulfill(null);\n                    } else {\n\n                        var start = Math.max(0, qstart); // qstart should never be < 0\n                        var end = Math.min(idxEntry.size, qend);\n                        var bytesPerLine = idxEntry.bytesPerLine;\n                        var basesPerLine = idxEntry.basesPerLine;\n                        var position = idxEntry.position;\n                        var nEndBytes = bytesPerLine - basesPerLine;\n\n                        var startLine = Math.floor(start / basesPerLine);\n                        var endLine = Math.floor(end / basesPerLine);\n\n                        var base0 = startLine * basesPerLine; // Base at beginning of start line\n\n                        var offset = start - base0;\n\n                        var startByte = position + startLine * bytesPerLine + offset;\n\n                        var base1 = endLine * basesPerLine;\n                        var offset1 = end - base1;\n                        var endByte = position + endLine * bytesPerLine + offset1 - 1;\n                        var byteCount = endByte - startByte + 1;\n                        if (byteCount <= 0) {\n                            fulfill(null);\n                        }\n\n                        _igvxhr.igvxhr.load(self.file, {\n                            range: { start: startByte, size: byteCount }\n                        }).then(function (allBytes) {\n\n                            var nBases,\n                                seqBytes = \"\",\n                                srcPos = 0,\n                                desPos = 0,\n                                allBytesLength = allBytes.length;\n\n                            if (offset > 0) {\n                                nBases = Math.min(end - start, basesPerLine - offset);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            while (srcPos < allBytesLength) {\n                                nBases = Math.min(basesPerLine, allBytesLength - srcPos);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            fulfill(seqBytes);\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return FastaSequence;\n}();\n\nexports.FeatureSource = FeatureSource;\nexports.FastaSequence = FastaSequence;\nexports.BigBedFeatureSource = BigBedFeatureSource;\nexports.TabixBedFeatureSource = TabixBedFeatureSource;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanM/MzFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcbmltcG9ydCB7VXRpbHN9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7aWd2eGhyLHVuYmd6Zn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcbmltcG9ydCB7bG9hZEJhbUluZGV4fSBmcm9tIFwiLi9iYW0uanNcIjtcclxuaW1wb3J0IHtCV1NvdXJjZX0gZnJvbSBcIi4vYmlnd2lnLmpzXCI7XHJcblxyXG5jb25zdCBNQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmVhdHVyZSBzb3VyY2UgZm9yIFwiYmVkIGxpa2VcIiBmaWxlcyAodGFiIGRlbGltaXRlZCBmaWxlcyB3aXRoIDEgZmVhdHVyZSBwZXIgbGluZTogYmVkLCBnZmYsIHZjZiwgZXRjKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbmNsYXNzIEZlYXR1cmVTb3VyY2V7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0RmlsZUhlYWRlcigpIHtcclxuICAgICAgICB0aGlzLmlzX2luZGV4ZWQ9dHJ1ZTsgIFxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bGZpbGwoKTsgICAgICAgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSAgIFxyXG5cclxuXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpe1xyXG4gICAgICBcclxuICAgICAgICAvL25vIG5lZWQgdG8gZ2V0IGhlYWRlclxyXG4gICAgICAgIGlmICh0aGlzLmlzX2luZGV4ZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9nZXQgaGVhZGVycy9pbmRleCB0aGVuIGdldCBmZWF0dXJlc1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZnVsZmlsbCxyZWplY3Qpe1xyXG4gICAgICAgICAgICBzZWxmLmdldEZpbGVIZWFkZXIoKS50aGVuKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9nZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpLnRoZW4oZnVuY3Rpb24oZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgZnVuY3Rpb24gZm8gYWxsIGRhdGEgc291cmNlIG9iamVjdHMuICBGZXRjaGVzIGZlYXR1cmVzIGZvciB0aGVcclxuICAgICAqIHJhbmdlIHJlcXVlc3RlZCBhbmQgcGFzc2VzIHRoZW0gb24gdG8gdGhlIHN1Y2Nlc3MgZnVuY3Rpb24uICBVc3VhbGx5IHRoaXMgaXNcclxuICAgICAqIGEgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBmZWF0dXJlcyBvbiB0aGUgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHBhcmFtIGJwU3RhcnRcclxuICAgICAqIEBwYXJhbSBicEVuZFxyXG4gICAgICovXHJcbiAgICBfZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgaWYgKGJwU3RhcnQ9PT0wKXtcclxuICAgICAgICAgICAgYnBTdGFydD0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi50aW1lPURhdGUubm93KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZUNhY2hlICYmIGNociAhPT0gc2VsZi5mZWF0dXJlQ2FjaGUucmFuZ2UuY2hyKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlPW51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdlbm9taWNJbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBicFN0YXJ0LCBicEVuZCksXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlQ2FjaGUgPSBzZWxmLmZlYXR1cmVDYWNoZSxcclxuICAgICAgICAgICAgICAgIG1heFJvd3MgPSBzZWxmLmNvbmZpZy5tYXhSb3dzIHx8IDUwMDtcclxuICAgICAgICAgICAgbGV0IHJhbmdlc190b19nZXQ9ZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghZmVhdHVyZUNhY2hlKXtcclxuICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9e2FsbDpbYnBTdGFydCxicEVuZF19O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUNhY2hlLnJhbmdlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9ZmVhdHVyZUNhY2hlLnJhbmdlLnJhbmdlc1RvR2V0KGdlbm9taWNJbnRlcnZhbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJhbmdlc190b19nZXQpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGxldCBwcm9taXNlcz1bXTtcclxuICAgICAgICAgICAgICAgIGxldCBwX3R5cGVzPVtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiByYW5nZXNfdG9fZ2V0KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2U9IHJhbmdlc190b19nZXRbdHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnJldHJpZXZlRmVhdHVyZXMoY2hyLCByYW5nZVswXSwgcmFuZ2VbMV0sZm9yY2UsZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBfdHlwZXMucHVzaChbdHlwZSxyYW5nZXNfdG9fZ2V0W3R5cGVdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ19mZWF0dXJlcz1bXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZUNhY2hlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX2ZlYXR1cmVzPXNlbGYuZmVhdHVyZUNhY2hlLmFsbEZlYXR1cmVzKCk7Ly9mZWF0dXJlQ2FjaGUuYWxsRmVhdHVyZXMoY2hyLHNlbGYuZmVhdHVyZUNhY2hlLnJhbmdlLnN0YXJ0LHNlbGYuZmVhdHVyZUNhY2hlLnJhbmdlLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4PTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmVMaXN0IG9mIGFsbF9mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3QgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0PVtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwX3R5cGVzW2luZGV4XVswXT09PVwibGVmdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcF90eXBlc1tpbmRleF1bMV1bMV07IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBhbHJlYWR5IHJldGlldmVkICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaWNlPTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbj1mZWF0dXJlTGlzdC5sZW5ndGgtMTtuPj0wO24tLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdFtuXS5lbmQ8IGVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGljZSE9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdC5zcGxpY2UoLXNwbGljZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBfdHlwZXNbaW5kZXhdWzBdPT09XCJyaWdodFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ9cF90eXBlc1tpbmRleF1bMV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYW55IGFscmVhZHkgcmV0aWV2ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaT0wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7aTxmZWF0dXJlTGlzdC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0W2ldLnN0YXJ0PiBzdGFydCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSE9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdC5zcGxpY2UoMCxpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19mZWF0dXJlcz1leGlzdGluZ19mZWF0dXJlcy5jb25jYXQoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnaSA9IHNlbGYuZmVhdHVyZUNhY2hlP3NlbGYuZmVhdHVyZUNhY2hlLnJhbmdlOmdlbm9taWNJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlQ2FjaGUgPSBuZXcgRmVhdHVyZUNhY2hlKGV4aXN0aW5nX2ZlYXR1cmVzLCBnaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZlYXR1cmVTb3VyY2UucGFja0ZlYXR1cmVzKGV4aXN0aW5nX2ZlYXR1cmVzLCBtYXhSb3dzKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgc3RhdGljIHBhY2tGZWF0dXJlcyhmZWF0dXJlcywgbWF4Um93cykge1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZXMgPT0gbnVsbCB8fCBmZWF0dXJlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VncmVnYXRlIGJ5IGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgdmFyIGNockZlYXR1cmVNYXAgPSB7fSxcclxuICAgICAgICAgICAgY2hycyA9IFtdO1xyXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaHIgPSBmZWF0dXJlLmNocixcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gY2hyRmVhdHVyZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgZmxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNockZlYXR1cmVNYXBbY2hyXSA9IGZsaXN0O1xyXG4gICAgICAgICAgICAgICAgY2hycy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsaXN0LnB1c2goZmVhdHVyZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBjaHJvc29tb3NvbWVzIGFuZCBwYWNrIGZlYXR1cmVzO1xyXG5cclxuICAgICAgICBjaHJzLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xyXG5cclxuICAgICAgICAgICAgcGFjayhjaHJGZWF0dXJlTWFwW2Nocl0sIG1heFJvd3MpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gQXNzaWducyBhIHJvdyAjIHRvIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBmZWF0dXJlIGRvZXMgbm90IGZpdCBpbiBhbnkgcm93IGFuZCAjcm93cyA9PSBtYXhSb3dzIG5vXHJcbiAgICAgICAgLy8gcm93IG51bWJlciBpcyBhc3NpZ25lZC5cclxuICAgICAgICBmdW5jdGlvbiBwYWNrKGZlYXR1cmVMaXN0LCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJvd3MucHVzaCgtMTAwMCk7XHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICByLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWluKHJvd3MubGVuZ3RoLCBtYXhSb3dzKSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZlYXR1cmUuc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IGxlbjsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IHJvd3Nbcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5yb3cgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnJvdyA9IHI7XHJcbiAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcblxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgVGFiaXhCZWRGZWF0dXJlU291cmNlIGV4dGVuZHMgRmVhdHVyZVNvdXJjZXtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pe1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgRmVhdHVyZUZpbGVSZWFkZXIoY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0cmlldmVGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIucmVhZEZlYXR1cmVzKGNocixzdGFydCxlbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpbGVIZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVhZGVyLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuaXNfaW5kZXhlZD10cnVlOyAgXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcbiAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICB9ICAgXHJcbn1cclxuXHJcbmNsYXNzIEJpZ0JlZEZlYXR1cmVTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLGRlY29kZV9mdW5jdGlvbil7XHJcblx0XHRjb25maWcuc291cmNlVHlwZT1cImd0ZXhcIjtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHR0aGlzLmhlYWRlcj10cnVlO1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQldTb3VyY2UoY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXRyaWV2ZUZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0RmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZmFsc2UsZGF0YSk7ICAgICBcdFxyXG5cdH1cclxufVxyXG5cclxuLy8qKioqKioqKmpzL0ZlYXR1cmVGaWxlUmVhZGVyLmpzKioqKipcclxuXHJcblxyXG5cclxuY29uc3QgRl9NQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZGVyIGZvciBcImJlZCBsaWtlXCIgZmlsZXMgKHRhYiBkZWxpbWl0ZWQgZmlsZXMgd2l0aCAxIGZlYXR1cmUgcGVyIGxpbmU6IGJlZCwgZ2ZmLCB2Y2YsIGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5jbGFzcyBGZWF0dXJlRmlsZVJlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxkZWNfZnVuY3Rpb24pIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgICAgIGlmIChjb25maWcubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxGaWxlID0gY29uZmlnLmxvY2FsRmlsZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGNvbmZpZy5sb2NhbEZpbGUubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcclxuICAgICAgICAgICAgdGhpcy5pbmRleFVSTCA9IGNvbmZpZy5pbmRleFVSTDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkVVJMID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5maWxlbmFtZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cmlQYXJ0cyA9IFV0aWxzLnBhcnNlVXJpKGNvbmZpZy51cmwpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gdXJpUGFydHMuZmlsZTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gdXJpUGFydHMucGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gY29uZmlnLmZvcm1hdDtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB0aGlzLmdldFBhcnNlcih0aGlzLmZvcm1hdCwgZGVjX2Z1bmN0aW9uKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGdldFBhcnNlcihmb3JtYXQsIGRlY29kZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2Y2ZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmNmUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZWdcIiA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlZ1BhcnNlcigpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlUGFyc2VyKGZvcm1hdCwgZGVjb2RlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWcgZmlsZXMgZG9uJ3QgaGF2ZSBhbiBpbmRleFxyXG4gICAgaXNJbmRleGFibGUoKSB7XHJcbiAgICAgICAgdmFyIGNvbmZpZ0luZGV4VVJMID0gdGhpcy5jb25maWcuaW5kZXhVUkwsXHJcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbmZpZ0luZGV4ZWQgPSB0aGlzLmNvbmZpZy5pbmRleGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gY29uZmlnSW5kZXhVUkwgfHwgKHR5cGUgIT0gXCJ3aWdcIiAmJiBjb25maWdJbmRleGVkICE9IGZhbHNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgYXN5bmMgbG9hZGVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGxvYWRJbmRleCgpIHtcclxuICAgICAgICB2YXIgaWR4RmlsZSA9IHRoaXMuaW5kZXhVUkw7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsZW5hbWUuZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgaWYgKCFpZHhGaWxlKSBpZHhGaWxlID0gdGhpcy51cmwgKyBcIi50YmlcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRCYW1JbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlkeEZpbGUpIGlkeEZpbGUgPSB0aGlzLnVybCArIFwiLmlkeFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9hZFRyaWJibGVJbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRGZWF0dXJlc05vSW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IHNlbGYucGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLCAgICAgICAgICAgLy8gaHR0cCBoZWFkZXJzLCBub3QgZmlsZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGEoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSBwYXJzZXIucGFyc2VIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIgaW5zdGFuY2VvZiBTdHJpbmcgJiYgc2VsZi5oZWFkZXIuc3RhcnRzV2l0aChcIiMjZ2ZmLXZlcnNpb24gM1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZm9ybWF0ID0gJ2dmZjMnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChwYXJzZXIucGFyc2VGZWF0dXJlcyhkYXRhKSk7ICAgLy8gPD0gUEFSU0lORyBET05FIEhFUkVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiBcclxuXHJcbiAgICBsb2FkRmVhdHVyZXNXaXRoSW5kZXgoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleCxcclxuICAgICAgICAgICAgICAgIHRhYml4ID0gaW5kZXggJiYgaW5kZXgudGFiaXgsXHJcbiAgICAgICAgICAgICAgICByZWZJZCA9IHRhYml4ID8gaW5kZXguc2VxdWVuY2VJbmRleE1hcFtjaHJdIDogY2hyLFxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGJsb2NrcyA9IGluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZklkLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYmxvY2tzIHx8IGJsb2Nrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7ICAgICAgIC8vIFRPRE8gLS0gaXMgdGhpcyBjb3JyZWN0PyAgU2hvdWxkIGl0IHJldHVybiBhbiBlbXB0eSBhcnJheT9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBibG9jay5taW52LmJsb2NrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBibG9jay5taW52Lm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IGJsb2NrLm1heHYuYmxvY2sgKyAoaW5kZXgudGFiaXggPyBGX01BWF9HWklQX0JMT0NLX1NJWkUgOiAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc3RhcnRQb3MsIHNpemU6IGVuZFBvcyAtIHN0YXJ0UG9zICsgMX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGVkLCBzbGljZWREYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleC50YWJpeCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsYXRlZCA9IGlndnhoci5hcnJheUJ1ZmZlclRvU3RyaW5nKHVuYmd6ZihkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBkZWNvbXByZXNzIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxhdGVkID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWREYXRhID0gc3RhcnRPZmZzZXQgPyBpbmZsYXRlZC5zbGljZShzdGFydE9mZnNldCkgOiBpbmZsYXRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc2VsZi5wYXJzZXIucGFyc2VGZWF0dXJlcyhzbGljZWREYXRhLGNocixzdGFydCxlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3luYyBsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4LnRhYml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmcoc2VsZi51cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcykuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVBcnJheXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGFsbEZlYXR1cmVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUFycmF5cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBmZWF0dXJlQXJyYXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChmZWF0dXJlQXJyYXlzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxsRmVhdHVyZXMpXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG4gICAgXHJcblxyXG5cclxuICAgIGdldEluZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaXNJbmRlZWRJbmRleGlibGUgPSB0aGlzLmlzSW5kZXhhYmxlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4ZWQgPT09IHVuZGVmaW5lZCAmJiBpc0luZGVlZEluZGV4aWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpOyAgIC8vIElzIGVpdGhlciBhbHJlYWR5IGxvYWRlZCwgb3IgdGhlcmUgaXNuJ3Qgb25lXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmhlYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGZvcmNlIGEgbG9hZCBvZiB0aGUgaW5kZXggZmlyc3RcclxuXHJcbiAgICAgICAgICAgICAgIHNlbGYuIGdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIGZpbGUgaGVhZGVyIChub3QgSFRUUCBoZWFkZXIpIGZvciBhbiBpbmRleGVkIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gbm90ZSB0aGlzIHdpbGwgZmFpbCBpZiB0aGUgZmlsZSBoZWFkZXIgaXMgPiA2NWtiIGluIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmd6OiBpbmRleC50YWJpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiA2NTAwMH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhlYWRlciA9IHNlbGYucGFyc2VyLnBhcnNlSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5oZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzTm9JbmRleCh1bmRlZmluZWQpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gc2VsZi5oZWFkZXIgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuZmVhdHVyZXMgPSBmZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bGZpbGxcclxuICAgICAqIEBwYXJhbSByYW5nZSAtLSBnZW5vbWljIHJhbmdlIHRvIGxvYWQuICBGb3IgdXNlIHdpdGggaW5kZXhlZCBzb3VyY2UgKG9wdGlvbmFsKVxyXG4gICAgICovXHJcbiAgICByZWFkRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRGZWF0dXJlc1dpdGhJbmRleChjaHIsIHN0YXJ0LCBlbmQpLnRoZW4ocGFja0ZlYXR1cmVzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkRmVhdHVyZXNOb0luZGV4KCkudGhlbihwYWNrRmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYWNrRmVhdHVyZXMoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcGFja1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChmZWF0dXJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqanMvZmVhdHVyZS9GZWF0dXJlUGFyc2Vycy5qcyoqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgbWF4RmVhdHVyZUNvdW50ID0gTnVtYmVyLk1BWF9WQUxVRTsgICAgLy8gRm9yIGZ1dHVyZSB1c2UsICBjb250cm9scyBkb3duc2FtcGxpbmdcclxuXHJcbmNvbnN0IGdmZk5hbWVGaWVsZHMgPSBbXCJOYW1lXCIsIFwiZ2VuZV9uYW1lXCIsIFwiZ2VuZVwiLCBcImdlbmVfaWRcIiwgXCJhbGlhc1wiLCBcImxvY3VzXCJdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmYWN0b3J5IGZ1bmN0aW9uLiAgUmV0dXJuIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gZmlsZSBmb3JtYXQuXHJcbiAgICAgKi9cclxuY2xhc3MgRmVhdHVyZVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCwgZGVjb2RlX2Z1bmMsIGNvbmZpZykge1xyXG5cclxuICAgICAgICB2YXIgY3VzdG9tRm9ybWF0O1xyXG5cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLm5hbWVGaWVsZCA9IGNvbmZpZyA/IGNvbmZpZy5uYW1lRmllbGQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5za2lwUm93cyA9IDA7ICAgLy8gVGhlIG51bWJlciBvZiBmaXhlZCBoZWFkZXIgcm93cyB0byBza2lwLiAgT3ZlcnJpZGUgZm9yIHNwZWNpZmljIHR5cGVzIGFzIG5lZWRlXHJcblxyXG4gICAgICAgIGlmIChkZWNvZGVfZnVuYykge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlID1mdW5jdGlvbih0b2tlbnMsaWdub3JlKXtcclxuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlPXtjaHI6dG9rZW5zWzBdLHN0YXJ0OnBhcnNlSW50KHRva2Vuc1sxXSksZW5kOnBhcnNlSW50KHRva2Vuc1syXSl9XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVfZnVuYyh0b2tlbnMuc2xpY2UoMyksZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICAgICAgfSA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWNvZGVfZnVuY3Rpb249PT1cImdlbmVyaWNcIil7XHJcbiAgICAgICAgICAgICB0aGlzLmRlY29kZSA9ZnVuY3Rpb24odG9rZW5zLGlnbm9yZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZT17Y2hyOnRva2Vuc1swXSxzdGFydDpwYXJzZUludCh0b2tlbnNbMV0pLGVuZDpwYXJzZUludCh0b2tlbnNbMl0pfVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5kYXRhPXRva2Vucy5zbGljZSgzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG4gICAgICAgICAgICB9IDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSBGZWF0dXJlUGFyc2VyLmRlY29kZUJlZDtcclxuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuXHJcbiAgICAgICAvKiBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFycm93cGVha1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRwZWFrXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZWFrc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlY29kZVBlYWs7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmVkZ3JhcGhcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVCZWRHcmFwaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3aWdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVXaWc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2ZmM1wiIDpcclxuICAgICAgICAgICAgY2FzZSBcImdmZlwiIDpcclxuICAgICAgICAgICAgY2FzZSBcImd0ZlwiIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVHRkY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImFuZXVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVBbmV1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmdXNpb25qdW5jc3BhblwiOlxyXG4gICAgICAgICAgICAgICAgLy8gYmhhYXMsIG5lZWRlZCBmb3IgRnVzaW9uSW5zcGVjdG9yIHZpZXdcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVGdXNpb25KdW5jU3BhbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJndGV4Z3dhc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwUm93cyA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlR3RleEdXQVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJlZmZsYXRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVSZWZmbGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICBjdXN0b21Gb3JtYXQgPSBpZ3YuYnJvd3Nlci5nZXRGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Gb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gZGVjb2RlQ3VzdG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gY3VzdG9tRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gY3VzdG9tRm9ybWF0LmRlbGltaXRlciB8fCBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgfSovXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZUhlYWRlcihkYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIiksXHJcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaGVhZGVyO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJicm93c2VyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSB0aGlzLnBhcnNlVHJhY2tMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiIyNnZmYtdmVyc2lvbiAzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBcImdmZjNcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcikgaGVhZGVyID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyW1wiZm9ybWF0XCJdID0gXCJnZmYzXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXI9e307XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZUZlYXR1cmVzKGRhdGEsY2hyLHN0YXJ0LGVuZCkge1xyXG5cclxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgd2lnLFxyXG4gICAgICAgICAgICBmZWF0dXJlLFxyXG4gICAgICAgICAgICBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIiksXHJcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgdG9rZW5zLFxyXG4gICAgICAgICAgICBhbGxGZWF0dXJlcyA9IFtdLFxyXG4gICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBjbnQgPSAwLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBkZWNvZGUgPSB0aGlzLmRlY29kZSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQsXHJcbiAgICAgICAgICAgIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyIHx8IFwiXFx0XCI7XHJcblxyXG5cclxuICAgICAgICBmb3IgKGkgPSB0aGlzLnNraXBSb3dzOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJicm93c2VyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwid2lnXCIgJiYgbGluZS5zdGFydHNXaXRoKFwiZml4ZWRTdGVwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB3aWcgPSB0aGlzLnBhcnNlRml4ZWRTdGVwKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIndpZ1wiICYmIGxpbmUuc3RhcnRzV2l0aChcInZhcmlhYmxlU3RlcFwiKSkge1xyXG4gICAgICAgICAgICAgICAgd2lnID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RlcChsaW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2tlbnMgPSBsaW5lc1tpXS5zcGxpdChkZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDEgfHwgKGZvcm1hdCE9PVwid2lnXCIgJiYgdG9rZW5zLmxlbmd0aDwzKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0gdGhpcy5kZWNvZGUodG9rZW5zLCB3aWcpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jaHIgIT09Y2hyIHx8IGZlYXR1cmUuZW5kPHN0YXJ0IHx8IGZlYXR1cmUuc3RhcnQ+ZW5kKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlcy5sZW5ndGggPCBtYXhGZWF0dXJlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXJ2b2lyIHNhbXBsaW5nLCAgY29uZGl0aW9uYWxseSByZXBsYWNlIGV4aXN0aW5nIGZlYXR1cmUgd2l0aCBuZXcgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbWF4RmVhdHVyZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzW2pdID0gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxGZWF0dXJlcztcclxuICAgIH07XHJcblxyXG5cclxuICAgIHN0YXRpYyBwYXJzZUZpeGVkU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3MgPSBwYXJzZUludCh0b2tlbnNbMl0uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHN0ZXAgPSBwYXJzZUludCh0b2tlbnNbM10uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHNwYW4gPSAodG9rZW5zLmxlbmd0aCA+IDQpID8gcGFyc2VJbnQodG9rZW5zWzRdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtmb3JtYXQ6IFwiZml4ZWRTdGVwXCIsIGNocm9tOiBjYywgc3RhcnQ6IHNzLCBzdGVwOiBzdGVwLCBzcGFuOiBzcGFuLCBpbmRleDogMH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVZhcmlhYmxlU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3BhbiA9IHRva2Vucy5sZW5ndGggPiAyID8gcGFyc2VJbnQodG9rZW5zWzJdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuICAgICAgICByZXR1cm4ge2Zvcm1hdDogXCJ2YXJpYWJsZVN0ZXBcIiwgY2hyb206IGNjLCBzcGFuOiBzcGFufVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VUcmFja0xpbmUobGluZSkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge30sXHJcbiAgICAgICAgICAgIHRva2VucyA9IGxpbmUuc3BsaXQoLyg/OlwiKShbXlwiXSspKD86XCIpfChbXlxcc1wiXSspKD89XFxzK3wkKS9nKSxcclxuICAgICAgICAgICAgdG1wID0gW10sXHJcbiAgICAgICAgICAgIGksIHRrLCBjdXJyO1xyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCB0b2tlbnMgYXJyYXlcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdG9rZW5zW2ldIHx8IHRva2Vuc1tpXS50cmltKCkubGVuZ3RoID09PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHRrID0gdG9rZW5zW2ldLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ay5lbmRzV2l0aChcIj1cIikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gdGs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3Vycikge1xyXG4gICAgICAgICAgICAgICAgdG1wLnB1c2goY3VyciArIHRrKTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0bXAucHVzaCh0ayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdG1wLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICBpZiAoIXN0cikgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIga3YgPSBzdHIuc3BsaXQoJz0nLCAyKTtcclxuICAgICAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2t2WzBdXSA9IGt2WzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSB0aGUgXCJzdGFuZGFyZFwiIFVDU0MgYmVkIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgZGVjb2RlZCBmZWF0dXJlLCBvciBudWxsIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgcmVjb3JkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVCZWQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgaWQsIG5hbWUsIHRtcCwgaWROYW1lLCBleG9uQ291bnQsIGV4b25TaXplcywgZXhvblN0YXJ0cywgZXhvbnMsIGV4b24sIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGVTdGFydCwgZUVuZDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICBlbmQgPSB0b2tlbnMubGVuZ3RoID4gMiA/IHBhcnNlSW50KHRva2Vuc1syXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHNjb3JlOiAxMDAwfTtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXNlIGFyZSB2ZXJ5IHNwZWNpYWwgcnVsZXMgZm9yIHRoZSBnZW5jb2RlIGdlbmUgZmlsZXMuXHJcbiAgICAgICAgICAgIHRtcCA9IHRva2Vuc1szXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgICAgIGlkTmFtZSA9IHRtcC5zcGxpdCgnOycpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkTmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGt2ID0gaWROYW1lW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa3ZbMF0gPT0gXCJnZW5lX2lkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IGt2WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGt2WzBdID09IFwiZ2VuZV9uYW1lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga3ZbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmVhdHVyZS5pZCA9IGlkID8gaWQgOiB0bXA7XHJcbiAgICAgICAgICAgIGZlYXR1cmUubmFtZSA9IG5hbWUgPyBuYW1lIDogdG1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNSkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnN0cmFuZCA9IHRva2Vuc1s1XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA2KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuY2RTdGFydCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNykge1xyXG4gICAgICAgICAgICBmZWF0dXJlLmNkRW5kID0gcGFyc2VJbnQodG9rZW5zWzddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbnNbOF0gIT09IFwiLlwiICYmIHRva2Vuc1s4XSAhPT0gXCIwXCIpXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRva2Vuc1s4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMTEpIHtcclxuICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzldKTtcclxuICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzExXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIGVFbmQgPSBlU3RhcnQgKyBwYXJzZUludChleG9uU2l6ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4b24gPSB7c3RhcnQ6IGVTdGFydCwgZW5kOiBlRW5kfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID4gZUVuZCB8fCBmZWF0dXJlLmNkRW5kIDwgZmVhdHVyZS5jZFN0YXJ0KSBleG9uLnV0ciA9IHRydWU7ICAgLy8gRW50aXJlIGV4b24gaXMgVVRSXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID49IGVTdGFydCAmJiBmZWF0dXJlLmNkU3RhcnQgPD0gZUVuZCkgZXhvbi5jZFN0YXJ0ID0gZmVhdHVyZS5jZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuY2RFbmQgPj0gZVN0YXJ0ICYmIGZlYXR1cmUuY2RFbmQgPD0gZUVuZCkgZXhvbi5jZEVuZCA9IGZlYXR1cmUuY2RFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZXhvbnMucHVzaChleG9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLm5hbWUpIGRhdGEucHVzaCh7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9KTtcclxuICAgICAgICAgICAgaWYgKFwiK1wiID09PSBmZWF0dXJlLnN0cmFuZCB8fCBcIi1cIiA9PT0gZmVhdHVyZS5zdHJhbmQpIGRhdGEucHVzaCh7bmFtZTogXCJTdHJhbmRcIiwgdmFsdWU6IGZlYXR1cmUuc3RyYW5kfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBhIFVDU0MgXCJyZWZmbGF0XCIgcmVjb3JkXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZVJlZmZsYXQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAxMCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlID0ge1xyXG4gICAgICAgICAgICAgICAgY2hyOiB0b2tlbnNbMl0sXHJcbiAgICAgICAgICAgICAgICBzdGFydDogcGFyc2VJbnQodG9rZW5zWzRdKSxcclxuICAgICAgICAgICAgICAgIGVuZDogcGFyc2VJbnQodG9rZW5zWzVdKSxcclxuICAgICAgICAgICAgICAgIGlkOiB0b2tlbnNbMV0sXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbnNbMF0sXHJcbiAgICAgICAgICAgICAgICBzdHJhbmQ6IHRva2Vuc1szXSxcclxuICAgICAgICAgICAgICAgIGNkU3RhcnQ6IHBhcnNlSW50KHRva2Vuc1s2XSksXHJcbiAgICAgICAgICAgICAgICBjZEVuZDogcGFyc2VJbnQodG9rZW5zWzddKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleG9uQ291bnQgPSBwYXJzZUludCh0b2tlbnNbOF0pLFxyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzldLnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgIGV4b25FbmRzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBwYXJzZUludChleG9uU3RhcnRzW2ldKSwgZW5kOiBwYXJzZUludChleG9uRW5kc1tpXSl9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZlYXR1cmUuZXhvbnMgPSBleG9ucztcclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVQZWFrKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICBuYW1lID0gdG9rZW5zWzNdO1xyXG4gICAgICAgIHNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIHN0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgc2lnbmFsID0gcGFyc2VGbG9hdCh0b2tlbnNbNl0pO1xyXG4gICAgICAgIHBWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzddKTtcclxuICAgICAgICBxVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s4XSk7XHJcblxyXG4gICAgICAgIGlmIChzY29yZSA9PT0gMCkgc2NvcmUgPSBzaWduYWw7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBuYW1lOiBuYW1lLCBzY29yZTogc2NvcmUsIHN0cmFuZDogc3RyYW5kLCBzaWduYWw6IHNpZ25hbCxcclxuICAgICAgICAgICAgcFZhbHVlOiBwVmFsdWUsIHFWYWx1ZTogcVZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlQmVkR3JhcGgodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1szXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHZhbHVlOiB2YWx1ZX07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZyh0b2tlbnMsIHdpZykge1xyXG5cclxuICAgICAgICB2YXIgc3MsXHJcbiAgICAgICAgICAgIGVlLFxyXG4gICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHdpZy5mb3JtYXQgPT09IFwiZml4ZWRTdGVwXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHNzID0gKHdpZy5pbmRleCAqIHdpZy5zdGVwKSArIHdpZy5zdGFydDtcclxuICAgICAgICAgICAgZWUgPSBzcyArIHdpZy5zcGFuO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzBdKTtcclxuICAgICAgICAgICAgKysod2lnLmluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IG51bGwgOiB7Y2hyOiB3aWcuY2hyb20sIHN0YXJ0OiBzcywgZW5kOiBlZSwgdmFsdWU6IHZhbHVlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2lnLmZvcm1hdCA9PT0gXCJ2YXJpYWJsZVN0ZXBcIikge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHNzID0gcGFyc2VJbnQodG9rZW5zWzBdLCAxMCk7XHJcbiAgICAgICAgICAgIGVlID0gc3MgKyB3aWcuc3BhbjtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBudWxsIDoge2Nocjogd2lnLmNocm9tLCBzdGFydDogc3MsIGVuZDogZWUsIHZhbHVlOiB2YWx1ZX07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJlZEdyYXBoKHRva2Vucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVBbmV1KHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHIsIHN0YXJ0LCBlbmQsIGZlYXR1cmU7XHJcblxyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIGVuZCA9IHRva2Vucy5sZW5ndGggPiAzID8gcGFyc2VJbnQodG9rZW5zWzNdKSA6IHN0YXJ0ICsgMTtcclxuXHJcbiAgICAgICAgZmVhdHVyZSA9IHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICBmZWF0dXJlLnZhbHVlID0gZmVhdHVyZS5zY29yZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUZ1c2lvbkp1bmNTcGFuKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIEZvcm1hdDpcclxuXHJcbiAgICAgICAgIDAgICAgICAgI3NjYWZmb2xkXHJcbiAgICAgICAgIDEgICAgICAgZnVzaW9uX2JyZWFrX25hbWVcclxuICAgICAgICAgMiAgICAgICBicmVha19sZWZ0XHJcbiAgICAgICAgIDMgICAgICAgYnJlYWtfcmlnaHRcclxuICAgICAgICAgNCAgICAgICBudW1fanVuY3Rpb25fcmVhZHNcclxuICAgICAgICAgNSAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3NcclxuICAgICAgICAgNiAgICAgICBzcGFubmluZ19mcmFnX2Nvb3Jkc1xyXG5cclxuICAgICAgICAgMCAgICAgICBCM0dOVDEtLU5QU1IxXHJcbiAgICAgICAgIDEgICAgICAgQjNHTlQxLS1OUFNSMXwyMjAzLTEwMTgyXHJcbiAgICAgICAgIDIgICAgICAgMjIwM1xyXG4gICAgICAgICAzICAgICAgIDEwMTgyXHJcbiAgICAgICAgIDQgICAgICAgMTg5XHJcbiAgICAgICAgIDUgICAgICAgMTEzOFxyXG4gICAgICAgICA2ICAgICAgIDE4NjAtMTM3NTcsMTc5OC0xMzgxOSwxMzkxLTE4MTI3LDE0NDMtMTcxNzQsLi4uXHJcblxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICB2YXIgZnVzaW9uX25hbWUgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgdmFyIGp1bmN0aW9uX2xlZnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIHZhciBqdW5jdGlvbl9yaWdodCA9IHBhcnNlSW50KHRva2Vuc1szXSk7XHJcbiAgICAgICAgdmFyIG51bV9qdW5jdGlvbl9yZWFkcyA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgdmFyIG51bV9zcGFubmluZ19mcmFncyA9IHBhcnNlSW50KHRva2Vuc1s1XSk7XHJcblxyXG4gICAgICAgIHZhciBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0ID0gdG9rZW5zWzZdO1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSA9IHtcclxuICAgICAgICAgICAgY2hyOiBjaHIsXHJcbiAgICAgICAgICAgIG5hbWU6IGZ1c2lvbl9uYW1lLFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9sZWZ0OiBqdW5jdGlvbl9sZWZ0LFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9yaWdodDoganVuY3Rpb25fcmlnaHQsXHJcbiAgICAgICAgICAgIG51bV9qdW5jdGlvbl9yZWFkczogbnVtX2p1bmN0aW9uX3JlYWRzLFxyXG4gICAgICAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3M6IG51bV9zcGFubmluZ19mcmFncyxcclxuICAgICAgICAgICAgc3Bhbm5pbmdfZnJhZ19jb29yZHM6IFtdLFxyXG5cclxuICAgICAgICAgICAgc3RhcnQ6IC0xLFxyXG4gICAgICAgICAgICBlbmQ6IC0xXHJcbiAgICAgICAgfTsgLy8gc2V0IHN0YXJ0IGFuZCBlbmQgbGF0ZXIgYmFzZWQgb24gbWluL21heCBvZiBzcGFuIGNvb3Jkc1xyXG5cclxuICAgICAgICB2YXIgbWluX2Nvb3JkID0ganVuY3Rpb25fbGVmdDtcclxuICAgICAgICB2YXIgbWF4X2Nvb3JkID0ganVuY3Rpb25fcmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChudW1fc3Bhbm5pbmdfZnJhZ3MgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmRfcGFpcnMgPSBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0LnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkX3BhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRfY29vcmRzID0gY29vcmRfcGFpcnNbaV0uc3BsaXQoJy0nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3Bhbl9sZWZ0ID0gc3BsaXRfY29vcmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5fcmlnaHQgPSBzcGxpdF9jb29yZHNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwYW5fbGVmdCA8IG1pbl9jb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb29yZCA9IHNwYW5fbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzcGFuX3JpZ2h0ID4gbWF4X2Nvb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvb3JkID0gc3Bhbl9yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc3Bhbm5pbmdfZnJhZ19jb29yZHMucHVzaCh7bGVmdDogc3Bhbl9sZWZ0LCByaWdodDogc3Bhbl9yaWdodH0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5zdGFydCA9IG1pbl9jb29yZDtcclxuICAgICAgICBmZWF0dXJlLmVuZCA9IG1heF9jb29yZDtcclxuXHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX1dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlR3RleEdXQVModG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1szXS5zcGxpdCgnOicpWzFdKTtcclxuICAgICAgICAvL25hbWUgPSB0b2tlbnNbM107XHJcbiAgICAgICAgLy9zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICAvL3N0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgLy9zaWduYWwgPSBwYXJzZUZsb2F0KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgcFZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbNV0pO1xyXG4gICAgICAgIC8vcVZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbOF0pO1xyXG5cclxuICAgICAgICAvL3JldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIG5hbWU6IG5hbWUsIHNjb3JlOiBzY29yZSwgc3RyYW5kOiBzdHJhbmQsIHNpZ25hbDogc2lnbmFsLFxyXG4gICAgICAgIC8vICAgIHBWYWx1ZTogcFZhbHVlLCBxVmFsdWU6IHFWYWx1ZX07XHJcbiAgICAgICAgcmV0dXJuIHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcHZhbHVlOiBwVmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIGEgc2luZ2xlIGdmZiByZWNvcmQgKDEgbGluZSBpbiBmaWxlKS4gIEFnZ3JlZ2F0aW9ucyBzdWNoIGFzIGdlbmUgbW9kZWxzIGFyZSBjb25zdHJ1Y3RlZCBhdCBhIGhpZ2hlciBsZXZlbC5cclxuICAgICAqICAgICAgY3RnMTIzIC4gbVJOQSAgICAgICAgICAgIDEwNTAgIDkwMDAgIC4gICsgIC4gIElEPW1STkEwMDAwMTtQYXJlbnQ9Z2VuZTAwMDAxXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZUdGRih0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5Db3VudCwgY2hyLCBzdGFydCwgZW5kLCBzdHJhbmQsIHR5cGUsIHNjb3JlLCBwaGFzZSwgYXR0cmlidXRlU3RyaW5nLCBpZCwgcGFyZW50LCBjb2xvciwgbmFtZSxcclxuICAgICAgICAgICAgdHJhbnNjcmlwdF9pZCwgaSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgICAgICAvLyBOb3QgYSB2YWxpZCBnZmYgcmVjb3JkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgdHlwZSA9IHRva2Vuc1syXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1szXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgc2NvcmUgPSBcIi5cIiA9PT0gdG9rZW5zWzVdID8gMCA6IHBhcnNlRmxvYXQodG9rZW5zWzVdKTtcclxuICAgICAgICBzdHJhbmQgPSB0b2tlbnNbNl07XHJcbiAgICAgICAgcGhhc2UgPSBcIi5cIiA9PT0gdG9rZW5zWzddID8gMCA6IHBhcnNlSW50KHRva2Vuc1s3XSk7XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nID0gdG9rZW5zWzhdO1xyXG5cclxuICAgICAgICAvLyBGaW5kIElEIGFuZCBQYXJlbnQsIG9yIHRyYW5zY3JpcHRfaWRcclxuICAgICAgICB2YXIgZGVsaW0gPSAoJ2dmZjMnID09PSBmb3JtYXQpID8gJz0nIDogL1xccysvO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBrdi50cmltKCkuc3BsaXQoZGVsaW0sIDIpLCBrZXksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gdFswXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgcXVvdGVzLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJJRFwiID09PSB0WzBdKSBpZCA9IHRbMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIlBhcmVudFwiID09PSB0WzBdKSBwYXJlbnQgPSB0WzFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJjb2xvclwiID09PSB0WzBdLnRvTG93ZXJDYXNlKCkpIGNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJ0cmFuc2NyaXB0X2lkXCIgPT09IHRbMF0pIGlkID0gdFsxXTsgICAgIC8vIGd0ZiBmb3JtYXRcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgbmFtZSAobGFiZWwpIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKHRoaXMubmFtZUZpZWxkKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGVzW3RoaXMubmFtZUZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmZOYW1lRmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShnZmZOYW1lRmllbGRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZUZpZWxkID0gZ2ZmTmFtZUZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlc1t0aGlzLm5hbWVGaWVsZF07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGNocjogY2hyLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICBzY29yZTogc2NvcmUsXHJcbiAgICAgICAgICAgIHN0cmFuZDogc3RyYW5kLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZVN0cmluZzogYXR0cmlidXRlU3RyaW5nLFxyXG4gICAgICAgICAgICBwb3B1cERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrdnMgPSB0aGlzLmF0dHJpYnV0ZVN0cmluZy5zcGxpdCgnOycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBkID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGt2cy5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga3YudHJpbSgpLnNwbGl0KGRlbGltLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPT09IDIgJiYgdFsxXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHRbMF0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1N0cmlwIG9mZiBxdW90ZXMsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXCInKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGQucHVzaCh7bmFtZToga2V5LCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIHRoZSBcInN0YW5kYXJkXCIgVUNTQyBiZWQgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyBkZWNvZGVkIGZlYXR1cmUsIG9yIG51bGwgaWYgdGhpcyBpcyBub3QgYSB2YWxpZCByZWNvcmRcclxuICAgICAqL1xyXG4gICAgZGVjb2RlQ3VzdG9tKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlLFxyXG4gICAgICAgICAgICBjaHIsIHN0YXJ0LCBlbmQsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0LCAgICAgICAgIC8vIFwidGhpc1wiIHJlZmVycyB0byBGZWF0dXJlUGFyc2VyIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvb3JkcyA9IGZvcm1hdC5jb29yZHMgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zW2Zvcm1hdC5jaHJdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zW2Zvcm1hdC5zdGFydF0pIC0gY29vcmRzO1xyXG4gICAgICAgIGVuZCA9IGZvcm1hdC5lbmQgIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHRva2Vuc1tmb3JtYXQuZW5kXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xyXG5cclxuICAgICAgICBpZiAoZm9ybWF0LmZpZWxkcykge1xyXG4gICAgICAgICAgICBmb3JtYXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IGZvcm1hdC5jaHIgJiYgaW5kZXggIT0gZm9ybWF0LnN0YXJ0ICYmIGluZGV4ICE9IGZvcm1hdC5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKipqcy9mZWF0dXJlL2ZlYXR1cmVDYWNoZS5qcyoqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYmplY3QgZm9yIGNhY2hpbmcgbGlzdHMgb2YgZmVhdHVyZXMuICBTdXBwb3J0cyBlZmZlY2llbnQgcXVlcmllcyBmb3Igc3ViLXJhbmdlICAoY2hyLCBzdGFydCwgZW5kKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlTGlzdFxyXG4gICAgICogQHBhcmFtIFRoZSBnZW5vbWljIHJhbmdlIHNwYW5uZWQgYnkgZmVhdHVyZUxpc3QgKG9wdGlvbmFsKVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuXHJcbmNsYXNzIEZlYXR1cmVDYWNoZXtcclxuICAgIGNvbnN0cnVjdG9yKGZlYXR1cmVMaXN0LCByYW5nZSkge1xyXG4gICAgICAgIHRoaXMudHJlZU1hcCA9IEZlYXR1cmVDYWNoZS5idWlsZFRyZWVNYXAoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICBxdWVyeUZlYXR1cmVzKGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmVMaXN0LCBpbnRlcnZhbEZlYXR1cmVzLCBmZWF0dXJlLCBsZW4sIGksIHRyZWUsIGludGVydmFscztcclxuXHJcbiAgICAgICAgdHJlZSA9IHRoaXMudHJlZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICBpZiAoIXRyZWUpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgaW50ZXJ2YWxzID0gdHJlZS5maW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcnZhbHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVHJpbSB0aGUgbGlzdCBvZiBmZWF0dXJlcyBpbiB0aGUgaW50ZXJ2YWxzIHRvIHRob3NlXHJcbiAgICAgICAgICAgIC8vIG92ZXJsYXBwaW5nIHRoZSByZXF1ZXN0ZWQgcmFuZ2UuXHJcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IGZlYXR1cmVzIGFyZSBzb3J0ZWQgYnkgc3RhcnQgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gW107XHJcblxyXG4gICAgICAgICAgICBpbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsRmVhdHVyZXMgPSBpbnRlcnZhbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGludGVydmFsRmVhdHVyZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IGludGVydmFsRmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBlbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZW5kID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0LnB1c2goZmVhdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZUxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgYWxsRmVhdHVyZXMoKSB7XHJcblxyXG4gICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0cmVlTWFwID0gdGhpcy50cmVlTWFwO1xyXG4gICAgICAgIGlmICh0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJlZU1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlID0gdHJlZU1hcFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWUubWFwSW50ZXJ2YWxzKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChpbnRlcnZhbC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbEZlYXR1cmVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYnVpbGRUcmVlTWFwKGZlYXR1cmVMaXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlQ2FjaGUgPSB7fSxcclxuICAgICAgICAgICAgY2hyb21vc29tZXMgPSBbXSxcclxuICAgICAgICAgICAgdHJlZU1hcCA9IHt9LFxyXG4gICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gZmVhdHVyZS5jaHIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VuZUxpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIFwib2ZmaWNpYWxcIiBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZihnZW5vbWUpIGNociA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShjaHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlbmVMaXN0ID0gZmVhdHVyZUNhY2hlW2Nocl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFnZW5lTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tb3NvbWVzLnB1c2goY2hyKTtcclxuICAgICAgICAgICAgICAgICAgICBnZW5lTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVDYWNoZVtjaHJdID0gZ2VuZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VuZUxpc3QucHVzaChmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBidWlsZCBpbnRlcnZhbCB0cmVlIGZvciBlYWNoIGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hyb21vc29tZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaHIgPSBjaHJvbW9zb21lc1tpXTtcclxuICAgICAgICAgICAgICAgIHRyZWVNYXBbY2hyXSA9RmVhdHVyZUNhY2hlLmJ1aWxkSW50ZXJ2YWxUcmVlKGZlYXR1cmVDYWNoZVtjaHJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWVNYXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYW4gaW50ZXJ2YWwgdHJlZSBmcm9tIHRoZSBmZWF0dXJlIGxpc3QgZm9yIGZhc3QgaW50ZXJ2YWwgYmFzZWQgcXVlcmllcy4gICBXZSBsdW1wIGZlYXR1cmVzIGluIGdyb3Vwc1xyXG4gICAgICogb2YgMTAsIG9yIHRvdGFsIHNpemUgLyAxMDAsICAgdG8gcmVkdWNlIHNpemUgb2YgdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVMaXN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBidWlsZEludGVydmFsVHJlZShmZWF0dXJlTGlzdCkge1xyXG5cclxuICAgICAgICB2YXIgaSwgZSwgaVN0YXJ0LCBpRW5kLCB0cmVlLCBjaHVua1NpemUsIGxlbiwgc3ViQXJyYXk7XHJcblxyXG4gICAgICAgIHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICAgICAgbGVuID0gZmVhdHVyZUxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBjaHVua1NpemUgPSBNYXRoLm1heCgxMCwgTWF0aC5yb3VuZChsZW4gLyAxMDApKTtcclxuXHJcbiAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoZjEsIGYyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZjEuc3RhcnQgPT09IGYyLnN0YXJ0ID8gMCA6IChmMS5zdGFydCA+IGYyLnN0YXJ0ID8gMSA6IC0xKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLm1pbihsZW4sIGkgKyBjaHVua1NpemUpO1xyXG4gICAgICAgICAgICBzdWJBcnJheSA9IGZlYXR1cmVMaXN0LnNsaWNlKGksIGUpO1xyXG4gICAgICAgICAgICBpU3RhcnQgPSBzdWJBcnJheVswXS5zdGFydDtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgaUVuZCA9IGlTdGFydDtcclxuICAgICAgICAgICAgc3ViQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaUVuZCA9IE1hdGgubWF4KGlFbmQsIGZlYXR1cmUuZW5kKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyZWUuaW5zZXJ0KGlTdGFydCwgaUVuZCwgc3ViQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuLy8qKioqKmpzL2ludGVydmFsVHJlZS5qcyoqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMQUNLID0gMTtcclxuY29uc3QgUkVEID0gMjtcclxuXHJcbmxldCBOSUwgPSB7fVxyXG5OSUwuY29sb3IgPSBCTEFDSztcclxuTklMLnBhcmVudCA9IE5JTDtcclxuTklMLmxlZnQgPSBOSUw7XHJcbk5JTC5yaWdodCA9IE5JTDtcclxuXHJcbiAgXHJcbmNsYXNzIEludGVydmFsVHJlZXtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyAgICBcclxuICAgICAgICB0aGlzLnJvb3QgPSBOSUw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGluc2VydChzdGFydCwgZW5kLCB2YWx1ZSkge1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnQsIGVuZCwgdmFsdWUpO1xyXG4gICAgICAgIHZhciB4ID0gbmV3IE5vZGUoaW50ZXJ2YWwpO1xyXG4gICAgICAgIHRoaXMudHJlZUluc2VydCh4KTtcclxuICAgICAgICB4LmNvbG9yID0gUkVEO1xyXG4gICAgICAgIHdoaWxlICh4ICE9IHRoaXMucm9vdCAmJiB4LnBhcmVudC5jb2xvciA9PSBSRUQpIHtcclxuICAgICAgICAgICAgaWYgKHgucGFyZW50ID09IHgucGFyZW50LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHgucGFyZW50LnBhcmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4LnBhcmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB4LnBhcmVudC5wYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Um90YXRlKHgucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb290LmNvbG9yID0gQkxBQ0s7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGFydCAtIHF1ZXJ5IGludGVydmFsXHJcbiAgICAgKiBAcGFyYW0gZW5kIC0gcXVlcnkgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCBpbnRlcnZhbHMgb3ZlcmxhcHBpbmcgdGhlIHF1ZXJ5IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICBmaW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHNlYXJjaEludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0LCBlbmQsIDApO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSBOSUwpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVydmFscyA9IHRoaXMuc2VhcmNoQWxsKHNlYXJjaEludGVydmFsLCB0aGlzLnJvb3QsIFtdKTtcclxuXHJcbiAgICAgICAgaWYoaW50ZXJ2YWxzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oaTEsIGkyKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGkxLmxvdyAtIGkyLmxvdztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHVtcCBpbmZvIG9uIGludGVydmFscyB0byBjb25zb2xlLiAgRm9yIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG4gICAgbG9nSW50ZXJ2YWxzKCkge1xyXG5cclxuICAgICAgICBsb2dOb2RlKHRoaXMucm9vdCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvZ05vZGUobm9kZSwgaW5kZW50KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpbmRlbnQ7IGkrKykgc3BhY2UgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgbm9kZS5pbnRlcnZhbC5sb3cgKyBcIiBcIiArIG5vZGUuaW50ZXJ2YWwuaGlnaCk7IC8vICsgXCIgXCIgKyAobm9kZS5pbnRlcnZhbC52YWx1ZSA/IG5vZGUuaW50ZXJ2YWwudmFsdWUgOiBcIiBudWxsXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGluZGVudCArPSA1O1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5sZWZ0ICE9IE5JTCkgbG9nTm9kZShub2RlLmxlZnQsIGluZGVudCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBsb2dOb2RlKG5vZGUucmlnaHQsIGluZGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbWFwSW50ZXJ2YWxzKGZ1bmMpIHtcclxuXHJcbiAgICAgICAgYXBwbHlJbnRlcnZhbCh0aGlzLnJvb3QpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhcHBseUludGVydmFsKG5vZGUpIHtcclxuXHJcbiAgICAgICAgICAgIGZ1bmMobm9kZS5pbnRlcnZhbCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmxlZnQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUsIHJlc3VsdHMpIHtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuaW50ZXJ2YWwub3ZlcmxhcHMoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlLmludGVydmFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLmxlZnQgIT0gTklMICYmIG5vZGUubGVmdC5tYXggPj0gaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQWxsKGludGVydmFsLCBub2RlLmxlZnQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUucmlnaHQgIT0gTklMICYmIG5vZGUucmlnaHQubWluIDw9IGludGVydmFsLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUucmlnaHQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgbGVmdFJvdGF0ZSh4KSB7XHJcbiAgICAgICAgdmFyIHkgPSB4LnJpZ2h0O1xyXG4gICAgICAgIHgucmlnaHQgPSB5LmxlZnQ7XHJcbiAgICAgICAgaWYgKHkubGVmdCAhPSBOSUwpIHtcclxuICAgICAgICAgICAgeS5sZWZ0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5sZWZ0ID09IHgpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LmxlZnQgPSB5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQucmlnaHQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJpZ2h0Um90YXRlKHgpIHtcclxuICAgICAgICB2YXIgeSA9IHgubGVmdDtcclxuICAgICAgICB4LmxlZnQgPSB5LnJpZ2h0O1xyXG4gICAgICAgIGlmICh5LnJpZ2h0ICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5LnJpZ2h0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5yaWdodCA9PSB4KSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5yaWdodCA9IHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5sZWZ0ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90ZTogIERvZXMgbm90IG1haW50YWluIFJCIGNvbnN0cmFpbnRzLCAgdGhpcyBpcyBkb25lIHBvc3QgaW5zZXJ0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggIGEgTm9kZVxyXG4gICAgICovXHJcbiAgIHRyZWVJbnNlcnQoeCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHZhciB5ID0gTklMO1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5ID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKHguaW50ZXJ2YWwubG93IDw9IG5vZGUuaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICBpZiAoeSA9PSBOSUwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0geDtcclxuICAgICAgICAgICAgeC5sZWZ0ID0geC5yaWdodCA9IE5JTDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeC5pbnRlcnZhbC5sb3cgPD0geS5pbnRlcnZhbC5sb3cpIHtcclxuICAgICAgICAgICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZSh4KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXBwbGllcyB0aGUgc3RhdGlzdGljIHVwZGF0ZSBvbiB0aGUgbm9kZSBhbmQgaXRzIGFuY2VzdG9ycy5cclxuICAgIGFwcGx5VXBkYXRlIChub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlTWF4ID0gbm9kZS5sZWZ0Lm1heCA+IG5vZGUucmlnaHQubWF4ID8gbm9kZS5sZWZ0Lm1heCA6IG5vZGUucmlnaHQubWF4O1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxIaWdoID0gbm9kZS5pbnRlcnZhbC5oaWdoO1xyXG4gICAgICAgICAgICBub2RlLm1heCA9IG5vZGVNYXggPiBpbnRlcnZhbEhpZ2ggPyBub2RlTWF4IDogaW50ZXJ2YWxIaWdoO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vZGVNaW4gPSBub2RlLmxlZnQubWluIDwgbm9kZS5yaWdodC5taW4gPyBub2RlLmxlZnQubWluIDogbm9kZS5yaWdodC5taW47XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbExvdyA9IG5vZGUuaW50ZXJ2YWwubG93O1xyXG4gICAgICAgICAgICBub2RlLm1pbiA9IG5vZGVNaW4gPCBpbnRlcnZhbExvdyA/IG5vZGVNaW4gOiBpbnRlcnZhbExvdztcclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgSW50ZXJ2YWwge1xyXG4gICAgY29uc3RydWN0b3IobG93LCBoaWdoLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93O1xyXG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIW90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgPT0gb3RoZXJJbnRlcnZhbC5sb3cgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09IG90aGVySW50ZXJ2YWwuaGlnaCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPCBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPiBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oaWdoIDwgb3RoZXIuaGlnaClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmhpZ2ggPiBvdGhlci5oaWdoKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBpbnRlcnZhbCBvdmVybGFwcyB0aGUgb3RoZXIuXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBzKG90aGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA8PSBvdGhlci5oaWdoICYmIG90aGVyLmxvdyA8PSB0aGlzLmhpZ2gpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy9hbGVydChlKTtcclxuICAgICAgICAgICAgaWd2LnByZXNlbnRBbGVydChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE5vZGV7XHJcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gTklMO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IE5JTDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gTklMO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gUkVEO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBHZW5vbWljSW50ZXJ2YWx7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgZmVhdHVyZXMpIHtcclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zIChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT09IHJhbmdlLmNociAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDw9IHJhbmdlLnN0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZW5kID49IHJhbmdlLmVuZDtcclxuICAgIH1cclxuICAgIHJhbmdlc1RvR2V0KHJhbmdlKXtcclxuICAgICAgICBsZXQgbmVlZHNfcmFuZ2U9ZmFsc2U7XHJcbiAgICAgICAgbGV0IHJhbmdlcz17fTtcclxuICAgICAgICBpZiAodGhpcy5jaHIgIT09IHJhbmdlLmNocil7XHJcbiAgICAgICAgICAgIHJhbmdlcy5hbGw9W3JhbmdlLnN0YXJ0LHJhbmdlLmVuZF07XHJcbiAgICAgICAgICAgIG5lZWRzX3JhbmdlPXRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQ9cmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kPXJhbmdlLmVuZDtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7ICAgXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydDx0aGlzLnN0YXJ0KXtcclxuICAgICAgICAgICAgICAgIHJhbmdlcy5sZWZ0PVtyYW5nZS5zdGFydCx0aGlzLnN0YXJ0XTtcclxuICAgICAgICAgICAgICAgIG5lZWRzX3JhbmdlPXRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0PXJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmQ+dGhpcy5lbmQpe1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnJpZ2h0PVt0aGlzLmVuZCxyYW5nZS5lbmRdO1xyXG4gICAgICAgICAgICAgICAgbmVlZHNfcmFuZ2U9dHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kPXJhbmdlLmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5lZWRzX3JhbmdlKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEZhc3RhU2VxdWVuY2V7XHJcblxyXG4gICAgY29uc3RydWN0b3IodXJsKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsZSA9IHVybDtcclxuICAgICAgICB0aGlzLmluZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleEZpbGUgPSB0aGlzLmZpbGUgKyBcIi5mYWlcIjtcclxuICAgICAgICB9XHJcbiAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICBpbml0KCl7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuaW5kZXhlZCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicExlbmd0aCA9IHNlbGYuaW5kZXhbY2hyTmFtZV0uc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lc1tjaHJOYW1lXSA9IG5ldyBpZ3YuQ2hyb21vc29tZShjaHJOYW1lLCBvcmRlcisrLCBicExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW5kZXgsIGdldHRpbmcgY2hyIG5hbWVzIGFzIGEgc2lkZSBlZmZlY3QuICBSZWFsbHkgYmFkIHByYWN0aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5sb2FkQWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXF1ZW5jZShjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXF1ZW5jZUluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRTZXF1ZW5jZU5vbkluZGV4ZWQudGhpcyhjaHIsIHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFNlcXVlbmNlSW5kZXhlZChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZWxmLmludGVydmFsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIGludGVydmFsLmNvbnRhaW5zKGNociwgc3RhcnQsIGVuZCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGdldFNlcXVlbmNlRnJvbUludGVydmFsKGludGVydmFsLCBzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhY2hlIG1pc3M6IFwiICsgKGludGVydmFsID09PSB1bmRlZmluZWQgPyBcIm5pbFwiIDogaW50ZXJ2YWwuY2hyICsgXCI6XCIgKyBpbnRlcnZhbC5zdGFydCArIFwiLVwiICsgaW50ZXJ2YWwuZW5kKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIHF1ZXJ5LCB0byBtaW5pbXVtIG9mIDEwMGtiXHJcbiAgICAgICAgICAgICAgICB2YXIgcXN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcWVuZCA9IGVuZDtcclxuICAgICAgICAgICAgICAgIGlmICgoZW5kIC0gc3RhcnQpIDwgMTAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgdyAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHFzdGFydCA9IE1hdGgubWF4KDAsIGNlbnRlciAtIDUwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICBxZW5kID0gY2VudGVyICsgNTAwMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYucmVhZFNlcXVlbmNlKGNociwgcXN0YXJ0LCBxZW5kKS50aGVuKGZ1bmN0aW9uIChzZXFCeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW50ZXJ2YWwgPSBuZXcgR2Vub21pY0ludGVydmFsKGNociwgcXN0YXJ0LCBxZW5kLCBzZXFCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChzZWxmLmludGVydmFsLCBzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0IC0gaW50ZXJ2YWwuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IGludGVydmFsLmZlYXR1cmVzID8gaW50ZXJ2YWwuZmVhdHVyZXMuc3Vic3RyKG9mZnNldCwgbikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRTZXF1ZW5jZU5vbkluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHNlcSA9IHNlbGYuc2VxdWVuY2VzW2Nocl07XHJcbiAgICAgICAgICAgIGlmIChzZXEgJiYgc2VxLmxlbmd0aCA+IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZXEuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRJbmRleCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5pbmRleCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZChzZWxmLmluZGV4RmlsZSx7fSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU5vID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMgPSBbXTsgICAgIC8vIFRPRE8gLS0gZWxpbWluYXRlIHRoaXMgc2lkZSBlZmZlY3QgISEhIVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXggPSB7fTsgICAgICAgICAgICAgICAvLyBUT0RPIC0tIGRpdHRvXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpbmVObyA8IGxlbikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmVzW2xpbmVObysrXS5zcGxpdChcIlxcdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoblRva2VucyA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW5kZXggbGluZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VzUGVyTGluZSA9IHBhcnNlSW50KHRva2Vuc1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNQZXJMaW5lID0gcGFyc2VJbnQodG9rZW5zWzRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhFbnRyeSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLCBwb3NpdGlvbjogcG9zaXRpb24sIGJhc2VzUGVyTGluZTogYmFzZXNQZXJMaW5lLCBieXRlc1BlckxpbmU6IGJ5dGVzUGVyTGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4W2Nocl0gPSBpbmRleEVudHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVsZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkQWxsKCl7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lcyA9IHt9O1xyXG4gICAgICAgICAgICBzZWxmLnNlcXVlbmNlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5maWxlLCB7XHJcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdExpbmVzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVObyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlcSA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENocixcclxuICAgICAgICAgICAgICAgICAgICBvcmRlciA9IDA7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lTm8gPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IGxpbmVzW2xpbmVObysrXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMaW5lLnN0YXJ0c1dpdGgoXCIjXCIpIHx8IG5leHRMaW5lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dExpbmUuc3RhcnRzV2l0aChcIj5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzLnB1c2goY3VycmVudENocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlc1tjdXJyZW50Q2hyXSA9IGN1cnJlbnRTZXE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzW2N1cnJlbnRDaHJdID0gbmV3IGlndi5DaHJvbW9zb21lKGN1cnJlbnRDaHIsIG9yZGVyKyssIGN1cnJlbnRTZXEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hyID0gbmV4dExpbmUuc3Vic3RyKDEpLnNwbGl0KFwiXFxcXHMrXCIpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VxID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXEgKz0gbmV4dExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlYWRTZXF1ZW5jZShjaHIsIHFzdGFydCwgcWVuZCkge1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZCBzZXF1ZW5jZSBcIiArIGNociArIFwiOlwiICsgcXN0YXJ0ICsgXCItXCIgKyBxZW5kKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuZ2V0SW5kZXgoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaWR4RW50cnkgPSBzZWxmLmluZGV4W2Nocl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlkeEVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBpbmRleCBlbnRyeSBmb3IgY2hyOiBcIiArIGNocik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRhZyBpbnRlcnZhbCB3aXRoIG51bGwgc28gd2UgZG9uJ3QgdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBxc3RhcnQsIHFlbmQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgcXN0YXJ0KTsgICAgLy8gcXN0YXJ0IHNob3VsZCBuZXZlciBiZSA8IDBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oaWR4RW50cnkuc2l6ZSwgcWVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzUGVyTGluZSA9IGlkeEVudHJ5LmJ5dGVzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZXNQZXJMaW5lID0gaWR4RW50cnkuYmFzZXNQZXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGlkeEVudHJ5LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuRW5kQnl0ZXMgPSBieXRlc1BlckxpbmUgLSBiYXNlc1BlckxpbmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBNYXRoLmZsb29yKHN0YXJ0IC8gYmFzZXNQZXJMaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTGluZSA9IE1hdGguZmxvb3IoZW5kIC8gYmFzZXNQZXJMaW5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UwID0gc3RhcnRMaW5lICogYmFzZXNQZXJMaW5lOyAgIC8vIEJhc2UgYXQgYmVnaW5uaW5nIG9mIHN0YXJ0IGxpbmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0IC0gYmFzZTA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEJ5dGUgPSBwb3NpdGlvbiArIHN0YXJ0TGluZSAqIGJ5dGVzUGVyTGluZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UxID0gZW5kTGluZSAqIGJhc2VzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IGVuZCAtIGJhc2UxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRCeXRlID0gcG9zaXRpb24gKyBlbmRMaW5lICogYnl0ZXNQZXJMaW5lICsgb2Zmc2V0MSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IGVuZEJ5dGUgLSBzdGFydEJ5dGUgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5maWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHN0YXJ0Qnl0ZSwgc2l6ZTogYnl0ZUNvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFsbEJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbkJhc2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxQnl0ZXMgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUG9zID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc1BvcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxCeXRlc0xlbmd0aCA9IGFsbEJ5dGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuQmFzZXMgPSBNYXRoLm1pbihlbmQgLSBzdGFydCwgYmFzZXNQZXJMaW5lIC0gb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzICs9IGFsbEJ5dGVzLnN1YnN0cihzcmNQb3MsIG5CYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQb3MgKz0gKG5CYXNlcyArIG5FbmRCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgKz0gbkJhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3JjUG9zIDwgYWxsQnl0ZXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5CYXNlcyA9IE1hdGgubWluKGJhc2VzUGVyTGluZSwgYWxsQnl0ZXNMZW5ndGggLSBzcmNQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxQnl0ZXMgKz0gYWxsQnl0ZXMuc3Vic3RyKHNyY1BvcywgbkJhc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BvcyArPSAobkJhc2VzICsgbkVuZEJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc1BvcyArPSBuQmFzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VxQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtGZWF0dXJlU291cmNlLEZhc3RhU2VxdWVuY2UsQmlnQmVkRmVhdHVyZVNvdXJjZSxUYWJpeEJlZEZlYXR1cmVTb3VyY2V9Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBbkJBO0FBQ0E7QUFxQkE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUNBO0FBRUE7QUFDQTtBQUpBO0FBS0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBSEE7QUFIQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0RBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQTBlQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQXRnQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUVBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFnQ0E7Ozs7OztBQXVDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/feature.js\n");

/***/ }),

/***/ "../MLVPanel/src/igvxhr.js":
/*!****************************!*\
  !*** .Panel/src/igvxhr.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Zlib) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.unbgzf = exports.igvxhr = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"../MLVPanel/src/vendor/inflate.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar is_node = false;\ntry {\n    navigator;\n} catch (e) {\n    is_node = true;\n}\n\nif (!Zlib.Zlib) {\n    Zlib.Zlib = Zlib;\n}\n\nvar NONE = 0;\nvar GZIP = 1;\nvar BGZF = 2;\n\nvar igvxhr = function () {\n    function igvxhr() {\n        _classCallCheck(this, igvxhr);\n    }\n\n    _createClass(igvxhr, null, [{\n        key: \"load\",\n\n\n        // Compression types\n\n\n        value: function load(url, options) {\n\n            return new Promise(function (fulfill, reject) {\n                var xhr = new XMLHttpRequest(),\n                    sendData = options.sendData,\n                    method = options.method || (sendData ? \"POST\" : \"GET\"),\n                    range = options.range,\n                    responseType = options.responseType,\n                    contentType = options.contentType,\n                    mimeType = options.mimeType,\n                    headers = options.headers,\n                    isSafari = is_node ? false : navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent),\n                    withCredentials = options.withCredentials,\n                    header_keys,\n                    key,\n                    value,\n                    i;\n\n                // Support for GCS paths.\n                //url = url.startsWith(\"gs://\") ? igv.Google.translateGoogleCloudURL(url) : url;\n\n\n                /* if (igv.Google.isGoogleURL(url)) {\r\n                       url = igv.Google.addApiKey(url);\r\n                       // Add google headers (e.g. oAuth)\r\n                     headers = headers || {};\r\n                     igv.Google.addGoogleHeaders(headers);\r\n                       // Hack to prevent caching for google storage files.  Get weird net:err-cache errors otherwise\r\n                     if (range) {\r\n                         url += url.includes(\"?\") ? \"&\" : \"?\";\r\n                         url += \"someRandomSeed=\" + Math.random().toString(36);\r\n                     }\r\n                 }\r\n                 */\n\n                xhr.open(method, url);\n\n                if (range) {\n                    var rangeEnd = range.size ? range.start + range.size - 1 : \"\";\n                    xhr.setRequestHeader(\"Range\", \"bytes=\" + range.start + \"-\" + rangeEnd);\n                }\n                if (contentType) {\n                    xhr.setRequestHeader(\"Content-Type\", contentType);\n                }\n                if (mimeType) {\n                    xhr.overrideMimeType(mimeType);\n                }\n                if (responseType) {\n                    xhr.responseType = responseType;\n                }\n                if (headers) {\n                    header_keys = Object.keys(headers);\n                    for (i = 0; i < header_keys.length; i++) {\n                        key = header_keys[i];\n                        value = headers[key];\n                        // console.log(\"Adding to header: \" + key + \"=\" + value);\n                        xhr.setRequestHeader(key, value);\n                    }\n                }\n\n                // NOTE: using withCredentials with servers that return \"*\" for access-allowed-origin will fail\n                if (withCredentials === true) {\n                    xhr.withCredentials = true;\n                }\n                xhr.timeout = 30000;\n\n                xhr.onload = function (event) {\n                    // when the url points to a local file, the status is 0 but that is no error\n                    if (xhr.status == 0 || xhr.status >= 200 && xhr.status <= 300) {\n\n                        if (range && xhr.status != 206) {\n                            handleError(\"ERROR: range-byte header was ignored for url: \" + url);\n                        } else {\n\n                            fulfill(xhr.response, xhr);\n                        }\n                    } else {\n\n                        //\n                        if (xhr.status === 416) {\n                            //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an\n                            handleError(\"Unsatisfiable range\");\n                        } else {\n                            // TODO -- better error handling\n                            handleError(\"Error accessing resource: \" + xhr.status);\n                        }\n                    }\n                };\n\n                xhr.onerror = function (event) {\n                    handleError(\"Error accessing resource: \" + url + \" Status: \" + xhr.status);\n                };\n\n                xhr.ontimeout = function (event) {\n                    handleError(\"Timed out\");\n                };\n\n                xhr.onabort = function (event) {\n                    console.log(\"Aborted\");\n                    reject(new igv.AbortLoad());\n                };\n\n                try {\n\n                    xhr.send(sendData);\n                } catch (e) {\n                    reject(e);\n                }\n\n                function handleError(message) {\n                    if (reject) {\n                        reject(message);\n                    } else {\n                        throw Error(message);\n                    }\n                }\n            });\n        }\n    }, {\n        key: \"loadArrayBuffer\",\n        value: function loadArrayBuffer(url, options) {\n\n            if (options === undefined) options = {};\n            options.responseType = \"arraybuffer\";\n            return igvxhr.load(url, options);\n        }\n    }, {\n        key: \"loadJson\",\n        value: function loadJson(url, options) {\n\n            var method = options.method || (options.sendData ? \"POST\" : \"GET\");\n\n            if (method == \"POST\") options.contentType = \"application/json\";\n\n            return new Promise(function (fulfill, reject) {\n\n                igvxhr.load(url, options).then(function (result) {\n                    if (result) {\n                        fulfill(JSON.parse(result));\n                    } else {\n                        fulfill(result);\n                    }\n                }).catch(reject);\n            });\n        }\n\n        /**\r\n         * Load a \"raw\" string.\r\n         */\n\n    }, {\n        key: \"loadString\",\n        value: function loadString(url, options) {\n\n            var compression, fn, idx;\n\n            if (options === undefined) options = {};\n\n            // Strip parameters from url\n            // TODO -- handle local files with ?\n            idx = url.indexOf(\"?\");\n            fn = idx > 0 ? url.substring(0, idx) : url;\n\n            if (options.bgz) {\n                compression = BGZF;\n            } else if (fn.endsWith(\".gz\")) {\n                compression = GZIP;\n            } else {\n                compression = NONE;\n            }\n\n            if (compression === NONE) {\n                options.mimeType = 'text/plain; charset=x-user-defined';\n                return igvxhr.load(url, options);\n            } else {\n                options.responseType = \"arraybuffer\";\n\n                return new Promise(function (fulfill, reject) {\n\n                    igvxhr.load(url, options).then(function (data) {\n                        var result = igvxhr.arrayBufferToString(data, compression);\n                        fulfill(result);\n                    }).catch(reject);\n                });\n            }\n        }\n    }, {\n        key: \"loadStringFromFile\",\n        value: function loadStringFromFile(localfile, options) {\n\n            return new Promise(function (fulfill, reject) {\n\n                var fileReader = new FileReader(),\n                    range = options.range;\n\n                fileReader.onload = function (e) {\n\n                    var compression, result;\n\n                    if (options.bgz) {\n                        compression = BGZF;\n                    } else if (localfile.name.endsWith(\".gz\")) {\n\n                        compression = GZIP;\n                    } else {\n                        compression = NONE;\n                    }\n\n                    result = igvxhr.arrayBufferToString(fileReader.result, compression);\n\n                    fulfill(result, localfile);\n                };\n\n                fileReader.onerror = function (e) {\n                    console.log(\"reject uploading local file \" + localfile.name);\n                    reject(null, fileReader);\n                };\n\n                fileReader.readAsArrayBuffer(localfile);\n            });\n        }\n    }, {\n        key: \"isCrossDomain\",\n        value: function isCrossDomain(url) {\n\n            var origin = window.location.origin;\n\n            return !url.startsWith(origin);\n        }\n    }, {\n        key: \"arrayBufferToString\",\n        value: function arrayBufferToString(arraybuffer, compression) {\n\n            var plain, inflate;\n\n            if (compression === GZIP) {\n                inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arraybuffer));\n                plain = inflate.decompress();\n            } else if (compression === BGZF) {\n                plain = new Uint8Array(unbgzf(arraybuffer));\n            } else {\n                plain = new Uint8Array(arraybuffer);\n            }\n\n            var result = \"\";\n            for (var i = 0, len = plain.length; i < len; i++) {\n                result = result + String.fromCharCode(plain[i]);\n            }\n            return result;\n        }\n    }]);\n\n    return igvxhr;\n}();\n\n//**********js/bam/bgzf.js***************************************\n\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\nvar unbgzf = function unbgzf(data, lim) {\n\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nexports.igvxhr = igvxhr;\nexports.unbgzf = unbgzf;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! .Panel/src/vendor/zlib_and_gzip.min.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2lndnhoci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvaWd2eGhyLmpzP2EwODgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge2pzemxpYl9pbmZsYXRlX2J1ZmZlcixhcnJheUNvcHl9IGZyb20gXCIuL3ZlbmRvci9pbmZsYXRlLmpzXCI7XHJcblxyXG5cclxubGV0IGlzX25vZGU9ZmFsc2U7XHJcbnRyeXtcclxuICAgIG5hdmlnYXRvcjtcclxufWNhdGNoKGUpe1xyXG4gICAgaXNfbm9kZT10cnVlO1xyXG59XHJcblxyXG5pZiAoIVpsaWIuWmxpYil7XHJcblx0WmxpYi5abGliPVpsaWI7XHJcbn1cclxuXHJcbmNvbnN0IE5PTkUgPSAwO1xyXG5jb25zdCBHWklQID0gMTtcclxuY29uc3QgQkdaRiA9IDI7XHJcbmNsYXNzIGlndnhociB7XHJcbiAgIFxyXG4gICAgLy8gQ29tcHJlc3Npb24gdHlwZXNcclxuICAgXHJcblxyXG4gICAgc3RhdGljIGxvYWQodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgXHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcclxuICAgICAgICAgICAgICAgIHNlbmREYXRhID0gb3B0aW9ucy5zZW5kRGF0YSxcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IChzZW5kRGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiksXHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2UsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gb3B0aW9ucy5taW1lVHlwZSxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICBpc1NhZmFyaSA9IGlzX25vZGU/ZmFsc2U6bmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiQXBwbGVcIikgPT0gMCAmJiAvXFxzU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLFxyXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJfa2V5cywga2V5LCB2YWx1ZSwgaTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIEdDUyBwYXRocy5cclxuICAgICAgICAgICAvL3VybCA9IHVybC5zdGFydHNXaXRoKFwiZ3M6Ly9cIikgPyBpZ3YuR29vZ2xlLnRyYW5zbGF0ZUdvb2dsZUNsb3VkVVJMKHVybCkgOiB1cmw7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgICAgIC8qIGlmIChpZ3YuR29vZ2xlLmlzR29vZ2xlVVJMKHVybCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBpZ3YuR29vZ2xlLmFkZEFwaUtleSh1cmwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBnb29nbGUgaGVhZGVycyAoZS5nLiBvQXV0aClcclxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgaWd2Lkdvb2dsZS5hZGRHb29nbGVIZWFkZXJzKGhlYWRlcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhY2sgdG8gcHJldmVudCBjYWNoaW5nIGZvciBnb29nbGUgc3RvcmFnZSBmaWxlcy4gIEdldCB3ZWlyZCBuZXQ6ZXJyLWNhY2hlIGVycm9ycyBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSB1cmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIjtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCJzb21lUmFuZG9tU2VlZD1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICBcclxuXHJcbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gcmFuZ2Uuc2l6ZSA/IHJhbmdlLnN0YXJ0ICsgcmFuZ2Uuc2l6ZSAtIDEgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiICsgcmFuZ2Uuc3RhcnQgKyBcIi1cIiArIHJhbmdlRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWltZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJfa2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhlYWRlcl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaGVhZGVyX2tleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBZGRpbmcgdG8gaGVhZGVyOiBcIiArIGtleSArIFwiPVwiICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOT1RFOiB1c2luZyB3aXRoQ3JlZGVudGlhbHMgd2l0aCBzZXJ2ZXJzIHRoYXQgcmV0dXJuIFwiKlwiIGZvciBhY2Nlc3MtYWxsb3dlZC1vcmlnaW4gd2lsbCBmYWlsXHJcbiAgICAgICAgICAgIGlmICh3aXRoQ3JlZGVudGlhbHMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhoci50aW1lb3V0PTMwMDAwO1xyXG5cclxuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdXJsIHBvaW50cyB0byBhIGxvY2FsIGZpbGUsIHRoZSBzdGF0dXMgaXMgMCBidXQgdGhhdCBpcyBubyBlcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMCB8fCAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8PSAzMDApKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiB4aHIuc3RhdHVzICE9IDIwNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIkVSUk9SOiByYW5nZS1ieXRlIGhlYWRlciB3YXMgaWdub3JlZCBmb3IgdXJsOiBcIiArIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoeGhyLnJlc3BvbnNlLHhocik7XHJcbiAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSA0MTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFRyaWVkIHRvIHJlYWQgb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUuICAgVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgaWYgaXQgZG9lcyByZXR1cm4gYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJVbnNhdGlzZmlhYmxlIHJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsvLyBUT0RPIC0tIGJldHRlciBlcnJvciBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIkVycm9yIGFjY2Vzc2luZyByZXNvdXJjZTogXCIgKyB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiRXJyb3IgYWNjZXNzaW5nIHJlc291cmNlOiBcIiArIHVybCArIFwiIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIlRpbWVkIG91dFwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFib3J0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGlndi5BYm9ydExvYWQoKSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHhoci5zZW5kKHNlbmREYXRhKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgbG9hZEFycmF5QnVmZmVyICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgIHJldHVybiBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgbG9hZEpzb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgKG9wdGlvbnMuc2VuZERhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIpO1xyXG5cclxuICAgICAgICBpZiAobWV0aG9kID09IFwiUE9TVFwiKSBvcHRpb25zLmNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKEpTT04ucGFyc2UocmVzdWx0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIFwicmF3XCIgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbG9hZFN0cmluZyh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBmbiwgaWR4O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XHJcblxyXG4gICAgICAgIC8vIFN0cmlwIHBhcmFtZXRlcnMgZnJvbSB1cmxcclxuICAgICAgICAvLyBUT0RPIC0tIGhhbmRsZSBsb2NhbCBmaWxlcyB3aXRoID9cclxuICAgICAgICBpZHggPSB1cmwuaW5kZXhPZihcIj9cIik7XHJcbiAgICAgICAgZm4gPSBpZHggPiAwID8gdXJsLnN1YnN0cmluZygwLCBpZHgpIDogdXJsO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5iZ3opIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBCR1pGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmbi5lbmRzV2l0aChcIi5nelwiKSkge1xyXG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9IEdaSVA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9IE5PTkU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IE5PTkUpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJztcclxuICAgICAgICAgICAgcmV0dXJuIGlndnhoci5sb2FkKHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyhkYXRhLCBjb21wcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvYWRTdHJpbmdGcm9tRmlsZShsb2NhbGZpbGUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKSxcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcclxuXHJcblxyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uLCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYmd6KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb24gPSBCR1pGO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxmaWxlLm5hbWUuZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb24gPSBHWklQO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb24gPSBOT05FO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlndnhoci5hcnJheUJ1ZmZlclRvU3RyaW5nKGZpbGVSZWFkZXIucmVzdWx0LCBjb21wcmVzc2lvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQsIGxvY2FsZmlsZSk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVqZWN0IHVwbG9hZGluZyBsb2NhbCBmaWxlIFwiICsgbG9jYWxmaWxlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG51bGwsIGZpbGVSZWFkZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihsb2NhbGZpbGUpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaXNDcm9zc0RvbWFpbih1cmwpIHtcclxuXHJcbiAgICAgICAgdmFyIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcblxyXG4gICAgICAgIHJldHVybiAhdXJsLnN0YXJ0c1dpdGgob3JpZ2luKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGFycmF5QnVmZmVyVG9TdHJpbmcgKGFycmF5YnVmZmVyLCBjb21wcmVzc2lvbikge1xyXG5cclxuICAgICAgICB2YXIgcGxhaW4sIGluZmxhdGU7XHJcblxyXG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gR1pJUCkge1xyXG4gICAgICAgICAgICBpbmZsYXRlID0gbmV3IFpsaWIuWmxpYi5HdW56aXAobmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpKTtcclxuICAgICAgICAgICAgcGxhaW4gPSBpbmZsYXRlLmRlY29tcHJlc3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcHJlc3Npb24gPT09IEJHWkYpIHtcclxuICAgICAgICAgICAgcGxhaW4gPSBuZXcgVWludDhBcnJheSh1bmJnemYoYXJyYXlidWZmZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBsYWluID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBsYWluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIFN0cmluZy5mcm9tQ2hhckNvZGUocGxhaW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqKioqKioqKmpzL2JhbS9iZ3pmLmpzKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQkxPQ0tfSEVBREVSX0xFTkdUSCA9IDE4O1xyXG5jb25zdCBCTE9DS19MRU5HVEhfT0ZGU0VUID0gMTY7ICAvLyBMb2NhdGlvbiBpbiB0aGUgZ3ppcCBibG9jayBvZiB0aGUgdG90YWwgYmxvY2sgc2l6ZSAoYWN0dWFsbHkgdG90YWwgYmxvY2sgc2l6ZSAtIDEpXHJcbmNvbnN0IEJMT0NLX0ZPT1RFUl9MRU5HVEggPSA4OyAvLyBOdW1iZXIgb2YgYnl0ZXMgdGhhdCBmb2xsb3cgdGhlIGRlZmxhdGVkIGRhdGFcclxuY29uc3QgTUFYX0NPTVBSRVNTRURfQkxPQ0tfU0laRSA9IDY0ICogMTAyNDsgLy8gV2UgcmVxdWlyZSB0aGF0IGEgY29tcHJlc3NlZCBibG9jayAoaW5jbHVkaW5nIGhlYWRlciBhbmQgZm9vdGVyLCBiZSA8PSB0aGlzKVxyXG5jb25zdCBHWklQX09WRVJIRUFEID0gQkxPQ0tfSEVBREVSX0xFTkdUSCArIEJMT0NLX0ZPT1RFUl9MRU5HVEggKyAyOyAvLyBHemlwIG92ZXJoZWFkIGlzIHRoZSBoZWFkZXIsIHRoZSBmb290ZXIsIGFuZCB0aGUgYmxvY2sgc2l6ZSAoZW5jb2RlZCBhcyBhIHNob3J0KS5cclxuY29uc3QgR1pJUF9JRDEgPSAzMTsgICAvLyBNYWdpYyBudW1iZXJcclxuY29uc3QgR1pJUF9JRDIgPSAxMzk7ICAvLyBNYWdpYyBudW1iZXJcclxuY29uc3QgR1pJUF9GTEcgPSA0OyAvLyBGRVhUUkEgZmxhZyBtZWFucyB0aGVyZSBhcmUgb3B0aW9uYWwgZmllbGRzXHJcblxyXG5cclxuICAgIC8vIFVuY29tcHJlc3MgZGF0YSwgIGFzc3VtZWQgdG8gYmUgc2VyaWVzIG9mIGJnemlwcGVkIGJsb2Nrc1xyXG4gICAgLy8gQ29kZSBpcyBiYXNlZCBoZWF2aWx5IG9uIGJhbS5qcywgcGFydCBvZiB0aGUgRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlciwgIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMDEuXHJcbmxldCB1bmJnemYgPSBmdW5jdGlvbiAoZGF0YSwgbGltKSB7XHJcblxyXG4gICAgICAgIHZhciBvQmxvY2tMaXN0ID0gW10sXHJcbiAgICAgICAgICAgIHB0ciA9IFswXSxcclxuICAgICAgICAgICAgdG90YWxTaXplID0gMDtcclxuXHJcbiAgICAgICAgbGltID0gbGltIHx8IGRhdGEuYnl0ZUxlbmd0aCAtIDE4O1xyXG5cclxuICAgICAgICB3aGlsZSAocHRyWzBdIDwgbGltKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhLCBwdHJbMF0sIDE4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4bGVuID0gKGJhWzExXSA8PCA4KSB8IChiYVsxMF0pO1xyXG4gICAgICAgICAgICB2YXIgc2kxID0gYmFbMTJdO1xyXG4gICAgICAgICAgICB2YXIgc2kyID0gYmFbMTNdO1xyXG4gICAgICAgICAgICB2YXIgc2xlbiA9IChiYVsxNV0gPDwgOCkgfCAoYmFbMTRdKTtcclxuICAgICAgICAgICAgdmFyIGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDEyICsgeGxlbiArIHB0clswXTsgICAgLy8gU3RhcnQgb2YgQ0RBVEFcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IChic2l6ZSArIDgpKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmMgPSBqc3psaWJfaW5mbGF0ZV9idWZmZXIoZGF0YSwgc3RhcnQsIGxlbmd0aCwgcHRyKTtcclxuXHJcbiAgICAgICAgICAgIHB0clswXSArPSA4OyAgICAvLyBTa2lwcGluZyBDUkMtMzIgYW5kIHNpemUgb2YgdW5jb21wcmVzc2VkIGRhdGFcclxuXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSB1bmMuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgb0Jsb2NrTGlzdC5wdXNoKHVuYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25jYXRlbmF0ZSBkZWNvbXByZXNzZWQgYmxvY2tzXHJcbiAgICAgICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9CbG9ja0xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkob0Jsb2NrTGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7aWd2eGhyLHVuYmd6Zn07XHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/igvxhr.js\n");

/***/ }),

/***/ "../MLVPanel/src/panel.js":
/*!***************************!*\
  !*** .Panel/src/panel.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MLVPanel = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n/**\r\n * Class representing a lightweight panel the can host multiple tracks of\r\n * different types\r\n */\n\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nvar _panel_legend = __webpack_require__(/*! ./panel_legend.js */ \"../MLVPanel/src/panel_legend.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVPanel = function () {\n    /**\r\n    * Creates a panel\r\n    * @param {array} tracks - a list of config objects describing each track\r\n    * @param {object} config - A config with the panel settings\r\n    */\n    function MLVPanel(tracks, config) {\n        _classCallCheck(this, MLVPanel);\n\n        if (!config) {\n            config = {};\n        }\n        this.fixed_height_mode = false;\n        if (config.fixed_height_mode) {\n            this.fixed_height_mode = true;\n        }\n\n        this.show_scale = true;\n        if (config.show_scale) {\n            this.show_scale = true;\n        }\n\n        var height = config.height ? config.height : 200;\n        var width = config.width ? config.width : 400;\n        var dim = { height: height, width: width };\n        var panel_div = null;\n        if (!config.div) {\n            panel_div = $(\"<div>\").height(height).width(width);\n        } else {\n            if (typeof config.div === 'string') {\n                panel_div = $(\"#\" + config.div);\n            } else {\n                panel_div = $(config.div);\n            }\n            height = panel_div.height();\n            width = panel_div.width();\n        }\n        this.tracks = {};\n        this.track_order = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = tracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var t_config = _step.value;\n\n                if (this.fixed_height_mode) {\n                    t_config.discrete = true;\n                }\n                var track = _tracks.MLVTrack.getTrack(t_config);\n                this.tracks[track.config.track_id] = track;\n                this.track_order.push(track.config.track_id);\n            }\n            //check for linked scales\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this._tracksChanged();\n        this.legend = null;\n\n        this.trackDiv = panel_div.addClass(\"igv-track-div\").css(\"position\", \"absolute\");\n\n        this.canvas = $('<canvas class = \"igv-content-canvas\">')[0];\n        this.trackDiv.append(this.canvas);\n        this.canvas.setAttribute('width', width);\n        this.canvas.setAttribute('height', height);\n        this.ctx = this.canvas.getContext(\"2d\");\n\n        if (this.show_scale) {\n            this.addScaleCanvas(height);\n        }\n\n        this.trackDiv.append(_utils.Utils.spinner());\n\n        var icon_div = $(\"<div>\").css({ \"z-index\": 100, position: \"absolute\", top: \"2px\", right: \"2px\" }).appendTo(this.trackDiv).attr(\"class\", \"panel-icon-div\");\n\n        //for event handlers\n        this.is_dragging = false;\n        this.isMouseDown = false, this.lastMouseX = undefined;\n        this.mouseDownX = undefined;\n\n        //amount to show each side of view port\n        this.buffer_level = 1;\n\n        this.groups = {};\n\n        this.highlighted_regions = {};\n\n        //listeners\n        this.listeners = {\n            \"panel_empty\": new Map(),\n            \"panel_closed\": new Map(),\n            \"track_added\": new Map(),\n            \"track_removed\": new Map(),\n            \"view_changed\": new Map(),\n            \"feature_clicked\": new Map(),\n            \"feature_over\": new Map(),\n            \"range_selected\": new Map()\n        };\n\n        if (config.allow_user_drag) {\n            this.allowUserDrag();\n        }\n        if (config.allow_user_zoom) {\n            this.allowUserZoom();\n        }\n        if (config.allow_user_resize) {\n            this.allowUserResize(config.allow_user_resize);\n        }\n        if (config.allow_user_move) {\n            this.allowUserMove(config.allow_user_move);\n        }\n        if (config.allow_user_feature_click) {\n            this.allowUserFeatureClick();\n        }\n        if (config.allow_user_feature_over) {\n            this.allowUserFeatureOver();\n        }\n        if (config.allow_user_close) {\n            this.allowUserClose();\n        }\n        if (config.allow_user_drop) {\n            this.allowUserDrop();\n        }\n        if (config.allow_user_range_selection) {\n            this.allowUserRangeSelection();\n        }\n\n        if (config.ruler_track) {\n            this.addRulerTrack();\n        }\n        if (config.legend) {\n            this.addLegend();\n        }\n\n        this.retries = 0;\n        this.yOffset = 0;\n    }\n\n    _createClass(MLVPanel, [{\n        key: \"_parseConfig\",\n        value: function _parseConfig(config) {\n            //check the tracks have the right settings\n            if (this.fixed_height_mode) {\n                config.discrete = true;\n                if (!config.height) {\n                    config.height = 150;\n                }\n            }\n        }\n    }, {\n        key: \"addScaleCanvas\",\n        value: function addScaleCanvas(height) {\n            this.scale_canvas = $('<canvas>').css({ position: \"absolute\", top: \"0px\", left: \"5px\" });\n            this.scale_canvas[0].setAttribute('width', 100);\n            this.scale_canvas[0].setAttribute('height', height);\n            this.scale_canvas.appendTo(this.trackDiv);\n            this.scale_ctx = this.scale_canvas[0].getContext(\"2d\");\n        }\n\n        /**\r\n        * sets the extra amount of track to draw each side of the view. A value \r\n        * of 1 will retreive 1 x the view width each side i.e. 3 x the visible window\r\n        * @param {integer} level - The type of listener - track_empty \r\n        */\n\n    }, {\n        key: \"setBufferLevel\",\n        value: function setBufferLevel(level) {\n            this.buffer_level = level;\n        }\n        /**\r\n        * Returns the element that houses the panel\r\n        * @returns {integer} level - The type of listener - track_empty \r\n        */\n\n    }, {\n        key: \"getDiv\",\n        value: function getDiv() {\n            return this.trackDiv;\n        }\n    }, {\n        key: \"addLegend\",\n        value: function addLegend() {\n            this.legend = new _panel_legend.PanelLegend(this);\n        }\n\n        /**\r\n        * Sets the highligted region\r\n        * @param {Object} location - An object containing chr, start and end\r\n        * @param {name} The name(id) of the region (used to remove the region)\r\n        * @param {String} The color to give the highligted region\r\n        */\n\n    }, {\n        key: \"setHighlightedRegion\",\n        value: function setHighlightedRegion(location, name, color) {\n            this.highlighted_regions[name] = {\n                chr: location.chr,\n                start: location.start,\n                end: location.end,\n                color: color\n            };\n            this.force_redraw = true;\n        }\n\n        /**\r\n        * Removes the highlighted region from the panel\r\n        * @param {string} name - The name of the highlighted region\r\n        * that was given when it was created.\r\n        */\n\n    }, {\n        key: \"removeHighlightedRegion\",\n        value: function removeHighlightedRegion(name) {\n            delete this.highlighted_regions[name];\n            this.force_redraw = true;\n        }\n    }, {\n        key: \"addRulerTrack\",\n        value: function addRulerTrack() {\n            var track = new _tracks.RulerTrack();\n            var config = track.getConfig();\n            this.tracks[config.track_id] = track;\n            this.track_order.unshift(config.track_id);\n            return this;\n        }\n\n        /**\r\n        * Adds a listener to the panel\r\n        * @param {string} type - The type of listener - track_empty\r\n        * @param {function} func - The function to call \r\n        * @param {string} id - The id of the handler (can be used to remove the handler)\r\n        * Optional - an id will be assigned (and returned) if not supplied\r\n        * @returns{string} The id of the handler or null if the type did not exist \r\n        */\n\n    }, {\n        key: \"addListener\",\n        value: function addListener(type, func, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return null;\n            }\n            if (!id) {\n                id = type + \"_\" + listener.size;\n            }\n            listener.set(id, func);\n            return id;\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {string} type - The type of listener - track_empty \r\n        * @param {string} id - The id of the handler to remove\r\n        * @returns{boolean} true if the listener was removed, otherwise false \r\n        */\n\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(type, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return false;\n            }\n            return listener.delete(id);\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {object} config - The config of the track to addTrack\r\n        * @param {integer} index - Optional, the vertical order of the track\r\n        */\n\n    }, {\n        key: \"addTrack\",\n        value: function addTrack(config, index) {\n            var track = _tracks.MLVTrack.getTrack(config);\n            if (this.fixed_height_mode) {\n                track.config.discrete = true;\n            }\n            this.tracks[track.config.track_id] = track;\n            if (index || index == 0) {\n                this.track_order.splice(index, 0, track.config.track_id);\n            } else {\n                this.track_order.push(track.config.track_id);\n            }\n\n            this._tracksChanged();\n            if (this.legend) {\n                this.legend.addTrack(track.config, index);\n            }\n            this._callListeners(\"track_added\", track.config);\n        }\n    }, {\n        key: \"_callListeners\",\n        value: function _callListeners(type, config) {\n\n            this.listeners[type].forEach(function (v) {\n                v(config);\n            });\n        }\n    }, {\n        key: \"removeAllTracks\",\n        value: function removeAllTracks() {\n            var dup_array = this.track_order.slice();\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = dup_array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var id = _step2.value;\n\n                    this.removeTrack(id, true);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {object} config - The config of the track to add \r\n        */\n\n    }, {\n        key: \"removeTrack\",\n        value: function removeTrack(track_id, not_repaint) {\n            if (!this.tracks[track_id]) {\n                return null;\n            }\n            this.track_order = this.track_order.filter(function (e) {\n                return e !== track_id;\n            });\n            if (!not_repaint) {\n                this.repaint(true, true);\n            }\n\n            if (this.legend) {\n                this.legend.removeTrack(track_id);\n            }\n            var config = this.tracks[track_id].config;\n            delete this.tracks[track_id];\n\n            this._callListeners(\"track_removed\", config);\n            if (this.track_order.length === 0) {\n                for (var l_id in this.listeners[\"panel_empty\"]) {\n                    this.listeners[\"panel_empty\"][l_id](this);\n                }\n            }\n            return config;\n        }\n    }, {\n        key: \"getTrackConfig\",\n        value: function getTrackConfig(track_id) {\n            var track = this.tracks[track_id];\n            return track.getConfig();\n        }\n    }, {\n        key: \"getAllTrackConfigs\",\n        value: function getAllTrackConfigs() {\n            var configs = [];\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.track_order[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var id = _step3.value;\n\n                    configs.push(this.tracks[id].getConfig());\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            return configs;\n        }\n    }, {\n        key: \"setTrackAttribute\",\n        value: function setTrackAttribute(track_id, key, value) {\n            var track = this.tracks[track_id];\n            if (!track) {\n                return;\n            }\n            track.setConfigAttribute(key, value);\n            if (key === \"scale_link_to\") {\n                this.tracks[track_id].scale_link_to = this.tracks[value];\n            }\n            if ((key === \"color\" || key === \"display\") && this.legend) {\n                this.legend.updateTrack(track_id);\n            }\n        }\n    }, {\n        key: \"setTrackAttributes\",\n        value: function setTrackAttributes(track_id, attributes) {\n            var track = this.tracks[track_id];\n            for (var key in attributes) {\n                track.setConfigAttribute(key, attributes[key]);\n                if (key === \"color\" && this.legend) {\n                    this.legend.updateTrack(track_id);\n                }\n            }\n        }\n\n        /**\r\n        * Sets the filter  function for track. \r\n        * @param {string} track_id- The id of the track\r\n        * @param {string} func - The filter function. It should accept the feature\r\n        * and return true to dispaly the feature and false to hide it. Use null \r\n        * to cancel the filter\r\n        */\n\n    }, {\n        key: \"setTrackFeatureFilter\",\n        value: function setTrackFeatureFilter(track_id, func) {\n            var track = this.tracks[track_id];\n            track.setFilterFunction(func);\n        }\n\n        /**\r\n        * Sets the filter  function for track \r\n        * @param {string} track_id- The id of the track\r\n        * @param {string} func - The color function. It should accept the feature\r\n        * and return the feature color. Use null to go back to default colors \r\n        */\n\n    }, {\n        key: \"setTrackColorFunction\",\n        value: function setTrackColorFunction(track_id, func) {\n            var track = this.tracks[track_id];\n            track.setColorFunction(func);\n        }\n    }, {\n        key: \"setTrackLabelFunction\",\n        value: function setTrackLabelFunction(track_id, func) {\n            var track = this.tracks[track_id];\n            if (track) {\n                track.label_function = func;\n            }\n        }\n    }, {\n        key: \"_tracksChanged\",\n        value: function _tracksChanged() {\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.track_order[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var t_id = _step4.value;\n\n                    var track = this.tracks[t_id];\n                    //if this track is linked to the scale of another\n                    //get pointer to the track\n                    var link_to = track.config['scale_link_to'];\n                    if (link_to) {\n                        var other_track = this.tracks[link_to];\n                        if (other_track) {\n                            track.scale_link_to = other_track;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getCurrentTrackFeatures\",\n        value: function getCurrentTrackFeatures(track_id) {\n            var track = this.tracks[track_id];\n            return track.getCurrentFeatures(this.chr, this.start, this.end);\n        }\n\n        /**\r\n         * Updated the panel view, if chromosome start and end are supplied\r\n         * it will go to this location. If no parameters are given the panel\r\n         * will be redrawn at the same location e.g after the color, scale or another\r\n         * paramter has been set\r\n         * @param {string} force - If true then a cached image will not be used\r\n         * @param {integer} start of the region to draw\r\n         * @param {integer} end of the region to draw\r\n         */\n\n    }, {\n        key: \"update\",\n        value: function update(chr, start, end, no_propagation) {\n            this.call_update_listener = no_propagation;\n            if (chr) {\n                this.chr = chr;\n                this.start = start;\n                this.end = end;\n                this.repaint();\n            } else {\n                this.repaint(true, true);\n            }\n        }\n    }, {\n        key: \"getTracksHeight\",\n        value: function getTracksHeight() {\n            var h = 0;\n            var groups = {};\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = this.track_order[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var tid = _step5.value;\n\n                    var track = this.tracks[tid];\n                    var g = track.config.group;\n                    if (g) {\n                        if (!groups[g]) {\n                            h += track.config.height;\n                            groups[g] = true;\n                        }\n                    } else {\n                        h += track.config.height;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return h;\n        }\n    }, {\n        key: \"getAllFeatures\",\n        value: function getAllFeatures(bpStart, bpEnd, force, data) {\n            var promises = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = this.track_order[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var track_id = _step6.value;\n\n                    var track = this.tracks[track_id];\n                    promises.push(track.getFeatures(this.chr, bpStart, bpEnd, force, data));\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            return Promise.all(promises);\n        }\n\n        /**\r\n         * Repaint the view, using a cached image if available.\r\n         * @param {boolean} force - If true then a cached image will not be used\r\n         * @param {boolean} range_from_tile Redraw the tile\r\n         */\n\n    }, {\n        key: \"repaint\",\n        value: function repaint(force, range_from_tile) {\n\n            var pixelWidth,\n                bpWidth,\n                bpStart,\n                bpEnd,\n                self = this,\n                ctx,\n                referenceFrame,\n                chr,\n                refFrameStart,\n                refFrameEnd,\n                success;\n\n            chr = this.chr;\n            refFrameStart = this.start;\n            refFrameEnd = this.end;\n            this.bpPerPixel = (this.end - this.start) / this.canvas.width;\n            var get_features = true;\n            if (this.tile && this.tile.containsRange(chr, refFrameStart, refFrameEnd, this.bpPerPixel)) {\n                get_features = false;\n            }\n            if (!get_features && !force && !this.force_redraw) {\n                this.force_redraw = false;\n                this.paintImage();\n                if (!self.call_update_listener) {\n                    self.listeners.view_changed.forEach(function (func) {\n                        func(self.chr, parseInt(self.start), parseInt(self.end));\n                    });\n                }\n                self.call_update_listener = false;\n\n                self.retries = 0;\n            } else {\n                // Expand the requested range so we can pan a bit without reloading\n                this.force_redraw = false;\n                pixelWidth = (this.buffer_level * 2 + 1) * this.canvas.width;\n                bpWidth = Math.round(pixelWidth * this.bpPerPixel);\n                bpStart = Math.max(0, Math.round(this.start - this.buffer_level * this.canvas.width * this.bpPerPixel));\n                bpEnd = bpStart + bpWidth;\n                if (self.loading) {\n                    if (force && range_from_tile) {\n                        self.update_required = true;\n                    } else {\n                        self.update_required = \"location\";\n                    }\n                    return;\n                }\n                if (range_from_tile) {\n                    if (this.tile) {\n                        bpStart = this.tile.startBP;\n                        bpEnd = this.tile.endBP;\n                    }\n                }\n\n                self.loading = { start: bpStart, end: bpEnd };\n                self.trackDiv.find(\".mlv-alert\").remove();\n\n                _utils.Utils.startSpinnerAtParentElement(self.trackDiv);\n\n                self.getAllFeatures(bpStart, bpEnd, !get_features, { pixelWidth: pixelWidth, bpPerPixel: self.bpPerPixel }).then(function (all_features) {\n\n                    if (all_features) {\n\n                        var buffer = document.createElement('canvas');\n                        buffer.width = pixelWidth;\n                        buffer.height = self.fixed_height_mode ? self.getTracksHeight() : self.canvas.height;\n                        ctx = buffer.getContext('2d');\n                        if (self.show_scale) {\n                            self.scale_buffer = document.createElement('canvas');\n                            self.scale_buffer.width = 200;\n                            self.scale_buffer.height = buffer.height;\n                            self.scale_buffer_ctx = self.scale_buffer.getContext(\"2d\");\n                        }\n\n                        var options = {\n                            context: ctx,\n                            bpStart: bpStart,\n                            bpPerPixel: self.bpPerPixel,\n                            pixelWidth: buffer.width,\n                            pixelHeight: buffer.height,\n                            chr: chr\n                        };\n                        var top = 0;\n                        self.groups = {};\n                        self.calculateMaxScale(all_features);\n                        for (var i in all_features) {\n                            var track = self.tracks[self.track_order[i]];\n                            options.features = all_features[i];\n                            var group = track.config.group;\n                            if (group) {\n                                if (!self.groups[group]) {\n                                    self.groups[group] = { top: top, height: track.config.height\n                                        //first time increase top\n                                    };top += track.config.height;\n                                }\n                                options.top = self.groups[group].top;\n                                options.height = self.groups[group].height;\n                            } else {\n                                options.top = top;\n                            }\n\n                            var disc = self.fixed_height_mode || track.config.discrete || group;\n                            if (disc) {\n                                var h = group ? options.height : track.config.height;\n                                ctx.save();\n                                ctx.rect(0, options.top, options.pixelWidth, h);\n                                ctx.clip();\n                                ctx.beginPath();\n                            }\n                            var offset = track.drawFeatures(options);\n\n                            if (disc) {\n                                ctx.restore();\n                                if (!group) {\n                                    top += track.config.height;\n                                    track.bottom = top;\n                                }\n                            } else if (offset) {\n                                top = offset;\n                            }\n\n                            if (self.show_scale) {\n\n                                track.drawScale(options.pixelHeight, self.scale_buffer_ctx);\n                            }\n                        }\n                        for (var name in self.highlighted_regions) {\n                            var region = self.highlighted_regions[name];\n                            if (self.chr !== region.chr) {\n                                continue;\n                            }\n                            if (region.end < bpStart || region.start > bpEnd) {\n                                continue;\n                            }\n                            self.drawHighlightedRegion(region, options);\n                        }\n                        self.retries = 0;\n                        self.loading = false;\n                        self.tile = new Tile(chr, bpStart, bpEnd, self.bpPerPixel, buffer);\n                        self.paintImage();\n                        if (!self.call_update_listener) {\n                            self.listeners.view_changed.forEach(function (func) {\n                                func(self.chr, parseInt(self.start), parseInt(self.end));\n                            });\n                        }\n                        self.call_update_listener = false;\n                    } else {\n                        self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);\n                    }\n                    if (self.update_required) {\n                        if (self.update_required === \"location\") {\n                            self.update(self.chr, self.start, self.end);\n                            self.update_required = false;\n                        } else {\n                            self.update_required = false;\n                            self.update();\n                        }\n                    }\n                    _utils.Utils.stopSpinnerAtParentElement(self.trackDiv);\n                }).catch(function (error) {\n                    self.loading = false;\n\n                    console.log(error);\n                    if (self.retries < 3 && error !== \"Timed out\") {\n                        self.retries++;\n                        self.repaint(force, range_from_tile);\n                    } else {\n                        _utils.Utils.stopSpinnerAtParentElement(self.trackDiv);\n                        self.loading = false;\n                        self.force_redraw = true;\n                        _utils.Utils.presentAlert(self.trackDiv, error);\n                    }\n                });\n            }\n\n            function viewIsReady() {\n                return this.track;\n            }\n        }\n    }, {\n        key: \"autoScale\",\n        value: function autoScale(features, min, max) {\n            if (!features) {\n                return { min: 0, max: 1 };\n            }\n            features.forEach(function (f) {\n                min = Math.min(min, f.value);\n                max = Math.max(max, f.value);\n            });\n            return { min: min, max: max };\n        }\n    }, {\n        key: \"calculateMaxScale\",\n        value: function calculateMaxScale(all_features) {\n            var groups = {};\n            for (var i in all_features) {\n                var track = this.tracks[this.track_order[i]];\n                track.set_scale = null;\n                var group = track.config.group;\n                if (group && track.config.scale !== \"fixed\" && !track.config.scale_link_to) {\n                    track.config.scale_group = group;\n                }\n                group = track.config.scale_group;\n                if (group) {\n                    var group_info = groups[group];\n                    if (!group_info) {\n                        group_info = { tracks: [track], features: [all_features[i]] };\n                        groups[group] = group_info;\n                    } else {\n                        group_info.features.push(all_features[i]);\n                        group_info.tracks.push(track);\n                    }\n                }\n            }\n            for (var name in groups) {\n                var g = groups[name];\n                if (!g.ignore) {\n                    var min = 0;\n                    var max = -Number.MAX_VALUE;\n                    var scale = null;\n                    var _iteratorNormalCompletion7 = true;\n                    var _didIteratorError7 = false;\n                    var _iteratorError7 = undefined;\n\n                    try {\n                        for (var _iterator7 = g.features[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                            var f = _step7.value;\n\n                            scale = this.autoScale(f, min, max);\n                            min = scale.min;\n                            max = scale.max;\n                        }\n                    } catch (err) {\n                        _didIteratorError7 = true;\n                        _iteratorError7 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                _iterator7.return();\n                            }\n                        } finally {\n                            if (_didIteratorError7) {\n                                throw _iteratorError7;\n                            }\n                        }\n                    }\n\n                    var _iteratorNormalCompletion8 = true;\n                    var _didIteratorError8 = false;\n                    var _iteratorError8 = undefined;\n\n                    try {\n                        for (var _iterator8 = g.tracks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                            var t = _step8.value;\n\n                            t.set_scale = scale;\n                        }\n                    } catch (err) {\n                        _didIteratorError8 = true;\n                        _iteratorError8 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                _iterator8.return();\n                            }\n                        } finally {\n                            if (_didIteratorError8) {\n                                throw _iteratorError8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"drawHighlightedRegion\",\n        value: function drawHighlightedRegion(region, options) {\n            var start = (region.start - options.bpStart) / options.bpPerPixel;\n            start = start < 0 ? 0 : start;\n\n            var width = (region.end - region.start) / options.bpPerPixel;\n            width = width < 3 ? 3 : width;\n            width = width > options.pixelWidth ? options.pixelWidth : width;\n            options.context.globalAlpha = 0.1;\n            options.context.fillStyle = region.color;\n            options.context.fillRect(start, 0, width, options.pixelHeight);\n            options.context.globalAlpha = 1.0;\n        }\n    }, {\n        key: \"paintImage\",\n        value: function paintImage() {\n\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            if (this.show_scale) {\n                this.scale_ctx.clearRect(0, 0, 100, this.canvas.height);\n                this.scale_ctx.drawImage(this.scale_buffer, 0, this.yOffset);\n            }\n\n            if (this.tile) {\n                this.xOffset = Math.round((this.tile.startBP - this.start) / this.bpPerPixel);\n                this.ctx.drawImage(this.tile.image, this.xOffset, this.yOffset);\n                this.ctx.save();\n                this.ctx.restore();\n            }\n        }\n    }, {\n        key: \"allowUserFeatureOver\",\n        value: function allowUserFeatureOver() {\n            var self = this;\n\n            this.trackDiv.on(\"mousemove.feature_over\", function (e) {\n                if (self.loading) {\n                    return;\n                }\n                clearTimeout(self.moto);\n                self.moto = setTimeout(function () {\n                    if (!self.is_dragging) {\n                        var info = self.getFeatureAt(e);\n                        var i = self.mouse_over_feature;\n                        if (info.feature) {\n                            if (i && i.feature !== info.feature) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(i.track, i.feature, e, \"out\");\n                                });\n                            }\n\n                            if (!i || i.feature !== info.feature) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(info.track, info.feature, e, \"over\");\n                                });\n                                self.mouse_over_feature = info;\n                            }\n                        } else {\n                            var _i = self.mouse_over_feature;\n                            if (_i) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(_i.track, _i.feature, e, \"out\");\n                                });\n                                self.mouse_over_feature = null;\n                            }\n                        }\n                    }\n                }, 10);\n            });\n        }\n    }, {\n        key: \"removeFeatureOverHandler\",\n        value: function removeFeatureOverHandler() {\n            this.trackDiv.off(\"mousedown.feature_over\");\n        }\n    }, {\n        key: \"allowUserFeatureClick\",\n        value: function allowUserFeatureClick() {\n            var self = this;\n\n            this.allowUserFeatureOver();\n            this.addListener(\"feature_over\", function (track, feature, over, type) {\n                if (!feature) {\n                    self.trackDiv.css(\"cursor\", \"default\");\n                }\n                var pointer = type === \"over\" ? \"pointer\" : \"default\";\n                self.trackDiv.css(\"cursor\", pointer);\n            });\n\n            this.trackDiv.on(\"mousedown.feature_click\", function (e) {\n                if (self.loading) {\n                    return;\n                }\n                clearTimeout(self.to);\n                self.to = setTimeout(function () {\n                    if (!self.is_dragging) {\n                        var info = self.getFeatureAt(e);\n                        if (info.track) {\n                            self.listeners.feature_clicked.forEach(function (func) {\n                                func(info.track, info.feature, e);\n                            });\n                        }\n                    }\n                }, 200);\n            });\n        }\n    }, {\n        key: \"removeFeatureOverHandler\",\n        value: function removeFeatureOverHandler() {\n            this.trackDiv.off(\"mousedown.feature_click\");\n        }\n    }, {\n        key: \"allowUserDrag\",\n        value: function allowUserDrag() {\n            var self = this;\n            this.trackDiv.on(\"mousedown.draghandler\", function (e) {\n                if (e.shiftKey) {\n                    return;\n                }\n                var canvasCoords = _utils.Utils.translateMouseCoordinates(e, self.canvas);\n                self.isMouseDown = true;\n                self.start_dragging = true;\n                self.lastMouseX = canvasCoords.x;\n                self.lastMouseY = canvasCoords.y;\n                self.mouseDownX = self.lastMouseX;\n            }).on(\"mousemove.draghandler\", function (e) {\n                var canvasCoords = _utils.Utils.translateMouseCoordinates(e, self.canvas);\n                if (self.is_dragging || self.start_dragging) {\n                    var diff = canvasCoords.x - self.lastMouseX;\n                    var bp_diff = self.bpPerPixel * diff;\n                    self.start -= bp_diff;\n                    self.end -= bp_diff;\n                    var dd = self.canvas.height - self.tile.image.height;\n                    var y_diff = 0;\n                    if (dd < 0 || self.yOffset !== 0) {\n                        var _y_diff = canvasCoords.y - self.lastMouseY;\n                        self.yOffset += _y_diff;\n                        if (self.yOffset > 0) {\n                            self.yOffset = 0;\n                        } else if (self.yOffset < dd) {\n                            self.yOffset = dd;\n                        }\n                    }\n                    self.repaint();\n                    self.lastMouseX = canvasCoords.x;\n                    self.lastMouseY = canvasCoords.y;\n                    if (self.start_dragging && (diff > 5 || y_diff > 5)) {\n                        self.is_dragging = true;\n                        self.start_dragging = false;\n                    }\n                }\n            }).on(\"mouseup.draghandler\", function (e) {\n                self.is_dragging = false;\n                self.start_dragging = false;\n            });\n            return this;\n        }\n    }, {\n        key: \"removeDragHandler\",\n        value: function removeDragHandler() {\n            this.trackDiv.off(\"mousedown.draghandler mousemove.draghandler mouseup.draghandler\");\n        }\n    }, {\n        key: \"_getCoords\",\n        value: function _getCoords(e) {\n            var x = e.pageX - $(this.canvas).offset().left;\n            var y = e.pageY - $(this.canvas).offset().top;\n            return { x: x, y: y };\n        }\n    }, {\n        key: \"allowUserZoom\",\n        value: function allowUserZoom() {\n            var self = this;\n            this.trackDiv.on('mousewheel.zoom  mouse.zoom DOMMouseScroll', function (event) {\n                var deltaY = event.originalEvent.deltaY;\n                if (deltaY === undefined) {\n                    deltaY = event.originalEvent.detail;\n                }\n                if (self.loading || self.bpPerPixel < 0.05 && deltaY > 0) {\n                    return;\n                }\n\n                var canvasCoords = self._getCoords(event.originalEvent);\n                var factor = deltaY < 0 ? 2 : 0.5;\n                var mbp = self.start + canvasCoords.x * self.bpPerPixel;\n                var new_length = (self.end - self.start) * factor;\n                var new_start = mbp - canvasCoords.x / self.canvas.width * new_length;\n                self.start = new_start;\n                self.end = new_start + new_length;\n\n                self.repaint();\n            });\n            return this;\n        }\n    }, {\n        key: \"disableUserZoom\",\n        value: function disableUserZoom() {\n            this.trackDiv.off(\"mousewheel.zoom\");\n        }\n    }, {\n        key: \"allowUserRangeSelection\",\n        value: function allowUserRangeSelection() {\n            var self = this;\n            this.trackDiv.on(\"mousedown.selection\", function (e) {\n                if (e.shiftKey) {\n                    self.start_select = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    var left = self.start_select + \"px\";\n                    var td = $(this);\n                    self.select_div = $(\"<div>\").css({ \"position\": \"absolute\", \"opacity\": 0.2, \"background-color\": \"blue\", \"top\": \"0px\", \"height\": td.css(\"height\"), left: left, \"width\": \"0px\" }).appendTo(td);\n\n                    e.stopPropagation();\n                }\n            }).on(\"mousemove.selection\", function (e) {\n                if (e.shiftKey && self.start_select) {\n                    var x = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    if (x < self.start_select) {\n                        self.select_div.css({ \"left\": x + \"px\", \"width\": self.start_select - x + \"px\" });\n                    } else {\n\n                        self.select_div.css({ \"left\": self.start_select + \"px\", \"width\": x - self.start_select + \"px\" });\n                    }\n\n                    e.stopPropagation();\n                }\n            }).on(\"mouseup.selection\", function (e) {\n                if (self.start_select) {\n                    var x = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    var start = self.start + self.start_select * self.bpPerPixel;\n                    var end = self.start + x * self.bpPerPixel;\n                    self.start_select = null;\n                    self.select_div.remove();\n                    if (start > end) {\n                        var temp = end;\n                        end = start;\n                        start = temp;\n                    }\n                    self.listeners.range_selected.forEach(function (func) {\n                        func(self.chr, start, end);\n                    });\n                }\n            });\n        }\n    }, {\n        key: \"removeAllowSelection\",\n        value: function removeAllowSelection() {\n            this.trackDiv.off(\"mousedown.selection mousemove.selection mouseup.selection\");\n        }\n    }, {\n        key: \"getImage\",\n        value: function getImage() {\n            var imgURL = this.canvas[0].toDataURL(MIME_TYPE);\n        }\n    }, {\n        key: \"allowUserDrop\",\n        value: function allowUserDrop() {\n            var div = this.trackDiv;\n            var self = this;\n            div.droppable({\n                over: function over(e, ui) {\n                    var track = ui.draggable.data(\"track\");\n                    var panel = ui.draggable.data(\"panel\");\n                    if (panel === self) {\n                        return;\n                    }\n                    if (track) {\n                        var icon = \"<span class='ui-icon ui-icon-check'></span>\";\n                        if (track.no_drop || self.tracks[track.track_id]) {\n                            icon = \"<span class='ui-icon  ui-icon-closethick'></span>\";\n                        }\n                        setTimeout(function () {\n                            ui.helper.prepend(icon).css(\"white-space\", \"nowrap\");\n                        }, 20);\n                    }\n                },\n                greedy: true,\n                out: function out(e, ui) {\n                    ui.helper.find(\".ui-icon\").remove();\n                },\n                drop: function drop(e, ui) {\n                    var track = $(ui.draggable[0]).data(\"track\");\n                    ui.helper.find(\".ui-icon\").remove();\n\n                    if (!track) {\n                        return;\n                    }\n                    var panel = $(ui.draggable[0]).data(\"panel\");\n\n                    if (panel === self || track.no_drop || self.tracks[track.track_id]) {\n                        return;\n                    } else {\n                        if (panel) {\n                            panel.removeTrack(track.track_id);\n                            panel.update();\n                        }\n                        self.addTrack(track);\n                        self.update();\n                    }\n                }\n            });\n            return this;\n        }\n\n        /**\r\n        * Gets the feature that was clicked\r\n        * @param {JQuery Event} e - Can be any object- all that is required is pageX and PageY\r\n        * @returns {object} An object with track - the track config at the event position(or null) and\r\n        * feature - the feature at the postition (or null). \r\n        */\n\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(e) {\n            var co = _utils.Utils.translateMouseCoordinates(e, this.canvas);\n            co.y -= this.yOffset;\n            var gl = Math.round(this.start + co.x * this.bpPerPixel);\n            for (var t in this.tracks) {\n                var track = this.tracks[t];\n                if (co.y > track.top && co.y < track.bottom) {\n                    return { track: track,\n                        feature: track.getFeatureAt(gl, this.chr, co, this.bpPerPixel, this.ctx, this.yOffset)\n                    };\n                }\n            }\n            return { track: null, feature: null };\n        }\n    }, {\n        key: \"allowUserResize\",\n        value: function allowUserResize(direction) {\n            var handles = \"all\";\n            if (direction === \"vertical\") {\n                handles = \"n,s\";\n            } else if (direction === \"horizontal\") {\n                handles = \"e,w\";\n            }\n            var div = this.trackDiv;\n            var self = this;\n\n            div.resizable({\n\n                resize: function resize(e, ui) {\n                    e.stopPropagation();\n                    if (self.loading) {\n                        return false;\n                    }\n\n                    clearTimeout(self.to);\n                    self.to = setTimeout(function (e) {\n                        self.setWidth(ui.size.width);\n                        self.setHeight(ui.size.height);\n                        self.update();\n                    }, 100);\n                },\n                handles: handles\n\n            });\n            return this;\n        }\n\n        /**\r\n        * Allows the user to move the panel via a handle in the\r\n        * top right hand corner\r\n        * @param {string} direction - either vertical or horzontal, will restrict movement \r\n        * in this plane\r\n        * @param {boolean} if true then the panel will be constrained within its parent \r\n        */\n\n    }, {\n        key: \"allowUserMove\",\n        value: function allowUserMove(direction, contain) {\n            var axis = false;\n            var icon = \"fa-arrows-alt\";\n            if (direction == \"vertical\") {\n                axis = \"y\";\n                icon += \"-v\";\n            } else if (direction == \"horizontal\") {\n                axis = \"x\";\n                icon += \"-h\";\n            }\n            var div = this.trackDiv;\n            div.find(\".panel-icon-div\").prepend($(\"<span class='track-handle fas \" + icon + \"'></span>\").css({ \"cursor\": \"move\" }));\n            var self = this;\n            var c = false;\n            if (contain) {\n                c = \"parent\";\n            }\n            div.draggable({ handle: \".track-handle\", axis: axis, containment: c });\n            return this;\n        }\n    }, {\n        key: \"allowUserClose\",\n        value: function allowUserClose() {\n            var div = this.trackDiv;\n            var self = this;\n            var icon = $(\"<span class='fas fa-trash'></span>\").click(function () {\n                self.listeners.panel_closed.forEach(function (func) {\n                    func(self);\n                });\n                div.remove();\n            });\n            div.find(\".panel-icon-div\").append(icon);\n        }\n    }, {\n        key: \"setWidth\",\n        value: function setWidth(width) {\n            this.trackDiv.width(width);\n            this.canvas.setAttribute('width', width);\n        }\n    }, {\n        key: \"setHeight\",\n        value: function setHeight(height) {\n            $(this.trackDiv).height(height);\n            this.canvas.setAttribute('height', height);\n            if (this.show_scale) {\n                this.scale_canvas[0].setAttribute(\"height\", height);\n            }\n        }\n    }, {\n        key: \"redrawTile\",\n        value: function redrawTile(features) {\n\n            if (!this.tile) return;\n\n            var self = this,\n                chr = self.tile.chr,\n                bpStart = self.tile.startBP,\n                bpEnd = self.tile.endBP,\n                buffer = document.createElement('canvas'),\n                bpPerPixel = self.tile.scale;\n\n            buffer.width = self.tile.image.width;\n            buffer.height = self.tile.image.height;\n            var ctx = buffer.getContext('2d');\n\n            self.track.draw({\n                features: features,\n                context: ctx,\n                bpStart: bpStart,\n                bpPerPixel: bpPerPixel,\n                pixelWidth: buffer.width,\n                pixelHeight: buffer.height\n            });\n\n            self.tile = new Tile(chr, bpStart, bpEnd, bpPerPixel, buffer);\n            self.paintImage();\n        }\n    }]);\n\n    return MLVPanel;\n}();\n\nvar Tile = function () {\n    function Tile(chr, tileStart, tileEnd, scale, image) {\n        _classCallCheck(this, Tile);\n\n        this.chr = chr;\n        this.startBP = tileStart;\n        this.endBP = tileEnd;\n        this.scale = scale;\n        this.image = image;\n    }\n\n    _createClass(Tile, [{\n        key: \"containsRange\",\n        value: function containsRange(chr, start, end, scale) {\n            if (start < 0) {\n                start = 0;\n            }\n            return this.scale.toFixed(3) === scale.toFixed(3) && start >= this.startBP && end <= this.endBP && chr === this.chr;\n        }\n    }, {\n        key: \"overlapsRange\",\n        value: function overlapsRange(chr, start, end) {\n            return this.chr === chr && this.endBP >= start && this.startBP <= end;\n        }\n    }]);\n\n    return Tile;\n}();\n\nexports.MLVPanel = MLVPanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3BhbmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9wYW5lbC5qcz9hNGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGlnaHR3ZWlnaHQgcGFuZWwgdGhlIGNhbiBob3N0IG11bHRpcGxlIHRyYWNrcyBvZlxyXG4gKiBkaWZmZXJlbnQgdHlwZXNcclxuICovXHJcbmltcG9ydCB7TUxWVHJhY2ssUnVsZXJUcmFja30gZnJvbSBcIi4vdHJhY2tzLmpzXCI7XHJcbmltcG9ydCB7VXRpbHN9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7UGFuZWxMZWdlbmR9IGZyb20gXCIuL3BhbmVsX2xlZ2VuZC5qc1wiO1xyXG5cclxuXHJcblxyXG5jbGFzcyBNTFZQYW5lbCB7XHJcblx0LyoqXHJcblx0KiBDcmVhdGVzIGEgcGFuZWxcclxuXHQqIEBwYXJhbSB7YXJyYXl9IHRyYWNrcyAtIGEgbGlzdCBvZiBjb25maWcgb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggdHJhY2tcclxuXHQqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBBIGNvbmZpZyB3aXRoIHRoZSBwYW5lbCBzZXR0aW5nc1xyXG5cdCovXHJcblx0Y29uc3RydWN0b3IgKHRyYWNrcyxjb25maWcpIHtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0Y29uZmlnPXt9O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXhlZF9oZWlnaHRfbW9kZT1mYWxzZTtcclxuXHRcdGlmIChjb25maWcuZml4ZWRfaGVpZ2h0X21vZGUpe1xyXG5cdFx0XHR0aGlzLmZpeGVkX2hlaWdodF9tb2RlPXRydWU7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXMuc2hvd19zY2FsZT10cnVlO1xyXG5cdFx0aWYgKGNvbmZpZy5zaG93X3NjYWxlKXtcclxuICAgICAgIFx0XHR0aGlzLnNob3dfc2NhbGU9dHJ1ZTtcclxuICAgICAgIFx0fVxyXG5cclxuXHRcdGxldCBoZWlnaHQ9Y29uZmlnLmhlaWdodD9jb25maWcuaGVpZ2h0OjIwMDtcclxuXHRcdGxldCB3aWR0aD0gY29uZmlnLndpZHRoP2NvbmZpZy53aWR0aDo0MDA7XHJcblx0XHRsZXQgZGltPXtoZWlnaHQ6aGVpZ2h0LHdpZHRoOndpZHRofTtcclxuXHRcdGxldCBwYW5lbF9kaXY9bnVsbDtcclxuXHRcdGlmICghY29uZmlnLmRpdil7XHJcblx0XHRcdHBhbmVsX2Rpdj0kKFwiPGRpdj5cIikuaGVpZ2h0KGhlaWdodCkud2lkdGgod2lkdGgpO1xyXG5cclxuXHRcdH1cclxuXHRcdGVsc2V7XHJcblx0XHRcdGlmICh0eXBlb2YgY29uZmlnLmRpdiA9PT0gJ3N0cmluZycgKXtcclxuXHRcdFx0XHRwYW5lbF9kaXY9JChcIiNcIitjb25maWcuZGl2KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNle1xyXG5cdFx0XHRcdHBhbmVsX2Rpdj0kKGNvbmZpZy5kaXYpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGhlaWdodD1wYW5lbF9kaXYuaGVpZ2h0KCk7XHJcblx0XHRcdHdpZHRoPXBhbmVsX2Rpdi53aWR0aCgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy50cmFja3M9e31cclxuXHRcdHRoaXMudHJhY2tfb3JkZXI9W107XHJcblx0XHRmb3IgKGxldCB0X2NvbmZpZyBvZiB0cmFja3Mpe1xyXG5cdFx0XHRpZiAodGhpcy5maXhlZF9oZWlnaHRfbW9kZSl7XHJcbiAgICBcdFx0XHR0X2NvbmZpZy5kaXNjcmV0ZT10cnVlO1xyXG4gICAgXHRcdH1cclxuXHRcdFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKHRfY29uZmlnKTtcclxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZClcclxuXHRcdH1cclxuXHRcdC8vY2hlY2sgZm9yIGxpbmtlZCBzY2FsZXNcclxuXHRcdHRoaXMuX3RyYWNrc0NoYW5nZWQoKTtcclxuXHRcdHRoaXMubGVnZW5kPSBudWxsO1xyXG5cclxuICAgICAgXHJcbiAgICAgICBcdHRoaXMudHJhY2tEaXYgPSBwYW5lbF9kaXYuYWRkQ2xhc3MoXCJpZ3YtdHJhY2stZGl2XCIpLmNzcyhcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKTtcclxuXHJcblx0XHR0aGlzLmNhbnZhcyA9ICQoJzxjYW52YXMgY2xhc3MgPSBcImlndi1jb250ZW50LWNhbnZhc1wiPicpWzBdO1xyXG4gICAgICAgIHRoaXMudHJhY2tEaXYuYXBwZW5kKHRoaXMuY2FudmFzKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgXHR0aGlzLmFkZFNjYWxlQ2FudmFzKGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMudHJhY2tEaXYuYXBwZW5kKFV0aWxzLnNwaW5uZXIoKSk7XHJcblxyXG4gICAgICAgIGxldCBpY29uX2Rpdj0kKFwiPGRpdj5cIikuY3NzKHtcInotaW5kZXhcIjoxMDAscG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjJweFwiLHJpZ2h0OlwiMnB4XCJ9KS5hcHBlbmRUbyh0aGlzLnRyYWNrRGl2KVxyXG4gICAgICAgIFx0XHRcdFx0XHQgICAuYXR0cihcImNsYXNzXCIsXCJwYW5lbC1pY29uLWRpdlwiKVxyXG5cclxuXHJcbiAgICAgICAgLy9mb3IgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgIFx0dGhpcy5pc19kcmFnZ2luZz1mYWxzZTtcclxuICAgICAgIFx0dGhpcy5pc01vdXNlRG93biA9IGZhbHNlLFxyXG4gICAgICBcdHRoaXMubGFzdE1vdXNlWCA9IHVuZGVmaW5lZDtcclxuICAgICAgIFx0dGhpcy5tb3VzZURvd25YID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vYW1vdW50IHRvIHNob3cgZWFjaCBzaWRlIG9mIHZpZXcgcG9ydFxyXG4gICAgICAgXHR0aGlzLmJ1ZmZlcl9sZXZlbD0xO1xyXG5cclxuICAgICAgIFx0dGhpcy5ncm91cHM9e307XHJcblxyXG4gICAgICAgXHR0aGlzLmhpZ2hsaWdodGVkX3JlZ2lvbnM9e307XHJcblxyXG4gICAgICAgXHQvL2xpc3RlbmVyc1xyXG5cdFx0dGhpcy5saXN0ZW5lcnM9e1xyXG4gICAgICAgXHRcdFwicGFuZWxfZW1wdHlcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJwYW5lbF9jbG9zZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJ0cmFja19hZGRlZFwiOm5ldyBNYXAoKSxcclxuICAgICAgIFx0XHRcInRyYWNrX3JlbW92ZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJ2aWV3X2NoYW5nZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJmZWF0dXJlX2NsaWNrZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJmZWF0dXJlX292ZXJcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJyYW5nZV9zZWxlY3RlZFwiOm5ldyBNYXAoKVxyXG4gICAgICAgXHR9O1xyXG5cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2RyYWcpe1xyXG4gICAgICAgXHRcdHRoaXMuYWxsb3dVc2VyRHJhZygpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl96b29tKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclpvb20oKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHRpZiAoY29uZmlnLmFsbG93X3VzZXJfcmVzaXplKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclJlc2l6ZShjb25maWcuYWxsb3dfdXNlcl9yZXNpemUpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9tb3ZlKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlck1vdmUoY29uZmlnLmFsbG93X3VzZXJfbW92ZSk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2ZlYXR1cmVfY2xpY2spe1xyXG4gICAgICAgXHRcdHRoaXMuYWxsb3dVc2VyRmVhdHVyZUNsaWNrKCk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2ZlYXR1cmVfb3Zlcil7XHJcbiAgICAgICBcdFx0dGhpcy5hbGxvd1VzZXJGZWF0dXJlT3ZlcigpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9jbG9zZSl7XHJcbiAgICAgICBcdFx0dGhpcy5hbGxvd1VzZXJDbG9zZSgpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9kcm9wKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlckRyb3AoKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHRpZiAoY29uZmlnLmFsbG93X3VzZXJfcmFuZ2Vfc2VsZWN0aW9uKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclJhbmdlU2VsZWN0aW9uKCk7XHJcbiAgICAgICBcdH1cclxuXHJcbiAgICAgICBcdGlmKGNvbmZpZy5ydWxlcl90cmFjayl7XHJcbiAgICAgICBcdFx0dGhpcy5hZGRSdWxlclRyYWNrKCk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYoY29uZmlnLmxlZ2VuZCl7XHJcbiAgICAgICBcdFx0dGhpcy5hZGRMZWdlbmQoKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHJcbiAgICAgICBcdHRoaXMucmV0cmllcz0wO1xyXG4gICAgICAgXHR0aGlzLnlPZmZzZXQ9MDtcclxuICAgIH1cclxuXHJcbiAgICBfcGFyc2VDb25maWcoY29uZmlnKXtcclxuICAgIFx0Ly9jaGVjayB0aGUgdHJhY2tzIGhhdmUgdGhlIHJpZ2h0IHNldHRpbmdzXHJcbiAgICBcdGlmICh0aGlzLmZpeGVkX2hlaWdodF9tb2RlKXtcclxuICAgIFx0XHRjb25maWcuZGlzY3JldGU9dHJ1ZTtcclxuICAgIFx0XHRpZiAoIWNvbmZpZy5oZWlnaHQpe1xyXG4gICAgXHRcdFx0Y29uZmlnLmhlaWdodD0xNTA7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkU2NhbGVDYW52YXMoaGVpZ2h0KXtcclxuICAgIFx0dGhpcy5zY2FsZV9jYW52YXMgPSAkKCc8Y2FudmFzPicpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjBweFwiLGxlZnQ6XCI1cHhcIn0pO1xyXG4gICAgXHR0aGlzLnNjYWxlX2NhbnZhc1swXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMTAwKTtcclxuICAgICAgICB0aGlzLnNjYWxlX2NhbnZhc1swXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zY2FsZV9jYW52YXMuYXBwZW5kVG8odGhpcy50cmFja0Rpdik7XHJcbiAgICAgICAgdGhpcy5zY2FsZV9jdHg9dGhpcy5zY2FsZV9jYW52YXNbMF0uZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogc2V0cyB0aGUgZXh0cmEgYW1vdW50IG9mIHRyYWNrIHRvIGRyYXcgZWFjaCBzaWRlIG9mIHRoZSB2aWV3LiBBIHZhbHVlIFxyXG5cdCogb2YgMSB3aWxsIHJldHJlaXZlIDEgeCB0aGUgdmlldyB3aWR0aCBlYWNoIHNpZGUgaS5lLiAzIHggdGhlIHZpc2libGUgd2luZG93XHJcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGxldmVsIC0gVGhlIHR5cGUgb2YgbGlzdGVuZXIgLSB0cmFja19lbXB0eSBcclxuXHQqL1xyXG4gICAgc2V0QnVmZmVyTGV2ZWwobGV2ZWwpe1xyXG4gICAgXHR0aGlzLmJ1ZmZlcl9sZXZlbD1sZXZlbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG5cdCogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGhvdXNlcyB0aGUgcGFuZWxcclxuXHQqIEByZXR1cm5zIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB0eXBlIG9mIGxpc3RlbmVyIC0gdHJhY2tfZW1wdHkgXHJcblx0Ki9cclxuXHJcbiAgICBnZXREaXYoKXtcclxuICAgIFx0cmV0dXJuIHRoaXMudHJhY2tEaXY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgYWRkTGVnZW5kKCl7XHJcbiAgICBcdHRoaXMubGVnZW5kID0gbmV3IFBhbmVsTGVnZW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgICAgICAvKipcclxuXHQqIFNldHMgdGhlIGhpZ2hsaWd0ZWQgcmVnaW9uXHJcblx0KiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBBbiBvYmplY3QgY29udGFpbmluZyBjaHIsIHN0YXJ0IGFuZCBlbmRcclxuXHQqIEBwYXJhbSB7bmFtZX0gVGhlIG5hbWUoaWQpIG9mIHRoZSByZWdpb24gKHVzZWQgdG8gcmVtb3ZlIHRoZSByZWdpb24pXHJcblx0KiBAcGFyYW0ge1N0cmluZ30gVGhlIGNvbG9yIHRvIGdpdmUgdGhlIGhpZ2hsaWd0ZWQgcmVnaW9uXHJcblx0Ki9cclxuICAgIHNldEhpZ2hsaWdodGVkUmVnaW9uKGxvY2F0aW9uLG5hbWUsY29sb3Ipe1xyXG4gICAgXHR0aGlzLmhpZ2hsaWdodGVkX3JlZ2lvbnNbbmFtZV09e1xyXG4gICAgXHRcdGNocjpsb2NhdGlvbi5jaHIsXHJcbiAgICBcdFx0c3RhcnQ6bG9jYXRpb24uc3RhcnQsXHJcbiAgICBcdFx0ZW5kOmxvY2F0aW9uLmVuZCxcclxuICAgIFx0XHRjb2xvcjpjb2xvclxyXG4gICAgXHR9XHJcbiAgICBcdHRoaXMuZm9yY2VfcmVkcmF3PXRydWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogUmVtb3ZlcyB0aGUgaGlnaGxpZ2h0ZWQgcmVnaW9uIGZyb20gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBoaWdobGlnaHRlZCByZWdpb25cclxuXHQqIHRoYXQgd2FzIGdpdmVuIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXHJcblx0Ki9cclxuICAgIHJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKG5hbWUpe1xyXG4gICAgXHRkZWxldGUgdGhpcy5oaWdobGlnaHRlZF9yZWdpb25zW25hbWVdO1xyXG4gICAgXHR0aGlzLmZvcmNlX3JlZHJhdz10cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIGFkZFJ1bGVyVHJhY2soKXtcclxuICAgIFx0bGV0IHRyYWNrPW5ldyBSdWxlclRyYWNrKCk7XHJcbiAgICBcdGxldCBjb25maWcgPSB0cmFjay5nZXRDb25maWcoKTtcclxuXHRcdHRoaXMudHJhY2tzW2NvbmZpZy50cmFja19pZF09dHJhY2s7XHJcblx0XHR0aGlzLnRyYWNrX29yZGVyLnVuc2hpZnQoY29uZmlnLnRyYWNrX2lkKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBwYW5lbFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0ZW5lciAtIHRyYWNrX2VtcHR5XHJcblx0KiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGhhbmRsZXIgKGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgaGFuZGxlcilcclxuXHQqIE9wdGlvbmFsIC0gYW4gaWQgd2lsbCBiZSBhc3NpZ25lZCAoYW5kIHJldHVybmVkKSBpZiBub3Qgc3VwcGxpZWRcclxuXHQqIEByZXR1cm5ze3N0cmluZ30gVGhlIGlkIG9mIHRoZSBoYW5kbGVyIG9yIG51bGwgaWYgdGhlIHR5cGUgZGlkIG5vdCBleGlzdCBcclxuXHQqL1xyXG4gICAgYWRkTGlzdGVuZXIodHlwZSxmdW5jLGlkKXtcclxuICAgIFx0bGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XHJcbiAgICBcdGlmICghbGlzdGVuZXIpe1xyXG4gICAgXHRcdHJldHVybiBudWxsO1xyXG4gICAgXHR9XHJcbiAgICBcdGlmICghaWQpe1xyXG4gICAgXHRcdGlkID0gdHlwZStcIl9cIitsaXN0ZW5lci5zaXplXHJcbiAgICBcdH1cclxuICAgIFx0bGlzdGVuZXIuc2V0KGlkLGZ1bmMpO1xyXG4gICAgXHRyZXR1cm4gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcblx0KiBSZW1vdmVzIGEgbGlzdGVuZXIgdG8gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGxpc3RlbmVyIC0gdHJhY2tfZW1wdHkgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGhhbmRsZXIgdG8gcmVtb3ZlXHJcblx0KiBAcmV0dXJuc3tib29sZWFufSB0cnVlIGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZCwgb3RoZXJ3aXNlIGZhbHNlIFxyXG5cdCovXHJcbiAgICByZW1vdmVMaXN0ZW5lcih0eXBlLGlkKXtcclxuICAgIFx0bGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XHJcbiAgICBcdGlmICghbGlzdGVuZXIpe1xyXG4gICAgXHRcdHJldHVybiBmYWxzZTtcclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gbGlzdGVuZXIuZGVsZXRlKGlkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgIFxyXG4gICAgLyoqXHJcblx0KiBSZW1vdmVzIGEgbGlzdGVuZXIgdG8gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gVGhlIGNvbmZpZyBvZiB0aGUgdHJhY2sgdG8gYWRkVHJhY2tcclxuXHQqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggLSBPcHRpb25hbCwgdGhlIHZlcnRpY2FsIG9yZGVyIG9mIHRoZSB0cmFja1xyXG5cdCovXHJcbiAgICBhZGRUcmFjayhjb25maWcsaW5kZXgpe1xyXG4gICAgXHRsZXQgdHJhY2s9TUxWVHJhY2suZ2V0VHJhY2soY29uZmlnKTtcclxuICAgIFx0aWYgKHRoaXMuZml4ZWRfaGVpZ2h0X21vZGUpe1xyXG4gICAgXHRcdHRyYWNrLmNvbmZpZy5kaXNjcmV0ZT10cnVlO1xyXG4gICAgXHR9XHJcblx0XHR0aGlzLnRyYWNrc1t0cmFjay5jb25maWcudHJhY2tfaWRdPXRyYWNrO1xyXG5cdFx0aWYgKGluZGV4IHx8IGluZGV4PT0wKXtcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5zcGxpY2UoaW5kZXgsMCx0cmFjay5jb25maWcudHJhY2tfaWQpXHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLnRyYWNrX29yZGVyLnB1c2godHJhY2suY29uZmlnLnRyYWNrX2lkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90cmFja3NDaGFuZ2VkKCk7XHJcblx0XHRpZiAodGhpcy5sZWdlbmQpe1xyXG4gICAgXHRcdHRoaXMubGVnZW5kLmFkZFRyYWNrKHRyYWNrLmNvbmZpZyxpbmRleCk7XHJcbiAgICBcdH1cclxuXHRcdHRoaXMuX2NhbGxMaXN0ZW5lcnMoXCJ0cmFja19hZGRlZFwiLHRyYWNrLmNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIF9jYWxsTGlzdGVuZXJzKHR5cGUsY29uZmlnKXtcclxuICAgIFx0ICBcclxuICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbih2KXt2KGNvbmZpZyl9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVBbGxUcmFja3MoKXtcclxuICAgIFx0bGV0IGR1cF9hcnJheSA9IHRoaXMudHJhY2tfb3JkZXIuc2xpY2UoKTtcclxuICAgIFx0Zm9yIChsZXQgaWQgb2YgZHVwX2FycmF5KXtcclxuICAgIFx0XHR0aGlzLnJlbW92ZVRyYWNrKGlkLHRydWUpXHJcbiAgICBcdH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuXHQvKipcclxuXHQqIFJlbW92ZXMgYSBsaXN0ZW5lciB0byB0aGUgcGFuZWxcclxuXHQqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBUaGUgY29uZmlnIG9mIHRoZSB0cmFjayB0byBhZGQgXHJcblx0Ki9cclxuICAgIHJlbW92ZVRyYWNrKHRyYWNrX2lkLG5vdF9yZXBhaW50KXtcclxuICAgIFx0aWYgKCF0aGlzLnRyYWNrc1t0cmFja19pZF0pe1xyXG4gICAgXHRcdHJldHVybiBudWxsO1xyXG4gICAgXHR9XHJcbiAgICBcdHRoaXMudHJhY2tfb3JkZXIgPSB0aGlzLnRyYWNrX29yZGVyLmZpbHRlcihlID0+IGUgIT09IHRyYWNrX2lkKTtcclxuICAgIFx0aWYgKCFub3RfcmVwYWludCl7XHJcbiAgICBcdFx0dGhpcy5yZXBhaW50KHRydWUsdHJ1ZSk7XHJcbiAgICBcdH1cclxuICAgIFxyXG4gICAgXHRpZiAodGhpcy5sZWdlbmQpe1xyXG4gICAgXHRcdHRoaXMubGVnZW5kLnJlbW92ZVRyYWNrKHRyYWNrX2lkKTtcclxuICAgIFx0fVxyXG4gICAgXHRsZXQgY29uZmlnID0gIHRoaXMudHJhY2tzW3RyYWNrX2lkXS5jb25maWdcclxuICAgIFx0ZGVsZXRlIHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0XHJcbiAgICBcdHRoaXMuX2NhbGxMaXN0ZW5lcnMoXCJ0cmFja19yZW1vdmVkXCIsY29uZmlnKTtcclxuICAgIFx0aWYgKHRoaXMudHJhY2tfb3JkZXIubGVuZ3RoPT09MCl7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxfaWQgaW4gdGhpcy5saXN0ZW5lcnNbXCJwYW5lbF9lbXB0eVwiXSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tcInBhbmVsX2VtcHR5XCJdW2xfaWRdKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25maWc7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFRyYWNrQ29uZmlnKHRyYWNrX2lkKXtcclxuICAgIFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgXHRyZXR1cm4gdHJhY2suZ2V0Q29uZmlnKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEFsbFRyYWNrQ29uZmlncygpe1xyXG4gICAgXHRsZXQgY29uZmlncz1bXTtcclxuICAgIFx0Zm9yIChsZXQgaWQgb2YgdGhpcy50cmFja19vcmRlcil7XHJcblx0XHRcdGNvbmZpZ3MucHVzaCh0aGlzLnRyYWNrc1tpZF0uZ2V0Q29uZmlnKCkpO1xyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiBjb25maWdzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZXRUcmFja0F0dHJpYnV0ZSh0cmFja19pZCxrZXksdmFsdWUpe1xyXG4gICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICBcdGlmICghdHJhY2spe1xyXG4gICAgXHRcdHJldHVybjtcclxuICAgIFx0fVxyXG4gICAgXHR0cmFjay5zZXRDb25maWdBdHRyaWJ1dGUoa2V5LHZhbHVlKTtcclxuICAgIFx0aWYgKGtleT09PVwic2NhbGVfbGlua190b1wiKXtcclxuICAgIFx0XHR0aGlzLnRyYWNrc1t0cmFja19pZF0uc2NhbGVfbGlua190byA9IHRoaXMudHJhY2tzW3ZhbHVlXTtcclxuICAgIFx0fVxyXG4gICAgXHRpZiAoKGtleT09PVwiY29sb3JcIiB8fCBrZXk9PT1cImRpc3BsYXlcIikgJiYgdGhpcy5sZWdlbmQpe1xyXG4gICAgXHRcdHRoaXMubGVnZW5kLnVwZGF0ZVRyYWNrKHRyYWNrX2lkKTtcclxuICAgIFx0fVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZXRUcmFja0F0dHJpYnV0ZXModHJhY2tfaWQsYXR0cmlidXRlcyl7XHJcbiAgICBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0Zm9yIChsZXQga2V5IGluIGF0dHJpYnV0ZXMpe1xyXG4gICAgXHRcdHRyYWNrLnNldENvbmZpZ0F0dHJpYnV0ZShrZXksYXR0cmlidXRlc1trZXldKTtcclxuICAgIFx0XHRpZiAoa2V5PT09XCJjb2xvclwiICYmIHRoaXMubGVnZW5kKXtcclxuICAgICAgICBcdFx0dGhpcy5sZWdlbmQudXBkYXRlVHJhY2sodHJhY2tfaWQpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG5cdCogU2V0cyB0aGUgZmlsdGVyICBmdW5jdGlvbiBmb3IgdHJhY2suIFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IHRyYWNrX2lkLSBUaGUgaWQgb2YgdGhlIHRyYWNrXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gZnVuYyAtIFRoZSBmaWx0ZXIgZnVuY3Rpb24uIEl0IHNob3VsZCBhY2NlcHQgdGhlIGZlYXR1cmVcclxuXHQqIGFuZCByZXR1cm4gdHJ1ZSB0byBkaXNwYWx5IHRoZSBmZWF0dXJlIGFuZCBmYWxzZSB0byBoaWRlIGl0LiBVc2UgbnVsbCBcclxuXHQqIHRvIGNhbmNlbCB0aGUgZmlsdGVyXHJcblx0Ki9cclxuICAgIHNldFRyYWNrRmVhdHVyZUZpbHRlcih0cmFja19pZCxmdW5jKXtcclxuICAgIFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgXHR0cmFjay5zZXRGaWx0ZXJGdW5jdGlvbihmdW5jKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQqIFNldHMgdGhlIGZpbHRlciAgZnVuY3Rpb24gZm9yIHRyYWNrIFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IHRyYWNrX2lkLSBUaGUgaWQgb2YgdGhlIHRyYWNrXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gZnVuYyAtIFRoZSBjb2xvciBmdW5jdGlvbi4gSXQgc2hvdWxkIGFjY2VwdCB0aGUgZmVhdHVyZVxyXG5cdCogYW5kIHJldHVybiB0aGUgZmVhdHVyZSBjb2xvci4gVXNlIG51bGwgdG8gZ28gYmFjayB0byBkZWZhdWx0IGNvbG9ycyBcclxuXHQqL1xyXG4gICAgc2V0VHJhY2tDb2xvckZ1bmN0aW9uKHRyYWNrX2lkLGZ1bmMpe1xyXG4gICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICBcdHRyYWNrLnNldENvbG9yRnVuY3Rpb24oZnVuYyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VHJhY2tMYWJlbEZ1bmN0aW9uKHRyYWNrX2lkLGZ1bmMpe1xyXG4gICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICBcdGlmICh0cmFjayl7XHJcbiAgICBcdFx0dHJhY2subGFiZWxfZnVuY3Rpb249ZnVuYztcclxuICAgIFx0fVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gIFxyXG5cclxuXHJcblxyXG5cclxuICAgIF90cmFja3NDaGFuZ2VkKCl7XHJcbiAgICBcdGZvciAobGV0IHRfaWQgb2YgdGhpcy50cmFja19vcmRlcil7XHJcbiAgICBcdFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdF9pZF07XHJcbiAgICBcdFx0Ly9pZiB0aGlzIHRyYWNrIGlzIGxpbmtlZCB0byB0aGUgc2NhbGUgb2YgYW5vdGhlclxyXG4gICAgXHRcdC8vZ2V0IHBvaW50ZXIgdG8gdGhlIHRyYWNrXHJcbiAgICBcdFx0bGV0IGxpbmtfdG8gPSB0cmFjay5jb25maWdbJ3NjYWxlX2xpbmtfdG8nXTtcclxuICAgIFx0XHRpZiAobGlua190byl7XHJcblx0XHRcdFx0bGV0IG90aGVyX3RyYWNrID0gdGhpcy50cmFja3NbbGlua190b107XHJcblx0XHRcdFx0aWYgKG90aGVyX3RyYWNrKXtcclxuXHRcdFx0XHRcdHRyYWNrLnNjYWxlX2xpbmtfdG89b3RoZXJfdHJhY2s7XHJcblx0XHRcdFx0fVxyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRDdXJyZW50VHJhY2tGZWF0dXJlcyh0cmFja19pZCl7XHJcbiAgICBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0cmV0dXJuIHRyYWNrLmdldEN1cnJlbnRGZWF0dXJlcyh0aGlzLmNocix0aGlzLnN0YXJ0LHRoaXMuZW5kKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgXHJcblx0IFxyXG5cdCBcclxuXHQgXHJcblxyXG4gIFxyXG5cclxuICAgLyoqXHJcbiAgICAqIFVwZGF0ZWQgdGhlIHBhbmVsIHZpZXcsIGlmIGNocm9tb3NvbWUgc3RhcnQgYW5kIGVuZCBhcmUgc3VwcGxpZWRcclxuICAgICogaXQgd2lsbCBnbyB0byB0aGlzIGxvY2F0aW9uLiBJZiBubyBwYXJhbWV0ZXJzIGFyZSBnaXZlbiB0aGUgcGFuZWxcclxuICAgICogd2lsbCBiZSByZWRyYXduIGF0IHRoZSBzYW1lIGxvY2F0aW9uIGUuZyBhZnRlciB0aGUgY29sb3IsIHNjYWxlIG9yIGFub3RoZXJcclxuICAgICogcGFyYW10ZXIgaGFzIGJlZW4gc2V0XHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JjZSAtIElmIHRydWUgdGhlbiBhIGNhY2hlZCBpbWFnZSB3aWxsIG5vdCBiZSB1c2VkXHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnQgb2YgdGhlIHJlZ2lvbiB0byBkcmF3XHJcbiAgICAqIEBwYXJhbSB7aW50ZWdlcn0gZW5kIG9mIHRoZSByZWdpb24gdG8gZHJhd1xyXG4gICAgKi9cclxuXHJcbiAgICB1cGRhdGUgKGNocixzdGFydCxlbmQsbm9fcHJvcGFnYXRpb24pIHtcclxuICAgIFx0dGhpcy5jYWxsX3VwZGF0ZV9saXN0ZW5lcj1ub19wcm9wYWdhdGlvbjtcclxuICAgICAgICBpZiAoY2hyKXtcclxuICAgICAgICAgICAgdGhpcy5jaHI9Y2hyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0PXN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmVuZD1lbmQ7XHJcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgIFx0dGhpcy5yZXBhaW50KHRydWUsdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgZ2V0VHJhY2tzSGVpZ2h0KCl7XHJcbiAgICBcdGxldCBoID0wO1xyXG4gICAgXHRsZXQgZ3JvdXBzPXt9XHJcbiAgICBcdGZvciAobGV0IHRpZCBvZiB0aGlzLnRyYWNrX29yZGVyKXtcclxuICAgIFx0XHRsZXQgdHJhY2s9ICB0aGlzLnRyYWNrc1t0aWRdO1xyXG4gICAgXHRcdGxldCBnID0gdHJhY2suY29uZmlnLmdyb3VwO1xyXG4gICAgXHRcdGlmIChnKXtcclxuICAgIFx0XHRcdGlmICghZ3JvdXBzW2ddKXtcclxuICAgIFx0XHRcdFx0aCs9dHJhY2suY29uZmlnLmhlaWdodDtcclxuICAgIFx0XHRcdFx0Z3JvdXBzW2ddPXRydWU7XHJcbiAgICBcdFx0XHR9XHJcblxyXG4gICAgXHRcdH1cclxuICAgIFx0XHRlbHNle1xyXG5cdFx0XHRcdGgrPXRyYWNrLmNvbmZpZy5oZWlnaHQ7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICBcdHJldHVybiBoO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRBbGxGZWF0dXJlcyhicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgdHJhY2tfaWQgIG9mIHRoaXMudHJhY2tfb3JkZXIpe1xyXG4gICAgICAgIFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgICAgIFx0cHJvbWlzZXMucHVzaCh0cmFjay5nZXRGZWF0dXJlcyh0aGlzLmNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpKTsgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwYWludCB0aGUgdmlldywgdXNpbmcgYSBjYWNoZWQgaW1hZ2UgaWYgYXZhaWxhYmxlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIElmIHRydWUgdGhlbiBhIGNhY2hlZCBpbWFnZSB3aWxsIG5vdCBiZSB1c2VkXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJhbmdlX2Zyb21fdGlsZSBSZWRyYXcgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgcmVwYWludChmb3JjZSxyYW5nZV9mcm9tX3RpbGUpIHtcclxuXHJcbiAgICAgICBcclxuXHRcdFxyXG4gICAgICAgIHZhciBwaXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicFdpZHRoLFxyXG4gICAgICAgICAgICBicFN0YXJ0LFxyXG4gICAgICAgICAgICBicEVuZCxcclxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGN0eCxcclxuICAgICAgICAgICAgcmVmZXJlbmNlRnJhbWUsXHJcbiAgICAgICAgICAgIGNocixcclxuICAgICAgICAgICAgcmVmRnJhbWVTdGFydCxcclxuICAgICAgICAgICAgcmVmRnJhbWVFbmQsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3M7XHJcblxyXG4gICAgICAgIGNociA9IHRoaXMuY2hyO1xyXG4gICAgICAgIHJlZkZyYW1lU3RhcnQgPSB0aGlzLnN0YXJ0O1xyXG4gICAgICAgIHJlZkZyYW1lRW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgdGhpcy5icFBlclBpeGVsPSh0aGlzLmVuZC10aGlzLnN0YXJ0KS90aGlzLmNhbnZhcy53aWR0aDtcclxuICAgICAgICBsZXQgZ2V0X2ZlYXR1cmVzPXRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMudGlsZSAmJiB0aGlzLnRpbGUuY29udGFpbnNSYW5nZShjaHIsIHJlZkZyYW1lU3RhcnQsIHJlZkZyYW1lRW5kLCB0aGlzLmJwUGVyUGl4ZWwpKXtcclxuICAgICAgICAgICAgZ2V0X2ZlYXR1cmVzPWZhbHNlO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgaWYgKCFnZXRfZmVhdHVyZXMgJiYgIWZvcmNlICYmICF0aGlzLmZvcmNlX3JlZHJhdykge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlX3JlZHJhdz1mYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5wYWludEltYWdlKCk7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5jYWxsX3VwZGF0ZV9saXN0ZW5lcil7XHJcbiAgICAgICAgICAgIFx0c2VsZi5saXN0ZW5lcnMudmlld19jaGFuZ2VkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhzZWxmLmNocixwYXJzZUludChzZWxmLnN0YXJ0KSxwYXJzZUludChzZWxmLmVuZCkpfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5jYWxsX3VwZGF0ZV9saXN0ZW5lcj1mYWxzZTtcclxuICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgICAgc2VsZi5yZXRyaWVzPTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHJlcXVlc3RlZCByYW5nZSBzbyB3ZSBjYW4gcGFuIGEgYml0IHdpdGhvdXQgcmVsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VfcmVkcmF3PWZhbHNlO1xyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gKCh0aGlzLmJ1ZmZlcl9sZXZlbCoyKSsxKSAqIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICBicFdpZHRoID0gTWF0aC5yb3VuZChwaXhlbFdpZHRoKnRoaXMuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgIGJwU3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRoaXMuc3RhcnQtKHRoaXMuYnVmZmVyX2xldmVsKnRoaXMuY2FudmFzLndpZHRoKnRoaXMuYnBQZXJQaXhlbCkpKTtcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgYnBXaWR0aDtcclxuICAgICAgICAgICAgaWYgKHNlbGYubG9hZGluZyl7XHJcbiAgICAgICAgICAgIFx0aWYgKGZvcmNlICYmIHJhbmdlX2Zyb21fdGlsZSl7XHJcbiAgICAgICAgICAgIFx0XHRzZWxmLnVwZGF0ZV9yZXF1aXJlZD10cnVlO1xyXG4gICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgXHRlbHNle1xyXG4gICAgICAgICAgICBcdFx0c2VsZi51cGRhdGVfcmVxdWlyZWQ9XCJsb2NhdGlvblwiO1xyXG4gICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgXHRyZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJhbmdlX2Zyb21fdGlsZSl7XHJcbiAgICAgICAgICAgIFx0aWYgKHRoaXMudGlsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgYnBTdGFydD10aGlzLnRpbGUuc3RhcnRCUDtcclxuICAgICAgICAgICAgICAgICAgICBicEVuZD10aGlzLnRpbGUuZW5kQlA7XHJcbiAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICBcclxuXHJcbiAgICAgICAgICAgIHNlbGYubG9hZGluZyA9IHtzdGFydDogYnBTdGFydCwgZW5kOiBicEVuZH07XHJcbiAgICAgICAgICAgIHNlbGYudHJhY2tEaXYuZmluZChcIi5tbHYtYWxlcnRcIikucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICBVdGlscy5zdGFydFNwaW5uZXJBdFBhcmVudEVsZW1lbnQoc2VsZi50cmFja0Rpdik7XHJcblxyXG5cclxuICAgICAgICAgICAgc2VsZi5nZXRBbGxGZWF0dXJlcyggYnBTdGFydCwgYnBFbmQsIWdldF9mZWF0dXJlcyx7cGl4ZWxXaWR0aDpwaXhlbFdpZHRoLGJwUGVyUGl4ZWw6c2VsZi5icFBlclBpeGVsfSlcclxuXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbF9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud2lkdGggPSBwaXhlbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuaGVpZ2h0ID0gc2VsZi5maXhlZF9oZWlnaHRfbW9kZT9zZWxmLmdldFRyYWNrc0hlaWdodCgpOnNlbGYuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNob3dfc2NhbGUpe1xyXG4gICAgICAgIFx0XHRcdFx0XHRzZWxmLnNjYWxlX2J1ZmZlcj0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgXHRcdFx0XHRcdHNlbGYuc2NhbGVfYnVmZmVyLndpZHRoID0gMjAwO1xyXG4gICAgICAgIFx0XHRcdFx0XHRzZWxmLnNjYWxlX2J1ZmZlci5oZWlnaHQgPSBidWZmZXIuaGVpZ2h0O1xyXG4gICAgICAgIFx0XHRcdFx0XHRzZWxmLnNjYWxlX2J1ZmZlcl9jdHg9c2VsZi5zY2FsZV9idWZmZXIuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBTdGFydDogYnBTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFBlclBpeGVsOiBzZWxmLmJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxXaWR0aDogYnVmZmVyLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsSGVpZ2h0OiBidWZmZXIuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocjpjaHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcD0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdyb3Vwcz17fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxjdWxhdGVNYXhTY2FsZShhbGxfZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGFsbF9mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bGV0IHRyYWNrID0gc2VsZi50cmFja3Nbc2VsZi50cmFja19vcmRlcltpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0b3B0aW9ucy5mZWF0dXJlcz1hbGxfZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bGV0IGdyb3VwID0gdHJhY2suY29uZmlnLmdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0aWYgKGdyb3VwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdGlmICghc2VsZi5ncm91cHNbZ3JvdXBdKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdFx0c2VsZi5ncm91cHNbZ3JvdXBdPXt0b3A6dG9wLGhlaWdodDp0cmFjay5jb25maWcuaGVpZ2h0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0XHQvL2ZpcnN0IHRpbWUgaW5jcmVhc2UgdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHRvcCs9dHJhY2suY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdG9wdGlvbnMudG9wPXNlbGYuZ3JvdXBzW2dyb3VwXS50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLmhlaWdodD1zZWxmLmdyb3Vwc1tncm91cF0uaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdG9wdGlvbnMudG9wID10b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCBkaXNjID0gICBzZWxmLmZpeGVkX2hlaWdodF9tb2RlIHx8IHRyYWNrLmNvbmZpZy5kaXNjcmV0ZSB8fCBncm91cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAoZGlzYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRsZXQgaD1ncm91cD9vcHRpb25zLmhlaWdodDp0cmFjay5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5yZWN0KDAsb3B0aW9ucy50b3Asb3B0aW9ucy5waXhlbFdpZHRoLGgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmNsaXAoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0PSB0cmFjay5kcmF3RmVhdHVyZXMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNjICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdGN0eC5yZXN0b3JlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0aWYgKCFncm91cCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcdFx0XHR0b3ArPXRyYWNrLmNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcdFx0XHR0cmFjay5ib3R0b209dG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmZzZXQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR0b3A9b2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaG93X3NjYWxlKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRyYWNrLmRyYXdTY2FsZShvcHRpb25zLnBpeGVsSGVpZ2h0LHNlbGYuc2NhbGVfYnVmZmVyX2N0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzZWxmLmhpZ2hsaWdodGVkX3JlZ2lvbnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCByZWdpb24gPSBzZWxmLmhpZ2hsaWdodGVkX3JlZ2lvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0aWYgKHNlbGYuY2hyICE9PSByZWdpb24uY2hyKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAocmVnaW9uLmVuZDxicFN0YXJ0IHx8cmVnaW9uLnN0YXJ0PmJwRW5kKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdHNlbGYuZHJhd0hpZ2hsaWdodGVkUmVnaW9uKHJlZ2lvbixvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJldHJpZXM9MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGlsZSA9IG5ldyBUaWxlKGNociwgYnBTdGFydCwgYnBFbmQsIHNlbGYuYnBQZXJQaXhlbCwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWludEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5jYWxsX3VwZGF0ZV9saXN0ZW5lcil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0c2VsZi5saXN0ZW5lcnMudmlld19jaGFuZ2VkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhzZWxmLmNocixwYXJzZUludChzZWxmLnN0YXJ0KSxwYXJzZUludChzZWxmLmVuZCkpfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxsX3VwZGF0ZV9saXN0ZW5lcj1mYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3R4LmNsZWFyUmVjdCgwLCAwLCBzZWxmLmNhbnZhcy53aWR0aCwgc2VsZi5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudXBkYXRlX3JlcXVpcmVkKXtcclxuICAgICAgICAgICAgICAgICAgICBcdGlmIChzZWxmLnVwZGF0ZV9yZXF1aXJlZD09PVwibG9jYXRpb25cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlKHNlbGYuY2hyLHNlbGYuc3RhcnQsc2VsZi5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFx0XHRzZWxmLnVwZGF0ZV9yZXF1aXJlZD1mYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgICAgICBcdGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlX3JlcXVpcmVkPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFx0XHRzZWxmLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgIH1cdFxyXG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLnN0b3BTcGlubmVyQXRQYXJlbnRFbGVtZW50KHNlbGYudHJhY2tEaXYpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5yZXRyaWVzPDMgJiYgZXJyb3IhPT1cIlRpbWVkIG91dFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBcdHNlbGYucmV0cmllcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIFx0c2VsZi5yZXBhaW50KGZvcmNlLHJhbmdlX2Zyb21fdGlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMuc3RvcFNwaW5uZXJBdFBhcmVudEVsZW1lbnQoc2VsZi50cmFja0Rpdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZGluZz1mYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mb3JjZV9yZWRyYXc9dHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHMucHJlc2VudEFsZXJ0KHNlbGYudHJhY2tEaXYsZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHZpZXdJc1JlYWR5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFjaztcclxuICAgICAgICB9XHJcbiBcclxuICAgIH1cclxuXHJcblxyXG4gICAgYXV0b1NjYWxlKGZlYXR1cmVzLG1pbixtYXgpe1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlcyl7XHJcbiAgICAgICAgICAgICAgICBcdHJldHVybih7bWluOjAsbWF4OjF9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFx0XHRmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGYudmFsdWUpO1xyXG4gICAgICAgICAgIFx0XHRcdG1heCA9IE1hdGgubWF4KG1heCwgZi52YWx1ZSk7XHJcbiAgICAgICAgXHRcdH0pO1xyXG4gICAgICAgIFx0XHRyZXR1cm4ge21pbjogbWluLCBtYXg6IG1heH07XHJcbiAgICBcdFx0XHJcbiAgICB9XHJcblxyXG4gICAgY2FsY3VsYXRlTWF4U2NhbGUoYWxsX2ZlYXR1cmVzKXtcclxuICAgIFx0ICBsZXQgZ3JvdXBzPXt9O1xyXG4gICAgXHQgIGZvciAodmFyIGkgaW4gYWxsX2ZlYXR1cmVzKXtcclxuICAgICAgICAgICAgICBsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrX29yZGVyW2ldXTtcclxuICAgICAgICAgICAgICB0cmFjay5zZXRfc2NhbGU9bnVsbDtcclxuICAgICAgICAgICAgICBsZXQgZ3JvdXAgPXRyYWNrLmNvbmZpZy5ncm91cDtcclxuICAgICAgICAgICAgIGlmIChncm91cCAmJiB0cmFjay5jb25maWcuc2NhbGUhPT1cImZpeGVkXCIgJiYgISh0cmFjay5jb25maWcuc2NhbGVfbGlua190bykpe1xyXG4gICAgICAgICAgICAgXHRcdHRyYWNrLmNvbmZpZy5zY2FsZV9ncm91cD1ncm91cDtcclxuICAgICAgICAgICAgIH0gICAgICAgXHRcclxuICAgICAgICAgICAgIGdyb3VwID0gdHJhY2suY29uZmlnLnNjYWxlX2dyb3VwXHJcbiAgICAgICAgICAgICBpZiAoZ3JvdXApe1xyXG4gICAgICAgICAgICAgXHRsZXQgZ3JvdXBfaW5mbz0gZ3JvdXBzW2dyb3VwXTtcclxuICAgICAgICAgICAgIFx0aWYgKCFncm91cF9pbmZvKXtcclxuICAgICAgICAgICAgIFx0XHRncm91cF9pbmZvPXt0cmFja3M6W3RyYWNrXSxmZWF0dXJlczpbYWxsX2ZlYXR1cmVzW2ldXX1cclxuICAgICAgICAgICAgIFx0XHRncm91cHNbZ3JvdXBdPWdyb3VwX2luZm9cclxuXHJcbiAgICAgICAgICAgICBcdFx0XHJcbiAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgIFx0ZWxzZXtcclxuICAgICAgICAgICAgIFx0XHRncm91cF9pbmZvLmZlYXR1cmVzLnB1c2goYWxsX2ZlYXR1cmVzW2ldKTtcclxuICAgICAgICAgICAgIFx0XHRncm91cF9pbmZvLnRyYWNrcy5wdXNoKHRyYWNrKTtcclxuICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICB9XHJcbiAgICBcdCAgfVxyXG4gICAgXHQgIGZvciAobGV0IG5hbWUgaW4gZ3JvdXBzKXtcclxuICAgIFx0ICBcdGxldCBnPSBncm91cHNbbmFtZV07XHJcbiAgICBcdCAgXHRpZiAoIWcuaWdub3JlKXtcclxuICAgIFx0ICBcdFx0bGV0IG1pbj0wO1xyXG4gICAgXHQgIFx0XHRsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBcdCAgXHRcdGxldCBzY2FsZT1udWxsO1xyXG4gICAgXHQgIFx0XHRmb3IgKGxldCBmIG9mIGcuZmVhdHVyZXMpe1xyXG4gICAgXHQgIFx0XHRcdCBzY2FsZT0gdGhpcy5hdXRvU2NhbGUoZixtaW4sbWF4KVxyXG4gICAgXHQgIFx0XHRcdCBtaW49IHNjYWxlLm1pbjtcclxuICAgIFx0ICBcdFx0XHQgbWF4PXNjYWxlLm1heDtcclxuICAgIFx0ICBcdFx0fVxyXG4gICAgXHQgIFx0XHRmb3IgKGxldCB0IG9mIGcudHJhY2tzKXtcclxuICAgIFx0ICBcdFx0XHR0LnNldF9zY2FsZT1zY2FsZTtcclxuICAgIFx0ICBcdFx0fVxyXG4gICAgXHQgIFx0fVxyXG4gICAgXHQgIH0gXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0hpZ2hsaWdodGVkUmVnaW9uKHJlZ2lvbixvcHRpb25zKXtcclxuICAgIFx0bGV0IHN0YXJ0PSAocmVnaW9uLnN0YXJ0LW9wdGlvbnMuYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG4gICAgXHRzdGFydCA9IHN0YXJ0PDA/MDpzdGFydDtcclxuXHJcbiAgICBcdGxldCB3aWR0aCA9IChyZWdpb24uZW5kLXJlZ2lvbi5zdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG4gICAgXHR3aWR0aCA9IHdpZHRoPDM/Mzp3aWR0aDtcclxuICAgIFx0d2lkdGggPXdpZHRoPm9wdGlvbnMucGl4ZWxXaWR0aD9vcHRpb25zLnBpeGVsV2lkdGg6d2lkdGg7XHJcblx0XHRvcHRpb25zLmNvbnRleHQuZ2xvYmFsQWxwaGE9MC4xO1xyXG5cdFx0b3B0aW9ucy5jb250ZXh0LmZpbGxTdHlsZT1yZWdpb24uY29sb3I7XHJcbiAgICBcdG9wdGlvbnMuY29udGV4dC5maWxsUmVjdChzdGFydCwwLHdpZHRoLG9wdGlvbnMucGl4ZWxIZWlnaHQpO1xyXG4gICAgXHRvcHRpb25zLmNvbnRleHQuZ2xvYmFsQWxwaGE9MS4wO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgcGFpbnRJbWFnZSgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dfc2NhbGUpe1xyXG4gICAgICAgIFx0dGhpcy5zY2FsZV9jdHguY2xlYXJSZWN0KDAsIDAsMTAwLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIFx0dGhpcy5zY2FsZV9jdHguZHJhd0ltYWdlKHRoaXMuc2NhbGVfYnVmZmVyLDAsdGhpcy55T2Zmc2V0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudGlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnhPZmZzZXQgPSBNYXRoLnJvdW5kKCh0aGlzLnRpbGUuc3RhcnRCUCAtIHRoaXMuc3RhcnQpL3RoaXMuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRpbGUuaW1hZ2UsIHRoaXMueE9mZnNldCwgdGhpcy55T2Zmc2V0KTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhbGxvd1VzZXJGZWF0dXJlT3Zlcigpe1xyXG4gICAgXHRsZXQgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgXHQgdGhpcy50cmFja0Rpdi5vbihcIm1vdXNlbW92ZS5mZWF0dXJlX292ZXJcIixmdW5jdGlvbiAoZSkge1xyXG4gICAgXHQgXHRpZiAoc2VsZi5sb2FkaW5nKXtcclxuICAgIFx0IFx0XHRyZXR1cm47XHJcbiAgICBcdCBcdH1cclxuICAgIFx0IFx0Y2xlYXJUaW1lb3V0KHNlbGYubW90byk7XHJcbiAgICBcdCBcdHNlbGYubW90bz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICBcdCBcdFx0aWYgKCFzZWxmLmlzX2RyYWdnaW5nKXtcclxuXHRcdFx0XHRcdGxldCBpbmZvPXNlbGYuZ2V0RmVhdHVyZUF0KGUpO1xyXG5cdFx0XHRcdFx0bGV0IGkgPSBzZWxmLm1vdXNlX292ZXJfZmVhdHVyZTtcclxuXHRcdFx0XHRcdGlmIChpbmZvLmZlYXR1cmUgKXtcclxuXHRcdFx0XHRcdFx0aWYoaSAmJiBpLmZlYXR1cmUhPT1pbmZvLmZlYXR1cmUpe1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYubGlzdGVuZXJzLmZlYXR1cmVfb3Zlci5mb3JFYWNoKChmdW5jKT0+e2Z1bmMoaS50cmFjayxpLmZlYXR1cmUsZSxcIm91dFwiKX0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0aWYgKCghaSkgfHwgKGkuZmVhdHVyZSE9PWluZm8uZmVhdHVyZSkpe1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYubGlzdGVuZXJzLmZlYXR1cmVfb3Zlci5mb3JFYWNoKChmdW5jKT0+e2Z1bmMoaW5mby50cmFjayxpbmZvLmZlYXR1cmUsZSxcIm92ZXJcIil9KTtcclxuXHRcdFx0XHRcdFx0XHRzZWxmLm1vdXNlX292ZXJfZmVhdHVyZT1pbmZvO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0XHRsZXQgaSA9IHNlbGYubW91c2Vfb3Zlcl9mZWF0dXJlXHJcblx0XHRcdFx0XHRcdGlmIChpKXtcclxuXHRcdFx0XHRcdFx0XHRzZWxmLmxpc3RlbmVycy5mZWF0dXJlX292ZXIuZm9yRWFjaCgoZnVuYyk9PntmdW5jKGkudHJhY2ssaS5mZWF0dXJlLGUsXCJvdXRcIil9KTtcclxuXHRcdFx0XHRcdFx0XHRzZWxmLm1vdXNlX292ZXJfZmVhdHVyZT1udWxsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcbiAgICBcdCBcdFx0fVxyXG4gICAgXHQgXHR9LDEwKTtcclxuICAgIFx0IH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVGZWF0dXJlT3ZlckhhbmRsZXIoKXtcclxuICAgIFx0XHR0aGlzLnRyYWNrRGl2Lm9mZihcIm1vdXNlZG93bi5mZWF0dXJlX292ZXJcIik7XHJcbiAgICB9XHJcblxyXG5cclxuXHRhbGxvd1VzZXJGZWF0dXJlQ2xpY2soKXtcclxuICAgIFx0bGV0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIFx0dGhpcy5hbGxvd1VzZXJGZWF0dXJlT3ZlcigpO1xyXG4gICAgXHR0aGlzLmFkZExpc3RlbmVyKFwiZmVhdHVyZV9vdmVyXCIsZnVuY3Rpb24odHJhY2ssZmVhdHVyZSxvdmVyLHR5cGUpe1xyXG4gICAgXHRcdGlmKCFmZWF0dXJlKXtcclxuICAgIFx0XHRcdHNlbGYudHJhY2tEaXYuY3NzKFwiY3Vyc29yXCIsXCJkZWZhdWx0XCIpXHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGxldCBwb2ludGVyPSh0eXBlPT09XCJvdmVyXCIpP1wicG9pbnRlclwiOlwiZGVmYXVsdFwiO1xyXG4gICAgXHRcdHNlbGYudHJhY2tEaXYuY3NzKFwiY3Vyc29yXCIscG9pbnRlcik7XHJcblxyXG4gICAgXHR9KVxyXG5cclxuICAgIFx0IHRoaXMudHJhY2tEaXYub24oXCJtb3VzZWRvd24uZmVhdHVyZV9jbGlja1wiLGZ1bmN0aW9uIChlKSB7XHJcbiAgICBcdCBcdGlmIChzZWxmLmxvYWRpbmcpe1xyXG4gICAgXHQgXHRcdHJldHVybjtcclxuICAgIFx0IFx0fVxyXG4gICAgXHQgXHRjbGVhclRpbWVvdXQoc2VsZi50byk7XHJcbiAgICBcdCBcdHNlbGYudG89c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgXHQgXHRcdGlmICghc2VsZi5pc19kcmFnZ2luZyl7XHJcblx0XHRcdFx0XHRsZXQgaW5mbz1zZWxmLmdldEZlYXR1cmVBdChlKTtcclxuXHRcdFx0XHRcdGlmIChpbmZvLnRyYWNrKXtcclxuXHRcdFx0XHRcdFx0c2VsZi5saXN0ZW5lcnMuZmVhdHVyZV9jbGlja2VkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhpbmZvLnRyYWNrLGluZm8uZmVhdHVyZSxlKX0pO1xyXG5cdFx0XHRcdFx0fVxyXG4gICAgXHQgXHRcdH1cclxuICAgIFx0IFx0fSwyMDApO1xyXG4gICAgXHQgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZW1vdmVGZWF0dXJlT3ZlckhhbmRsZXIoKXtcclxuICAgIFx0dGhpcy50cmFja0Rpdi5vZmYoXCJtb3VzZWRvd24uZmVhdHVyZV9jbGlja1wiKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGFsbG93VXNlckRyYWcoKXtcclxuICAgIFx0bGV0IHNlbGY9dGhpcztcclxuICAgIFx0IHRoaXMudHJhY2tEaXYub24oXCJtb3VzZWRvd24uZHJhZ2hhbmRsZXJcIixmdW5jdGlvbiAoZSkge1xyXG4gICAgXHQgXHRpZiAoZS5zaGlmdEtleSl7XHJcbiAgICBcdCBcdFx0cmV0dXJuO1xyXG4gICAgXHQgXHR9XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNDb29yZHMgPSBVdGlscy50cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsIHNlbGYuY2FudmFzKTtcclxuICAgICAgICAgICAgc2VsZi5pc01vdXNlRG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhcnRfZHJhZ2dpbmc9dHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYID0gY2FudmFzQ29vcmRzLng7XHJcbiAgICAgICAgICAgIHNlbGYubGFzdE1vdXNlWT0gY2FudmFzQ29vcmRzLnk7XHJcbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duWCA9IHNlbGYubGFzdE1vdXNlWDtcclxuXHJcbiAgICAgICAgfSlcclxuICAgICAgIFx0Lm9uKFwibW91c2Vtb3ZlLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgbGV0IGNhbnZhc0Nvb3JkcyA9IFV0aWxzLnRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSwgc2VsZi5jYW52YXMpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5pc19kcmFnZ2luZyB8fCBzZWxmLnN0YXJ0X2RyYWdnaW5nKXtcclxuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2FudmFzQ29vcmRzLngtc2VsZi5sYXN0TW91c2VYO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJwX2RpZmY9c2VsZi5icFBlclBpeGVsKmRpZmY7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0LT1icF9kaWZmO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lbmQtPWJwX2RpZmY7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGQgPSBzZWxmLmNhbnZhcy5oZWlnaHQtc2VsZi50aWxlLmltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGxldCB5X2RpZmY9MDtcclxuICAgICAgICAgICAgICAgIGlmIChkZDwwIHx8IHNlbGYueU9mZnNldCAhPT0wKXtcclxuICAgICAgICAgICAgICAgIFx0bGV0IHlfZGlmZj0gIGNhbnZhc0Nvb3Jkcy55LXNlbGYubGFzdE1vdXNlWTtcclxuICAgICAgICAgICAgICAgIFx0c2VsZi55T2Zmc2V0Kz15X2RpZmY7XHJcbiAgICAgICAgICAgICAgICBcdGlmIChzZWxmLnlPZmZzZXQ+MCl7XHJcbiAgICAgICAgICAgICAgICBcdFx0c2VsZi55T2Zmc2V0PTA7XHJcbiAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgIFx0ZWxzZSBpZiAoc2VsZi55T2Zmc2V0PGRkKXtcclxuXHRcdFx0XHRcdFx0c2VsZi55T2Zmc2V0PWRkO1xyXG4gICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYubGFzdE1vdXNlWD1jYW52YXNDb29yZHMueDtcclxuICAgICAgICAgICAgICAgIHNlbGYubGFzdE1vdXNlWT1jYW52YXNDb29yZHMueTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnN0YXJ0X2RyYWdnaW5nICYmIChkaWZmPjUgfHwgeV9kaWZmPjUpKXtcclxuICAgICAgICAgICAgICAgIFx0c2VsZi5pc19kcmFnZ2luZz10cnVlO1xyXG4gICAgICAgICAgICAgICAgXHRzZWxmLnN0YXJ0X2RyYWdnaW5nPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZXVwLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHsgICBcclxuICAgICAgICAgICAgICBzZWxmLmlzX2RyYWdnaW5nPWZhbHNlO1xyXG4gICAgICAgICAgICAgIHNlbGYuc3RhcnRfZHJhZ2dpbmc9ZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlRHJhZ0hhbmRsZXIoKXtcclxuICAgIFx0dGhpcy50cmFja0Rpdi5vZmYoXCJtb3VzZWRvd24uZHJhZ2hhbmRsZXIgbW91c2Vtb3ZlLmRyYWdoYW5kbGVyIG1vdXNldXAuZHJhZ2hhbmRsZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldENvb3JkcyhlKXtcclxuICAgIFx0IGxldCB4ID0gZS5wYWdlWCAtICQodGhpcy5jYW52YXMpLm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgIGxldCB5ID0gZS5wYWdlWSAtICQodGhpcy5jYW52YXMpLm9mZnNldCgpLnRvcDtcclxuICAgICAgICAgcmV0dXJuIHt4LHl9O1xyXG4gICAgXHRcclxuICAgIH1cclxuXHJcblxyXG4gICAgYWxsb3dVc2VyWm9vbSgpe1xyXG4gICAgXHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICBcdHRoaXMudHJhY2tEaXYub24oJ21vdXNld2hlZWwuem9vbSAgbW91c2Uuem9vbSBET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdGxldCBkZWx0YVk9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFZO1xyXG5cdFx0XHRpZiAoZGVsdGFZID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRcdGRlbHRhWT1ldmVudC5vcmlnaW5hbEV2ZW50LmRldGFpbFxyXG5cdFx0XHR9XHJcbiAgICBcdCBcdGlmIChzZWxmLmxvYWRpbmcgfHwgKHNlbGYuYnBQZXJQaXhlbDwwLjA1ICYmIGRlbHRhWT4wKSl7XHJcbiAgICBcdCBcdFx0cmV0dXJuO1xyXG4gICAgXHQgXHR9XHJcbiAgICBcdCBcdFxyXG4gICBcclxuICAgIFx0IFx0bGV0IGNhbnZhc0Nvb3JkcyA9IHNlbGYuX2dldENvb3JkcyhldmVudC5vcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGZhY3RvciA9IGRlbHRhWTwwPzI6MC41O1xyXG4gICAgICAgICAgICBsZXQgbWJwPSAoc2VsZi5zdGFydCsgY2FudmFzQ29vcmRzLnggKiBzZWxmLmJwUGVyUGl4ZWwpXHJcbiAgICAgICAgICAgIGxldCBuZXdfbGVuZ3RoID0gKHNlbGYuZW5kLXNlbGYuc3RhcnQpKmZhY3RvcjtcclxuICAgICAgICAgICAgbGV0IG5ld19zdGFydCA9IG1icC0oKGNhbnZhc0Nvb3Jkcy54L3NlbGYuY2FudmFzLndpZHRoKSpuZXdfbGVuZ3RoKTtcclxuICAgICAgICAgICAgc2VsZi5zdGFydD0gIG5ld19zdGFydFxyXG4gICAgICAgICAgICBzZWxmLmVuZD0gbmV3X3N0YXJ0K25ld19sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTsgICAgICBcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlVXNlclpvb20oKXtcclxuXHRcdHRoaXMudHJhY2tEaXYub2ZmKFwibW91c2V3aGVlbC56b29tXCIpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIGFsbG93VXNlclJhbmdlU2VsZWN0aW9uKCl7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudHJhY2tEaXYub24oXCJtb3VzZWRvd24uc2VsZWN0aW9uXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuc3RhcnRfc2VsZWN0ID1VdGlscy50cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsdGhpcykueDtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gc2VsZi5zdGFydF9zZWxlY3QrXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRkID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0X2Rpdj0kKFwiPGRpdj5cIikuY3NzKHtcInBvc2l0aW9uXCI6XCJhYnNvbHV0ZVwiLFwib3BhY2l0eVwiOjAuMixcImJhY2tncm91bmQtY29sb3JcIjpcImJsdWVcIixcInRvcFwiOlwiMHB4XCIsXCJoZWlnaHRcIjp0ZC5jc3MoXCJoZWlnaHRcIiksbGVmdDpsZWZ0LFwid2lkdGhcIjpcIjBweFwifSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0ZCk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZW1vdmUuc2VsZWN0aW9uXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIHNlbGYuc3RhcnRfc2VsZWN0KXtcclxuICAgICAgICAgICAgICAgIGxldCB4PVV0aWxzLnRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSx0aGlzKS54O1xyXG4gICAgICAgICAgICAgICAgaWYgKHg8c2VsZi5zdGFydF9zZWxlY3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0X2Rpdi5jc3Moe1wibGVmdFwiOngrXCJweFwiLFwid2lkdGhcIjooc2VsZi5zdGFydF9zZWxlY3QteCkrXCJweFwifSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0X2Rpdi5jc3Moe1wibGVmdFwiOnNlbGYuc3RhcnRfc2VsZWN0K1wicHhcIixcIndpZHRoXCI6KHgtc2VsZi5zdGFydF9zZWxlY3QpK1wicHhcIn0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZXVwLnNlbGVjdGlvblwiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5zdGFydF9zZWxlY3Qpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHg9VXRpbHMudHJhbnNsYXRlTW91c2VDb29yZGluYXRlcyhlLHRoaXMpLng7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBzZWxmLnN0YXJ0ICsgKHNlbGYuc3RhcnRfc2VsZWN0KnNlbGYuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gIHNlbGYuc3RhcnQgKyAoeCpzZWxmLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGFydF9zZWxlY3Q9bnVsbDtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0X2Rpdi5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydD5lbmQpe1xyXG4gICAgICAgICAgICAgICAgXHRsZXQgdGVtcD1lbmQ7XHJcbiAgICAgICAgICAgICAgICBcdGVuZD1zdGFydDtcclxuICAgICAgICAgICAgICAgIFx0c3RhcnQ9dGVtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYubGlzdGVuZXJzLnJhbmdlX3NlbGVjdGVkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhzZWxmLmNocixzdGFydCxlbmQpfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICByZW1vdmVBbGxvd1NlbGVjdGlvbigpe1xyXG4gICAgXHR0aGlzLnRyYWNrRGl2Lm9mZihcIm1vdXNlZG93bi5zZWxlY3Rpb24gbW91c2Vtb3ZlLnNlbGVjdGlvbiBtb3VzZXVwLnNlbGVjdGlvblwiKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJbWFnZSgpe1xyXG4gICAgXHQgdmFyIGltZ1VSTCA9IHRoaXMuY2FudmFzWzBdLnRvRGF0YVVSTChNSU1FX1RZUEUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIGFsbG93VXNlckRyb3AoKXtcclxuICAgICAgICBsZXQgZGl2ID0gdGhpcy50cmFja0RpdjtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZGl2LmRyb3BwYWJsZSh7XHJcbiAgICAgICAgXHRvdmVyOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgIFx0XHRsZXQgdHJhY2sgPSB1aS5kcmFnZ2FibGUuZGF0YShcInRyYWNrXCIpO1xyXG4gICAgICAgIFx0XHRsZXQgcGFuZWwgPSB1aS5kcmFnZ2FibGUuZGF0YShcInBhbmVsXCIpO1xyXG4gICAgICAgIFx0XHRpZiAocGFuZWw9PT1zZWxmKXtcclxuICAgICAgICBcdFx0XHRyZXR1cm47XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0aWYgICh0cmFjayApe1xyXG4gICAgICAgIFx0XHRcdGxldCBpY29uID0gXCI8c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNoZWNrJz48L3NwYW4+XCI7XHJcbiAgICAgICAgXHRcdFx0aWYgKHRyYWNrLm5vX2Ryb3AgfHwgc2VsZi50cmFja3NbdHJhY2sudHJhY2tfaWRdKXtcclxuICAgICAgICBcdFx0XHRcdGljb249XCI8c3BhbiBjbGFzcz0ndWktaWNvbiAgdWktaWNvbi1jbG9zZXRoaWNrJz48L3NwYW4+XCJcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0c2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgIFx0XHRcdHVpLmhlbHBlci5wcmVwZW5kKGljb24pLmNzcyhcIndoaXRlLXNwYWNlXCIsXCJub3dyYXBcIik7XHJcbiAgICAgICAgXHRcdFx0fSwyMCk7XHJcblxyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9LFxyXG4gICAgICAgIFx0Z3JlZWR5OnRydWUsXHJcbiAgICAgICAgXHRvdXQ6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgXHRcdHVpLmhlbHBlci5maW5kKFwiLnVpLWljb25cIikucmVtb3ZlKCk7XHJcbiAgICAgICAgXHR9LFxyXG4gICAgICAgICAgICBkcm9wOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICAgICAgIGxldCB0cmFjayA9ICQodWkuZHJhZ2dhYmxlWzBdKS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgICAgICAgICAgdWkuaGVscGVyLmZpbmQoXCIudWktaWNvblwiKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgaWYgKCF0cmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBsZXQgcGFuZWw9JCh1aS5kcmFnZ2FibGVbMF0pLmRhdGEoXCJwYW5lbFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgaWYgKHBhbmVsPT09c2VsZiB8fCB0cmFjay5ub19kcm9wIHx8IHNlbGYudHJhY2tzW3RyYWNrLnRyYWNrX2lkXSkgeyAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIFx0IGlmIChwYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBcdFx0IHBhbmVsLnJlbW92ZVRyYWNrKHRyYWNrLnRyYWNrX2lkKTtcclxuICAgICAgICAgICAgICAgIFx0XHQgcGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBcdCB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZFRyYWNrKHRyYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICAvKipcclxuXHQqIEdldHMgdGhlIGZlYXR1cmUgdGhhdCB3YXMgY2xpY2tlZFxyXG5cdCogQHBhcmFtIHtKUXVlcnkgRXZlbnR9IGUgLSBDYW4gYmUgYW55IG9iamVjdC0gYWxsIHRoYXQgaXMgcmVxdWlyZWQgaXMgcGFnZVggYW5kIFBhZ2VZXHJcblx0KiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0cmFjayAtIHRoZSB0cmFjayBjb25maWcgYXQgdGhlIGV2ZW50IHBvc2l0aW9uKG9yIG51bGwpIGFuZFxyXG5cdCogZmVhdHVyZSAtIHRoZSBmZWF0dXJlIGF0IHRoZSBwb3N0aXRpb24gKG9yIG51bGwpLiBcclxuXHQqL1xyXG5cclxuICAgICBnZXRGZWF0dXJlQXQoZSl7XHJcbiAgICBcdCBsZXQgY28gPSBVdGlscy50cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsIHRoaXMuY2FudmFzKTtcclxuICAgIFx0IGNvLnktPXRoaXMueU9mZnNldDtcclxuICAgIFx0IGxldCBnbCA9IE1hdGgucm91bmQodGhpcy5zdGFydCsoY28ueCp0aGlzLmJwUGVyUGl4ZWwpKTtcclxuICAgIFx0IGZvciAobGV0IHQgaW4gdGhpcy50cmFja3Mpe1xyXG4gICAgXHQgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0XTtcclxuICAgIFx0IFx0aWYgKGNvLnk+dHJhY2sudG9wICYmIGNvLnk8dHJhY2suYm90dG9tKXtcclxuICAgIFx0IFx0XHRyZXR1cm4ge3RyYWNrOnRyYWNrLFxyXG4gICAgXHQgXHRcdFx0XHRmZWF0dXJlOnRyYWNrLmdldEZlYXR1cmVBdChnbCx0aGlzLmNocixjbyx0aGlzLmJwUGVyUGl4ZWwsdGhpcy5jdHgsdGhpcy55T2Zmc2V0KVxyXG4gICAgXHQgXHRcdH07XHJcbiAgICBcdCBcdH1cdFx0XHJcbiAgICBcdCB9XHJcbiAgICBcdCByZXR1cm4ge3RyYWNrOm51bGwsZmVhdHVyZTpudWxsfTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIGFsbG93VXNlclJlc2l6ZShkaXJlY3Rpb24pe1xyXG4gICAgXHRsZXQgaGFuZGxlcz1cImFsbFwiO1xyXG4gICAgXHRpZiAoZGlyZWN0aW9uPT09XCJ2ZXJ0aWNhbFwiKXtcclxuICAgIFx0XHRoYW5kbGVzPVwibixzXCI7XHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZSBpZiAoZGlyZWN0aW9uPT09XCJob3Jpem9udGFsXCIpe1xyXG4gICAgXHRcdGhhbmRsZXM9XCJlLHdcIjtcclxuICAgIFx0fVxyXG4gICAgICAgIGxldCBkaXYgPSB0aGlzLnRyYWNrRGl2O1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuXHRcdFxyXG4gICAgICAgIGRpdi5yZXNpemFibGUoe1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlc2l6ZTpmdW5jdGlvbihlLHVpKXtcclxuICAgICAgICAgICAgXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBcdGlmIChzZWxmLmxvYWRpbmcpe1xyXG4gICAgICAgICAgICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgICAgIFx0Y2xlYXJUaW1lb3V0KHNlbGYudG8pO1xyXG4gICAgICAgICAgICBcdHNlbGYudG89c2V0VGltZW91dChmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgXHRcdHNlbGYuc2V0V2lkdGgodWkuc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgICAgIFx0XHRzZWxmLnNldEhlaWdodCh1aS5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgIFx0XHRzZWxmLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBcdH0sMTAwKVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhbmRsZXM6aGFuZGxlc1xyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAgLyoqXHJcblx0KiBBbGxvd3MgdGhlIHVzZXIgdG8gbW92ZSB0aGUgcGFuZWwgdmlhIGEgaGFuZGxlIGluIHRoZVxyXG5cdCogdG9wIHJpZ2h0IGhhbmQgY29ybmVyXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIC0gZWl0aGVyIHZlcnRpY2FsIG9yIGhvcnpvbnRhbCwgd2lsbCByZXN0cmljdCBtb3ZlbWVudCBcclxuXHQqIGluIHRoaXMgcGxhbmVcclxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gaWYgdHJ1ZSB0aGVuIHRoZSBwYW5lbCB3aWxsIGJlIGNvbnN0cmFpbmVkIHdpdGhpbiBpdHMgcGFyZW50IFxyXG5cdCovXHJcbiAgICBhbGxvd1VzZXJNb3ZlKGRpcmVjdGlvbixjb250YWluKXtcclxuICAgIFx0bGV0IGF4aXM9ZmFsc2U7XHJcbiAgICBcdGxldCBpY29uPSBcImZhLWFycm93cy1hbHRcIjtcclxuICAgIFx0aWYgKGRpcmVjdGlvbj09XCJ2ZXJ0aWNhbFwiKXtcclxuICAgIFx0XHRheGlzPVwieVwiO1xyXG4gICAgXHRcdGljb24gKz1cIi12XCI7XHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZSBpZiAoZGlyZWN0aW9uPT1cImhvcml6b250YWxcIil7XHJcbiAgICBcdFx0YXhpcz1cInhcIjtcclxuICAgIFx0XHRpY29uKz1cIi1oXCI7XHJcbiAgICBcdH1cclxuICAgIFx0bGV0IGRpdiA9IHRoaXMudHJhY2tEaXY7XHJcblx0XHRkaXYuZmluZChcIi5wYW5lbC1pY29uLWRpdlwiKS5wcmVwZW5kKCQoXCI8c3BhbiBjbGFzcz0ndHJhY2staGFuZGxlIGZhcyBcIitpY29uK1wiJz48L3NwYW4+XCIpLmNzcyh7XCJjdXJzb3JcIjpcIm1vdmVcIn0pKTtcclxuICAgICAgICBsZXQgc2VsZiA9dGhpcztcclxuICAgICAgICBsZXQgYz1mYWxzZTtcclxuICAgICAgICBpZiAoY29udGFpbil7XHJcbiAgICAgICAgXHRjPVwicGFyZW50XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpdi5kcmFnZ2FibGUoe2hhbmRsZTpcIi50cmFjay1oYW5kbGVcIixheGlzOmF4aXMsY29udGFpbm1lbnQ6Y30pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGFsbG93VXNlckNsb3NlKCl7XHJcblx0XHRsZXQgZGl2ID0gdGhpcy50cmFja0RpdjtcclxuXHRcdGxldCBzZWxmID10aGlzO1xyXG5cdFx0bGV0IGljb249JChcIjxzcGFuIGNsYXNzPSdmYXMgZmEtdHJhc2gnPjwvc3Bhbj5cIilcclxuXHRcdFx0XHQuY2xpY2soKCk9PntcclxuXHRcdFx0XHRcdCAgc2VsZi5saXN0ZW5lcnMucGFuZWxfY2xvc2VkLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhzZWxmKX0pO1xyXG5cdFx0XHRcdFx0XHRkaXYucmVtb3ZlKClcclxuXHRcdFx0XHR9KTtcclxuXHRcdGRpdi5maW5kKFwiLnBhbmVsLWljb24tZGl2XCIpLmFwcGVuZChpY29uKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRXaWR0aCh3aWR0aCl7XHJcbiAgICAgICAgdGhpcy50cmFja0Rpdi53aWR0aCh3aWR0aCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRIZWlnaHQoaGVpZ2h0KXtcclxuICAgICAgICAkKHRoaXMudHJhY2tEaXYpLmhlaWdodChoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dfc2NhbGUpe1xyXG4gICAgICAgIFx0dGhpcy5zY2FsZV9jYW52YXNbMF0uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICByZWRyYXdUaWxlKGZlYXR1cmVzKSB7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50aWxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgY2hyID0gc2VsZi50aWxlLmNocixcclxuICAgICAgICAgICAgYnBTdGFydCA9IHNlbGYudGlsZS5zdGFydEJQLFxyXG4gICAgICAgICAgICBicEVuZCA9IHNlbGYudGlsZS5lbmRCUCxcclxuICAgICAgICAgICAgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXHJcbiAgICAgICAgICAgIGJwUGVyUGl4ZWwgPSBzZWxmLnRpbGUuc2NhbGU7XHJcblxyXG4gICAgICAgIGJ1ZmZlci53aWR0aCA9IHNlbGYudGlsZS5pbWFnZS53aWR0aDtcclxuICAgICAgICBidWZmZXIuaGVpZ2h0ID0gc2VsZi50aWxlLmltYWdlLmhlaWdodDtcclxuICAgICAgICB2YXIgY3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICBcclxuXHJcbiAgICAgICAgc2VsZi50cmFjay5kcmF3KHtcclxuICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjdHgsXHJcbiAgICAgICAgICAgIGJwU3RhcnQ6IGJwU3RhcnQsXHJcbiAgICAgICAgICAgIGJwUGVyUGl4ZWw6IGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgIHBpeGVsV2lkdGg6IGJ1ZmZlci53aWR0aCxcclxuICAgICAgICAgICAgcGl4ZWxIZWlnaHQ6IGJ1ZmZlci5oZWlnaHRcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIHNlbGYudGlsZSA9IG5ldyBUaWxlKGNociwgYnBTdGFydCwgYnBFbmQsIGJwUGVyUGl4ZWwsIGJ1ZmZlcik7XHJcbiAgICAgICAgc2VsZi5wYWludEltYWdlKCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgVGlsZXtcclxuXHRjb25zdHJ1Y3RvciAoY2hyLCB0aWxlU3RhcnQsIHRpbGVFbmQsIHNjYWxlLCBpbWFnZSkge1xyXG5cdFx0dGhpcy5jaHIgPSBjaHI7XHJcblx0XHR0aGlzLnN0YXJ0QlAgPSB0aWxlU3RhcnQ7XHJcblx0XHR0aGlzLmVuZEJQID0gdGlsZUVuZDtcclxuXHRcdHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuXHRcdHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuXHR9XHJcblxyXG5cdGNvbnRhaW5zUmFuZ2UoY2hyLCBzdGFydCwgZW5kLCBzY2FsZSkge1xyXG5cdFx0aWYgKHN0YXJ0PDApe1xyXG5cdFx0XHRzdGFydD0wO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2NhbGUudG9GaXhlZCgzKSA9PT0gc2NhbGUudG9GaXhlZCgzKSAmJiBzdGFydCA+PSB0aGlzLnN0YXJ0QlAgJiYgZW5kIDw9IHRoaXMuZW5kQlAgJiYgY2hyID09PSB0aGlzLmNocjtcclxuXHR9XHJcblxyXG5cdG92ZXJsYXBzUmFuZ2UoY2hyLCBzdGFydCwgZW5kKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaHIgPT09IGNociAmJiB0aGlzLmVuZEJQID49IHN0YXJ0ICYmIHRoaXMuc3RhcnRCUCA8PSBlbmQ7XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcblx0IFxyXG5leHBvcnQge01MVlBhbmVsfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBbUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFRQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7OztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWdCQTtBQUNBOzs7QUFHQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBU0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/panel.js\n");

/***/ }),

/***/ "../MLVPanel/src/panel_legend.js":
/*!**********************************!*\
  !*** .Panel/src/panel_legend.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PanelLegend = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _track_dialog = __webpack_require__(/*! ./track_dialog.js */ \"../MLVPanel/src/track_dialog.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelLegend = function () {\n    function PanelLegend(panel, config) {\n        _classCallCheck(this, PanelLegend);\n\n        if (!config) {\n            config = {};\n        }\n\n        this.panel = panel;\n        this.track_index = {};\n        this.div = $(\"<div>\").attr({ \"class\": \"mlv-track-legend\" }).mousedown(function (e) {\n            e.stopPropagation();\n        });\n\n        if (config.draggable || config.draggable === undefined) {\n            this.div.draggable({\n                containment: \"parent\"\n            });\n        }\n\n        if (config.transparent == false || config.transparent === undefined) {\n            this.div.css(\"background-color\", \"white\");\n        }\n\n        this.li = $(\"<ul>\").css({ \"list-style-type\": \"none\", \"padding\": \"4px\", \"margin\": \"4px\" });\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = panel.track_order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var id = _step.value;\n\n                this.addTrack(panel.tracks[id].config);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        var self = this;\n        this.div.append(this.li);\n        this.li.sortable({\n            helper: \"clone\",\n            stop: function stop(e, ui) {\n                self._reOrder(ui.item);\n            }\n        });\n\n        panel.trackDiv.append(this.div);\n    }\n\n    _createClass(PanelLegend, [{\n        key: \"swapOrder\",\n        value: function swapOrder(id1, id2) {\n            var el1 = null;\n            var el2 = null;\n            this.li.children().each(function (i, el) {\n                var e = $(el);\n                var track = e.data(\"track\");\n\n                if (track.track_id === id2) {\n                    el2 = e;\n                } else if (track.track_id === id1) {\n                    el1 = e;\n                }\n            });\n\n            el1.detach();\n            el1.insertAfter(el2);\n        }\n    }, {\n        key: \"_reOrder\",\n        value: function _reOrder(item) {\n            var group = item.data(\"track\").group;\n            var item_id = item.data(\"track\").track_id;\n            var order = [];\n            var group_index = 0;\n            var other_group_members = [];\n            this.li.children().each(function (i, el) {\n                var track = $(el).data(\"track\");\n                if (group && track.group === group) {\n                    if (track.track_id === item_id) {\n                        group_index = order.length;\n                        order.push(track.track_id);\n                    } else {\n                        other_group_members.push(track.track_id);\n                    }\n                    return;\n                }\n                order.push(track.track_id);\n            });\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = other_group_members[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var tid = _step2.value;\n\n                    order.splice(group_index + 1, 0, tid);\n                    group_index++;\n                    this.track_index[tid].detach().insertAfter(item);\n                    item = this.track_index[tid];\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.panel.track_order = order;\n\n            this.panel.update();\n        }\n    }, {\n        key: \"updateTrack\",\n        value: function updateTrack(track_id) {\n            var element = this.track_index[track_id];\n            var track = element.data(\"track\");\n            element.children().each(function (index, el) {\n                el = $(el);\n                if (index == 0) {\n                    el.css(\"color\", track.color);\n                } else if (index == 1) {\n                    el.text(track.short_label);\n                }\n            });\n            this.li.width(null);\n        }\n    }, {\n        key: \"addTrack\",\n        value: function addTrack(track, index) {\n            var self = this;\n            var item = $(\"<li>\").data({ track: track, panel: this.panel }).click(function (e) {\n                new _track_dialog.MLVTrackDialog(track, self.panel);\n            });\n            var span = $(\"<span>\");\n            var icon = \"fas fa-signature\";\n            if (track.format === \"feature\") {\n                icon = \"fas fa-stream\";\n            } else if (track.format === \"ruler\") {\n                icon = \"fas fa-ruler-horizontal\";\n            }\n\n            span.attr(\"class\", icon).css({ \"color\": track.color });\n            /*if (track.format==='line'){\r\n                span.height(2);\r\n            }\r\n            if (track.display===\"line\"){\r\n                span.height(4)\r\n            }\r\n            */\n            var text = $(\"<span>\").attr(\"class\", \"mlv-track-legend-text\");\n            item.append(span).append(text);\n            var t_sp = $(\"<span>\").width(15).appendTo(item);\n            if (track.allow_user_remove) {\n                var rm = $(\"<i class='fas  fa-trash'></i>\").click(function (e) {\n                    self.panel.removeTrack(track.track_id);\n                    self.removeTrack(track.track_id);\n                }).css(\"float\", \"right\").appendTo(t_sp);\n            }\n            if (index === 0) {\n                this.li.prepend(item);\n            } else if (index) {\n                var pos_el = this.li.children()[index - 1];\n                item.insertAfter($(pos_el));\n            } else {\n                this.li.append(item);\n            }\n            this.track_index[track.track_id] = item;\n            this.updateTrack(track.track_id);\n        }\n    }, {\n        key: \"removeTrack\",\n        value: function removeTrack(track_id) {\n            this.li.children().each(function (index, element) {\n                element = $(element);\n                var t = element.data(\"track\");\n                if (t && t.track_id === track_id) {\n                    element.remove();\n                }\n            });\n            delete this.track_index[track_id];\n        }\n    }, {\n        key: \"hide\",\n        value: function hide() {\n            this.div.hide();\n        }\n    }]);\n\n    return PanelLegend;\n}();\n\nexports.PanelLegend = PanelLegend;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3BhbmVsX2xlZ2VuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvcGFuZWxfbGVnZW5kLmpzPzg1OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNTFZUcmFja0RpYWxvZ30gZnJvbSBcIi4vdHJhY2tfZGlhbG9nLmpzXCI7XHJcblxyXG5jbGFzcyBQYW5lbExlZ2VuZHtcclxuICAgIGNvbnN0cnVjdG9yKHBhbmVsLGNvbmZpZyl7XHJcbiAgICAgICAgaWYgKCFjb25maWcpe1xyXG4gICAgICAgICAgICBjb25maWc9e307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBhbmVsPXBhbmVsO1xyXG4gICAgICAgIHRoaXMudHJhY2tfaW5kZXg9e307XHJcbiAgICAgICAgdGhpcy5kaXY9JChcIjxkaXY+XCIpLmF0dHIoe1wiY2xhc3NcIjpcIm1sdi10cmFjay1sZWdlbmRcIn0pXHJcbiAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmRyYWdnYWJsZSB8fCBjb25maWcuZHJhZ2dhYmxlPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICB0aGlzLmRpdi5kcmFnZ2FibGUoe1xyXG4gICAgICAgICAgICBjb250YWlubWVudDpcInBhcmVudFwiXHJcbiAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYgKGNvbmZpZy50cmFuc3BhcmVudCA9PSBmYWxzZSB8fCBjb25maWcudHJhbnNwYXJlbnQ9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgdGhpcy5kaXYuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLFwid2hpdGVcIilcclxuICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgdGhpcy5saSA9JChcIjx1bD5cIikuY3NzKHtcImxpc3Qtc3R5bGUtdHlwZVwiOlwibm9uZVwiLFwicGFkZGluZ1wiOlwiNHB4XCIsXCJtYXJnaW5cIjpcIjRweFwifSk7XHJcbiAgICAgICAgZm9yIChsZXQgaWQgb2YgcGFuZWwudHJhY2tfb3JkZXIpe1xyXG4gICAgICAgICAgIHRoaXMuYWRkVHJhY2socGFuZWwudHJhY2tzW2lkXS5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMubGkpO1xyXG4gICAgICAgIHRoaXMubGkuc29ydGFibGUoe1xyXG4gICAgICAgICAgICBoZWxwZXI6XCJjbG9uZVwiLFxyXG4gICAgICAgICAgICBzdG9wOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICBcdHNlbGYuX3JlT3JkZXIodWkuaXRlbSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBcclxuICAgICAgICBwYW5lbC50cmFja0Rpdi5hcHBlbmQodGhpcy5kaXYpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN3YXBPcmRlcihpZDEsaWQyKXtcclxuICAgICAgICBsZXQgZWwxPW51bGw7XHJcbiAgICAgICAgbGV0IGVsMj1udWxsO1xyXG4gICAgICAgICAgIHRoaXMubGkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGksZWwpe1xyXG4gICAgICAgICAgICBsZXQgZSA9ICQoZWwpO1xyXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSAgZS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0cmFjay50cmFja19pZD09PWlkMil7XHJcbiAgICAgICAgICAgICAgICBlbDI9ZTsgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgICh0cmFjay50cmFja19pZD09PWlkMSl7XHJcbiAgICAgICAgICAgICAgICBlbDE9ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsMS5kZXRhY2goKTtcclxuICAgICAgICBlbDEuaW5zZXJ0QWZ0ZXIoZWwyKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgX3JlT3JkZXIoaXRlbSl7XHJcbiAgICAgICAgbGV0IGdyb3VwID0gaXRlbS5kYXRhKFwidHJhY2tcIikuZ3JvdXA7XHJcbiAgICAgICAgbGV0IGl0ZW1faWQ9aXRlbS5kYXRhKFwidHJhY2tcIikudHJhY2tfaWQ7XHJcbiAgICAgICAgbGV0IG9yZGVyPVtdO1xyXG4gICAgICAgIGxldCBncm91cF9pbmRleD0wO1xyXG4gICAgICAgIGxldCBvdGhlcl9ncm91cF9tZW1iZXJzPVtdXHJcbiAgICAgICAgdGhpcy5saS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oaSxlbCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFjayA9ICAkKGVsKS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgICAgIGlmIChncm91cCAmJiB0cmFjay5ncm91cCA9PT1ncm91cCl7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sudHJhY2tfaWQ9PT1pdGVtX2lkKXtcclxuICAgICAgICAgICAgICAgICAgICBncm91cF9pbmRleD1vcmRlci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaCh0cmFjay50cmFja19pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfZ3JvdXBfbWVtYmVycy5wdXNoKHRyYWNrLnRyYWNrX2lkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9yZGVyLnB1c2godHJhY2sudHJhY2tfaWQpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgICBcclxuICAgICAgICBmb3IobGV0IHRpZCBvZiBvdGhlcl9ncm91cF9tZW1iZXJzKXtcclxuICAgICAgICAgICBvcmRlci5zcGxpY2UoZ3JvdXBfaW5kZXgrMSwwLHRpZCk7XHJcbiAgICAgICAgICAgZ3JvdXBfaW5kZXgrKztcclxuICAgICAgICAgICB0aGlzLnRyYWNrX2luZGV4W3RpZF0uZGV0YWNoKCkuaW5zZXJ0QWZ0ZXIoaXRlbSk7XHJcbiAgICAgICAgICAgaXRlbSA9ICB0aGlzLnRyYWNrX2luZGV4W3RpZF07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhbmVsLnRyYWNrX29yZGVyPW9yZGVyO1xyXG4gICAgICAgXHJcbiAgICAgICAgdGhpcy5wYW5lbC51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVUcmFjayh0cmFja19pZCl7XHJcbiAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMudHJhY2tfaW5kZXhbdHJhY2tfaWRdO1xyXG4gICAgICAgbGV0IHRyYWNrID0gZWxlbWVudC5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICBlbGVtZW50LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpbmRleCxlbCl7XHJcbiAgICBcdCAgIGVsPSQoZWwpO1xyXG4gICAgICAgICAgIGlmIChpbmRleD09MCl7XHJcbiAgICAgICAgXHQgICBlbC5jc3MoXCJjb2xvclwiLHRyYWNrLmNvbG9yKTsgIFx0ICAgXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2UgaWYgKGluZGV4PT0xKXtcclxuICAgICAgICAgICAgICAgZWwudGV4dCggdHJhY2suc2hvcnRfbGFiZWwpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxpLndpZHRoKG51bGwpOyAgICAgICAgICAgICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhZGRUcmFjayh0cmFjayxpbmRleCl7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxldCBpdGVtID0gJChcIjxsaT5cIikuZGF0YSh7dHJhY2s6dHJhY2sscGFuZWw6dGhpcy5wYW5lbH0pXHJcbiAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBuZXcgTUxWVHJhY2tEaWFsb2codHJhY2ssc2VsZi5wYW5lbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHNwYW4gPSAkKFwiPHNwYW4+XCIpO1xyXG4gICAgICAgIGxldCBpY29uPSBcImZhcyBmYS1zaWduYXR1cmVcIlxyXG4gICAgICAgIGlmICh0cmFjay5mb3JtYXQ9PT1cImZlYXR1cmVcIil7XHJcbiAgICAgICAgICAgIGljb24gPSBcImZhcyBmYS1zdHJlYW1cIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmFjay5mb3JtYXQ9PT1cInJ1bGVyXCIpe1xyXG4gICAgICAgICAgICBpY29uPVwiZmFzIGZhLXJ1bGVyLWhvcml6b250YWxcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwYW4uYXR0cihcImNsYXNzXCIsaWNvbikuY3NzKHtcImNvbG9yXCI6dHJhY2suY29sb3J9KVxyXG4gICAgICAgIC8qaWYgKHRyYWNrLmZvcm1hdD09PSdsaW5lJyl7XHJcbiAgICAgICAgICAgIHNwYW4uaGVpZ2h0KDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2suZGlzcGxheT09PVwibGluZVwiKXtcclxuICAgICAgICAgICAgc3Bhbi5oZWlnaHQoNClcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICBsZXQgdGV4dCA9ICQoXCI8c3Bhbj5cIikuYXR0cihcImNsYXNzXCIsXCJtbHYtdHJhY2stbGVnZW5kLXRleHRcIik7XHJcbiAgICAgICAgaXRlbS5hcHBlbmQoc3BhbikuYXBwZW5kKHRleHQpO1xyXG4gICAgICAgIGxldCB0X3NwID0gJChcIjxzcGFuPlwiKS53aWR0aCgxNSkuYXBwZW5kVG8oaXRlbSk7XHJcbiAgICAgICAgaWYgKHRyYWNrLmFsbG93X3VzZXJfcmVtb3ZlKXtcclxuICAgICAgICAgICAgbGV0IHJtPSQoXCI8aSBjbGFzcz0nZmFzICBmYS10cmFzaCc+PC9pPlwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwucmVtb3ZlVHJhY2sodHJhY2sudHJhY2tfaWQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVUcmFjayh0cmFjay50cmFja19pZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jc3MoXCJmbG9hdFwiLFwicmlnaHRcIilcclxuICAgICAgICAgICAgLmFwcGVuZFRvKHRfc3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXg9PT0wKXtcclxuICAgICAgICAgICAgdGhpcy5saS5wcmVwZW5kKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbmRleCl7XHJcbiAgICAgICAgICAgIGxldCBwb3NfZWw9dGhpcy5saS5jaGlsZHJlbigpW2luZGV4LTFdXHJcbiAgICAgICAgICAgIGl0ZW0uaW5zZXJ0QWZ0ZXIoJChwb3NfZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5saS5hcHBlbmQoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhY2tfaW5kZXhbdHJhY2sudHJhY2tfaWRdPWl0ZW07XHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmFjayh0cmFjay50cmFja19pZCk7ICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbW92ZVRyYWNrKHRyYWNrX2lkKXtcclxuICAgICAgICB0aGlzLmxpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpbmRleCxlbGVtZW50KXtcclxuICAgICAgICAgICAgZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGxldCB0ID0gIGVsZW1lbnQuZGF0YShcInRyYWNrXCIpO1xyXG4gICAgICAgICAgICBpZiAodCAmJiB0LnRyYWNrX2lkPT09dHJhY2tfaWQpe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrX2luZGV4W3RyYWNrX2lkXTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlKCl7XHJcbiAgICAgICAgdGhpcy5kaXYuaGlkZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtQYW5lbExlZ2VuZH07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUJBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTEE7QUFDQTtBQVFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQXJCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBc0JBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUE1QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/panel_legend.js\n");

/***/ }),

/***/ "../MLVPanel/src/track_dialog.js":
/*!**********************************!*\
  !*** .Panel/src/track_dialog.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AddTrackDialog = exports.MLVTrackDialog = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVTrackDialog = function () {\n    function MLVTrackDialog(config, panel) {\n        _classCallCheck(this, MLVTrackDialog);\n\n        this.config = _tracks.MLVTrack.parseConfig(config);\n        this.panel = panel;\n        this.div = $(\"<div>\").attr(\"class\", \"mlv-track-dialog\");\n        this.id = MLVTrackDialog.id++;\n\n        this.div.dialog({\n            autoOpen: true,\n            close: function close() {\n                $(this).dialog('destroy').remove();\n            },\n            title: this.config.short_label,\n            width: 250\n\n        }).dialogFix();\n        this.init();\n    }\n\n    _createClass(MLVTrackDialog, [{\n        key: \"_updatePanelScale\",\n        value: function _updatePanelScale() {\n            if (!this.panel) {\n                return;\n            }\n            this.panel.setTrackAttribute(this.config.track_id, \"max_y\", this.config.max_y);\n            this.panel.setTrackAttribute(this.config.track_id, \"min_y\", this.config.min_y);\n            this.panel.update();\n        }\n    }, {\n        key: \"_reOrderTrack\",\n        value: function _reOrderTrack(other_track) {\n            var this_i = this.panel.track_order.indexOf(this.config.track_id);\n            var other_i = this.panel.track_order.indexOf(other_track);\n            if (this_i < other_i) {\n                var temp = this.panel.track_order[this_i];\n                this.panel.track_order[this_i] = this.panel.track_order[other_i];\n                this.panel.track_order[other_i] = temp;\n                if (this.panel.legend) {\n                    this.panel.legend.swapOrder(this.config.track_id, other_track);\n                }\n            }\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var self = this;\n\n            var color_input = $(\"<input>\").attr({ type: \"color\" }).change(function (e) {\n                var color = $(this).val();\n                self.config.color = $(this).val();\n                if (self.panel) {\n                    self.panel.setTrackAttribute(self.config.track_id, \"color\", self.config.color);\n                    self.panel.update();\n                }\n            });\n            var color_div = $(\"<div class='t-d-div'></div>\");\n            color_div.append(\"<label>Color</label><br>\");\n            color_div.append(color_input).appendTo(this.div);\n            color_input.val(self.config.color).height(15);\n            this.div.append(\"<hr>\");\n            if (this.config.format === \"wig\") {\n                var scale_name = \"sc-ra-name-\" + this.id;\n                var scale_div = $(\"<div class='t-d-div'></div>\").append(\"<label>Scale</label><br>\");\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"automatic\", checked: this.config.scale === \"automatic\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Automatic\"));\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"fixed\", checked: this.config.scale === \"fixed\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Fixed\"));\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"dynamic\", checked: this.config.scale === \"dynamic\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Dynamic\"));\n                scale_div.appendTo(this.div);\n                $(\"input[name='\" + scale_name + \"']\").click(function (e) {\n                    var scale = $(\"input[name='\" + scale_name + \"']:checked\").val();\n                    self.config.scale = scale;\n                    if (scale === \"fixed\") {\n                        self.config.scale_group = \"\";\n                        self.sg_input.val(\"\");\n                    }\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"scale\", scale);\n                        self.panel.setTrackAttribute(self.config.track_id, \"scale_group\", self.config.scale_group);\n                        delete self.panel.tracks[self.config.track_id].max_y;\n                        self.panel.update();\n                    }\n                });\n                self.scale_slider = $(\"<div>\").slider({\n\n                    range: true,\n                    min: self.config.min_y,\n                    max: self.config.max_y,\n                    values: [self.config.min_y, self.config.max_y],\n                    slide: function slide(event, ui) {\n                        self.config.max_y = ui.values[1];\n                        self.config.min_y = ui.values[0];\n                        self._updatePanelScale();\n                        self.min_y_input.val(ui.values[0]);\n                        self.max_y_input.val(ui.values[1]);\n                    }\n                }).css(\"margin\", \"5px 3px\");\n                self.scale_slider.appendTo(scale_div);\n                self.scale_slider.slider(\"option\", \"values\", [self.config.min_y, self.config.max_y]);\n                self.min_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    var y = self.min_y_input.val();\n                    y = parseFloat(y);\n                    if (y < self.config.min_y) {\n                        self.scale_slider.slider(\"option\", \"min\", y);\n                    }\n                    self.scale_slider.slider(\"option\", \"values\", [y, self.config.max_y]);\n                    self.config.min_y = y;\n                    self._updatePanelScale();\n                }).appendTo(scale_div).width(40).val(self.config.min_y);\n                self.max_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    var y = self.max_y_input.val();\n                    y = parseFloat(y);\n                    var range = y - self.min_y_input.val();\n                    self.scale_slider.slider(\"option\", \"step\", range / 100);\n                    self.scale_slider.slider(\"option\", \"max\", y);\n                    self.scale_slider.slider(\"option\", \"values\", [self.config.min_y, y]);\n                    self.config.max_y = y;\n                    self._updatePanelScale();\n                }).appendTo(scale_div).width(40).css({ \"float\": \"right\" }).val(self.config.max_y);\n\n                scale_div.append(\"<br>Linked To:\");\n                var _track = this.panel.tracks[this.config.track_id];\n\n                this.link_opt = $(\"<select>\").css(\"max-width\", \"140px\").change(function (e) {\n                    var val = $(this).val();\n                    var dis = true;\n                    if (!val) {\n                        dis = false;\n                    }\n                    self.max_y_input.attr(\"disabled\", dis);\n                    self.min_y_input.attr(\"disabled\", dis);\n                    self.scale_slider.slider(\"option\", \"disabled\", dis);\n                    self._reOrderTrack(val);\n                    self.config.scale_link_to = val;\n                    self.panel.setTrackAttribute(self.config.track_id, \"scale_link_to\", val);\n\n                    self.panel.update();\n                });\n                scale_div.append(this.link_opt);\n                this.link_opt.append($(\"<option>\").val(null).text(\"none\"));\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this.panel.track_order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var tn = _step.value;\n\n                        var c = this.panel.tracks[tn].config;\n\n                        if (c.format !== \"wig\" || c.track_id === this.config.track_id || c.scale_link_to) {\n                            continue;\n                        }\n                        this.link_opt.append($(\"<option>\").val(c.track_id).text(c.short_label));\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                this.link_opt.val(this.config.scale_link_to);\n\n                if (this.config.scale_link_to) {\n                    this.max_y_input.attr(\"disabled\", true);\n                    this.min_y_input.attr(\"disabled\", true);\n                    this.scale_slider.slider(\"option\", \"disabled\", true);\n                }\n\n                scale_div.append(\"<br>\").append(\"<span>Scale Group:</span>\");\n                this.sg_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    self.config.scale_group = $(this).val();\n                    self.panel.setTrackAttribute(self.config.track_id, \"scale_group\", self.config.scale_group);\n                    self.panel.update();\n                }).width(120);\n                this.sg_input.val(this.config.scale_group).appendTo(scale_div);\n\n                this.div.append(\"<hr>\");\n\n                this.div.append(\"<hr>\");\n\n                var display_name = \"di-ra-name-\" + this.id;\n                var display_div = $(\"<div class='t-d-div'></div>\").append(\"<label>Display</label><br>\");\n                display_div.append($(\"<input>\").attr({ type: \"radio\", value: \"fill\", checked: this.config.display === \"fill\" || !this.config.display_type, name: display_name }));\n                display_div.append($(\"<span>\").text(\"Fill\"));\n                display_div.append($(\"<input>\").attr({ type: \"radio\", value: \"line\", checked: this.config.display === \"line\", name: display_name }));\n                display_div.append($(\"<span>\").text(\"Line\"));\n                this.div.append(display_div);\n                $(\"input[name='\" + display_name + \"']\").click(function (e) {\n                    var display = $(\"input[name='\" + display_name + \"']:checked\").val();\n                    self.config.display = display;\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"display\", display);\n                        self.panel.update();\n                    }\n                });\n                display_div.append(\"<br>\");\n\n                display_div.append(\"<label>group:</label>\").append(\"<br>\");\n                var input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    self.config.group = $(this).val();\n                    self.panel.setTrackAttribute(self.config.track_id, \"group\", self.config.group);\n                    self.panel.update();\n                });\n                input.val(this.config.group).appendTo(display_div);\n\n                this.div.append(\"<hr>\");\n            }\n            var discrete_div = $(\"<div>\").append(\"<label>Discrete</label>\");\n            var check = $(\"<input>\").attr({ type: \"checkbox\" }).prop(\"checked\", this.config.discrete).click(function (e) {\n                self.config.discrete = $(this).prop(\"checked\");\n                if (self.panel) {\n                    self.panel.setTrackAttribute(self.config.track_id, \"discrete\", self.config.discrete);\n                    self.panel.update();\n                }\n                if (self.config.discrete) {\n                    self.height_div.show();\n                } else {\n                    self.height_div.hide();\n                }\n            }).appendTo(discrete_div);\n            if (this.panel.fixed_height_mode) {\n                check.attr(\"disabled\", true);\n            }\n            discrete_div.appendTo(this.div);\n\n            // if (this.config.discrete || this.panel.fixed_height_mode){\n            this.height_div = $(\"<div class='t-d-div'></div>\");\n\n            this.height_div.append(\"<label>height:</label>\").appendTo(this.div);\n\n            var height_slider = $(\"<div>\").slider({\n                min: 10,\n                max: 500,\n                value: self.config.height,\n                slide: function slide(event, ui) {\n                    self.config.height = ui.value;\n                    self.panel.setTrackAttribute(self.config.track_id, \"height\", self.config.height);\n                    self.panel.update();\n                }\n            }).css({ \"margin\": \"5px 3px\" });\n            height_slider.appendTo(this.height_div);\n            if (!self.panel.fixed_height_mode) {\n                if (!self.config.discrete) {\n                    this.height_div.hide();\n                }\n            }\n\n            if (this.config.format === \"feature\" || this.config.type === \"bam\") {\n\n                var feature_div = $(\"<div>\").append(\"<label>Feature Height</label><br>\");\n                self.feature_height_slider = $(\"<div>\").slider({\n                    max: 40,\n                    min: 3,\n                    slide: function slide(e, ui) {\n                        self.config.featureHeight = ui.value;\n                        if (self.panel) {\n                            self.panel.setTrackAttribute(self.config.track_id, \"featureHeight\", self.config.featureHeight);\n                            self.panel.update();\n                        }\n                    }\n                });\n                self.feature_height_slider.slider(\"option\", \"value\", self.config.featureHeight);\n                feature_div.append(self.feature_height_slider).appendTo(this.div);\n                this.div.append(\"<hr>\");\n            }\n            if (this.config.format === \"feature\") {\n\n                var feature_display_div = $(\"<div>\").append(\"<label>Display</label><br>\");\n\n                self.feature_display_select = $(\"<select>\").append(\"<option>EXPANDED</option>\").append(\"<option>SQUISHED</option>\").append(\"<option>COLLAPSED</option>\").change(function (e) {\n                    self.config.displayMode = $(this).val();\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"displayMode\", self.config.displayMode);\n                        self.panel.update();\n                    }\n                }).val(self.config.displayMode);\n                feature_display_div.append(self.feature_display_select).appendTo(this.div);\n                this.div.append(\"<hr>\");\n            }\n\n            var op_div = $(\"<div>\").append(\"<label>Opacity</label><br>\");\n\n            self.opacity_slider = $(\"<div>\").slider({\n                max: 1.0,\n                min: 0.0,\n                step: 0.05,\n                slide: function slide(e, ui) {\n                    self.config.opacity = ui.value;\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"opacity\", self.config.opacity);\n                        self.panel.update();\n                    }\n                }\n            });\n            op_div.append(self.opacity_slider).appendTo(this.div);\n            self.opacity_slider.slider(\"option\", \"value\", self.config.opacity);\n            var track = this.panel.tracks[this.config.track_id];\n            track.addExtraControls(this);\n\n            var p = this.div.parent();\n        }\n    }]);\n\n    return MLVTrackDialog;\n}();\n\nvar AddTrackDialog = function () {\n    function AddTrackDialog(callback, config) {\n        _classCallCheck(this, AddTrackDialog);\n\n        if (!config) {\n            config = {};\n        }\n        this.config = config;\n        this.div = $(\"<div>\").attr(\"class\", \"add-track-dialog\");\n        this.id = MLVTrackDialog.id++;\n        this.callback = callback;\n        var self = this;\n        this.div.dialog({\n            autoOpen: true,\n            buttons: [{\n                text: \"Add\",\n                click: function click(e) {\n                    self.getConfig();\n                    $(this).dialog(\"close\");\n                }\n            }],\n            close: function close() {\n                $(this).dialog('destroy').remove();\n            },\n            title: \"Add Track\",\n            width: 250\n\n        }).dialogFix();\n\n        this.init();\n    }\n\n    _createClass(AddTrackDialog, [{\n        key: \"getConfig\",\n        value: function getConfig() {\n            var type = $(\"input[name='\" + this.type_radio + \"']:checked\").val();\n            var config = { url: this.url_input.val(), type: type, short_label: this.name_input.val() };\n            this.callback(config);\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var self = this;\n            this.div.append(\"<label>Paste URL</label>\");\n            this.url_input = $(\"<textarea>\").appendTo(this.div).css({ width: \"95%\" });\n            this.url_input.on(\"blur keypress\", function (e) {\n                if (e.originalEvent.type === \"keypress\" && e.charCode !== 13) {\n                    return;\n                }\n                self._getInfoFromUrl($(this).val());\n            });\n            this.div.append($(\"<label>Name</label>\"));\n            this.name_input = $(\"<input>\").appendTo(this.div);\n            this.div.append($(\"<label>Type</label>\"));\n            var radio_div = $(\"<div>\").appendTo(this.div);\n            this.type_radio = 'track-add-radio-' + this.id;\n            for (var type in _tracks.MLVTrack.track_types) {\n                if (this.config.allowed_track_types && this.config.allowed_track_types.indexOf(type) === -1) {\n                    continue;\n                }\n                this.addRadioButton(radio_div, type);\n            }\n        }\n    }, {\n        key: \"setAddFunction\",\n        value: function setAddFunction(func) {\n            this.callback = callback;\n        }\n    }, {\n        key: \"_getInfoFromUrl\",\n        value: function _getInfoFromUrl(url) {\n            var type = _tracks.MLVTrack.getTypeFromURL(url).type;\n            var name = _tracks.MLVTrack.calculateLabel(url);\n            if (url.includes(\"hgTracks\")) {\n                name = \"UCSC Session\";\n                type = \"ucsc_track\";\n            }\n            this.name_input.val(name);\n            $(\"[name='\" + this.type_radio + \"']\").val([type]);\n        }\n    }, {\n        key: \"addRadioButton\",\n        value: function addRadioButton(div, type) {\n            var sp = $(\"<span>\").css({ \"display\": \"inline-block\", \"margin-right\": \"3px\" });\n            sp.append($(\"<input>\").attr({ type: \"radio\", value: type, name: this.type_radio }));\n            sp.append($(\"<span>\").text(_tracks.MLVTrack.track_types[type].name));\n            div.append(sp);\n        }\n    }]);\n\n    return AddTrackDialog;\n}();\n\nMLVTrackDialog.id = 0;\n\nexports.MLVTrackDialog = MLVTrackDialog;\nexports.AddTrackDialog = AddTrackDialog;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3RyYWNrX2RpYWxvZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvdHJhY2tfZGlhbG9nLmpzP2NjZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNTFZUcmFja30gZnJvbSBcIi4vdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuY2xhc3MgTUxWVHJhY2tEaWFsb2d7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcscGFuZWwpe1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gTUxWVHJhY2sucGFyc2VDb25maWcoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnBhbmVsPXBhbmVsO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gJChcIjxkaXY+XCIpLmF0dHIoXCJjbGFzc1wiLFwibWx2LXRyYWNrLWRpYWxvZ1wiKTtcclxuICAgICAgICB0aGlzLmlkPU1MVlRyYWNrRGlhbG9nLmlkKys7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5kaXYuZGlhbG9nKHtcclxuICAgICAgIFx0XHRhdXRvT3BlbjogdHJ1ZSwgXHJcbiAgICAgICAgICAgIGNsb3NlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnZGVzdHJveScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIFx0dGl0bGU6IHRoaXMuY29uZmlnLnNob3J0X2xhYmVsLFxyXG4gICAgICAgIFx0d2lkdGg6MjUwXHJcbiAgICAgICBcclxuICAgICAgICB9KS5kaWFsb2dGaXgoKTtcclxuICAgICAgICB0aGlzLmluaXQoKTsgIFxyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVQYW5lbFNjYWxlKCl7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHRoaXMuY29uZmlnLnRyYWNrX2lkLFwibWF4X3lcIix0aGlzLmNvbmZpZy5tYXhfeSk7XHJcbiAgICAgICAgdGhpcy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZSh0aGlzLmNvbmZpZy50cmFja19pZCxcIm1pbl95XCIsdGhpcy5jb25maWcubWluX3kpO1xyXG4gICAgICAgIHRoaXMucGFuZWwudXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlT3JkZXJUcmFjayhvdGhlcl90cmFjayl7XHJcbiAgICBcdGxldCB0aGlzX2kgPSB0aGlzLnBhbmVsLnRyYWNrX29yZGVyLmluZGV4T2YodGhpcy5jb25maWcudHJhY2tfaWQpO1xyXG4gICAgXHRsZXQgb3RoZXJfaSA9ICB0aGlzLnBhbmVsLnRyYWNrX29yZGVyLmluZGV4T2Yob3RoZXJfdHJhY2spO1xyXG4gICAgXHRpZiAodGhpc19pIDwgb3RoZXJfaSl7XHJcbiAgICBcdFx0bGV0IHRlbXAgPSB0aGlzLnBhbmVsLnRyYWNrX29yZGVyW3RoaXNfaV07XHJcbiAgICBcdFx0dGhpcy5wYW5lbC50cmFja19vcmRlclt0aGlzX2ldPXRoaXMucGFuZWwudHJhY2tfb3JkZXJbb3RoZXJfaV07XHJcbiAgICBcdFx0dGhpcy5wYW5lbC50cmFja19vcmRlcltvdGhlcl9pXT10ZW1wO1xyXG4gICAgXHRcdGlmICh0aGlzLnBhbmVsLmxlZ2VuZCl7XHJcbiAgICBcdFx0XHR0aGlzLnBhbmVsLmxlZ2VuZC5zd2FwT3JkZXIodGhpcy5jb25maWcudHJhY2tfaWQsb3RoZXJfdHJhY2spXHJcbiAgICBcdFx0fVxyXG5cclxuICAgIFx0fVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAgICAgXHJcbiAgICBpbml0KCl7XHJcbiAgICAgICAgbGV0IHNlbGY9dGhpcztcclxuXHJcbiAgICAgICAgbGV0IGNvbG9yX2lucHV0PSQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJjb2xvclwifSlcclxuICAgICAgICAuY2hhbmdlKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSAkKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5jb2xvcj0kKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiY29sb3JcIixzZWxmLmNvbmZpZy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGNvbG9yX2Rpdj0kKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpO1xyXG4gICAgICAgIGNvbG9yX2Rpdi5hcHBlbmQoXCI8bGFiZWw+Q29sb3I8L2xhYmVsPjxicj5cIik7XHJcbiAgICAgICAgY29sb3JfZGl2LmFwcGVuZChjb2xvcl9pbnB1dCkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgICAgIGNvbG9yX2lucHV0LnZhbChzZWxmLmNvbmZpZy5jb2xvcikuaGVpZ2h0KDE1KTtcclxuICAgICAgICB0aGlzLmRpdi5hcHBlbmQoXCI8aHI+XCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5mb3JtYXQ9PT1cIndpZ1wiKXtcclxuICAgICAgICAgICAgbGV0IHNjYWxlX25hbWU9IFwic2MtcmEtbmFtZS1cIit0aGlzLmlkXHJcbiAgICAgICAgICAgIGxldCBzY2FsZV9kaXYgPSAkKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5TY2FsZTwvbGFiZWw+PGJyPlwiKTtcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImF1dG9tYXRpY1wiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImF1dG9tYXRpY1wiLG5hbWU6c2NhbGVfbmFtZX0pKVxyXG4gICAgICAgICAgICBzY2FsZV9kaXYuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChcIkF1dG9tYXRpY1wiKSk7XHJcbiAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcInJhZGlvXCIsdmFsdWU6XCJmaXhlZFwiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImZpeGVkXCIsbmFtZTpzY2FsZV9uYW1lfSkpXHJcbiAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KFwiRml4ZWRcIikpO1xyXG4gICAgICAgICAgICBzY2FsZV9kaXYuYXBwZW5kKCQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJyYWRpb1wiLHZhbHVlOlwiZHluYW1pY1wiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImR5bmFtaWNcIixuYW1lOnNjYWxlX25hbWV9KSlcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJEeW5hbWljXCIpKTtcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuICAgICAgICAgICAgJChcImlucHV0W25hbWU9J1wiK3NjYWxlX25hbWUrXCInXVwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIGxldCBzY2FsZT0kKFwiaW5wdXRbbmFtZT0nXCIrc2NhbGVfbmFtZStcIiddOmNoZWNrZWRcIikudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zY2FsZT1zY2FsZTtcclxuICAgICAgICAgICAgICAgIGlmIChzY2FsZT09PVwiZml4ZWRcIil7XHJcbiAgICAgICAgICAgICAgICBcdHNlbGYuY29uZmlnLnNjYWxlX2dyb3VwPVwiXCI7XHJcbiAgICAgICAgICAgICAgICBcdHNlbGYuc2dfaW5wdXQudmFsKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJzY2FsZVwiLHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwic2NhbGVfZ3JvdXBcIixzZWxmLmNvbmZpZy5zY2FsZV9ncm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYucGFuZWwudHJhY2tzW3NlbGYuY29uZmlnLnRyYWNrX2lkXS5tYXhfeTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VsZi5zY2FsZV9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG5cclxuICAgICAgICAgICAgICAgIHJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWluOiBzZWxmLmNvbmZpZy5taW5feSxcclxuICAgICAgICAgICAgICAgIG1heDogc2VsZi5jb25maWcubWF4X3ksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFsgc2VsZi5jb25maWcubWluX3ksc2VsZi5jb25maWcubWF4X3kgXSxcclxuICAgICAgICAgICAgICAgIHNsaWRlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heF95PSB1aS52YWx1ZXNbIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5feT0gdWkudmFsdWVzWyAwIF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGFuZWxTY2FsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluX3lfaW5wdXQudmFsKHVpLnZhbHVlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXhfeV9pbnB1dC52YWwodWkudmFsdWVzWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY3NzKFwibWFyZ2luXCIsXCI1cHggM3B4XCIpO1xyXG4gICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5hcHBlbmRUbyhzY2FsZV9kaXYpO1xyXG4gICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlc1wiLFtzZWxmLmNvbmZpZy5taW5feSxzZWxmLmNvbmZpZy5tYXhfeV0pO1xyXG4gICAgICAgICAgICBzZWxmLm1pbl95X2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1zZWxmLm1pbl95X2lucHV0LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgeT1wYXJzZUZsb2F0KHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHk8c2VsZi5jb25maWcubWluX3kpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2NhbGVfc2xpZGVyLnNsaWRlcihcIm9wdGlvblwiLFwibWluXCIseSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlc1wiLFt5LHNlbGYuY29uZmlnLm1heF95XSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5feT15O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGFuZWxTY2FsZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KS5hcHBlbmRUbyhzY2FsZV9kaXYpLndpZHRoKDQwKS52YWwoc2VsZi5jb25maWcubWluX3kpO1xyXG4gICAgICAgICAgICBzZWxmLm1heF95X2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgIGlmIChlLnR5cGU9PT1cImtleXByZXNzXCIgJiYgIShlLndoaWNoPT09MTMpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9c2VsZi5tYXhfeV9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHk9cGFyc2VGbG9hdCh5KTtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSAgPSB5IC0gc2VsZi5taW5feV9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2NhbGVfc2xpZGVyLnNsaWRlcihcIm9wdGlvblwiLFwic3RlcFwiLHJhbmdlLzEwMCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcIm1heFwiLHkpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJ2YWx1ZXNcIixbc2VsZi5jb25maWcubWluX3kseV0pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4X3k9eTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZVBhbmVsU2NhbGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSkuYXBwZW5kVG8oc2NhbGVfZGl2KS53aWR0aCg0MCkuY3NzKHtcImZsb2F0XCI6XCJyaWdodFwifSkudmFsKHNlbGYuY29uZmlnLm1heF95KTtcclxuXHJcblx0XHRcdHNjYWxlX2Rpdi5hcHBlbmQoXCI8YnI+TGlua2VkIFRvOlwiKTtcclxuXHRcdFx0bGV0IHRyYWNrICA9IHRoaXMucGFuZWwudHJhY2tzW3RoaXMuY29uZmlnLnRyYWNrX2lkXTtcclxuICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5saW5rX29wdCA9ICQoXCI8c2VsZWN0PlwiKVxyXG4gICAgICAgICAgICBcdC5jc3MoXCJtYXgtd2lkdGhcIixcIjE0MHB4XCIpXHJcbiAgICAgICAgICAgIFx0LmNoYW5nZShmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgXHRcdGxldCB2YWw9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgIFx0XHRsZXQgZGlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgXHRcdGlmICghdmFsKXtcclxuXHRcdFx0XHRcdFx0ZGlzPWZhbHNlO1xyXG4gICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgICBcdFx0c2VsZi5tYXhfeV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkaXMpO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5taW5feV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkaXMpO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJkaXNhYmxlZFwiLGRpcyk7XHJcblx0XHRcdFx0XHRzZWxmLl9yZU9yZGVyVHJhY2sodmFsKTtcclxuXHRcdFx0XHRcdHNlbGYuY29uZmlnLnNjYWxlX2xpbmtfdG89dmFsO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShzZWxmLmNvbmZpZy50cmFja19pZCxcInNjYWxlX2xpbmtfdG9cIix2YWwpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHRcdHNlbGYucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcblx0XHRcdHNjYWxlX2Rpdi5hcHBlbmQodGhpcy5saW5rX29wdCk7XHJcblx0XHRcdHRoaXMubGlua19vcHQuYXBwZW5kKCQoXCI8b3B0aW9uPlwiKS52YWwobnVsbCkudGV4dChcIm5vbmVcIikpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0biBvZiB0aGlzLnBhbmVsLnRyYWNrX29yZGVyKXtcclxuICAgICAgICAgICAgXHRsZXQgYz0gdGhpcy5wYW5lbC50cmFja3NbdG5dLmNvbmZpZztcclxuXHJcbiAgICAgICAgICAgIFx0aWYgKGMuZm9ybWF0ICE9PSBcIndpZ1wiIHx8IGMudHJhY2tfaWQgPT09IHRoaXMuY29uZmlnLnRyYWNrX2lkICB8fCBjLnNjYWxlX2xpbmtfdG8gKXtcclxuICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBcdH1cclxuXHRcdFx0XHR0aGlzLmxpbmtfb3B0LmFwcGVuZCgkKFwiPG9wdGlvbj5cIikudmFsKGMudHJhY2tfaWQpLnRleHQoYy5zaG9ydF9sYWJlbCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpbmtfb3B0LnZhbCh0aGlzLmNvbmZpZy5zY2FsZV9saW5rX3RvKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zY2FsZV9saW5rX3RvKXtcclxuICAgICAgICAgICAgXHR0aGlzLm1heF95X2lucHV0LmF0dHIoXCJkaXNhYmxlZFwiLHRydWUpO1xyXG4gICAgICAgICAgICBcdHRoaXMubWluX3lfaW5wdXQuYXR0cihcImRpc2FibGVkXCIsdHJ1ZSk7XHJcbiAgICAgICAgICAgIFx0dGhpcy5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJkaXNhYmxlZFwiLHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuXHJcbiAgICAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoXCI8YnI+XCIpLmFwcGVuZChcIjxzcGFuPlNjYWxlIEdyb3VwOjwvc3Bhbj5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2dfaW5wdXQ9ICQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgIGlmIChlLnR5cGU9PT1cImtleXByZXNzXCIgJiYgIShlLndoaWNoPT09MTMpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zY2FsZV9ncm91cD0kKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShzZWxmLmNvbmZpZy50cmFja19pZCxcInNjYWxlX2dyb3VwXCIsc2VsZi5jb25maWcuc2NhbGVfZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIH0pLndpZHRoKDEyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2dfaW5wdXQudmFsKHRoaXMuY29uZmlnLnNjYWxlX2dyb3VwKS5hcHBlbmRUbyhzY2FsZV9kaXYpO1xyXG4gICAgICAgICBcclxuICAgICBcdFx0dGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgICAgICAgICBcclxuXHJcbiAgXHJcblxyXG4gICAgICAgXHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGRpc3BsYXlfbmFtZT0gXCJkaS1yYS1uYW1lLVwiK3RoaXMuaWQ7XHJcbiAgICAgICAgICAgIGxldCBkaXNwbGF5X2RpdiA9ICQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIikuYXBwZW5kKFwiPGxhYmVsPkRpc3BsYXk8L2xhYmVsPjxicj5cIik7XHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImZpbGxcIixjaGVja2VkOnRoaXMuY29uZmlnLmRpc3BsYXk9PT1cImZpbGxcIiB8fCAhdGhpcy5jb25maWcuZGlzcGxheV90eXBlLG5hbWU6ZGlzcGxheV9uYW1lfSkpXHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJGaWxsXCIpKTtcclxuICAgICAgICAgICAgZGlzcGxheV9kaXYuYXBwZW5kKCQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJyYWRpb1wiLHZhbHVlOlwibGluZVwiLGNoZWNrZWQ6dGhpcy5jb25maWcuZGlzcGxheT09PVwibGluZVwiLG5hbWU6ZGlzcGxheV9uYW1lfSkpXHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJMaW5lXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpc3BsYXlfZGl2KTtcclxuICAgICAgICAgICAgICQoXCJpbnB1dFtuYW1lPSdcIitkaXNwbGF5X25hbWUrXCInXVwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5PSQoXCJpbnB1dFtuYW1lPSdcIitkaXNwbGF5X25hbWUrXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZGlzcGxheT1kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5XCIsZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZChcIjxicj5cIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgXHJcbiAgICAgICBcclxuICAgICAgICAgICAgZGlzcGxheV9kaXYuYXBwZW5kKFwiPGxhYmVsPmdyb3VwOjwvbGFiZWw+XCIpLmFwcGVuZChcIjxicj5cIik7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dD0gJChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmdyb3VwPSQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZ3JvdXBcIixzZWxmLmNvbmZpZy5ncm91cCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlucHV0LnZhbCh0aGlzLmNvbmZpZy5ncm91cCkuYXBwZW5kVG8oZGlzcGxheV9kaXYpO1xyXG4gICAgICAgICBcclxuICAgICBcdFx0dGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuXHRcdH1cclxuXHRcdCAgICBsZXQgZGlzY3JldGVfZGl2PSQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+RGlzY3JldGU8L2xhYmVsPlwiKTtcclxuICAgICAgICAgICAgbGV0IGNoZWNrID0gJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcImNoZWNrYm94XCJ9KS5wcm9wKFwiY2hlY2tlZFwiLHRoaXMuY29uZmlnLmRpc2NyZXRlKVxyXG4gICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmRpc2NyZXRlPSQodGhpcykucHJvcChcImNoZWNrZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZGlzY3JldGVcIixzZWxmLmNvbmZpZy5kaXNjcmV0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRzZWxmLmhlaWdodF9kaXYuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIFx0c2VsZi5oZWlnaHRfZGl2LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmRUbyhkaXNjcmV0ZV9kaXYpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbC5maXhlZF9oZWlnaHRfbW9kZSl7XHJcbiAgICAgICAgICAgIFx0Y2hlY2suYXR0cihcImRpc2FibGVkXCIsdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzY3JldGVfZGl2LmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuXHJcblxyXG5cclxuICAgICAgIFx0Ly8gaWYgKHRoaXMuY29uZmlnLmRpc2NyZXRlIHx8IHRoaXMucGFuZWwuZml4ZWRfaGVpZ2h0X21vZGUpe1xyXG4gICAgICAgXHR0aGlzLmhlaWdodF9kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuICAgICAgICBcdFxyXG5cdFx0dGhpcy5oZWlnaHRfZGl2LmFwcGVuZChcIjxsYWJlbD5oZWlnaHQ6PC9sYWJlbD5cIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cclxuICAgICAgICBsZXQgaGVpZ2h0X3NsaWRlciA9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICAgIFx0bWluOiAxMCxcclxuICAgICAgICAgICAgbWF4OiA1MDAsXHJcbiAgICAgICAgICAgIHZhbHVlOnNlbGYuY29uZmlnLmhlaWdodCxcclxuICAgICAgICAgICAgc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XHJcbiAgICAgICAgICAgIFx0c2VsZi5jb25maWcuaGVpZ2h0PSB1aS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJoZWlnaHRcIixzZWxmLmNvbmZpZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTsgXHJcbiAgICAgICAgICAgIH1cclxuXHRcdH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgIGhlaWdodF9zbGlkZXIuYXBwZW5kVG8odGhpcy5oZWlnaHRfZGl2KTtcclxuICAgICAgICBpZiAoIShzZWxmLnBhbmVsLmZpeGVkX2hlaWdodF9tb2RlKSl7XHJcbiAgICAgICAgXHRpZiAoIShzZWxmLmNvbmZpZy5kaXNjcmV0ZSkpe1xyXG4gICAgICAgIFx0XHR0aGlzLmhlaWdodF9kaXYuaGlkZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH1cclxuIFxyXG5cclxuICAgXHJcblxyXG4gICAgICAgXHJcblxyXG4gICAgICAgXHJcblxyXG4gICBcdCBpZiAodGhpcy5jb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIgfHwgdGhpcy5jb25maWcudHlwZT09PVwiYmFtXCIpe1xyXG5cclxuICAgIGxldCBmZWF0dXJlX2Rpdj0gICQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+RmVhdHVyZSBIZWlnaHQ8L2xhYmVsPjxicj5cIik7XHJcbiAgICBzZWxmLmZlYXR1cmVfaGVpZ2h0X3NsaWRlcj0kKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgIG1heDo0MCxcclxuICAgICAgIG1pbjozLFxyXG4gICAgICAgc2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodD11aS52YWx1ZTtcclxuICAgICAgICAgICBpZiAoc2VsZi5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZmVhdHVyZUhlaWdodFwiLHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9IFxyXG4gICAgfSk7XHJcbiAgICBzZWxmLmZlYXR1cmVfaGVpZ2h0X3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodCk7XHJcbiAgICBmZWF0dXJlX2Rpdi5hcHBlbmQoc2VsZi5mZWF0dXJlX2hlaWdodF9zbGlkZXIpLmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuICAgIHRoaXMuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIpe1xyXG5cclxuICAgIGxldCBmZWF0dXJlX2Rpc3BsYXlfZGl2PSAgJChcIjxkaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5EaXNwbGF5PC9sYWJlbD48YnI+XCIpO1xyXG5cclxuXHJcbiAgICBzZWxmLmZlYXR1cmVfZGlzcGxheV9zZWxlY3Q9JChcIjxzZWxlY3Q+XCIpLmFwcGVuZChcIjxvcHRpb24+RVhQQU5ERUQ8L29wdGlvbj5cIilcclxuICAgICAgICAgICAgLmFwcGVuZChcIjxvcHRpb24+U1FVSVNIRUQ8L29wdGlvbj5cIilcclxuICAgICAgICAgICAgLmFwcGVuZChcIjxvcHRpb24+Q09MTEFQU0VEPC9vcHRpb24+XCIpXHJcbiAgICAgICAgICAgIC5jaGFuZ2UoZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5kaXNwbGF5TW9kZT0kKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5TW9kZVwiLHNlbGYuY29uZmlnLmRpc3BsYXlNb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSkudmFsKHNlbGYuY29uZmlnLmRpc3BsYXlNb2RlKTtcclxuICAgIGZlYXR1cmVfZGlzcGxheV9kaXYuYXBwZW5kKHNlbGYuZmVhdHVyZV9kaXNwbGF5X3NlbGVjdCkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgdGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb3BfZGl2PSQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+T3BhY2l0eTwvbGFiZWw+PGJyPlwiKTtcclxuXHJcbiAgICBzZWxmLm9wYWNpdHlfc2xpZGVyPSAkKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgICBtYXg6MS4wLFxyXG4gICAgICAgIG1pbjowLjAsXHJcbiAgICAgICAgc3RlcDowLjA1LFxyXG4gICAgICAgIHNsaWRlOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5vcGFjaXR5ID0gdWkudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJvcGFjaXR5XCIsc2VsZi5jb25maWcub3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIG9wX2Rpdi5hcHBlbmQoc2VsZi5vcGFjaXR5X3NsaWRlcikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgc2VsZi5vcGFjaXR5X3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2VsZi5jb25maWcub3BhY2l0eSk7XHJcbiAgICBsZXQgdHJhY2sgPSB0aGlzLnBhbmVsLnRyYWNrc1t0aGlzLmNvbmZpZy50cmFja19pZF07XHJcbiAgICB0cmFjay5hZGRFeHRyYUNvbnRyb2xzKHRoaXMpO1xyXG5cclxuICBcclxuXHJcbiAgIGxldCBwID0gdGhpcy5kaXYucGFyZW50KCk7XHJcblxyXG4gICAgfSAgICAgICBcclxufVxyXG5cclxuY2xhc3MgQWRkVHJhY2tEaWFsb2d7XHJcblx0Y29uc3RydWN0b3IoY2FsbGJhY2ssY29uZmlnKXtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0Y29uZmlnPXt9O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gJChcIjxkaXY+XCIpLmF0dHIoXCJjbGFzc1wiLFwiYWRkLXRyYWNrLWRpYWxvZ1wiKTtcclxuICAgICAgICB0aGlzLmlkPU1MVlRyYWNrRGlhbG9nLmlkKys7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjaz1jYWxsYmFja1xyXG4gICAgICAgIGxldCBzZWxmPXRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXYuZGlhbG9nKHtcclxuICAgICAgIFx0XHRhdXRvT3BlbjogdHJ1ZSxcclxuICAgICAgIFx0XHRidXR0b25zOlt7XHJcbiAgICAgICBcdFx0XHR0ZXh0OlwiQWRkXCIsXHJcbiAgICAgICBcdFx0XHRjbGljazpmdW5jdGlvbihlKXtcclxuICAgICAgIFx0XHRcdFx0c2VsZi5nZXRDb25maWcoKVxyXG4gICAgICAgXHRcdFx0XHQkKHRoaXMpLmRpYWxvZyhcImNsb3NlXCIpO1xyXG4gICAgICAgXHRcdFx0fVxyXG4gICAgICAgXHRcdH1dLFxyXG4gICAgICAgICAgICBjbG9zZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kaWFsb2coJ2Rlc3Ryb3knKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBcdHRpdGxlOiBcIkFkZCBUcmFja1wiLFxyXG4gICAgICAgIFx0d2lkdGg6MjUwXHJcbiAgICAgICBcclxuICAgICAgICB9KS5kaWFsb2dGaXgoKTtcclxuXHRcdFxyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICBcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDb25maWcoKXtcdFx0XHJcblx0XHRsZXQgdHlwZSA9ICQoXCJpbnB1dFtuYW1lPSdcIit0aGlzLnR5cGVfcmFkaW8rXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG5cdFx0bGV0IGNvbmZpZz0ge3VybDp0aGlzLnVybF9pbnB1dC52YWwoKSx0eXBlOnR5cGUsc2hvcnRfbGFiZWw6dGhpcy5uYW1lX2lucHV0LnZhbCgpfTtcclxuXHRcdHRoaXMuY2FsbGJhY2soY29uZmlnKTtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0aW5pdCgpe1xyXG5cdFx0bGV0IHNlbGY9dGhpcztcclxuXHRcdHRoaXMuZGl2LmFwcGVuZChcIjxsYWJlbD5QYXN0ZSBVUkw8L2xhYmVsPlwiKTtcclxuXHRcdHRoaXMudXJsX2lucHV0PSAkKFwiPHRleHRhcmVhPlwiKS5hcHBlbmRUbyh0aGlzLmRpdikuY3NzKHt3aWR0aDpcIjk1JVwifSk7XHJcblx0XHR0aGlzLnVybF9pbnB1dC5vbihcImJsdXIga2V5cHJlc3NcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudC50eXBlPT09XCJrZXlwcmVzc1wiICYmICBlLmNoYXJDb2RlICE9PTEzKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5fZ2V0SW5mb0Zyb21VcmwoKCQodGhpcykudmFsKCkpKVxyXG5cdFx0XHJcblxyXG5cdFx0fSk7XHJcblx0XHR0aGlzLmRpdi5hcHBlbmQoJChcIjxsYWJlbD5OYW1lPC9sYWJlbD5cIikpO1xyXG5cdFx0dGhpcy5uYW1lX2lucHV0ID0gJChcIjxpbnB1dD5cIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5kaXYuYXBwZW5kKCQoXCI8bGFiZWw+VHlwZTwvbGFiZWw+XCIpKTtcclxuXHRcdGxldCByYWRpb19kaXY9JChcIjxkaXY+XCIpLmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuXHRcdHRoaXMudHlwZV9yYWRpbz0gJ3RyYWNrLWFkZC1yYWRpby0nK3RoaXMuaWRcclxuXHRcdGZvciAobGV0IHR5cGUgaW4gTUxWVHJhY2sudHJhY2tfdHlwZXMpe1xyXG5cdFx0XHRpZiAodGhpcy5jb25maWcuYWxsb3dlZF90cmFja190eXBlcyAmJiB0aGlzLmNvbmZpZy5hbGxvd2VkX3RyYWNrX3R5cGVzLmluZGV4T2YodHlwZSk9PT0tMSl7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5hZGRSYWRpb0J1dHRvbihyYWRpb19kaXYsdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QWRkRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmNhbGxiYWNrPWNhbGxiYWNrO1xyXG5cdH1cclxuXHJcblx0X2dldEluZm9Gcm9tVXJsKHVybCl7XHJcblx0XHRsZXQgdHlwZSA9IE1MVlRyYWNrLmdldFR5cGVGcm9tVVJMKHVybCkudHlwZVxyXG5cdFx0bGV0IG5hbWUgPSBNTFZUcmFjay5jYWxjdWxhdGVMYWJlbCh1cmwpO1xyXG5cdFx0aWYgKHVybC5pbmNsdWRlcyhcImhnVHJhY2tzXCIpKXtcclxuXHRcdFx0bmFtZSA9IFwiVUNTQyBTZXNzaW9uXCI7XHJcblx0XHRcdHR5cGU9IFwidWNzY190cmFja1wiXHJcblx0XHR9XHJcblx0XHR0aGlzLm5hbWVfaW5wdXQudmFsKG5hbWUpO1xyXG5cdFx0JChcIltuYW1lPSdcIit0aGlzLnR5cGVfcmFkaW8rXCInXVwiKS52YWwoW3R5cGVdKTtcclxuXHJcblx0fVxyXG5cclxuXHRhZGRSYWRpb0J1dHRvbihkaXYsIHR5cGUpe1xyXG5cdFx0bGV0IHNwID0kKFwiPHNwYW4+XCIpLmNzcyh7XCJkaXNwbGF5XCI6XCJpbmxpbmUtYmxvY2tcIixcIm1hcmdpbi1yaWdodFwiOlwiM3B4XCJ9KTtcclxuXHRcdHNwLmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTp0eXBlLG5hbWU6dGhpcy50eXBlX3JhZGlvfSkpO1xyXG5cdFx0c3AuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChNTFZUcmFjay50cmFja190eXBlc1t0eXBlXS5uYW1lKSk7XHJcblx0XHRkaXYuYXBwZW5kKHNwKTtcclxuXHJcblx0fVxyXG5cclxuXHRcclxuXHJcblxyXG59XHJcblxyXG5cclxuTUxWVHJhY2tEaWFsb2cuaWQ9MDtcclxuXHJcbmV4cG9ydCB7TUxWVHJhY2tEaWFsb2csQWRkVHJhY2tEaWFsb2d9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0ZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUE4RkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBc0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/track_dialog.js\n");

/***/ }),

/***/ "../MLVPanel/src/tracks.js":
/*!****************************!*\
  !*** .Panel/src/tracks.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Graphics = exports.MLVBigBedTrack = exports.RulerTrack = exports.MLVBedTrack = exports.MLVWigTrack = exports.MLVTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"../MLVPanel/src/feature.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVTrack = function () {\n  function MLVTrack(config) {\n    _classCallCheck(this, MLVTrack);\n\n    this.config = config;\n  }\n\n  _createClass(MLVTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      //overriden by tracks with feature sources\n    }\n  }, {\n    key: \"drawScale\",\n    value: function drawScale(ctx) {\n      //overidden in tracks with scale\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return $.extend(true, {}, this.config);\n    }\n  }, {\n    key: \"setConfigAttribute\",\n    value: function setConfigAttribute(attribute, value) {\n      this.config[attribute] = value;\n      if (attribute === \"url\") {\n        this._setFeatureSource();\n      }\n    }\n  }, {\n    key: \"getFeatureAt\",\n    value: function getFeatureAt(genomicLocation, chr, yOffset, bpPerPixel) {\n      return null;\n    }\n  }, {\n    key: \"setConfig\",\n    value: function setConfig(config) {\n      if (this.config.url !== config.url) {\n        this.config = config;\n        this._setFeatureSource();\n      } else {\n        this._setFeatureSource();\n      }\n    }\n\n    /**\r\n    * Reteives the features requested, the default is just to get the features\r\n    * from the feature source \r\n    * @param {string} chr - The chromosome \r\n    * @param {integer} start - The start of the range from which to obtain features\r\n    * @param {integer} end - The end of the range from which to obtain features \r\n    * @param {boolean} force - If true then cached features should not be used\r\n    * but fresh features retrieved\r\n    * @param {Object} data - contains bp  ber pixel and width of the canvas \r\n    */\n\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n      return this.feature_source.getFeatures(chr, bpStart, bpEnd, force, data);\n    }\n  }, {\n    key: \"addExtraControls\",\n    value: function addExtraControls(div, panel) {}\n  }], [{\n    key: \"calculateLabel\",\n    value: function calculateLabel(url) {\n      if (typeof url !== \"string\") {\n        url = url[0];\n      }\n      var arr = url.split(\"/\");\n      var label = arr[arr.length - 1];\n      arr = label.split(\".\");\n      label = arr[0];\n      return label;\n    }\n  }, {\n    key: \"getTypeFromURL\",\n    value: function getTypeFromURL(url) {\n      var config = {};\n      if (typeof url !== \"string\") {\n        return config;\n      }\n      if (url.endsWith(\"bw\")) {\n        config.type = \"bigwig\";\n        config.format = \"wig\";\n      } else if (url.endsWith(\".bed.gz\")) {\n        config.type = \"bed\";\n        config.format = \"feature\";\n      } else if (url.endsWith(\".bb\") && !config.type) {\n        config.type = \"bigbed\";\n        config.format = \"feature\";\n      } else if (url.endsWith(\".fasta\")) {\n        config.type = \"fasta\";\n        config.format = \"sequence\";\n      } else if (url.endsWith(\".bam\")) {\n        config.type = \"bam\";\n        config.format = \"alignment\";\n      }\n      return config;\n    }\n  }, {\n    key: \"parseConfig\",\n    value: function parseConfig(con) {\n      var config = $.extend(true, {}, con);\n\n      if (!config.type && config.url) {\n        var info = MLVTrack.getTypeFromURL(config.url);\n        if (info.type) {\n          config.type = info.type;\n          config.format = info.format;\n        }\n      }\n      if (config.type === \"bed\" || config.type === \"bigbed\") {\n        config.format = \"feature\";\n      }\n      if (!config.short_label && config.url) {\n        config.short_label = MLVTrack.calculateLabel(config.url);\n      }\n\n      if (!config.track_id) {\n        config.track_id = config.url;\n      }\n\n      if (config.format === \"feature\") {\n        config.displayMode = config.displayMode || \"COLLAPSED\"; // COLLAPSED | EXPANDED | SQUISHED\n        config.labelDisplayMode = \"SLANT\";\n        config.squishedCallHeight = config.squishedCallHeight || 30;\n        config.expandedCallHeight = config.expandedCallHeight || 15;\n        config.featureHeight = config.featureHeight || 12;\n      }\n\n      if (config.format === \"wig\" || config.type === \"bigwig\") {\n        if (!config.scale) {\n          config.scale = \"dynamic\";\n        }\n        if (!config.min_y) {\n          config.min_y = 0;\n        }\n        if (!config.max_y) {\n          config.max_y = 100;\n        }\n        if (!config.height) {\n          config.height = 100;\n        }\n      }\n      if (config.type === \"bam\") {\n        if (!config.featureHeight) {\n          config.featureHeight = 12;\n        }\n      }\n      if (!config.height) {\n        config.height = 100;\n      }\n\n      if (!config.color) {\n        if (config.type === \"bam\") {\n          config.color = \"#D3D3D3\";\n        } else {\n          config.color = \"black\";\n        }\n      }\n      if (!config.opacity) {\n        config.opacity = 1.0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"getTrack\",\n    value: function getTrack(config) {\n      config = MLVTrack.parseConfig(config);\n      var cl = MLVTrack.track_types[config.type];\n      if (!cl) {\n        throw new Error(\"Track type \" + config.type + \" not recognised\");\n      }\n      return new cl[\"class\"](config);\n    }\n  }]);\n\n  return MLVTrack;\n}();\n\nMLVTrack.custom_tracks = {};\n\nMLVTrack.track_types = {};\n\n//*******************js/rulerTrack.js**********************\n\n\nvar RulerTrack = function (_MLVTrack) {\n  _inherits(RulerTrack, _MLVTrack);\n\n  function RulerTrack(config) {\n    _classCallCheck(this, RulerTrack);\n\n    if (!config) {\n      config = { \"track_id\": \"ruler\" + RulerTrack.count, format: \"ruler\", short_label: \"Ruler\", type: \"ruler\" };\n    }\n\n    var _this = _possibleConstructorReturn(this, (RulerTrack.__proto__ || Object.getPrototypeOf(RulerTrack)).call(this, config));\n\n    _this.height = 30;\n    _this.config.height = 30;\n    _this.name = \"\";\n\n    _this.disableButtons = true;\n    _this.ignoreTrackMenu = true;\n    _this.order = -Number.MAX_VALUE;\n\n    RulerTrack.count++;\n    return _this;\n  }\n\n  _createClass(RulerTrack, [{\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd) {\n\n      return new Promise(function (fulfill, reject) {\n        fulfill([]);\n      });\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n\n      var fontStyle,\n          ctx = options.context,\n          range,\n          ts,\n          spacing,\n          nTick,\n          x;\n\n      fontStyle = { textAlign: 'center', font: '10px PT Sans', fillStyle: \"rgba(64, 64, 64, 1)\", strokeStyle: \"rgba(64, 64, 64, 1)\" };\n\n      range = Math.floor(1100 * options.bpPerPixel);\n      ts = RulerTrack.findSpacing(range);\n      spacing = ts.majorTick;\n\n      // Find starting point closest to the current origin\n      nTick = Math.floor(options.bpStart / spacing) - 1;\n      x = 0;\n      var y_pos = options.top + this.height;\n      //canvas.setProperties({textAlign: 'center'});\n      Graphics.setProperties(ctx, fontStyle);\n      while (x < options.pixelWidth) {\n\n        var l = Math.floor(nTick * spacing),\n            shim = 2;\n\n        x = Math.round((l - 1 - options.bpStart + 0.5) / options.bpPerPixel);\n        var chrPosition = formatNumber(l / ts.unitMultiplier, 0) + \" \" + ts.majorUnit;\n\n        if (nTick % 1 == 0) {\n          Graphics.fillText(ctx, chrPosition, x, y_pos - 15);\n        }\n\n        Graphics.strokeLine(ctx, x, y_pos - 10, x, y_pos - shim);\n\n        nTick++;\n      }\n      Graphics.strokeLine(ctx, 0, y_pos - shim, options.pixelWidth, y_pos - shim);\n\n      function formatNumber(anynum, decimal) {\n        //decimal  - the number of decimals after the digit from 0 to 3\n        //-- Returns the passed number as a string in the xxx,xxx.xx format.\n        //anynum = eval(obj.value);\n        var divider = 10;\n        switch (decimal) {\n          case 0:\n            divider = 1;\n            break;\n          case 1:\n            divider = 10;\n            break;\n          case 2:\n            divider = 100;\n            break;\n          default:\n            //for 3 decimal places\n            divider = 1000;\n        }\n\n        var workNum = Math.abs(Math.round(anynum * divider) / divider);\n\n        var workStr = \"\" + workNum;\n\n        if (workStr.indexOf(\".\") == -1) {\n          workStr += \".\";\n        }\n\n        var dStr = workStr.substr(0, workStr.indexOf(\".\"));\n        var dNum = dStr - 0;\n        var pStr = workStr.substr(workStr.indexOf(\".\"));\n\n        while (pStr.length - 1 < decimal) {\n          pStr += \"0\";\n        }\n\n        if (pStr == '.') pStr = '';\n\n        //--- Adds a comma in the thousands place.\n        if (dNum >= 1000) {\n          var dLen = dStr.length;\n          dStr = parseInt(\"\" + dNum / 1000) + \",\" + dStr.substring(dLen - 3, dLen);\n        }\n\n        //-- Adds a comma in the millions place.\n        if (dNum >= 1000000) {\n          dLen = dStr.length;\n          dStr = parseInt(\"\" + dNum / 1000000) + \",\" + dStr.substring(dLen - 7, dLen);\n        }\n        var retval = dStr + pStr;\n        //-- Put numbers in parentheses if negative.\n        if (anynum < 0) {\n          retval = \"(\" + retval + \")\";\n        }\n\n        //You could include a dollar sign in the return value.\n        //retval =  \"$\"+retval\n        return retval;\n      }\n      return y_pos;\n    }\n  }], [{\n    key: \"findSpacing\",\n    value: function findSpacing(maxValue) {\n\n      if (maxValue < 10) {\n        return new TickSpacing(1, \"\", 1);\n      }\n\n      // Now man zeroes?\n      var nZeroes = Math.floor(log10(maxValue));\n      var majorUnit = \"\";\n      var unitMultiplier = 1;\n      if (nZeroes > 9) {\n        majorUnit = \"gb\";\n        unitMultiplier = 1000000000;\n      }\n      if (nZeroes > 6) {\n        majorUnit = \"mb\";\n        unitMultiplier = 1000000;\n      } else if (nZeroes > 3) {\n        majorUnit = \"kb\";\n        unitMultiplier = 1000;\n      }\n\n      var nMajorTicks = maxValue / Math.pow(10, nZeroes - 1);\n      if (nMajorTicks < 25) {\n        return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);\n      } else {\n        return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);\n      }\n\n      function log10(x) {\n        var dn = Math.log(10);\n        return Math.log(x) / dn;\n      }\n    }\n  }]);\n\n  return RulerTrack;\n}(MLVTrack);\n\nRulerTrack.count = 0;\n\nMLVTrack.track_types[\"ruler\"] = {\n  \"class\": RulerTrack,\n  name: \"Ruler\"\n\n};\n\nvar TickSpacing = function TickSpacing(majorTick, majorUnit, unitMultiplier) {\n  _classCallCheck(this, TickSpacing);\n\n  this.majorTick = majorTick;\n  this.majorUnit = majorUnit;\n  this.unitMultiplier = unitMultiplier;\n};\n\nvar MLVBedTrack = function (_MLVTrack2) {\n  _inherits(MLVBedTrack, _MLVTrack2);\n\n  function MLVBedTrack(config) {\n    _classCallCheck(this, MLVBedTrack);\n\n    var _this2 = _possibleConstructorReturn(this, (MLVBedTrack.__proto__ || Object.getPrototypeOf(MLVBedTrack)).call(this, config));\n\n    _this2._setFeatureSource();\n    _this2.filter_function = null;\n    _this2.color_function = null;\n\n    return _this2;\n  }\n\n  _createClass(MLVBedTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _feature.TabixBedFeatureSource(this.config);\n    }\n  }, {\n    key: \"setFilterFunction\",\n    value: function setFilterFunction(func) {\n      this.filter_function = func;\n    }\n  }, {\n    key: \"setColorFunction\",\n    value: function setColorFunction(func) {\n      this.color_function = func;\n    }\n  }, {\n    key: \"getCurrentFeatures\",\n    value: function getCurrentFeatures(chr, start, end) {\n      return this.feature_source.featureCache.queryFeatures(chr, start, end);\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n      var max_y_val = 0;\n      var track = this,\n          py,\n          featureList = options.features,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          pixelHeight = options.pixelHeight,\n          offset = 0,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1;\n      var top = 0;\n      if (options.top) {\n        top = options.top;\n      }\n      this.top = top;\n      var conf = this.config;\n      var windowX = 0;\n      var windowX1 = windowX + pixelWidth;\n\n      this.config.squishedCallHeight = this.config.featureHeight + 10;\n      this.config.expandedCallHeight = this.config.featureHeight / 2 + 2;\n      var ki = null;\n      if (featureList.length > 50000) {\n        ki = Math.round(featureList.length / 50000) + 1;\n      }\n\n      if (featureList) {\n        var opacity = this.config.opacity ? this.config.opacity : 1;\n        ctx.globalAlpha = opacity;\n\n        for (var gene, i = 0, len = featureList.length; i < len; i++) {\n          if (ki && i % ki !== 0) {\n            continue;\n          }\n          gene = featureList[i];\n          if (this.filter_function && !this.filter_function(gene)) {\n            gene.display = false;\n            continue;\n          }\n          gene.display = true;\n          if (gene.end < bpStart) continue;\n          if (gene.start > bpEnd) break;\n          var coord = this.calculateFeatureCoordinates(gene, bpStart, bpPerPixel);\n          var h = conf.featureHeight;\n          if (conf.displayMode === \"SQUISHED\" && gene.row != undefined) {\n            h = conf.featureHeight / 2;\n            py = conf.expandedCallHeight * gene.row + 2;\n          } else if (conf.displayMode === \"EXPANDED\" && gene.row != undefined) {\n            py = conf.squishedCallHeight * gene.row + 5;\n          } else {\n            // collapsed\n            py = 5;\n          }\n          py += top;\n          if (py + h > max_y_val) {\n            max_y_val = py + h;\n          }\n          coord.py = py;\n          coord.h = h;\n          var info = { bpPerPixel: bpPerPixel, bpStart: bpStart, pixelWidth: pixelWidth };\n          if (this.color_function) {\n            gene.color = this.color_function(gene);\n          }\n\n          this.renderFeature(gene, coord, ctx, info);\n          this.renderFeatureLabel(ctx, gene, coord.px, coord.px1, py, windowX, windowX1);\n        }\n        ctx.globalAlpha = 1;\n      } else {\n        console.log(\"No feature list\");\n      }\n      this.bottom = max_y_val;\n      if (this.config.displayMode === \"COLLAPSED\") {\n        max_y_val += 25;\n      }\n      return max_y_val;\n    }\n\n    /**\r\n       * @param ctx       the canvas 2d context\r\n       * @param feature\r\n       * @param featureX  feature start x-coordinate\r\n       * @param featureX1 feature end x-coordinate\r\n       * @param featureY  feature y-coordinate\r\n       * @param windowX   visible window start x-coordinate\r\n       * @param windowX1  visible window end x-coordinate\r\n       */\n\n  }, {\n    key: \"renderFeatureLabel\",\n    value: function renderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1) {\n      var info = this.config;\n      var geneColor, geneFontStyle, transform, boxX, boxX1, // label should be centered between these two x-coordinates\n      labelX, labelY, textFitsInBox;\n\n      // feature outside of viewable window\n      if (featureX1 < windowX || featureX > windowX1) {\n        boxX = featureX;\n        boxX1 = featureX1;\n      } else {\n        // center label within visible portion of the feature\n        boxX = Math.max(featureX, windowX);\n        boxX1 = Math.min(featureX1, windowX1);\n      }\n\n      var text = feature.name;\n      if (this.label_function) {\n        text = this.label_function(feature);\n      }\n\n      //if (igv.browser.selection && \"genes\" === this.config.type && feature.name !== undefined) {\n      // TODO -- for gtex, figure out a better way to do this\n      //geneColor = igv.browser.selection.colorForGene(feature.name);\n      //  }\n\n      textFitsInBox = boxX1 - boxX > ctx.measureText(text).width;\n      //geneColor=\"black\";\n\n      if ((textFitsInBox || geneColor) && info.displayMode != \"SQUISHED\" && text) {\n        geneFontStyle = {\n          font: '10px PT Sans',\n          textAlign: 'center',\n          fillStyle: geneColor || info.color,\n          strokeStyle: geneColor || info.color\n        };\n\n        if (info.displayMode === \"COLLAPSED\" && info.labelDisplayMode === \"SLANT\") {\n          transform = { rotate: { angle: 45 } };\n          delete geneFontStyle.textAlign;\n        }\n\n        labelX = boxX + (boxX1 - boxX) / 2;\n        labelY = getFeatureLabelY(featureY, transform);\n\n        Graphics.fillText(ctx, text, labelX, labelY, geneFontStyle, transform);\n      }\n      function getFeatureLabelY(featureY, transform) {\n        return transform ? featureY + info.featureHeight + 14 : featureY + info.featureHeight + 7;\n      }\n    }\n  }, {\n    key: \"calculateFeatureCoordinates\",\n    value: function calculateFeatureCoordinates(feature, bpStart, xScale) {\n      var px = Math.round((feature.start - bpStart) / xScale),\n          px1 = Math.round((feature.end - bpStart) / xScale),\n          pw = px1 - px;\n\n      if (pw < 3) {\n        pw = 3;\n        px -= 1;\n      }\n\n      return {\n        px: px,\n        px1: px1,\n        pw: pw\n      };\n    }\n\n    /**\r\n        * Renders the feature to the canvas\r\n        * @param feature - The feature itself\r\n        * @param coord An object containing information on where to draw the feature\r\n        * px1,px2 the left and right pixels - pw - the width\r\n        * py the top, h - the height\r\n        * @param ctx - The context to draw the feature\r\n        * @param info - An object containing information about the genomic location\r\n        * bpStart.bpPerPixel and pixelWidth\r\n        * \r\n        */\n\n  }, {\n    key: \"renderFeature\",\n    value: function renderFeature(feature, coord, ctx, info) {\n      var e,\n          x,\n          cy,\n          direction,\n          exon,\n          ePx,\n          ePx1,\n          ePxU,\n          ePw,\n          py2,\n          h2,\n          step = 20,\n          color = this.config.color;\n      if (feature.color) {\n        color = feature.color;\n      }\n\n      ctx.fillStyle = color;\n      ctx.strokeStyle = color;\n\n      cy = coord.py + coord.h / 2;\n      h2 = coord.h / 2;\n      py2 = cy - h2 / 2;\n\n      var exonCount = feature.exons ? feature.exons.length : 0;\n      if (exonCount == 0) {\n        // single-exon transcript\n        ctx.fillRect(coord.px, coord.py, coord.pw, coord.h);\n      } else {\n        // multi-exon transcript\n        coord.px = Math.max(coord.px, 0);\n        coord.px1 = Math.min(coord.px1, info.pixelWidth);\n        Graphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns\n        direction = feature.strand == '+' ? 1 : -1;\n\n        for (x = coord.px + step / 2; x < coord.px1; x += step) {\n\n          // draw arrowheads along central line indicating transcribed orientation\n          Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n          Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n        }\n        for (e = 0; e < exonCount; e++) {\n          // draw the exons\n          exon = feature.exons[e];\n          ePx = Math.round((exon.start - info.bpStart) / info.bpPerPixel);\n          ePx1 = Math.round((exon.end - info.bpStart) / info.bpPerPixel);\n          ePw = Math.max(1, ePx1 - ePx);\n\n          if (exon.utr) {\n            ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR\n          } else {\n            if (exon.cdStart) {\n              ePxU = Math.round((exon.cdStart - info.bpStart) / info.bpPerPixel);\n              ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR\n              ePw -= ePxU - ePx;\n              ePx = ePxU;\n            }\n            if (exon.cdEnd) {\n              ePxU = Math.round((exon.cdEnd - info.bpStart) / info.bpPerPixel);\n              ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR\n              ePw -= ePx1 - ePxU;\n              ePx1 = ePxU;\n            }\n\n            ctx.fillRect(ePx, coord.py, ePw, coord.h);\n\n            // Arrows\n            if (ePw > step + 5) {\n              ctx.fillStyle = \"white\";\n              ctx.strokeStyle = \"white\";\n              for (x = ePx + step / 2; x < ePx1; x += step) {\n                // draw arrowheads along central line indicating transcribed orientation\n                Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n                Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n              }\n              ctx.fillStyle = color;\n              ctx.strokeStyle = color;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getFeatureAt\",\n    value: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\n      var yOffset = coord.y - this.top;\n      // We use the featureCache property rather than method to avoid async load.  If the\n      // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.\n      if (this.feature_source.featureCache) {\n\n        var tolerance = 2 * bpPerPixel,\n            // We need some tolerance around genomicLocation, start with +/- 2 pixels\n        featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance),\n            row;\n\n        if (this.config.displayMode != \"COLLAPSED\") {\n          row = Math.floor(this.config.displayMode === \"SQUISHED\" ? yOffset / this.config.expandedCallHeight : yOffset / this.config.squishedCallHeight);\n        }\n\n        if (featureList && featureList.length > 0) {\n\n          var popupData = [];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var feature = _step.value;\n\n              if (feature.end >= genomicLocation - tolerance && feature.start <= genomicLocation + tolerance) {\n\n                // If row number is specified use it\n                if ((row === undefined || feature.row === undefined || row === feature.row) && feature.display) {\n                  return feature;\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return MLVBedTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"bed\"] = {\n  \"class\": MLVBedTrack,\n  name: \"bed(tabix)\"\n};\n\nvar MLVBigBedTrack = function (_MLVBedTrack) {\n  _inherits(MLVBigBedTrack, _MLVBedTrack);\n\n  function MLVBigBedTrack(config) {\n    _classCallCheck(this, MLVBigBedTrack);\n\n    return _possibleConstructorReturn(this, (MLVBigBedTrack.__proto__ || Object.getPrototypeOf(MLVBigBedTrack)).call(this, config));\n  }\n\n  _createClass(MLVBigBedTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _feature.BigBedFeatureSource(this.config);\n    }\n  }]);\n\n  return MLVBigBedTrack;\n}(MLVBedTrack);\n\nMLVTrack.track_types[\"bigbed\"] = {\n  \"class\": MLVBigBedTrack,\n  \"name\": \"BigBed\"\n\n};\n\nvar MLVWigTrack = function (_MLVTrack3) {\n  _inherits(MLVWigTrack, _MLVTrack3);\n\n  function MLVWigTrack(config) {\n    _classCallCheck(this, MLVWigTrack);\n\n    config.format = \"wig\";\n\n    var _this4 = _possibleConstructorReturn(this, (MLVWigTrack.__proto__ || Object.getPrototypeOf(MLVWigTrack)).call(this, config));\n\n    _this4._setFeatureSource();\n    return _this4;\n  }\n\n  _createClass(MLVWigTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _bigwig.BWSource(this.config);\n    }\n  }, {\n    key: \"drawScale\",\n    value: function drawScale(pixel_height, ctx) {\n      if (this.config.scale_link_to && this.config.group) {\n        return;\n      }\n      var bot = pixel_height;\n      var top = 0;\n\n      if (this.config.discrete) {\n        top = this.top;\n        bot = this.bottom;\n      }\n      var range = this.max_y - this.min_y;\n\n      ctx.beginPath();\n      ctx.moveTo(0, top);\n      ctx.lineTo(0, bot);\n      ctx.moveTo(0, top);\n      ctx.lineTo(20, top);\n      ctx.moveTo(0, bot);\n      ctx.lineTo(20, bot);\n      ctx.font = \"12px Arial\";\n      ctx.stroke();\n      ctx.textBaseline = \"top\";\n      ctx.fillStyle = \"black\";\n      ctx.fillText(this.max_y.toFixed(2), 20, top);\n      ctx.textBaseline = \"alphabetic\";\n      ctx.fillText(this.min_y, 20, bot);\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n      var self = this,\n          features = options.features,\n          color = self.config.color,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          pixelHeight = options.pixelHeight,\n          y_offset = this.config.discrete ? options.top : 0,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n          featureValueMinimum = void 0,\n          featureValueMaximum = void 0,\n          featureValueRange = void 0,\n          $dataRangeTrackLabel = void 0,\n          str = void 0,\n          min = void 0,\n          max = void 0;\n      if (this.config.group) {\n        pixelHeight = options.height;\n      } else if (this.config.discrete) {\n        pixelHeight = this.config.height;\n      }\n\n      if (!color) {\n        color = \"black\";\n      }\n      self.prev_coords = { x: 0, y: 0 };\n\n      if (features) {\n        if (self.scale_link_to) {\n          var t = self.scale_link_to.config;\n          if (t) {\n            self.config.scale = t.scale;\n            self.max_y = self.scale_link_to.max_y;\n            self.min_y = self.scale_link_to.min_y;\n          }\n        } else if (self.set_scale) {\n          self.min_y = self.set_scale.min;\n          self.max_y = self.set_scale.max;\n        } else if (self.max_y === undefined && self.config.scale === \"automatic\" || self.config.scale === \"dynamic\") {\n          var s = autoscale(features);\n          self.min_y = s.min;\n          self.max_y = s.max;\n        } else if (self.config.scale === \"fixed\") {\n          self.min_y = self.config.min_y;\n          self.max_y = self.config.max_y;\n        }\n\n        featureValueRange = self.max_y - self.min_y;\n\n        //$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\n        //\n        //min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\n        //max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\n        //str = '[' + min + ' - ' + max + ']';\n        //\n        //$dataRangeTrackLabel.text(str);\n        var prev_x = 0;\n        var prev_y = 0;\n        ctx.globalAlpha = this.config.opacity ? this.config.opacity : 1;\n\n        if (self.is_line) {\n          var y = (1.0 - self.config.value / featureValueRange) * pixelHeight;\n          Graphics.strokeLine(ctx, 0, y, pixelWidth, y, { \"strokeStyle\": self.config.color, \"lineWidth\": self.config.width ? self.config.width : 1 });\n        } else {\n          features.forEach(renderFeature);\n        }\n\n        ctx.globalAlpha = 1;\n        if (self.config.threshold) {\n          var _y = y_offset + (1.0 - self.config.threshold / featureValueRange) * pixelHeight;\n          Graphics.strokeLine(ctx, 0, _y, pixelWidth, _y, { \"strokeStyle\": \"black\", \"lineWidth\": 1 });\n        }\n      }\n\n      function renderFeature(feature, index, featureList) {\n\n        var yUnitless, heightUnitLess, x, y, width, height, rectEnd, rectBaseline;\n\n        if (feature.end < bpStart) return;\n        if (feature.start > bpEnd) return;\n        if (feature.end === feature.start) {\n          feature.start -= 1;\n        }\n\n        x = Math.floor((feature.start - bpStart) / bpPerPixel);\n\n        rectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\n        width = Math.max(0, rectEnd - x);\n\n        //height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\n        //rectBaseline = pixelHeight - height;\n        //canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\n\n        if (signsDiffer(self.min_y, self.max_y)) {\n\n          if (feature.value < 0) {\n            yUnitless = self.max_y / featureValueRange;\n            heightUnitLess = -feature.value / featureValueRange;\n          } else {\n            yUnitless = (self.max_y - feature.value) / featureValueRange;\n            heightUnitLess = feature.value / featureValueRange;\n          }\n        } else if (self.min_y < 0) {\n          yUnitless = 0;\n          heightUnitLess = -feature.value / featureValueRange;\n        } else {\n          yUnitless = 1.0 - (feature.value - self.min_y) / featureValueRange;\n          heightUnitLess = (feature.value + self.min_y) / featureValueRange;\n        }\n\n        y = yUnitless * pixelHeight + y_offset;\n        y = y < y_offset ? y_offset : y;\n        height = heightUnitLess * pixelHeight;\n        height = height > pixelHeight ? pixelHeight : height;\n\n        //canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\n        if (self.config.display === 'line') {\n          if (self.prev_coords.x) {\n            Graphics.strokeLine(ctx, x, y, self.prev_coords.x, self.prev_coords.y, { \"strokeStyle\": color, \"lineWidth\": 3 });\n          }\n          self.prev_coords.x = x;\n          self.prev_coords.y = y;\n        } else {\n          Graphics.fillRect(ctx, x, y, width, height, { fillStyle: color });\n        }\n      }\n      function autoscale(features) {\n        var min = 0,\n            max = -Number.MAX_VALUE;\n        features.forEach(function (f) {\n          min = Math.min(min, f.value);\n          max = Math.max(max, f.value);\n        });\n        return { min: min, max: max };\n      }\n\n      function signsDiffer(a, b) {\n        return a > 0 && b < 0 || a < 0 && b > 0;\n      }\n      this.top = y_offset;\n      this.bottom = y_offset + pixelHeight;\n      if (this.config.discrete) {\n        return this.bottom;\n      } else {\n        this.top = 0;\n        this.bottom = 0;\n      }\n    }\n  }]);\n\n  return MLVWigTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"bigwig\"] = {\n  \"class\": MLVWigTrack,\n  name: \"BigWig\"\n};\n\nvar LineTrack = function (_MLVWigTrack) {\n  _inherits(LineTrack, _MLVWigTrack);\n\n  function LineTrack(config) {\n    _classCallCheck(this, LineTrack);\n\n    var _this5 = _possibleConstructorReturn(this, (LineTrack.__proto__ || Object.getPrototypeOf(LineTrack)).call(this, config));\n\n    _this5.is_line = true;\n    return _this5;\n  }\n\n  _createClass(LineTrack, [{\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd) {\n      return new Promise(function (fulfill, reject) {\n        fulfill([]);\n      });\n    }\n  }]);\n\n  return LineTrack;\n}(MLVWigTrack);\n\nMLVTrack.track_types[\"line\"] = {\n  \"class\": LineTrack,\n  name: \"Line Track\"\n};\n\nvar SequenceTrack = function (_MLVTrack4) {\n  _inherits(SequenceTrack, _MLVTrack4);\n\n  function SequenceTrack(config) {\n    _classCallCheck(this, SequenceTrack);\n\n    var _this6 = _possibleConstructorReturn(this, (SequenceTrack.__proto__ || Object.getPrototypeOf(SequenceTrack)).call(this, config));\n\n    _this6._setFeatureSource(config);\n    _this6.sequenceType = config.sequenceType || \"dna\";\n    _this6.height = 15;\n    return _this6;\n  }\n\n  _createClass(SequenceTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource(config) {\n      this.feature_source = new _feature.FastaSequence(config.url);\n    }\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n      var self = this;\n      return new Promise(function (fulfill, reject) {\n        if (data.bpPerPixel > 1 /*igv.browser.trackViewportWidthBP() > 30000*/) {\n            fulfill(null);\n          } else {\n          self.feature_source.getSequence(chr, bpStart, bpEnd).then(fulfill).catch(reject);\n        }\n      });\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n\n      var sequence = options.features,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n          len,\n          w,\n          y,\n          pos,\n          offset,\n          b,\n          p0,\n          p1,\n          pc,\n          c;\n\n      var y_pos1 = options.top;\n      var y_pos2 = y_pos1 + 5;\n\n      if (sequence) {\n\n        len = sequence.length;\n        w = 1 / bpPerPixel;\n\n        y = y_pos1 + this.height / 2;\n        for (pos = bpStart; pos <= bpEnd; pos++) {\n\n          offset = pos - bpStart;\n          if (offset < len) {\n            //                            var b = sequence.charAt(offset);\n            b = sequence[offset];\n            p0 = Math.floor(offset * w);\n            p1 = Math.floor((offset + 1) * w);\n            pc = Math.round((p0 + p1) / 2);\n\n            if (this.color) {\n              c = this.color;\n            } else if (\"dna\" === this.sequenceType) {\n              c = Graphics.nucleotideColors[b];\n            } else {\n              c = \"rgb(0, 0, 150)\";\n            }\n\n            if (!c) c = \"gray\";\n\n            if (bpPerPixel > 0.15) {\n\n              Graphics.fillRect(ctx, p0, y_pos1, p1 - p0, 10, { fillStyle: c });\n            } else {\n\n              Graphics.strokeText(ctx, b, pc, y, {\n                strokeStyle: c,\n                font: 'normal 10px Arial',\n                textAlign: 'center'\n              });\n            }\n          }\n        }\n      }\n      return y_pos1 + 10;\n    }\n  }]);\n\n  return SequenceTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"fasta\"] = {\n  \"class\": SequenceTrack,\n  name: \"Fasta\"\n\n  //*******js/ifv-canvas.js***********************\n\n\n};\nvar Graphics = function () {\n  function Graphics() {\n    _classCallCheck(this, Graphics);\n  }\n\n  _createClass(Graphics, null, [{\n    key: \"setProperties\",\n    value: function setProperties(ctx, properties) {\n\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          var value = properties[key];\n          ctx[key] = value;\n        }\n      }\n    }\n  }, {\n    key: \"strokeLine\",\n    value: function strokeLine(ctx, x1, y1, x2, y2, properties) {\n\n      x1 = Math.floor(x1) + 0.5;\n      y1 = Math.floor(y1) + 0.5;\n      x2 = Math.floor(x2) + 0.5;\n      y2 = Math.floor(y2) + 0.5;\n\n      //log(\"stroke line, prop: \" + properties);\n\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"fillRect\",\n    value: function fillRect(ctx, x, y, w, h, properties) {\n\n      var c;\n      x = Math.round(x);\n      y = Math.round(y);\n\n      if (properties) {\n        ctx.save();\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.fillRect(x, y, w, h);\n\n      if (properties) ctx.restore();\n    }\n  }, {\n    key: \"fillPolygon\",\n    value: function fillPolygon(ctx, x, y, properties) {\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n      Graphics.doPath(ctx, x, y);\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: \"strokePolygon\",\n    value: function strokePolygon(ctx, x, y, properties) {\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n      Graphics.doPath(ctx, x, y);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"fillText\",\n    value: function fillText(ctx, text, x, y, properties, transforms) {\n\n      if (properties) {\n        ctx.save();\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.save();\n\n      ctx.translate(x, y);\n      if (transforms) {\n\n        for (var transform in transforms) {\n          var value = transforms[transform];\n\n          // TODO: Add error checking for robustness\n          if (transform == 'translate') {\n            ctx.translate(value['x'], value['y']);\n          }\n          if (transform == 'rotate') {\n            ctx.rotate(value['angle'] * Math.PI / 180);\n          }\n        }\n      }\n\n      ctx.fillText(text, 0, 0);\n      ctx.restore();\n\n      if (properties) ctx.restore();\n    }\n  }, {\n    key: \"strokeText\",\n    value: function strokeText(ctx, text, x, y, properties, transforms) {\n\n      ctx.save();\n      if (properties) {\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.translate(x, y);\n      if (transforms) {\n\n        for (var transform in transforms) {\n          var value = transforms[transform];\n\n          // TODO: Add error checking for robustness\n          if (transform == 'translate') {\n            ctx.translate(value['x'], value['y']);\n          }\n          if (transform == 'rotate') {\n            ctx.rotate(value['angle'] * Math.PI / 180);\n          }\n        }\n      }\n\n      ctx.strokeText(text, 0, 0);\n      ctx.restore();\n    }\n  }, {\n    key: \"strokeCircle\",\n    value: function strokeCircle(ctx, x, y, radius) {\n\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }, {\n    key: \"fillCircle\",\n    value: function fillCircle(ctx, x, y, radius) {\n\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }, {\n    key: \"drawArrowhead\",\n    value: function drawArrowhead(ctx, x, y, size, lineWidth) {\n\n      ctx.save();\n      if (!size) {\n        size = 5;\n      }\n      if (lineWidth) {\n        ctx.lineWidth = lineWidth;\n      }\n      ctx.beginPath();\n      ctx.moveTo(x, y - size / 2);\n      ctx.lineTo(x, y + size / 2);\n      ctx.lineTo(x + size, y);\n      ctx.lineTo(x, y - size / 2);\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: \"dashedLine\",\n    value: function dashedLine(ctx, x1, y1, x2, y2, dashLen, properties) {\n      ctx.save();\n      x1 = Math.round(x1);\n      y1 = Math.round(y1);\n      x2 = Math.round(x2);\n      y2 = Math.round(y2);\n      dashLen = Math.round(dashLen);\n      log(\"dashedLine\");\n      if (properties) Graphics.setProperties(ctx, properties);\n\n      if (dashLen == undefined) dashLen = 2;\n      ctx.moveTo(x1, y1);\n\n      var dX = x2 - x1;\n      var dY = y2 - y1;\n      var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n      var dashX = dX / dashes;\n      var dashY = dY / dashes;\n\n      var q = 0;\n      while (q++ < dashes) {\n        x1 += dashX;\n        y1 += dashY;\n        ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\n      }\n      ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\n\n      ctx.restore();\n    }\n  }, {\n    key: \"doPath\",\n    value: function doPath(ctx, x, y) {\n\n      var i,\n          len = x.length;\n      for (i = 0; i < len; i++) {\n        x[i] = Math.round(x[i]);\n        y[i] = Math.round(y[i]);\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(x[0], y[0]);\n      for (i = 1; i < len; i++) {\n        ctx.lineTo(x[i], y[i]);\n      }\n      ctx.closePath();\n    }\n  }]);\n\n  return Graphics;\n}();\n\nGraphics.nucleotideColors = {\n  \"A\": \"green\",\n  \"T\": \"red\",\n  \"G\": \"black\",\n  \"C\": \"blue\",\n  \"a\": \"green\",\n  \"t\": \"red\",\n  \"c\": \"black\",\n  \"g\": \"blue\"\n\n};\n\nexports.MLVTrack = MLVTrack;\nexports.MLVWigTrack = MLVWigTrack;\nexports.MLVBedTrack = MLVBedTrack;\nexports.RulerTrack = RulerTrack;\nexports.MLVBigBedTrack = MLVBigBedTrack;\nexports.Graphics = Graphics;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3RyYWNrcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzPzc2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbmltcG9ydCB7QldTb3VyY2V9IGZyb20gXCIuL2JpZ3dpZy5qc1wiO1xyXG5pbXBvcnQge0ZlYXR1cmVTb3VyY2UsRmFzdGFTZXF1ZW5jZSxCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4vZmVhdHVyZS5qc1wiO1xyXG5cclxuXHJcbmNsYXNzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcblx0fVxyXG5cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0Ly9vdmVycmlkZW4gYnkgdHJhY2tzIHdpdGggZmVhdHVyZSBzb3VyY2VzXHJcblx0fVxyXG5cclxuXHRkcmF3U2NhbGUoY3R4KXtcclxuXHRcdC8vb3ZlcmlkZGVuIGluIHRyYWNrcyB3aXRoIHNjYWxlXHJcblx0fVxyXG5cclxuXHRnZXRDb25maWcoKXtcclxuXHRcdHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcblx0c2V0Q29uZmlnQXR0cmlidXRlKGF0dHJpYnV0ZSx2YWx1ZSl7XHJcblx0XHR0aGlzLmNvbmZpZ1thdHRyaWJ1dGVdPXZhbHVlO1xyXG4gICAgXHRpZiAoYXR0cmlidXRlPT09XCJ1cmxcIil7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcbiAgICBnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIseU9mZnNldCwgYnBQZXJQaXhlbCl7XHJcbiAgICBcdHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbmZpZyhjb25maWcpe1xyXG4gICAgXHRpZiAodGhpcy5jb25maWcudXJsICE9PSBjb25maWcudXJsKXtcclxuICAgIFx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2V7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG4gICAgIC8qKlxyXG5cdCogUmV0ZWl2ZXMgdGhlIGZlYXR1cmVzIHJlcXVlc3RlZCwgdGhlIGRlZmF1bHQgaXMganVzdCB0byBnZXQgdGhlIGZlYXR1cmVzXHJcblx0KiBmcm9tIHRoZSBmZWF0dXJlIHNvdXJjZSBcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBjaHIgLSBUaGUgY2hyb21vc29tZSBcclxuXHQqIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlIGZyb20gd2hpY2ggdG8gb2J0YWluIGZlYXR1cmVzXHJcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGVuZCAtIFRoZSBlbmQgb2YgdGhlIHJhbmdlIGZyb20gd2hpY2ggdG8gb2J0YWluIGZlYXR1cmVzIFxyXG5cdCogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIElmIHRydWUgdGhlbiBjYWNoZWQgZmVhdHVyZXMgc2hvdWxkIG5vdCBiZSB1c2VkXHJcblx0KiBidXQgZnJlc2ggZmVhdHVyZXMgcmV0cmlldmVkXHJcblx0KiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGNvbnRhaW5zIGJwICBiZXIgcGl4ZWwgYW5kIHdpZHRoIG9mIHRoZSBjYW52YXMgXHJcblx0Ki9cclxuXHRnZXRGZWF0dXJlcyAoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5mZWF0dXJlX3NvdXJjZS5nZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmb3JjZSxkYXRhKTtcclxuXHR9XHJcblxyXG5cclxuXHRzdGF0aWMgY2FsY3VsYXRlTGFiZWwodXJsKXtcclxuXHRcdGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0dXJsID0gdXJsWzBdO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGFyciA9dXJsLnNwbGl0KFwiL1wiKTtcclxuXHRcdGxldCBsYWJlbD0gYXJyW2Fyci5sZW5ndGgtMV07XHJcblx0XHRhcnI9IGxhYmVsLnNwbGl0KFwiLlwiKTtcclxuXHRcdGxhYmVsID0gYXJyWzBdO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH1cclxuXHJcblx0YWRkRXh0cmFDb250cm9scyhkaXYscGFuZWwpe1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldFR5cGVGcm9tVVJMKHVybCl7XHJcblx0XHRsZXQgY29uZmlnPXt9XHJcblx0XHRpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIil7XHJcblx0XHRcdHJldHVybiBjb25maWc7XHJcblx0XHR9XHJcblx0XHRcdGlmICh1cmwuZW5kc1dpdGgoXCJid1wiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiaWd3aWdcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwid2lnXCI7XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodXJsLmVuZHNXaXRoKFwiLmJlZC5nelwiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiZWRcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iYlwiKSAmJiAhKGNvbmZpZy50eXBlKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiaWdiZWRcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5mYXN0YVwiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJmYXN0YVwiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJzZXF1ZW5jZVwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iYW1cIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmFtXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImFsaWdubWVudFwiO1xyXG5cdFx0XHR9XHJcblx0XHRyZXR1cm4gY29uZmlnO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBwYXJzZUNvbmZpZyhjb24pe1xyXG5cdFx0bGV0IGNvbmZpZyA9ICQuZXh0ZW5kKHRydWUsIHt9LGNvbik7XHJcblx0XHRcclxuXHRcdGlmICghKGNvbmZpZy50eXBlKSAmJiBjb25maWcudXJsKXtcclxuXHRcdFx0bGV0IGluZm8gPSBNTFZUcmFjay5nZXRUeXBlRnJvbVVSTChjb25maWcudXJsKTtcclxuXHRcdFx0aWYgKGluZm8udHlwZSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9aW5mby50eXBlO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9aW5mby5mb3JtYXQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChjb25maWcudHlwZT09PVwiYmVkXCIgfHwgY29uZmlnLnR5cGU9PT1cImJpZ2JlZFwiKXtcclxuXHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuXHRcdH1cclxuXHRcdGlmICghY29uZmlnLnNob3J0X2xhYmVsICYmIGNvbmZpZy51cmwpe1xyXG5cdFx0XHRjb25maWcuc2hvcnRfbGFiZWw9TUxWVHJhY2suY2FsY3VsYXRlTGFiZWwoY29uZmlnLnVybCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmICghY29uZmlnLnRyYWNrX2lkKXtcclxuXHRcdFx0Y29uZmlnLnRyYWNrX2lkPWNvbmZpZy51cmw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5mb3JtYXQ9PT1cImZlYXR1cmVcIil7XHJcblx0XHRcdGNvbmZpZy5kaXNwbGF5TW9kZSA9IGNvbmZpZy5kaXNwbGF5TW9kZSB8fCBcIkNPTExBUFNFRFwiOyAgICAvLyBDT0xMQVBTRUQgfCBFWFBBTkRFRCB8IFNRVUlTSEVEXHJcbiAgICAgICAgXHRjb25maWcubGFiZWxEaXNwbGF5TW9kZSA9IFwiU0xBTlRcIjtcclxuICAgICAgICBcdGNvbmZpZy5zcXVpc2hlZENhbGxIZWlnaHQgPSBjb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0IHx8IDMwO1xyXG4gICAgICAgIFx0Y29uZmlnLmV4cGFuZGVkQ2FsbEhlaWdodCA9IGNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgfHwgMTU7XHJcbiAgICAgICAgXHRjb25maWcuZmVhdHVyZUhlaWdodD1jb25maWcuZmVhdHVyZUhlaWdodCB8fCAxMjtcclxuXHRcdFxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuZm9ybWF0PT09XCJ3aWdcIiB8fCBjb25maWcudHlwZT09PVwiYmlnd2lnXCIpe1xyXG5cdFx0XHRpZiAoIWNvbmZpZy5zY2FsZSl7XHJcblx0XHRcdFx0Y29uZmlnLnNjYWxlPVwiZHluYW1pY1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghY29uZmlnLm1pbl95KXtcclxuXHRcdFx0XHRjb25maWcubWluX3k9MDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5tYXhfeSl7XHJcblx0XHRcdFx0Y29uZmlnLm1heF95PTEwMDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5oZWlnaHQpe1xyXG5cdFx0XHRcdGNvbmZpZy5oZWlnaHQ9MTAwO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoY29uZmlnLnR5cGU9PT1cImJhbVwiKXtcclxuXHRcdFx0aWYgKCFjb25maWcuZmVhdHVyZUhlaWdodCl7XHJcblx0XHRcdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9MTI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICghY29uZmlnLmhlaWdodCl7XHJcblx0XHRcdGNvbmZpZy5oZWlnaHQ9MTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29uZmlnLmNvbG9yKXtcclxuXHRcdFx0aWYgKGNvbmZpZy50eXBlPT09XCJiYW1cIil7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiI0QzRDNEM1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiYmxhY2tcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFjb25maWcub3BhY2l0eSl7XHJcblx0XHRcdGNvbmZpZy5vcGFjaXR5PTEuMDtcclxuXHRcdH1cclxuICAgICAgICAgICBcclxuXHRcdHJldHVybiBjb25maWc7XHJcblx0fVxyXG5cclxuXHJcblx0XHJcblx0c3RhdGljIGdldFRyYWNrKGNvbmZpZyl7XHJcblx0XHRjb25maWc9TUxWVHJhY2sucGFyc2VDb25maWcoY29uZmlnKTtcclxuXHRcdGxldCBjbD0gTUxWVHJhY2sudHJhY2tfdHlwZXNbY29uZmlnLnR5cGVdO1xyXG5cdFx0aWYgKCFjbCl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyYWNrIHR5cGUgXCIrIGNvbmZpZy50eXBlK1wiIG5vdCByZWNvZ25pc2VkXCIpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IGNsW1wiY2xhc3NcIl0oY29uZmlnKTtcclxuXHJcblx0fVxyXG5cdFx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3M9e307XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlcz17fVxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vKioqKioqKioqKioqKioqKioqKmpzL3J1bGVyVHJhY2suanMqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgUnVsZXJUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17XCJ0cmFja19pZFwiOlwicnVsZXJcIitSdWxlclRyYWNrLmNvdW50LGZvcm1hdDpcInJ1bGVyXCIsc2hvcnRfbGFiZWw6XCJSdWxlclwiLHR5cGU6XCJydWxlclwifTtcclxuXHRcdH1cclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAzMDtcclxuICAgICAgICB0aGlzLmNvbmZpZy5oZWlnaHQ9MzA7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVHJhY2tNZW51ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgIFxyXG4gICAgICAgIFJ1bGVyVHJhY2suY291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bGZpbGwoW10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBmb250U3R5bGUsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgIHRzLFxyXG4gICAgICAgICAgICBzcGFjaW5nLFxyXG4gICAgICAgICAgICBuVGljayxcclxuICAgICAgICAgICAgeDtcclxuXHJcbiAgICAgICAgZm9udFN0eWxlID0geyB0ZXh0QWxpZ246ICdjZW50ZXInLCBmb250OiAnMTBweCBQVCBTYW5zJywgZmlsbFN0eWxlOiBcInJnYmEoNjQsIDY0LCA2NCwgMSlcIiwgc3Ryb2tlU3R5bGU6IFwicmdiYSg2NCwgNjQsIDY0LCAxKVwiIH07XHJcblxyXG4gICAgICAgIHJhbmdlID0gTWF0aC5mbG9vcigxMTAwICogb3B0aW9ucy5icFBlclBpeGVsKTtcclxuICAgICAgICB0cyA9IFJ1bGVyVHJhY2suZmluZFNwYWNpbmcocmFuZ2UpO1xyXG4gICAgICAgIHNwYWNpbmcgPSB0cy5tYWpvclRpY2s7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgc3RhcnRpbmcgcG9pbnQgY2xvc2VzdCB0byB0aGUgY3VycmVudCBvcmlnaW5cclxuICAgICAgICBuVGljayA9IE1hdGguZmxvb3Iob3B0aW9ucy5icFN0YXJ0IC8gc3BhY2luZykgLSAxO1xyXG4gICAgICAgIHggPSAwO1xyXG5cdFx0bGV0IHlfcG9zPW9wdGlvbnMudG9wK3RoaXMuaGVpZ2h0O1xyXG4gICAgICAgIC8vY2FudmFzLnNldFByb3BlcnRpZXMoe3RleHRBbGlnbjogJ2NlbnRlcid9KTtcclxuICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgZm9udFN0eWxlICk7XHJcbiAgICAgICAgd2hpbGUgKHggPCBvcHRpb25zLnBpeGVsV2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihuVGljayAqIHNwYWNpbmcpLFxyXG4gICAgICAgICAgICAgICAgc2hpbSA9IDI7XHJcblxyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCgoKGwgLSAxKSAtIG9wdGlvbnMuYnBTdGFydCArIDAuNSkgLyBvcHRpb25zLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICB2YXIgY2hyUG9zaXRpb24gPSBmb3JtYXROdW1iZXIobCAvIHRzLnVuaXRNdWx0aXBsaWVyLCAwKSArIFwiIFwiICsgdHMubWFqb3JVbml0O1xyXG5cclxuICAgICAgICAgICAgaWYgKG5UaWNrICUgMSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsVGV4dChjdHgsIGNoclBvc2l0aW9uLCB4LCB5X3BvcyAtIDE1KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHgsIHlfcG9zIC0gMTAsIHgsIHlfcG9zIC0gc2hpbSk7XHJcblxyXG4gICAgICAgICAgICBuVGljaysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgMCwgeV9wb3MgLSBzaGltLCBvcHRpb25zLnBpeGVsV2lkdGgsIHlfcG9zIC0gc2hpbSk7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIoYW55bnVtLCBkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgIC8vZGVjaW1hbCAgLSB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZSBkaWdpdCBmcm9tIDAgdG8gM1xyXG4gICAgICAgICAgICAvLy0tIFJldHVybnMgdGhlIHBhc3NlZCBudW1iZXIgYXMgYSBzdHJpbmcgaW4gdGhlIHh4eCx4eHgueHggZm9ybWF0LlxyXG4gICAgICAgICAgICAvL2FueW51bSA9IGV2YWwob2JqLnZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGRpdmlkZXIgPSAxMDtcclxuICAgICAgICAgICAgc3dpdGNoIChkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICAgICAvL2ZvciAzIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEwMDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3b3JrTnVtID0gTWF0aC5hYnMoKE1hdGgucm91bmQoYW55bnVtICogZGl2aWRlcikgLyBkaXZpZGVyKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd29ya1N0ciA9IFwiXCIgKyB3b3JrTnVtXHJcblxyXG4gICAgICAgICAgICBpZiAod29ya1N0ci5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgd29ya1N0ciArPSBcIi5cIlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZFN0ciA9IHdvcmtTdHIuc3Vic3RyKDAsIHdvcmtTdHIuaW5kZXhPZihcIi5cIikpO1xyXG4gICAgICAgICAgICB2YXIgZE51bSA9IGRTdHIgLSAwXHJcbiAgICAgICAgICAgIHZhciBwU3RyID0gd29ya1N0ci5zdWJzdHIod29ya1N0ci5pbmRleE9mKFwiLlwiKSlcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChwU3RyLmxlbmd0aCAtIDEgPCBkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICBwU3RyICs9IFwiMFwiXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwU3RyID09ICcuJykgcFN0ciA9ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8tLS0gQWRkcyBhIGNvbW1hIGluIHRoZSB0aG91c2FuZHMgcGxhY2UuXHJcbiAgICAgICAgICAgIGlmIChkTnVtID49IDEwMDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkTGVuID0gZFN0ci5sZW5ndGhcclxuICAgICAgICAgICAgICAgIGRTdHIgPSBwYXJzZUludChcIlwiICsgKGROdW0gLyAxMDAwKSkgKyBcIixcIiArIGRTdHIuc3Vic3RyaW5nKGRMZW4gLSAzLCBkTGVuKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy0tIEFkZHMgYSBjb21tYSBpbiB0aGUgbWlsbGlvbnMgcGxhY2UuXHJcbiAgICAgICAgICAgIGlmIChkTnVtID49IDEwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgIGRMZW4gPSBkU3RyLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgZFN0ciA9IHBhcnNlSW50KFwiXCIgKyAoZE51bSAvIDEwMDAwMDApKSArIFwiLFwiICsgZFN0ci5zdWJzdHJpbmcoZExlbiAtIDcsIGRMZW4pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IGRTdHIgKyBwU3RyXHJcbiAgICAgICAgICAgIC8vLS0gUHV0IG51bWJlcnMgaW4gcGFyZW50aGVzZXMgaWYgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIGlmIChhbnludW0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBcIihcIiArIHJldHZhbCArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1lvdSBjb3VsZCBpbmNsdWRlIGEgZG9sbGFyIHNpZ24gaW4gdGhlIHJldHVybiB2YWx1ZS5cclxuICAgICAgICAgICAgLy9yZXR2YWwgPSAgXCIkXCIrcmV0dmFsXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5X3BvcztcclxuXHJcblxyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRTcGFjaW5nKG1heFZhbHVlKSB7XHJcblxyXG4gICAgICAgIGlmIChtYXhWYWx1ZSA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoMSwgXCJcIiwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gTm93IG1hbiB6ZXJvZXM/XHJcbiAgICAgICAgdmFyIG5aZXJvZXMgPSBNYXRoLmZsb29yKGxvZzEwKG1heFZhbHVlKSk7XHJcbiAgICAgICAgdmFyIG1ham9yVW5pdCA9IFwiXCI7XHJcbiAgICAgICAgdmFyIHVuaXRNdWx0aXBsaWVyID0gMTtcclxuICAgICAgICBpZiAoblplcm9lcyA+IDkpIHtcclxuICAgICAgICAgICAgbWFqb3JVbml0ID0gXCJnYlwiO1xyXG4gICAgICAgICAgICB1bml0TXVsdGlwbGllciA9IDEwMDAwMDAwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuWmVyb2VzID4gNikge1xyXG4gICAgICAgICAgICBtYWpvclVuaXQgPSBcIm1iXCI7XHJcbiAgICAgICAgICAgIHVuaXRNdWx0aXBsaWVyID0gMTAwMDAwMDtcclxuICAgICAgICB9IGVsc2UgaWYgKG5aZXJvZXMgPiAzKSB7XHJcbiAgICAgICAgICAgIG1ham9yVW5pdCA9IFwia2JcIjtcclxuICAgICAgICAgICAgdW5pdE11bHRpcGxpZXIgPSAxMDAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5NYWpvclRpY2tzID0gbWF4VmFsdWUgLyBNYXRoLnBvdygxMCwgblplcm9lcyAtIDEpO1xyXG4gICAgICAgIGlmIChuTWFqb3JUaWNrcyA8IDI1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoTWF0aC5wb3coMTAsIG5aZXJvZXMgLSAxKSwgbWFqb3JVbml0LCB1bml0TXVsdGlwbGllcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWNrU3BhY2luZyhNYXRoLnBvdygxMCwgblplcm9lcykgLyAyLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvZzEwKHgpIHtcclxuICAgICAgICAgICAgdmFyIGRuID0gTWF0aC5sb2coMTApO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBkbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5SdWxlclRyYWNrLmNvdW50PTA7XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcInJ1bGVyXCJdPXtcclxuXHRcImNsYXNzXCI6UnVsZXJUcmFjayxcclxuXHRuYW1lOlwiUnVsZXJcIlxyXG5cclxufVxyXG5cclxuY2xhc3MgVGlja1NwYWNpbmd7XHJcblx0Y29uc3RydWN0b3IobWFqb3JUaWNrLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgdGhpcy5tYWpvclRpY2sgPSBtYWpvclRpY2s7XHJcbiAgICAgICAgdGhpcy5tYWpvclVuaXQgPSBtYWpvclVuaXQ7XHJcbiAgICAgICAgdGhpcy51bml0TXVsdGlwbGllciA9IHVuaXRNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIFxyXG5jbGFzcyBNTFZCZWRUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG5cdFx0dGhpcy5maWx0ZXJfZnVuY3Rpb249bnVsbDtcclxuXHRcdHRoaXMuY29sb3JfZnVuY3Rpb249bnVsbDtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9IG5ldyBUYWJpeEJlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpXHJcblx0fVxyXG5cclxuXHRzZXRGaWx0ZXJGdW5jdGlvbihmdW5jKXtcclxuXHRcdHRoaXMuZmlsdGVyX2Z1bmN0aW9uPWZ1bmM7XHJcblx0fVxyXG5cdHNldENvbG9yRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmNvbG9yX2Z1bmN0aW9uPWZ1bmM7XHJcblx0fVxyXG5cclxuXHRnZXRDdXJyZW50RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCl7XHJcblx0XHRyZXR1cm4gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKTtcclxuXHR9XHJcblx0XHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHRcdGxldCBtYXhfeV92YWw9MDtcclxuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLFxyXG4gICAgICAgIFx0cHksXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBwaXhlbEhlaWdodCA9IG9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgICAgIG9mZnNldD0wLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDE7XHJcblx0IFx0bGV0IHRvcD0wO1xyXG4gICAgICAgXHRpZihvcHRpb25zLnRvcCl7XHJcbiAgICAgICAgICAgdG9wPW9wdGlvbnMudG9wO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdHRoaXMudG9wPXRvcDtcclxuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgIGxldCB3aW5kb3dYID0gMDtcclxuICAgICAgICBsZXQgd2luZG93WDEgPSB3aW5kb3dYICsgcGl4ZWxXaWR0aDtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0ID0gdGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCsxMDtcclxuICAgICAgICB0aGlzLmNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgPSAodGhpcy5jb25maWcuZmVhdHVyZUhlaWdodC8yKSsyO1xyXG4gICAgICAgIGxldCBraT1udWxsO1xyXG4gICAgICAgIGlmIChmZWF0dXJlTGlzdC5sZW5ndGg+NTAwMDApe1xyXG4gICAgICAgIFx0a2k9TWF0aC5yb3VuZChmZWF0dXJlTGlzdC5sZW5ndGgvNTAwMDApKzE7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIGlmIChmZWF0dXJlTGlzdCkge1xyXG4gICAgICAgIFx0bGV0IG9wYWNpdHkgPSB0aGlzLmNvbmZpZy5vcGFjaXR5P3RoaXMuY29uZmlnLm9wYWNpdHk6MTtcclxuICAgICAgICBcdGN0eC5nbG9iYWxBbHBoYT1vcGFjaXR5O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgZ2VuZSwgaSA9IDAsIGxlbiA9IGZlYXR1cmVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIFx0aWYgKGtpICYmIGkla2khPT0wKXtcclxuICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgIGdlbmUgPSBmZWF0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZ2VuZSkpe1xyXG4gICAgICAgICAgICAgICAgXHRnZW5lLmRpc3BsYXk9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2VuZS5kaXNwbGF5PXRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZS5lbmQgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChnZW5lLnN0YXJ0ID4gYnBFbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5jYWxjdWxhdGVGZWF0dXJlQ29vcmRpbmF0ZXMoZ2VuZSwgYnBTdGFydCxicFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBoID0gY29uZi5mZWF0dXJlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZi5kaXNwbGF5TW9kZSA9PT0gXCJTUVVJU0hFRFwiICYmIGdlbmUucm93ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBcdFx0aCA9IGNvbmYuZmVhdHVyZUhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIFx0XHRweSA9IGNvbmYuZXhwYW5kZWRDYWxsSGVpZ2h0ICogZ2VuZS5yb3cgKyAyO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKGNvbmYuZGlzcGxheU1vZGUgPT09IFwiRVhQQU5ERURcIiAmJiBnZW5lLnJvdyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgXHRcdHB5ID0gY29uZi5zcXVpc2hlZENhbGxIZWlnaHQgKiBnZW5lLnJvdyArIDU7XHJcbiAgICAgICAgXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAvLyBjb2xsYXBzZWRcclxuICAgICAgICAgICBcdFx0XHQgcHkgPSA1O1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHB5Kz10b3A7XHJcbiAgICAgICAgXHRcdGlmIChweStoPm1heF95X3ZhbCl7XHJcbiAgICAgICAgXHRcdFx0bWF4X3lfdmFsPXB5K2g7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0Y29vcmQucHk9cHk7XHJcbiAgICAgICAgXHRcdGNvb3JkLmg9aDtcclxuICAgICAgICBcdFx0bGV0IGluZm89e2JwUGVyUGl4ZWw6YnBQZXJQaXhlbCxicFN0YXJ0OmJwU3RhcnQscGl4ZWxXaWR0aDpwaXhlbFdpZHRofVxyXG4gICAgICAgIFx0XHRpZiAodGhpcy5jb2xvcl9mdW5jdGlvbil7XHJcbiAgICAgICAgXHRcdFx0Z2VuZS5jb2xvcj10aGlzLmNvbG9yX2Z1bmN0aW9uKGdlbmUpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGZWF0dXJlKGdlbmUsY29vcmQsY3R4LGluZm8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGZWF0dXJlTGFiZWwoY3R4LCBnZW5lLCBjb29yZC5weCwgY29vcmQucHgxLCBweSwgd2luZG93WCwgd2luZG93WDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBmZWF0dXJlIGxpc3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm90dG9tPW1heF95X3ZhbDtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuZGlzcGxheU1vZGU9PT1cIkNPTExBUFNFRFwiKXtcclxuICAgICAgICBcdG1heF95X3ZhbCs9MjU7XHJcbiAgICAgICAgfVx0XHJcbiAgICBcdHJldHVybiBtYXhfeV92YWw7XHJcbiAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgXHJcblxyXG4gICAgXHJcbiAgXHJcblx0IC8qKlxyXG4gICAgICogQHBhcmFtIGN0eCAgICAgICB0aGUgY2FudmFzIDJkIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVggIGZlYXR1cmUgc3RhcnQgeC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVgxIGZlYXR1cmUgZW5kIHgtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVZICBmZWF0dXJlIHktY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHdpbmRvd1ggICB2aXNpYmxlIHdpbmRvdyBzdGFydCB4LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aW5kb3dYMSAgdmlzaWJsZSB3aW5kb3cgZW5kIHgtY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgXHJcblxyXG5cclxuXHJcblx0cmVuZGVyRmVhdHVyZUxhYmVsKGN0eCwgZmVhdHVyZSwgZmVhdHVyZVgsIGZlYXR1cmVYMSwgZmVhdHVyZVksIHdpbmRvd1gsIHdpbmRvd1gxKSB7XHJcblx0XHRsZXQgaW5mbyA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgIHZhciBnZW5lQ29sb3IsIGdlbmVGb250U3R5bGUsIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgYm94WCwgYm94WDEsICAgIC8vIGxhYmVsIHNob3VsZCBiZSBjZW50ZXJlZCBiZXR3ZWVuIHRoZXNlIHR3byB4LWNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGxhYmVsWCwgbGFiZWxZLFxyXG4gICAgICAgICAgICB0ZXh0Rml0c0luQm94O1xyXG5cclxuICAgICAgICAvLyBmZWF0dXJlIG91dHNpZGUgb2Ygdmlld2FibGUgd2luZG93XHJcbiAgICAgICAgaWYgKGZlYXR1cmVYMSA8IHdpbmRvd1ggfHwgZmVhdHVyZVggPiB3aW5kb3dYMSkge1xyXG4gICAgICAgICAgICBib3hYID0gZmVhdHVyZVg7XHJcbiAgICAgICAgICAgIGJveFgxID0gZmVhdHVyZVgxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNlbnRlciBsYWJlbCB3aXRoaW4gdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBmZWF0dXJlXHJcbiAgICAgICAgICAgIGJveFggPSBNYXRoLm1heChmZWF0dXJlWCwgd2luZG93WCk7XHJcbiAgICAgICAgICAgIGJveFgxID0gTWF0aC5taW4oZmVhdHVyZVgxLCB3aW5kb3dYMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGV4dD0gZmVhdHVyZS5uYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmxhYmVsX2Z1bmN0aW9uKXtcclxuICAgICAgICBcdHRleHQ9dGhpcy5sYWJlbF9mdW5jdGlvbihmZWF0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgLy9pZiAoaWd2LmJyb3dzZXIuc2VsZWN0aW9uICYmIFwiZ2VuZXNcIiA9PT0gdGhpcy5jb25maWcudHlwZSAmJiBmZWF0dXJlLm5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIC0tIGZvciBndGV4LCBmaWd1cmUgb3V0IGEgYmV0dGVyIHdheSB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgIC8vZ2VuZUNvbG9yID0gaWd2LmJyb3dzZXIuc2VsZWN0aW9uLmNvbG9yRm9yR2VuZShmZWF0dXJlLm5hbWUpO1xyXG4gICAgICAvLyAgfVxyXG5cclxuICAgICAgICB0ZXh0Rml0c0luQm94ID0gKGJveFgxIC0gYm94WCkgPiBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgICAgICAgLy9nZW5lQ29sb3I9XCJibGFja1wiO1xyXG5cclxuICAgICAgICBpZiAoKHRleHRGaXRzSW5Cb3ggfHwgZ2VuZUNvbG9yKSAmJiBpbmZvLmRpc3BsYXlNb2RlICE9IFwiU1FVSVNIRURcIiAmJiB0ZXh0KSB7XHJcbiAgICAgICAgICAgIGdlbmVGb250U3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICBmb250OiAnMTBweCBQVCBTYW5zJyxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IGdlbmVDb2xvciB8fCBpbmZvLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IGdlbmVDb2xvciB8fCBpbmZvLmNvbG9yXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXNwbGF5TW9kZSA9PT0gXCJDT0xMQVBTRURcIiAmJiBpbmZvLmxhYmVsRGlzcGxheU1vZGUgPT09IFwiU0xBTlRcIikge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0ge3JvdGF0ZToge2FuZ2xlOiA0NX19O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdlbmVGb250U3R5bGUudGV4dEFsaWduO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYWJlbFggPSBib3hYICsgKChib3hYMSAtIGJveFgpIC8gMik7XHJcbiAgICAgICAgICAgIGxhYmVsWSA9IGdldEZlYXR1cmVMYWJlbFkoZmVhdHVyZVksIHRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICBHcmFwaGljcy5maWxsVGV4dChjdHgsIHRleHQsIGxhYmVsWCwgbGFiZWxZLCBnZW5lRm9udFN0eWxlLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRGZWF0dXJlTGFiZWxZKGZlYXR1cmVZLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICBcdHJldHVybiB0cmFuc2Zvcm0gPyBmZWF0dXJlWSArIGluZm8uZmVhdHVyZUhlaWdodCsxNCA6IGZlYXR1cmVZICsgaW5mby5mZWF0dXJlSGVpZ2h0Kzc7XHJcbiAgICBcdH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHRjYWxjdWxhdGVGZWF0dXJlQ29vcmRpbmF0ZXMoZmVhdHVyZSwgYnBTdGFydCwgeFNjYWxlKSB7XHJcbiAgICBcdHZhciBweCA9IE1hdGgucm91bmQoKGZlYXR1cmUuc3RhcnQgLSBicFN0YXJ0KSAvIHhTY2FsZSksXHJcbiAgICAgICAgcHgxID0gTWF0aC5yb3VuZCgoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIHhTY2FsZSksXHJcbiAgICAgICAgcHcgPSBweDEgLSBweDtcclxuXHJcbiAgICAgICAgaWYgKHB3IDwgMykge1xyXG4gICAgICAgIFx0cHcgPSAzO1xyXG4gICAgICAgICAgICBweCAtPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICBcdHB4OiBweCxcclxuICAgICAgICAgICAgcHgxOiBweDEsXHJcbiAgICAgICAgICAgIHB3OiBwd1xyXG4gICAgICAgIH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIGZlYXR1cmUgdG8gdGhlIGNhbnZhc1xyXG4gICAgICogQHBhcmFtIGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBpdHNlbGZcclxuICAgICAqIEBwYXJhbSBjb29yZCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvbiB3aGVyZSB0byBkcmF3IHRoZSBmZWF0dXJlXHJcbiAgICAgKiBweDEscHgyIHRoZSBsZWZ0IGFuZCByaWdodCBwaXhlbHMgLSBwdyAtIHRoZSB3aWR0aFxyXG4gICAgICogcHkgdGhlIHRvcCwgaCAtIHRoZSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0byBkcmF3IHRoZSBmZWF0dXJlXHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnZW5vbWljIGxvY2F0aW9uXHJcbiAgICAgKiBicFN0YXJ0LmJwUGVyUGl4ZWwgYW5kIHBpeGVsV2lkdGhcclxuICAgICAqIFxyXG4gICAgICovXHJcblx0XHJcblx0cmVuZGVyRmVhdHVyZShmZWF0dXJlLCBjb29yZCxjdHgsaW5mbyl7XHJcblx0XHR2YXIgZSx4LCBjeSwgZGlyZWN0aW9uLCBleG9uLCBlUHgsIGVQeDEsIGVQeFUsIGVQdywgcHkyLCBoMiwgXHJcbiAgICAgICAgICAgIHN0ZXAgPSAyMCxcclxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbmZpZy5jb2xvcjtcclxuICAgICAgICBpZiAoZmVhdHVyZS5jb2xvcikge1xyXG4gICAgICAgICAgICBjb2xvciA9IGZlYXR1cmUuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcblxyXG4gICAgICAgIGN5ID0gY29vcmQucHkgKyBjb29yZC5oIC8gMjtcclxuICAgICAgICBoMiA9IGNvb3JkLmggLyAyO1xyXG4gICAgICAgIHB5MiA9IGN5IC0gaDIgLyAyO1xyXG5cclxuXHRcdGxldCBleG9uQ291bnQgPSBmZWF0dXJlLmV4b25zID8gZmVhdHVyZS5leG9ucy5sZW5ndGggOiAwO1xyXG5cdFx0XHRpZiAoZXhvbkNvdW50ID09IDApIHtcclxuICAgICAgICAgICAgXHQvLyBzaW5nbGUtZXhvbiB0cmFuc2NyaXB0XHJcbiAgICAgICAgICAgIFx0Y3R4LmZpbGxSZWN0KGNvb3JkLnB4LCBjb29yZC5weSwgY29vcmQucHcsIGNvb3JkLmgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIC8vIG11bHRpLWV4b24gdHJhbnNjcmlwdFxyXG4gICAgICAgICAgICBjb29yZC5weD1NYXRoLm1heChjb29yZC5weCwwKTtcclxuICAgICAgICAgICAgY29vcmQucHgxPU1hdGgubWluKGNvb3JkLnB4MSxpbmZvLnBpeGVsV2lkdGgpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgY29vcmQucHggKyAxLCBjeSwgY29vcmQucHgxIC0gMSwgY3kpOyAvLyBjZW50ZXIgbGluZSBmb3IgaW50cm9uc1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBmZWF0dXJlLnN0cmFuZCA9PSAnKycgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAoIHg9Y29vcmQucHggKyBzdGVwIC8gMjsgeCA8ICBjb29yZC5weDE7IHggKz0gc3RlcCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRyYXcgYXJyb3doZWFkcyBhbG9uZyBjZW50cmFsIGxpbmUgaW5kaWNhdGluZyB0cmFuc2NyaWJlZCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHggLSBkaXJlY3Rpb24gKiAyLCBjeSAtIDIsIHgsIGN5KTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgKyAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8IGV4b25Db3VudDsgZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBleG9uc1xyXG4gICAgICAgICAgICAgICAgZXhvbiA9IGZlYXR1cmUuZXhvbnNbZV07XHJcbiAgICAgICAgICAgICAgICBlUHggPSBNYXRoLnJvdW5kKChleG9uLnN0YXJ0IC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBlUHgxID0gTWF0aC5yb3VuZCgoZXhvbi5lbmQgLSBpbmZvLmJwU3RhcnQpIC8gaW5mby5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGVQdyA9IE1hdGgubWF4KDEsIGVQeDEgLSBlUHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleG9uLnV0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHgsIHB5MiwgZVB3LCBoMik7IC8vIEVudGlyZSBleG9uIGlzIFVUUlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4b24uY2RTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHhVID0gTWF0aC5yb3VuZCgoZXhvbi5jZFN0YXJ0IC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHgsIHB5MiwgZVB4VSAtIGVQeCwgaDIpOyAvLyBzdGFydCBpcyBVVFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB3IC09IChlUHhVIC0gZVB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4ID0gZVB4VTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleG9uLmNkRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeFUgPSBNYXRoLnJvdW5kKChleG9uLmNkRW5kIC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHhVLCBweTIsIGVQeDEgLSBlUHhVLCBoMik7IC8vIHN0YXJ0IGlzIFVUUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHcgLT0gKGVQeDEgLSBlUHhVKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4MSA9IGVQeFU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBjb29yZC5weSwgZVB3LCBjb29yZC5oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVQdyA+IHN0ZXAgKyA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh4ID0gZVB4ICsgc3RlcCAvIDI7IHggPCBlUHgxOyB4ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgYXJyb3doZWFkcyBhbG9uZyBjZW50cmFsIGxpbmUgaW5kaWNhdGluZyB0cmFuc2NyaWJlZCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHggLSBkaXJlY3Rpb24gKiAyLCBjeSAtIDIsIHgsIGN5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgKyAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEZlYXR1cmVBdChnZW5vbWljTG9jYXRpb24sIGNociwgY29vcmQsIGJwUGVyUGl4ZWwpIHtcclxuXHRcdGxldCB5T2Zmc2V0PWNvb3JkLnktdGhpcy50b3A7XHJcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBmZWF0dXJlQ2FjaGUgcHJvcGVydHkgcmF0aGVyIHRoYW4gbWV0aG9kIHRvIGF2b2lkIGFzeW5jIGxvYWQuICBJZiB0aGVcclxuICAgICAgICAvLyBmZWF0dXJlIGlzIG5vdCBhbHJlYWR5IGxvYWRlZCB0aGlzIHdvbid0IHdvcmssICBidXQgdGhlIHVzZXIgd291bGRuJ3QgYmUgbW91c2luZyBvdmVyIGl0IGVpdGhlci5cclxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUpIHtcclxuXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDIgKiBicFBlclBpeGVsLCAgLy8gV2UgbmVlZCBzb21lIHRvbGVyYW5jZSBhcm91bmQgZ2Vub21pY0xvY2F0aW9uLCBzdGFydCB3aXRoICsvLSAyIHBpeGVsc1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZUxpc3QgPSB0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZS5xdWVyeUZlYXR1cmVzKGNociwgZ2Vub21pY0xvY2F0aW9uIC0gdG9sZXJhbmNlLCBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpLFxyXG4gICAgICAgICAgICAgICAgcm93O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRpc3BsYXlNb2RlICE9IFwiQ09MTEFQU0VEXCIpIHtcclxuICAgICAgICAgICAgICAgIHJvdyA9IChNYXRoLmZsb29yKSh0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZSA9PT0gXCJTUVVJU0hFRFwiID8geU9mZnNldCAvIHRoaXMuY29uZmlnLmV4cGFuZGVkQ2FsbEhlaWdodCA6IHlPZmZzZXQgLyB0aGlzLmNvbmZpZy5zcXVpc2hlZENhbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0ICYmIGZlYXR1cmVMaXN0Lmxlbmd0aCA+IDApIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZmVhdHVyZSBvZiBmZWF0dXJlTGlzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZW5kID49IGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0YXJ0IDw9IGdlbm9taWNMb2NhdGlvbiArIHRvbGVyYW5jZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcm93IG51bWJlciBpcyBzcGVjaWZpZWQgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93ID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZS5yb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IGZlYXR1cmUucm93KSYmICBmZWF0dXJlLmRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG59XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcImJlZFwiXT17XHJcblx0XCJjbGFzc1wiOk1MVkJlZFRyYWNrLFxyXG5cdG5hbWU6XCJiZWQodGFiaXgpXCJcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVkJpZ0JlZFRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHRcclxuXHR9XHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9bmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wiYmlnYmVkXCJdPXtcclxuXHRcImNsYXNzXCI6TUxWQmlnQmVkVHJhY2ssXHJcblx0XCJuYW1lXCI6XCJCaWdCZWRcIlxyXG5cdFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgTUxWV2lnVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0Y29uZmlnLmZvcm1hdD1cIndpZ1wiO1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPW5ldyBCV1NvdXJjZSh0aGlzLmNvbmZpZyk7XHRcclxuXHR9XHJcblxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxfaGVpZ2h0LGN0eCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcuc2NhbGVfbGlua190byAmJiB0aGlzLmNvbmZpZy5ncm91cCl7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGxldCBib3Q9IHBpeGVsX2hlaWdodDtcclxuXHRcdGxldCB0b3AgPSAwO1xyXG5cclxuXHJcblx0XHRpZiAodGhpcy5jb25maWcuZGlzY3JldGUpe1xyXG5cdFx0XHR0b3A9dGhpcy50b3A7XHJcblx0XHRcdGJvdCA9IHRoaXMuYm90dG9tO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJhbmdlPXRoaXMubWF4X3ktdGhpcy5taW5feTtcclxuXHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdGN0eC5saW5lVG8oMCxib3QpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDIwLHRvcCk7XHJcblx0XHRjdHgubW92ZVRvKDAsYm90KTtcclxuXHRcdGN0eC5saW5lVG8oMjAsYm90KTtcclxuXHRcdGN0eC5mb250PVwiMTJweCBBcmlhbFwiO1xyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZT1cInRvcFwiO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZT1cImJsYWNrXCI7XHJcblx0XHRjdHguZmlsbFRleHQodGhpcy5tYXhfeS50b0ZpeGVkKDIpLDIwLHRvcCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWluX3ksMjAsYm90KTtcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXMsXHJcblx0ICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuXHQgICAgY29sb3I9c2VsZi5jb25maWcuY29sb3IsXHJcblx0ICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuXHQgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuXHQgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuXHQgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuXHQgICAgcGl4ZWxIZWlnaHQgPW9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcblx0ICAgIHlfb2Zmc2V0PXRoaXMuY29uZmlnLmRpc2NyZXRlP29wdGlvbnMudG9wOjAsXHJcblx0ICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWluaW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWF4aW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlUmFuZ2UsXHJcblx0ICAgICRkYXRhUmFuZ2VUcmFja0xhYmVsLFxyXG5cdCAgICBzdHIsXHJcblx0ICAgIG1pbixcclxuXHQgICAgbWF4O1xyXG5cdCAgICBpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZih0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0ICAgIFx0XHRwaXhlbEhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ7XHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYoc2VsZi5zZXRfc2NhbGUpe1xyXG5cdCAgICAgICBcdFx0c2VsZi5taW5feT1zZWxmLnNldF9zY2FsZS5taW47XHJcblx0ICAgICAgIFx0XHRzZWxmLm1heF95PXNlbGYuc2V0X3NjYWxlLm1heDtcclxuXHQgICAgICAgfVxyXG5cdCAgICAgICBlbHNlIGlmICggKHNlbGYubWF4X3kgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNvbmZpZy5zY2FsZT09PVwiYXV0b21hdGljXCIpIHx8IHNlbGYuY29uZmlnLnNjYWxlPT09XCJkeW5hbWljXCIpe1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcyA9IGF1dG9zY2FsZShmZWF0dXJlcyk7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzLm1pbjtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeSA9IHMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5zY2FsZT09PVwiZml4ZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95ID0gc2VsZi5jb25maWcubWluX3k7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3k9c2VsZi5jb25maWcubWF4X3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgICAgICAgICBmZWF0dXJlVmFsdWVSYW5nZSA9IHNlbGYubWF4X3kgLSBzZWxmLm1pbl95O1xyXG5cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsID0gJCh0aGlzLnRyYWNrVmlldy50cmFja0RpdikuZmluZCgnLmlndi1kYXRhLXJhbmdlLXRyYWNrLWxhYmVsJyk7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvL21pbiA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5taW4pID09PSB0cmFjay5kYXRhUmFuZ2UubWluKSA/IHRyYWNrLmRhdGFSYW5nZS5taW4gOiB0cmFjay5kYXRhUmFuZ2UubWluLnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9tYXggPSAoTWF0aC5mbG9vcih0cmFjay5kYXRhUmFuZ2UubWF4KSA9PT0gdHJhY2suZGF0YVJhbmdlLm1heCkgPyB0cmFjay5kYXRhUmFuZ2UubWF4IDogdHJhY2suZGF0YVJhbmdlLm1heC50b0ZpeGVkKDIpO1xyXG5cdCAgICAgICAgICAgIC8vc3RyID0gJ1snICsgbWluICsgJyAtICcgKyBtYXggKyAnXSc7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsLnRleHQoc3RyKTtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl94PTA7XHJcblx0ICAgICAgICAgICAgbGV0IHByZXZfeT0wO1xyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAgID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcblx0ICAgICAgICAgXHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfbGluZSl7ICBcclxuXHQgICAgICAgICAgICAgICAgbGV0IHkgPSAoMS4wIC0gc2VsZi5jb25maWcudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZSkqcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LDAseSxwaXhlbFdpZHRoLHkse1wic3Ryb2tlU3R5bGVcIjpzZWxmLmNvbmZpZy5jb2xvcixcImxpbmVXaWR0aFwiOnNlbGYuY29uZmlnLndpZHRoP3NlbGYuY29uZmlnLndpZHRoOjF9KTtcclxuXHQgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHRmZWF0dXJlcy5mb3JFYWNoKHJlbmRlckZlYXR1cmUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgXHJcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhPTFcclxuXHQgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRocmVzaG9sZCl7XHJcblx0ICAgICAgICAgICAgIFx0ICAgIGxldCB5ID0geV9vZmZzZXQrKDEuMCAtIHNlbGYuY29uZmlnLnRocmVzaG9sZC8gZmVhdHVyZVZhbHVlUmFuZ2UpKnBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgICBcdCAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwwLHkscGl4ZWxXaWR0aCx5LHtcInN0cm9rZVN0eWxlXCI6XCJibGFja1wiLFwibGluZVdpZHRoXCI6MX0pO1xyXG5cdCAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShmZWF0dXJlLCBpbmRleCwgZmVhdHVyZUxpc3QpIHtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIHlVbml0bGVzcyxcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MsXHJcblx0ICAgICAgICAgICAgICAgIHgsXHJcblx0ICAgICAgICAgICAgICAgIHksXHJcblx0ICAgICAgICAgICAgICAgIHdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHQsXHJcblx0ICAgICAgICAgICAgICAgIHJlY3RFbmQsXHJcblx0ICAgICAgICAgICAgICAgIHJlY3RCYXNlbGluZTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKGZlYXR1cmUuZW5kIDwgYnBTdGFydCkgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHQgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZD09PWZlYXR1cmUuc3RhcnQpe1xyXG5cdCAgICAgICAgICAgIFx0ZmVhdHVyZS5zdGFydC09MTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICByZWN0RW5kID0gTWF0aC5mbG9vcigoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwpO1xyXG5cdCAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgcmVjdEVuZCAtIHgpO1xyXG5cdCAgICAgICAgICBcclxuXHJcblx0ICAgICAgICAgIFxyXG5cclxuXHQgICAgICAgICAgICAvL2hlaWdodCA9ICgoZmVhdHVyZS52YWx1ZSAtIGZlYXR1cmVWYWx1ZU1pbmltdW0pIC8gZmVhdHVyZVZhbHVlUmFuZ2UpICogcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9yZWN0QmFzZWxpbmUgPSBwaXhlbEhlaWdodCAtIGhlaWdodDtcclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdChyZWN0T3JpZ2luLCByZWN0QmFzZWxpbmUsIHJlY3RXaWR0aCwgcmVjdEhlaWdodCwge2ZpbGxTdHlsZTogdHJhY2suY29sb3J9KTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHNpZ25zRGlmZmVyKHNlbGYubWluX3ksIHNlbGYubWF4X3kpKSB7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS52YWx1ZSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IHNlbGYubWF4X3kvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gKChzZWxmLm1heF95IC0gZmVhdHVyZS52YWx1ZSkgLyBmZWF0dXJlVmFsdWVSYW5nZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IGZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5taW5feSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMDtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMS4wIC0gKChmZWF0dXJlLnZhbHVlLXNlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IChmZWF0dXJlLnZhbHVlK3NlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgIFx0eSA9ICh5VW5pdGxlc3MqcGl4ZWxIZWlnaHQpK3lfb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIHk9eTx5X29mZnNldD95X29mZnNldDp5O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHRVbml0TGVzcyAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHQ+cGl4ZWxIZWlnaHQ/cGl4ZWxIZWlnaHQ6aGVpZ2h0XHJcblxyXG5cdCAgICAgICAgICAgIC8vY2FudmFzLmZpbGxSZWN0KHgsIHlVbml0bGVzcyAqIHBpeGVsSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodCwgeyBmaWxsU3R5bGU6IGlndi5yYW5kb21SR0IoNjQsIDI1NSkgfSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRpc3BsYXk9PT0nbGluZScpe1xyXG5cdCAgICAgICAgICAgICAgICAgaWYgKHNlbGYucHJldl9jb29yZHMueCl7XHJcblx0ICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCx4LHksc2VsZi5wcmV2X2Nvb3Jkcy54LHNlbGYucHJldl9jb29yZHMueSx7XCJzdHJva2VTdHlsZVwiOmNvbG9yLFwibGluZVdpZHRoXCI6M30pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzZWxmLnByZXZfY29vcmRzLng9eDtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy55PXk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHQgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBjb2xvcn0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIFx0XHJcblxyXG5cdCAgICAgICAgICAgIFx0XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZmVhdHVyZXMpIHtcclxuICAgICAgICBcdFx0dmFyIG1pbiA9IDAsXHJcbiAgICAgICAgICAgIFx0bWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgXHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgZi52YWx1ZSk7XHJcbiAgICAgICAgICAgXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBmLnZhbHVlKTtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcdHJldHVybiB7bWluOiBtaW4sIG1heDogbWF4fTtcclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHRcdGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIChhID4gMCAmJiBiIDwgMCB8fCBhIDwgMCAmJiBiID4gMCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgXHRcdHRoaXMuYm90dG9tPXlfb2Zmc2V0K3BpeGVsSGVpZ2h0O1xyXG4gICAgXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGVsc2V7XHJcbiAgICBcdFx0XHR0aGlzLnRvcD0wO1xyXG4gICAgXHRcdFx0dGhpcy5ib3R0b209MDtcclxuICAgXHRcdFx0fVxyXG5cclxuXHQgICAgXHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wiYmlnd2lnXCJdPXtcclxuXHRcImNsYXNzXCI6TUxWV2lnVHJhY2ssXHJcblx0bmFtZTpcIkJpZ1dpZ1wiXHJcbn1cclxuXHJcblxyXG4gY2xhc3MgTGluZVRyYWNrIGV4dGVuZHMgTUxWV2lnVHJhY2t7XHJcblx0IGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHQgc3VwZXIoY29uZmlnKTtcclxuXHRcdCB0aGlzLmlzX2xpbmU9dHJ1ZTtcclxuXHQgfVxyXG5cdCBcclxuXHQgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cdFx0IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdCBmdWxmaWxsKFtdKTtcclxuXHQgICAgIH0pO1xyXG5cdCB9XHJcblx0IFxyXG5cdCBcclxuIH1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wibGluZVwiXT17XHJcblx0XCJjbGFzc1wiOkxpbmVUcmFjayxcclxuXHRuYW1lOlwiTGluZSBUcmFja1wiXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlcXVlbmNlVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpIFxyXG4gICAgICAgIHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZSA9IGNvbmZpZy5zZXF1ZW5jZVR5cGUgfHwgXCJkbmFcIjsgIFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKXtcclxuICAgIFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy51cmwpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYnBQZXJQaXhlbCA+IDEvKmlndi5icm93c2VyLnRyYWNrVmlld3BvcnRXaWR0aEJQKCkgPiAzMDAwMCovKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlX3NvdXJjZS5nZXRTZXF1ZW5jZShjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIGxlbiwgdywgeSwgcG9zLCBvZmZzZXQsIGIsIHAwLCBwMSwgcGMsIGM7XHJcblxyXG4gICAgICAgIGxldCB5X3BvczE9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgbGV0IHlfcG9zMj15X3BvczErNTtcclxuXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICBsZW4gPSBzZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHcgPSAxIC8gYnBQZXJQaXhlbDtcclxuXHJcbiAgICAgICAgICAgIHkgPSB5X3BvczErdGhpcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IGJwU3RhcnQ7IHBvcyA8PSBicEVuZDsgcG9zKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBicFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNlcXVlbmNlLmNoYXJBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZXF1ZW5jZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAwID0gTWF0aC5mbG9vcihvZmZzZXQgKiB3KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IE1hdGguZmxvb3IoKG9mZnNldCArIDEpICogdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMgPSBNYXRoLnJvdW5kKChwMCArIHAxKSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkbmFcIiA9PT0gdGhpcy5zZXF1ZW5jZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXCJyZ2IoMCwgMCwgMTUwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSBjID0gXCJncmF5XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsID4wLjE1KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHAwLCB5X3BvczEsIHAxIC0gcDAsIDEwLCB7ZmlsbFN0eWxlOiBjfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIGIsIHBjLCB5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdub3JtYWwgMTBweCBBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgcmV0dXJuIHlfcG9zMSsxMDtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJmYXN0YVwiXT17XHJcblx0XCJjbGFzc1wiOlNlcXVlbmNlVHJhY2ssXHJcblx0bmFtZTpcIkZhc3RhXCJcclxufVxyXG5cclxuXHJcblxyXG4vLyoqKioqKipqcy9pZnYtY2FudmFzLmpzKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jbGFzcyBHcmFwaGljc3tcclxuXHJcblxyXG4gICAgICAgc3RhdGljIHNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlTGluZSAoY3R4LCB4MSwgeTEsIHgyLCB5MiwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKHgxKSArIDAuNTtcclxuICAgICAgICAgICAgeTEgPSBNYXRoLmZsb29yKHkxKSArIDAuNTtcclxuICAgICAgICAgICAgeDIgPSBNYXRoLmZsb29yKHgyKSArIDAuNTtcclxuICAgICAgICAgICAgeTIgPSBNYXRoLmZsb29yKHkyKSArIDAuNTtcclxuXHJcbiAgICAgICAgICAgIC8vbG9nKFwic3Ryb2tlIGxpbmUsIHByb3A6IFwiICsgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxSZWN0KGN0eCwgeCwgeSwgdywgaCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsUG9seWdvbihjdHgsIHgsIHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5kb1BhdGgoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwgcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmRvUGF0aChjdHgsIHgsIHkpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZmlsbFRleHQoY3R4LCB0ZXh0LCB4LCB5LCBwcm9wZXJ0aWVzLCB0cmFuc2Zvcm1zKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRyYW5zZm9ybSBpbiB0cmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBZGQgZXJyb3IgY2hlY2tpbmcgZm9yIHJvYnVzdG5lc3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICd0cmFuc2xhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodmFsdWVbJ3gnXSwgdmFsdWVbJ3knXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0gPT0gJ3JvdGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSh2YWx1ZVsnYW5nbGUnXSAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VUZXh0KGN0eCwgdGV4dCwgeCwgeSwgcHJvcGVydGllcywgdHJhbnNmb3Jtcykge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRyYW5zZm9ybSBpbiB0cmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBZGQgZXJyb3IgY2hlY2tpbmcgZm9yIHJvYnVzdG5lc3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICd0cmFuc2xhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodmFsdWVbJ3gnXSwgdmFsdWVbJ3knXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0gPT0gJ3JvdGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSh2YWx1ZVsnYW5nbGUnXSAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VDaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMpIHtcclxuXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxDaXJjbGUgKGN0eCwgeCwgeSwgcmFkaXVzKSB7XHJcblxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZHJhd0Fycm93aGVhZChjdHgsIHgsIHksIHNpemUsIGxpbmVXaWR0aCkge1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5IC0gc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBzaXplIC8gMik7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHNpemUsIHkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgLSBzaXplIC8gMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBkYXNoZWRMaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIsIGRhc2hMZW4sIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgeDEgPSBNYXRoLnJvdW5kKHgxKTtcclxuICAgICAgICAgICAgeTEgPSBNYXRoLnJvdW5kKHkxKTtcclxuICAgICAgICAgICAgeDIgPSBNYXRoLnJvdW5kKHgyKTtcclxuICAgICAgICAgICAgeTIgPSBNYXRoLnJvdW5kKHkyKTtcclxuICAgICAgICAgICAgZGFzaExlbiA9IE1hdGgucm91bmQoZGFzaExlbik7XHJcbiAgICAgICAgICAgIGxvZyhcImRhc2hlZExpbmVcIik7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGFzaExlbiA9PSB1bmRlZmluZWQpIGRhc2hMZW4gPSAyO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZFggPSB4MiAtIHgxO1xyXG4gICAgICAgICAgICB2YXIgZFkgPSB5MiAtIHkxO1xyXG4gICAgICAgICAgICB2YXIgZGFzaGVzID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpIC8gZGFzaExlbik7XHJcbiAgICAgICAgICAgIHZhciBkYXNoWCA9IGRYIC8gZGFzaGVzO1xyXG4gICAgICAgICAgICB2YXIgZGFzaFkgPSBkWSAvIGRhc2hlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBxID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHErKyA8IGRhc2hlcykge1xyXG4gICAgICAgICAgICAgICAgeDEgKz0gZGFzaFg7XHJcbiAgICAgICAgICAgICAgICB5MSArPSBkYXNoWTtcclxuICAgICAgICAgICAgICAgIGN0eFtxICUgMiA9PSAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oeDEsIHkxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHhbcSAlIDIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHgyLCB5Mik7XHJcblxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgXHJcblxyXG4gICAgICAgIHN0YXRpYyBkb1BhdGgoY3R4LCB4LCB5KSB7XHJcblxyXG5cclxuICAgICAgICBcdHZhciBpLCBsZW4gPSB4Lmxlbmd0aDtcclxuICAgICAgICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIFx0XHR4W2ldID0gTWF0aC5yb3VuZCh4W2ldKTtcclxuICAgICAgICBcdFx0eVtpXSA9IE1hdGgucm91bmQoeVtpXSk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIFx0Y3R4Lm1vdmVUbyh4WzBdLCB5WzBdKTtcclxuICAgICAgICBcdGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIFx0XHRjdHgubGluZVRvKHhbaV0sIHlbaV0pO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuXHJcbn1cclxuXHJcbkdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnM9e1xyXG5cdFwiQVwiOlwiZ3JlZW5cIixcclxuXHRcIlRcIjpcInJlZFwiLFxyXG5cdFwiR1wiOlwiYmxhY2tcIixcclxuXHRcIkNcIjpcImJsdWVcIixcclxuXHRcImFcIjpcImdyZWVuXCIsXHJcblx0XCJ0XCI6XCJyZWRcIixcclxuXHRcImNcIjpcImJsYWNrXCIsXHJcblx0XCJnXCI6XCJibHVlXCJcclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtNTFZUcmFjayxNTFZXaWdUcmFjayxNTFZCZWRUcmFjayxSdWxlclRyYWNrLE1MVkJpZ0JlZFRyYWNrLEdyYXBoaWNzfSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7O0FBY0E7OztBQVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFqS0E7QUFDQTtBQW9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUF6VUE7QUFDQTtBQTRVQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBUEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRkE7QUFDQTtBQUVBO0FBSEE7QUFJQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBdE9BO0FBQ0E7QUEwT0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFWQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQU9BOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQXJGQTtBQUNBO0FBeUZBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBVEE7QUFVQTs7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/tracks.js\n");

/***/ }),

/***/ "../MLVPanel/src/utils.js":
/*!***************************!*\
  !*** .Panel/src/utils.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\nvar parseUri_options = {\n    strictMode: false,\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n        name: \"queryKey\",\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n};\n\nvar Utils = function () {\n    function Utils() {\n        _classCallCheck(this, Utils);\n    }\n\n    _createClass(Utils, null, [{\n        key: \"addAlphaToRGB\",\n        value: function addAlphaToRGB(rgbString, alpha) {\n\n            if (rgbString.startsWith(\"rgb\")) {\n                return rgbString.replace(\"rgb\", \"rgba\").replace(\")\", \", \" + alpha + \")\");\n            } else {\n                console.log(rgbString + \" is not an rgb style string\");\n                return rgbString;\n            }\n        }\n    }, {\n        key: \"presentAlert\",\n        value: function presentAlert(track_div, error) {\n            var div = $(\"<div>\").css({ \"position\": \"absolute\", \"background-color\": \"white\" }).attr(\"class\", \"mlv-alert\").appendTo(track_div);\n            var div1 = $(\"<div>\").css({ \"display\": \"flex\", \"justify-content\": \"center\" }).appendTo(div);\n            div1.append($('<i class=\"fas fa-exclamation-circle\"></i>').css({ color: \"red\", \"font-size\": \"16px\", \"text-align\": \"center\" }));\n            div.append($(\"<div>\" + error + \"</div>\").css({ color: \"red\", \"font-size\": \"14px\", \"text-align\": \"center\" }));\n            var left = Math.round(track_div.width() / 2 - div.width() / 2);\n            var top = Math.round(track_div.height() / 2 - div.height() / 2);\n            div.css({ \"left\": left + \"px\", top: top + \"px\" });\n        }\n    }, {\n        key: \"spinner\",\n        value: function spinner(size) {\n\n            // spinner\n            var $container, $spinner;\n\n            $spinner = $('<i class=\"fa fa-lg fa-spinner fa-spin igv-spinner\">').css({ position: \"absolute\", top: \"50%\", left: \"50%\" });\n            if (size) {\n                $spinner.css(\"font-size\", size);\n            }\n\n            return $spinner[0];\n        }\n\n        /**\r\n         * Find spinner\r\n         */\n\n    }, {\n        key: \"getSpinnerObjectWithParentElement\",\n        value: function getSpinnerObjectWithParentElement(parentElement) {\n            return parentElement.find(\"div.igv-spinner-container\");\n        }\n    }, {\n        key: \"startSpinnerAtParentElement\",\n\n\n        /**\r\n         * Start the spinner for the parent element, if it has one\r\n         */\n        value: function startSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").show();\n        }\n    }, {\n        key: \"stopSpinnerAtParentElement\",\n\n\n        /**\r\n         * Stop the spinner for the parent element, if it has one\r\n         * @param parentElement\r\n         */\n        value: function stopSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").hide();\n        }\n    }, {\n        key: \"parseUri\",\n        value: function parseUri(str) {\n\n            var o = parseUri_options,\n                m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\n                uri = {},\n                i = 14;\n\n            while (i--) {\n                uri[o.key[i]] = m[i] || \"\";\n            }uri[o.q.name] = {};\n            uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n                if ($1) uri[o.q.name][$1] = $2;\n            });\n\n            return uri;\n        }\n    }, {\n        key: \"domElementRectAsString\",\n        value: function domElementRectAsString(element) {\n            return \" x \" + element.clientLeft + \" y \" + element.clientTop + \" w \" + element.clientWidth + \" h \" + element.clientHeight;\n        }\n    }, {\n        key: \"isNumber\",\n        value: function isNumber(n) {\n\n            if (\"\" === n) {\n\n                return false;\n            } else if (undefined === n) {\n\n                return false;\n            } else {\n\n                return !isNaN(parseFloat(n)) && isFinite(n);\n            }\n        }\n    }, {\n        key: \"guid\",\n        value: function guid() {\n            return (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n        }\n    }, {\n        key: \"random\",\n\n\n        // Returns a random number between min (inclusive) and max (exclusive)\n        value: function random(min, max) {\n            return Math.random() * (max - min) + min;\n        }\n    }, {\n        key: \"numberFormatter\",\n\n\n        // StackOverflow: http://stackoverflow.com/a/10810674/116169\n        value: function numberFormatter(rawNumber) {\n\n            var dec = String(rawNumber).split(/[.,]/),\n                sep = ',',\n                decsep = '.';\n\n            return dec[0].split('').reverse().reduce(function (prev, now, i) {\n                return i % 3 === 0 ? prev + sep + now : prev + now;\n            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');\n        }\n    }, {\n        key: \"numberUnFormatter\",\n        value: function numberUnFormatter(formatedNumber) {\n\n            return formatedNumber.split(\",\").join().replace(\",\", \"\", \"g\");\n        }\n    }, {\n        key: \"translateMouseCoordinates\",\n\n\n        /**\r\n         * Translate the mouse coordinates for the event to the coordinates for the given target element\r\n         * @param e\r\n         * @param target\r\n         * @returns {{x: number, y: number}}\r\n         */\n        value: function translateMouseCoordinates(e, target) {\n\n            var eFixed = $.event.fix(e),\n                // Sets pageX and pageY for browsers that don't support them\n            posx = eFixed.pageX - $(target).offset().left,\n                posy = eFixed.pageY - $(target).offset().top;\n\n            return { x: posx, y: posy };\n        }\n    }, {\n        key: \"formatPopoverText\",\n\n\n        /**\r\n         * Format markup for popover text from an array of name value pairs [{name, value}]\r\n         */\n        value: function formatPopoverText(nameValueArray) {\n\n            var markup = \"<table class=\\\"igv-popover-table\\\">\";\n\n            nameValueArray.forEach(function (nameValue) {\n\n                if (nameValue.name) {\n                    //markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</td></tr>\";\n                    markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<div class=\\\"igv-popoverNameValue\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</div>\" + \"</td></tr>\";\n                } else {\n                    // not a name/value pair\n                    markup += \"<tr><td>\" + nameValue.toString() + \"</td></tr>\";\n                }\n            });\n\n            markup += \"</table>\";\n            return markup;\n        }\n    }, {\n        key: \"throttle\",\n        value: function throttle(fn, threshhold, scope) {\n            threshhold || (threshhold = 200);\n            var last, deferTimer;\n\n            return function () {\n                var context = scope || this;\n\n                var now = +new Date(),\n                    args = arguments;\n                if (last && now < last + threshhold) {\n                    // hold on to it\n                    clearTimeout(deferTimer);\n                    deferTimer = setTimeout(function () {\n                        last = now;\n                        fn.apply(context, args);\n                    }, threshhold);\n                } else {\n                    last = now;\n                    fn.apply(context, args);\n                }\n            };\n        }\n    }, {\n        key: \"splitStringRespectingQuotes\",\n        value: function splitStringRespectingQuotes(string, delim) {\n\n            var tokens = [],\n                len = string.length,\n                i,\n                n = 0,\n                quote = false,\n                c;\n\n            if (len > 0) {\n\n                tokens[n] = string.charAt(0);\n                for (i = 1; i < len; i++) {\n                    c = string.charAt(i);\n                    if (c === '\"') {\n                        quote = !quote;\n                    } else if (!quote && c === delim) {\n                        n++;\n                        tokens[n] = \"\";\n                    } else {\n                        tokens[n] += c;\n                    }\n                }\n            }\n            return tokens;\n        }\n    }, {\n        key: \"addAjaxExtensions\",\n\n\n        /**\r\n         * Extend jQuery's ajax function to handle binary requests.   Credit to Henry Algus:\r\n         *\r\n         * http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/\r\n         */\n        value: function addAjaxExtensions() {\n\n            // use this transport for \"binary\" data type\n            $.ajaxTransport(\"+binary\", function (options, originalOptions, jqXHR) {\n\n                return {\n                    // create new XMLHttpRequest\n                    send: function send(_, callback) {\n                        // setup all variables\n                        var xhr = new XMLHttpRequest(),\n                            url = options.url,\n                            type = options.type,\n                            responseType = \"arraybuffer\",\n                            data = options.data || null;\n\n                        xhr.addEventListener('load', function () {\n                            var data = {};\n                            data[options.dataType] = xhr.response;\n                            // make callback and send data\n                            callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());\n                        });\n\n                        xhr.open(type, url);\n                        xhr.responseType = responseType;\n\n                        if (options.headers) {\n                            for (var prop in options.headers) {\n                                if (options.headers.hasOwnProperty(prop)) {\n                                    xhr.setRequestHeader(prop, options.headers[prop]);\n                                }\n                            }\n                        }\n\n                        // TODO -- set any other options values\n                    },\n                    abort: function abort() {\n                        jqXHR.abort();\n                    }\n                };\n            });\n        }\n    }, {\n        key: \"isStringOrNumber\",\n\n\n        /**\r\n         * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.\r\n         *\r\n         * @param value\r\n         * @returns boolean\r\n         */\n        value: function isStringOrNumber(value) {\n            return value.substring || value.toFixed ? true : false;\n        }\n    }, {\n        key: \"constrainBBox\",\n        value: function constrainBBox($child, $parent) {\n\n            var delta,\n                topLeft,\n                bboxChild = {},\n                bboxParent = {};\n\n            bboxParent.left = bboxParent.top = 0;\n            bboxParent.right = $parent.outerWidth();\n            bboxParent.bottom = $parent.outerHeight();\n\n            topLeft = $child.offset();\n\n            bboxChild.left = topLeft.left - $parent.offset().left;\n            bboxChild.top = topLeft.top - $parent.offset().top;\n            bboxChild.right = bboxChild.left + $child.outerWidth();\n            bboxChild.bottom = bboxChild.top + $child.outerHeight();\n\n            delta = bboxChild.bottom - bboxParent.bottom;\n            if (delta > 0) {\n\n                // clamp to trackContainer bottom\n                topLeft.top -= delta;\n\n                bboxChild.top -= delta;\n                bboxChild.bottom -= delta;\n\n                delta = bboxChild.top - bboxParent.top;\n                if (delta < 0) {\n                    topLeft.top -= delta;\n                }\n            }\n\n            return topLeft;\n        }\n    }, {\n        key: \"log\",\n        value: function log(message) {\n            if (igv.enableLogging && console && console.log) {\n                console.log(message);\n            }\n        }\n    }]);\n\n    return Utils;\n}();\n\nexports.Utils = Utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy91dGlscy5qcz81NDZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5sZXQgcGFyc2VVcmlfb3B0aW9ucyA9IHtcclxuICAgICAgICBzdHJpY3RNb2RlOiBmYWxzZSxcclxuICAgICAgICBrZXk6IFtcInNvdXJjZVwiLCBcInByb3RvY29sXCIsIFwiYXV0aG9yaXR5XCIsIFwidXNlckluZm9cIiwgXCJ1c2VyXCIsIFwicGFzc3dvcmRcIiwgXCJob3N0XCIsIFwicG9ydFwiLCBcInJlbGF0aXZlXCIsIFwicGF0aFwiLCBcImRpcmVjdG9yeVwiLCBcImZpbGVcIiwgXCJxdWVyeVwiLCBcImFuY2hvclwiXSxcclxuICAgICAgICBxOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwicXVlcnlLZXlcIixcclxuICAgICAgICAgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcnNlcjoge1xyXG4gICAgICAgICAgICBzdHJpY3Q6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXHJcbiAgICAgICAgICAgIGxvb3NlOiAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShbXjpcXC8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5jbGFzcyBVdGlsc3tcclxuXHJcbiAgICBcclxuICAgIHN0YXRpYyBhZGRBbHBoYVRvUkdCKHJnYlN0cmluZywgYWxwaGEpIHtcclxuXHJcbiAgICAgICAgaWYgKHJnYlN0cmluZy5zdGFydHNXaXRoKFwicmdiXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JTdHJpbmcucmVwbGFjZShcInJnYlwiLCBcInJnYmFcIikucmVwbGFjZShcIilcIiwgXCIsIFwiICsgYWxwaGEgKyBcIilcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmdiU3RyaW5nICsgXCIgaXMgbm90IGFuIHJnYiBzdHlsZSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JTdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcHJlc2VudEFsZXJ0KHRyYWNrX2RpdixlcnJvcil7XHJcbiAgICAgICAgbGV0IGRpdj0gJChcIjxkaXY+XCIpLmNzcyh7XCJwb3NpdGlvblwiOlwiYWJzb2x1dGVcIixcImJhY2tncm91bmQtY29sb3JcIjpcIndoaXRlXCJ9KS5hdHRyKFwiY2xhc3NcIixcIm1sdi1hbGVydFwiKS5hcHBlbmRUbyh0cmFja19kaXYpO1xyXG4gICAgICAgIGxldCBkaXYxPSAkKFwiPGRpdj5cIikuY3NzKHtcImRpc3BsYXlcIjpcImZsZXhcIixcImp1c3RpZnktY29udGVudFwiOlwiY2VudGVyXCJ9KS5hcHBlbmRUbyhkaXYpO1xyXG4gICAgICAgIGRpdjEuYXBwZW5kKCQoJzxpIGNsYXNzPVwiZmFzIGZhLWV4Y2xhbWF0aW9uLWNpcmNsZVwiPjwvaT4nKS5jc3Moe2NvbG9yOlwicmVkXCIsXCJmb250LXNpemVcIjpcIjE2cHhcIixcInRleHQtYWxpZ25cIjpcImNlbnRlclwiLH0pKTtcclxuICAgICAgICBkaXYuYXBwZW5kKCQoXCI8ZGl2PlwiK2Vycm9yK1wiPC9kaXY+XCIpLmNzcyh7Y29sb3I6XCJyZWRcIixcImZvbnQtc2l6ZVwiOlwiMTRweFwiLFwidGV4dC1hbGlnblwiOlwiY2VudGVyXCJ9KSk7XHJcbiAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKCh0cmFja19kaXYud2lkdGgoKS8yKS0oZGl2LndpZHRoKCkvMikpO1xyXG4gICAgICAgIGxldCB0b3AgPU1hdGgucm91bmQoKHRyYWNrX2Rpdi5oZWlnaHQoKS8yKS0oZGl2LmhlaWdodCgpLzIpKTtcclxuICAgICAgICBkaXYuY3NzKHtcImxlZnRcIjpsZWZ0K1wicHhcIix0b3A6dG9wK1wicHhcIn0pO1xyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgIFxyXG5cclxuICAgIHN0YXRpYyBzcGlubmVyKHNpemUpIHtcclxuXHJcbiAgICAgICAgLy8gc3Bpbm5lclxyXG4gICAgICAgIHZhciAkY29udGFpbmVyLFxyXG4gICAgICAgICAgICAkc3Bpbm5lcjtcclxuXHJcbiAgICAgICAgJHNwaW5uZXIgPSAkKCc8aSBjbGFzcz1cImZhIGZhLWxnIGZhLXNwaW5uZXIgZmEtc3BpbiBpZ3Ytc3Bpbm5lclwiPicpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjUwJVwiLGxlZnQ6XCI1MCVcIn0pO1xyXG4gICAgICAgIGlmIChzaXplKSB7XHJcbiAgICAgICAgICAgICRzcGlubmVyLmNzcyhcImZvbnQtc2l6ZVwiLCBzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgICAgIHJldHVybiAkc3Bpbm5lclswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgc3Bpbm5lclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U3Bpbm5lck9iamVjdFdpdGhQYXJlbnRFbGVtZW50KHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50RWxlbWVudC5maW5kKFwiZGl2Lmlndi1zcGlubmVyLWNvbnRhaW5lclwiKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0aGUgc3Bpbm5lciBmb3IgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBoYXMgb25lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdGFydFNwaW5uZXJBdFBhcmVudEVsZW1lbnQocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbihcIi5mYS1zcGlubmVyXCIpLnNob3coKTsgIFxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBzcGlubmVyIGZvciB0aGUgcGFyZW50IGVsZW1lbnQsIGlmIGl0IGhhcyBvbmVcclxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdG9wU3Bpbm5lckF0UGFyZW50RWxlbWVudCAocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4oXCIuZmEtc3Bpbm5lclwiKS5oaWRlKCk7XHJcbiAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlVXJpKHN0cikge1xyXG5cclxuICAgICAgICB2YXIgbyA9IHBhcnNlVXJpX29wdGlvbnMsXHJcbiAgICAgICAgICAgIG0gPSBvLnBhcnNlcltvLnN0cmljdE1vZGUgPyBcInN0cmljdFwiIDogXCJsb29zZVwiXS5leGVjKHN0ciksXHJcbiAgICAgICAgICAgIHVyaSA9IHt9LFxyXG4gICAgICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pIHVyaVtvLmtleVtpXV0gPSBtW2ldIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIHVyaVtvLnEubmFtZV0gPSB7fTtcclxuICAgICAgICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XHJcbiAgICAgICAgICAgIGlmICgkMSkgdXJpW28ucS5uYW1lXVskMV0gPSAkMjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICBcclxuICAgIHN0YXRpYyBkb21FbGVtZW50UmVjdEFzU3RyaW5nKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gXCIgeCBcIiArIGVsZW1lbnQuY2xpZW50TGVmdCArIFwiIHkgXCIgKyBlbGVtZW50LmNsaWVudFRvcCArIFwiIHcgXCIgKyBlbGVtZW50LmNsaWVudFdpZHRoICsgXCIgaCBcIiArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgaXNOdW1iZXIobikge1xyXG5cclxuICAgICAgICBpZiAoXCJcIiA9PT0gbikge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIGlmICh1bmRlZmluZWQgPT09IG4pIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgZ3VpZCAgKCkge1xyXG4gICAgICAgIHJldHVybiAoXCIwMDAwXCIgKyAoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCA0KSA8PCAwKS50b1N0cmluZygzNikpLnNsaWNlKC00KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gKGluY2x1c2l2ZSkgYW5kIG1heCAoZXhjbHVzaXZlKVxyXG4gICAgc3RhdGljIHJhbmRvbShtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YWNrT3ZlcmZsb3c6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwODEwNjc0LzExNjE2OVxyXG4gICAgc3RhdGljIG51bWJlckZvcm1hdHRlcihyYXdOdW1iZXIpIHtcclxuXHJcbiAgICAgICAgdmFyIGRlYyA9IFN0cmluZyhyYXdOdW1iZXIpLnNwbGl0KC9bLixdLyksXHJcbiAgICAgICAgICAgIHNlcCA9ICcsJyxcclxuICAgICAgICAgICAgZGVjc2VwID0gJy4nO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVjWzBdLnNwbGl0KCcnKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBub3csIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICUgMyA9PT0gMCA/IHByZXYgKyBzZXAgKyBub3cgOiBwcmV2ICsgbm93O1xyXG4gICAgICAgICAgICB9KS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpICsgKGRlY1sxXSA/IGRlY3NlcCArIGRlY1sxXSA6ICcnKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIG51bWJlclVuRm9ybWF0dGVyIChmb3JtYXRlZE51bWJlcikge1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0ZWROdW1iZXIuc3BsaXQoXCIsXCIpLmpvaW4oKS5yZXBsYWNlKFwiLFwiLCBcIlwiLCBcImdcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIHRoZSBtb3VzZSBjb29yZGluYXRlcyBmb3IgdGhlIGV2ZW50IHRvIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gZVxyXG4gICAgICogQHBhcmFtIHRhcmdldFxyXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsIHRhcmdldCkge1xyXG5cclxuICAgICAgICB2YXIgZUZpeGVkID0gJC5ldmVudC5maXgoZSksICAgLy8gU2V0cyBwYWdlWCBhbmQgcGFnZVkgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGVtXHJcbiAgICAgICAgICAgIHBvc3ggPSBlRml4ZWQucGFnZVggLSAkKHRhcmdldCkub2Zmc2V0KCkubGVmdCxcclxuICAgICAgICAgICAgcG9zeSA9IGVGaXhlZC5wYWdlWSAtICQodGFyZ2V0KS5vZmZzZXQoKS50b3A7XHJcblxyXG4gICAgICAgIHJldHVybiB7eDogcG9zeCwgeTogcG9zeX1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0IG1hcmt1cCBmb3IgcG9wb3ZlciB0ZXh0IGZyb20gYW4gYXJyYXkgb2YgbmFtZSB2YWx1ZSBwYWlycyBbe25hbWUsIHZhbHVlfV1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcm1hdFBvcG92ZXJUZXh0IChuYW1lVmFsdWVBcnJheSkge1xyXG5cclxuICAgICAgICB2YXIgbWFya3VwID0gXCI8dGFibGUgY2xhc3M9XFxcImlndi1wb3BvdmVyLXRhYmxlXFxcIj5cIjtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobmFtZVZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZVZhbHVlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vbWFya3VwICs9IFwiPHRyPjx0ZCBjbGFzcz1cXFwiaWd2LXBvcG92ZXItdGRcXFwiPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJOYW1lXFxcIj5cIiArIG5hbWVWYWx1ZS5uYW1lICsgXCI8L3NwYW4+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3ZlclZhbHVlXFxcIj5cIiArIG5hbWVWYWx1ZS52YWx1ZSArIFwiPC9zcGFuPlwiICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgICAgICBtYXJrdXAgKz0gXCI8dHI+PHRkIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlci10ZFxcXCI+XCIgKyBcIjxkaXYgY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVZhbHVlXFxcIj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVxcXCI+XCIgKyBuYW1lVmFsdWUubmFtZSArIFwiPC9zcGFuPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJWYWx1ZVxcXCI+XCIgKyBuYW1lVmFsdWUudmFsdWUgKyBcIjwvc3Bhbj5cIiArIFwiPC9kaXY+XCIgKyBcIjwvdGQ+PC90cj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIG5hbWUvdmFsdWUgcGFpclxyXG4gICAgICAgICAgICAgICAgbWFya3VwICs9IFwiPHRyPjx0ZD5cIiArIG5hbWVWYWx1ZS50b1N0cmluZygpICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWFya3VwICs9IFwiPC90YWJsZT5cIjtcclxuICAgICAgICByZXR1cm4gbWFya3VwO1xyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyB0aHJvdHRsZShmbiwgdGhyZXNoaG9sZCwgc2NvcGUpIHtcclxuICAgICAgICB0aHJlc2hob2xkIHx8ICh0aHJlc2hob2xkID0gMjAwKTtcclxuICAgICAgICB2YXIgbGFzdCwgZGVmZXJUaW1lcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIG5vdyA8IGxhc3QgKyB0aHJlc2hob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBob2xkIG9uIHRvIGl0XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XHJcbiAgICAgICAgICAgICAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0sIHRocmVzaGhvbGQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgc3BsaXRTdHJpbmdSZXNwZWN0aW5nUXVvdGVzKHN0cmluZywgZGVsaW0pIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VucyA9IFtdLFxyXG4gICAgICAgICAgICBsZW4gPSBzdHJpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBuID0gMCxcclxuICAgICAgICAgICAgcXVvdGUgPSBmYWxzZSxcclxuICAgICAgICAgICAgYztcclxuXHJcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIHRva2Vuc1tuXSA9IHN0cmluZy5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYyA9IHN0cmluZy5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gIXF1b3RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1b3RlICYmIGMgPT09IGRlbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tuXSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbbl0gKz0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBqUXVlcnkncyBhamF4IGZ1bmN0aW9uIHRvIGhhbmRsZSBiaW5hcnkgcmVxdWVzdHMuICAgQ3JlZGl0IHRvIEhlbnJ5IEFsZ3VzOlxyXG4gICAgICpcclxuICAgICAqIGh0dHA6Ly93d3cuaGVucnlhbGd1cy5jb20vcmVhZGluZy1iaW5hcnktZmlsZXMtdXNpbmctanF1ZXJ5LWFqYXgvXHJcbiAgICAgKi9cclxuICAgc3RhdGljIGFkZEFqYXhFeHRlbnNpb25zICgpIHtcclxuXHJcbiAgICAgICAgLy8gdXNlIHRoaXMgdHJhbnNwb3J0IGZvciBcImJpbmFyeVwiIGRhdGEgdHlwZVxyXG4gICAgICAgICQuYWpheFRyYW5zcG9ydChcIitiaW5hcnlcIiwgZnVuY3Rpb24gKG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoXywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBhbGwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBvcHRpb25zLnVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29wdGlvbnMuZGF0YVR5cGVdID0geGhyLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGNhbGxiYWNrIGFuZCBzZW5kIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIGRhdGEsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKHR5cGUsIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMuaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3AsIG9wdGlvbnMuaGVhZGVyc1twcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gc2V0IGFueSBvdGhlciBvcHRpb25zIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcgb3IgbnVtYmVyLiAgTm90IHVzaW5nIHR5cGVvZiBhcyBpdCBmYWlscyBvbiBib3hlZCBwcmltaXRpdmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMgYm9vbGVhblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNTdHJpbmdPck51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUuc3Vic3RyaW5nIHx8IHZhbHVlLnRvRml4ZWQpID8gdHJ1ZSA6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBjb25zdHJhaW5CQm94KCRjaGlsZCwgJHBhcmVudCkge1xyXG5cclxuICAgICAgICB2YXIgZGVsdGEsXHJcbiAgICAgICAgICAgIHRvcExlZnQsXHJcbiAgICAgICAgICAgIGJib3hDaGlsZCA9IHt9LFxyXG4gICAgICAgICAgICBiYm94UGFyZW50ID0ge307XHJcblxyXG4gICAgICAgIGJib3hQYXJlbnQubGVmdCA9IGJib3hQYXJlbnQudG9wID0gMDtcclxuICAgICAgICBiYm94UGFyZW50LnJpZ2h0ID0gJHBhcmVudC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgYmJveFBhcmVudC5ib3R0b20gPSAkcGFyZW50Lm91dGVySGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIHRvcExlZnQgPSAkY2hpbGQub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgIGJib3hDaGlsZC5sZWZ0ID0gdG9wTGVmdC5sZWZ0IC0gJHBhcmVudC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgIGJib3hDaGlsZC50b3AgPSB0b3BMZWZ0LnRvcCAtICRwYXJlbnQub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgIGJib3hDaGlsZC5yaWdodCA9IGJib3hDaGlsZC5sZWZ0ICsgJGNoaWxkLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBiYm94Q2hpbGQuYm90dG9tID0gYmJveENoaWxkLnRvcCArICRjaGlsZC5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICBkZWx0YSA9IGJib3hDaGlsZC5ib3R0b20gLSBiYm94UGFyZW50LmJvdHRvbTtcclxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjbGFtcCB0byB0cmFja0NvbnRhaW5lciBib3R0b21cclxuICAgICAgICAgICAgdG9wTGVmdC50b3AgLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBiYm94Q2hpbGQudG9wIC09IGRlbHRhO1xyXG4gICAgICAgICAgICBiYm94Q2hpbGQuYm90dG9tIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgZGVsdGEgPSBiYm94Q2hpbGQudG9wIC0gYmJveFBhcmVudC50b3A7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRvcExlZnQudG9wIC09IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvcExlZnQ7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgbG9nKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaWd2LmVuYWJsZUxvZ2dpbmcgJiYgY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7VXRpbHN9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFQQTtBQUNBO0FBY0E7Ozs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7QUFHQTtBQUNBO0FBRUE7Ozs7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFFQTs7Ozs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBbUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/utils.js\n");

/***/ }),

/***/ "../MLVPanel/src/vendor/inflate.js":
/*!************************************!*\
  !*** .Panel/src/vendor/inflate.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS = 15; // 32K LZ77 window\nvar DEF_WBITS = MAX_WBITS;\nvar MAX_MEM_LEVEL = 9;\nvar MANY = 1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT = 0x20;\n\nvar Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\n\nvar Z_DEFLATED = 8;\n\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\nvar Z_ERRNO = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\nvar Z_VERSION_ERROR = -6;\n\nvar METHOD = 0; // waiting for method byte\nvar FLAG = 1; // waiting for flag byte\nvar DICT4 = 2; // four dictionary check bytes to go\nvar DICT3 = 3; // three dictionary check bytes to go\nvar DICT2 = 4; // two dictionary check bytes to go\nvar DICT1 = 5; // one dictionary check byte to go\nvar DICT0 = 6; // waiting for inflateSetDictionary\nvar BLOCKS = 7; // decompressing blocks\nvar CHECK4 = 8; // four check bytes to go\nvar CHECK3 = 9; // three check bytes to go\nvar CHECK2 = 10; // two check bytes to go\nvar CHECK1 = 11; // one check byte to go\nvar DONE = 12; // finished check, done\nvar BAD = 13; // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE = 0; // get type bits (3, including end bit)\nvar IB_LENS = 1; // get lengths for stored\nvar IB_STORED = 2; // processing stored block\nvar IB_TABLE = 3; // get table lengths\nvar IB_BTREE = 4; // get bit lengths tree for a dynamic block\nvar IB_DTREE = 5; // get length, distance trees for a dynamic block\nvar IB_CODES = 6; // processing fixed or dynamic block\nvar IB_DRY = 7; // output remaining window bytes\nvar IB_DONE = 8; // finished last block, done\nvar IB_BAD = 9; // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];\nvar fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];\n\n// Tables for deflate from PKZIP's appnote.txt.\nvar cplens = [// Copy lengths for literal codes 257..285\n3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\n\n// see note #13 above about 258\nvar cplext = [// Extra bits for literal codes 257..285\n0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n];\n\nvar cpdist = [// Copy offsets for distance codes 0..29\n1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n\nvar cpdext = [// Extra bits for distance codes\n0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {}\n\nZStream.prototype.inflateInit = function (w, nowrap) {\n  if (!w) {\n    w = DEF_WBITS;\n  }\n  if (nowrap) {\n    nowrap = false;\n  }\n  this.istate = new Inflate();\n  return this.istate.inflateInit(this, nowrap ? -w : w);\n};\n\nZStream.prototype.inflate = function (f) {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  return this.istate.inflate(this, f);\n};\n\nZStream.prototype.inflateEnd = function () {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  var ret = istate.inflateEnd(this);\n  this.istate = null;\n  return ret;\n};\nZStream.prototype.inflateSync = function () {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSync(this);\n};\nZStream.prototype.inflateSetDictionary = function (dictionary, dictLength) {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSetDictionary(this, dictionary, dictLength);\n};\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n  this.was = [0];\n}\n\nInflate.prototype.inflateReset = function (z) {\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n\n  z.total_in = z.total_out = 0;\n  z.msg = null;\n  z.istate.mode = z.istate.nowrap != 0 ? BLOCKS : METHOD;\n  z.istate.blocks.reset(z, null);\n  return Z_OK;\n};\n\nInflate.prototype.inflateEnd = function (z) {\n  if (this.blocks != null) this.blocks.free(z);\n  this.blocks = null;\n  return Z_OK;\n};\n\nInflate.prototype.inflateInit = function (z, w) {\n  z.msg = null;\n  this.blocks = null;\n\n  // handle undocumented nowrap option (no zlib header or check)\n  var nowrap = 0;\n  if (w < 0) {\n    w = -w;\n    nowrap = 1;\n  }\n\n  // set window size\n  if (w < 8 || w > 15) {\n    this.inflateEnd(z);\n    return Z_STREAM_ERROR;\n  }\n  this.wbits = w;\n\n  z.istate.blocks = new InfBlocks(z, z.istate.nowrap != 0 ? null : this, 1 << w);\n\n  // reset state\n  this.inflateReset(z);\n  return Z_OK;\n};\n\nInflate.prototype.inflate = function (z, f) {\n  var r, b;\n\n  if (z == null || z.istate == null || z.next_in == null) return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  while (true) {\n    switch (z.istate.mode) {\n      case METHOD:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED) {\n          z.istate.mode = BAD;\n          z.msg = \"unknown compression method\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n          z.istate.mode = BAD;\n          z.msg = \"invalid window size\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        z.istate.mode = FLAG;\n      case FLAG:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        b = z.next_in[z.next_in_index++] & 0xff;\n\n        if (((z.istate.method << 8) + b) % 31 != 0) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        if ((b & PRESET_DICT) == 0) {\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = DICT3;\n      case DICT3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = DICT2;\n      case DICT2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = DICT1;\n      case DICT1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0; // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if (r == Z_DATA_ERROR) {\n          z.istate.mode = BAD;\n          z.istate.marker = 0; // can try inflateSync\n          break;\n        }\n        if (r == Z_OK) {\n          r = f;\n        }\n        if (r != Z_STREAM_END) {\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if (z.istate.nowrap != 0) {\n          z.istate.mode = DONE;\n          break;\n        }\n        z.istate.mode = CHECK4;\n      case CHECK4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = CHECK3;\n      case CHECK3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n\n        if (z.istate.was[0] != z.istate.need) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n};\n\nInflate.prototype.inflateSetDictionary = function (z, dictionary, dictLength) {\n  var index = 0;\n  var length = dictLength;\n  if (z == null || z.istate == null || z.istate.mode != DICT0) return Z_STREAM_ERROR;\n\n  if (z._adler.adler32(1, dictionary, 0, dictLength) != z.adler) {\n    return Z_DATA_ERROR;\n  }\n\n  z.adler = z._adler.adler32(0, null, 0, 0);\n\n  if (length >= 1 << z.istate.wbits) {\n    length = (1 << z.istate.wbits) - 1;\n    index = dictLength - length;\n  }\n  z.istate.blocks.set_dictionary(dictionary, index, length);\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255];\n\nInflate.prototype.inflateSync = function (z) {\n  var n; // number of bytes to look at\n  var p; // pointer to bytes\n  var m; // number of marker bytes found in a row\n  var r, w; // temporaries to save total_in and total_out\n\n  // set up\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n  if (z.istate.mode != BAD) {\n    z.istate.mode = BAD;\n    z.istate.marker = 0;\n  }\n  if ((n = z.avail_in) == 0) return Z_BUF_ERROR;\n  p = z.next_in_index;\n  m = z.istate.marker;\n\n  // search\n  while (n != 0 && m < 4) {\n    if (z.next_in[p] == mark[m]) {\n      m++;\n    } else if (z.next_in[p] != 0) {\n      m = 0;\n    } else {\n      m = 4 - m;\n    }\n    p++;n--;\n  }\n\n  // restore\n  z.total_in += p - z.next_in_index;\n  z.next_in_index = p;\n  z.avail_in = n;\n  z.istate.marker = m;\n\n  // return no joy or set up to restart on a new block\n  if (m != 4) {\n    return Z_DATA_ERROR;\n  }\n  r = z.total_in;w = z.total_out;\n  this.inflateReset(z);\n  z.total_in = r;z.total_out = w;\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n// implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n// but removes the length bytes of the resulting empty stored block. When\n// decompressing, PPP checks that at the end of input packet, inflate is\n// waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function (z) {\n  if (z == null || z.istate == null || z.istate.blocks == null) return Z_STREAM_ERROR;\n  return z.istate.blocks.sync_point();\n};\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n  this.hufts = new Int32Array(MANY * 3);\n  this.window = new Uint8Array(w);\n  this.end = w;\n  this.checkfn = checkfn;\n  this.mode = IB_TYPE;\n  this.reset(z, null);\n\n  this.left = 0; // if STORED, bytes left to copy \n\n  this.table = 0; // table lengths (14 bits) \n  this.index = 0; // index into blens (or border) \n  this.blens = null; // bit lengths of codes \n  this.bb = new Int32Array(1); // bit length tree depth \n  this.tb = new Int32Array(1); // bit length decoding tree \n\n  this.codes = new InfCodes();\n\n  this.last = 0; // true if this block is the last block \n\n  // mode independent information \n  this.bitk = 0; // bits in bit buffer \n  this.bitb = 0; // bit buffer \n  this.read = 0; // window read pointer \n  this.write = 0; // window write pointer \n  this.check = 0; // check on output \n\n  this.inftree = new InfTree();\n}\n\nInfBlocks.prototype.reset = function (z, c) {\n  if (c) c[0] = this.check;\n  if (this.mode == IB_CODES) {\n    this.codes.free(z);\n  }\n  this.mode = IB_TYPE;\n  this.bitk = 0;\n  this.bitb = 0;\n  this.read = this.write = 0;\n\n  if (this.checkfn) z.adler = this.check = z._adler.adler32(0, null, 0, 0);\n};\n\nInfBlocks.prototype.proc = function (z, r) {\n  var t; // temporary storage\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n\n  // copy input/output information to locals (UPDATE macro restores)\n  {\n    p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n  }\n  {\n    q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n  }\n\n  // process input based on current state\n  while (true) {\n    switch (this.mode) {\n      case IB_TYPE:\n\n        while (k < 3) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n        t = b & 7;\n        this.last = t & 1;\n\n        switch (t >>> 1) {\n          case 0:\n            // stored \n            {\n              b >>>= 3;k -= 3;\n            }\n            t = k & 7; // go to byte boundary\n\n            {\n              b >>>= t;k -= t;\n            }\n            this.mode = IB_LENS; // get length of stored block\n            break;\n          case 1:\n            // fixed\n            {\n              var bl = new Int32Array(1);\n              var bd = new Int32Array(1);\n              var tl = [];\n              var td = [];\n\n              inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n            }\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_CODES;\n            break;\n          case 2:\n            // dynamic\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_TABLE;\n            break;\n          case 3:\n            // illegal\n\n            {\n              b >>>= 3;k -= 3;\n            }\n            this.mode = BAD;\n            z.msg = \"invalid block type\";\n            r = Z_DATA_ERROR;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n        }\n        break;\n      case IB_LENS:\n        while (k < 32) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {\n          this.mode = BAD;\n          z.msg = \"invalid stored block lengths\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.left = b & 0xffff;\n        b = k = 0; // dump bits\n        this.mode = left != 0 ? IB_STORED : this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_STORED:\n        if (n == 0) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        if (m == 0) {\n          if (q == end && read != 0) {\n            q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n          }\n          if (m == 0) {\n            this.write = q;\n            r = this.inflate_flush(z, r);\n            q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n            if (q == this.end && this.read != 0) {\n              q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n            }\n            if (m == 0) {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        t = this.left;\n        if (t > n) t = n;\n        if (t > m) t = m;\n        arrayCopy(z.next_in, p, window, q, t);\n        p += t;n -= t;\n        q += t;m -= t;\n        if ((this.left -= t) != 0) break;\n        this.mode = this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_TABLE:\n\n        while (k < 14) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.table = t = b & 0x3fff;\n        if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {\n          this.mode = IB_BAD;\n          z.msg = \"too many length or distance symbols\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);\n        if (this.blens == null || this.blens.length < t) {\n          this.blens = new Int32Array(t);\n        } else {\n          for (var i = 0; i < t; i++) {\n            this.blens[i] = 0;\n          }\n        }\n\n        {\n          b >>>= 14;k -= 14;\n        }\n\n        this.index = 0;\n        this.mode = IB_BTREE;\n      case IB_BTREE:\n        while (this.index < 4 + (this.table >>> 10)) {\n          while (k < 3) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          this.blens[INFBLOCKS_BORDER[this.index++]] = b & 7;\n\n          {\n            b >>>= 3;k -= 3;\n          }\n        }\n\n        while (this.index < 19) {\n          this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n        }\n\n        this.bb[0] = 7;\n        t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n        if (t != Z_OK) {\n          r = t;\n          if (r == Z_DATA_ERROR) {\n            this.blens = null;\n            this.mode = IB_BAD;\n          }\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        this.index = 0;\n        this.mode = IB_DTREE;\n      case IB_DTREE:\n        while (true) {\n          t = this.table;\n          if (!(this.index < 258 + (t & 0x1f) + (t >> 5 & 0x1f))) {\n            break;\n          }\n\n          var h; //int[]\n          var i, j, c;\n\n          t = this.bb[0];\n\n          while (k < t) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          //\t  if (this.tb[0]==-1){\n          //            dlog(\"null...\");\n          //\t  }\n\n          t = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 1];\n          c = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n          if (c < 16) {\n            b >>>= t;k -= t;\n            this.blens[this.index++] = c;\n          } else {\n            // c == 16..18\n            i = c == 18 ? 7 : c - 14;\n            j = c == 18 ? 11 : 3;\n\n            while (k < t + i) {\n              if (n != 0) {\n                r = Z_OK;\n              } else {\n                this.bitb = b;this.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;z.next_in_index = p;\n                this.write = q;\n                return this.inflate_flush(z, r);\n              };\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;\n              k += 8;\n            }\n\n            b >>>= t;k -= t;\n\n            j += b & inflate_mask[i];\n\n            b >>>= i;k -= i;\n\n            i = this.index;\n            t = this.table;\n            if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {\n              this.blens = null;\n              this.mode = IB_BAD;\n              z.msg = \"invalid bit length repeat\";\n              r = Z_DATA_ERROR;\n\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n\n            c = c == 16 ? this.blens[i - 1] : 0;\n            do {\n              this.blens[i++] = c;\n            } while (--j != 0);\n            this.index = i;\n          }\n        }\n\n        this.tb[0] = -1;\n        {\n          var bl = new Int32Array(1);\n          var bd = new Int32Array(1);\n          var tl = new Int32Array(1);\n          var td = new Int32Array(1);\n          bl[0] = 9; // must be <= 9 for lookahead assumptions\n          bd[0] = 6; // must be <= 9 for lookahead assumptions\n\n          t = this.table;\n          t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), this.blens, bl, bd, tl, td, this.hufts, z);\n\n          if (t != Z_OK) {\n            if (t == Z_DATA_ERROR) {\n              this.blens = null;\n              this.mode = BAD;\n            }\n            r = t;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          }\n          this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n        }\n        this.mode = IB_CODES;\n      case IB_CODES:\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n\n        if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END) {\n          return this.inflate_flush(z, r);\n        }\n        r = Z_OK;\n        this.codes.free(z);\n\n        p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n\n        if (this.last == 0) {\n          this.mode = IB_TYPE;\n          break;\n        }\n        this.mode = IB_DRY;\n      case IB_DRY:\n        this.write = q;\n        r = this.inflate_flush(z, r);\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n        if (this.read != this.write) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.mode = DONE;\n      case IB_DONE:\n        r = Z_STREAM_END;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n      case IB_BAD:\n        r = Z_DATA_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n    }\n  }\n};\n\nInfBlocks.prototype.free = function (z) {\n  this.reset(z, null);\n  this.window = null;\n  this.hufts = null;\n};\n\nInfBlocks.prototype.set_dictionary = function (d, start, n) {\n  arrayCopy(d, start, window, 0, n);\n  this.read = this.write = n;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function () {\n  return this.mode == IB_LENS;\n};\n\n// copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function (z, r) {\n  var n;\n  var p;\n  var q;\n\n  // local copies of source and destination pointers\n  p = z.next_out_index;\n  q = this.read;\n\n  // compute number of bytes to copy as far as end of window\n  n = (q <= this.write ? this.write : this.end) - q;\n  if (n > z.avail_out) n = z.avail_out;\n  if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n  // update counters\n  z.avail_out -= n;\n  z.total_out += n;\n\n  // update check information\n  if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n  // copy as far as end of window\n  arrayCopy(this.window, q, z.next_out, p, n);\n  p += n;\n  q += n;\n\n  // see if more to copy at beginning of window\n  if (q == this.end) {\n    // wrap pointers\n    q = 0;\n    if (this.write == this.end) this.write = 0;\n\n    // compute bytes to copy\n    n = this.write - q;\n    if (n > z.avail_out) n = z.avail_out;\n    if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n    // copy\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n  }\n\n  // update pointers\n  z.next_out_index = p;\n  this.read = q;\n\n  // done\n  return r;\n};\n\n//\n// InfCodes.java\n//\n\nvar IC_START = 0; // x: set up for LEN\nvar IC_LEN = 1; // i: get length/literal/eob next\nvar IC_LENEXT = 2; // i: getting length extra (have base)\nvar IC_DIST = 3; // i: get distance next\nvar IC_DISTEXT = 4; // i: getting distance extra\nvar IC_COPY = 5; // o: copying bytes in window, waiting for space\nvar IC_LIT = 6; // o: got literal, waiting for output space\nvar IC_WASH = 7; // o: got eob, possibly still output waiting\nvar IC_END = 8; // x: got eob and all data flushed\nvar IC_BADCODE = 9; // x: got error\n\nfunction InfCodes() {}\n\nInfCodes.prototype.init = function (bl, bd, tl, tl_index, td, td_index, z) {\n  this.mode = IC_START;\n  this.lbits = bl;\n  this.dbits = bd;\n  this.ltree = tl;\n  this.ltree_index = tl_index;\n  this.dtree = td;\n  this.dtree_index = td_index;\n  this.tree = null;\n};\n\nInfCodes.prototype.proc = function (s, z, r) {\n  var j; // temporary storage\n  var t; // temporary pointer (int[])\n  var tindex; // temporary pointer\n  var e; // extra bits or operation\n  var b = 0; // bit buffer\n  var k = 0; // bits in bit buffer\n  var p = 0; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var f; // pointer to copy strings from\n\n  // copy input/output information to locals (UPDATE macro restores)\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // process input and output based on current state\n  while (true) {\n    switch (this.mode) {\n      // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:\n        // x: set up for LEN\n        if (m >= 258 && n >= 10) {\n\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          r = this.inflate_fast(this.lbits, this.dbits, this.ltree, this.ltree_index, this.dtree, this.dtree_index, s, z);\n\n          p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n          q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n          if (r != Z_OK) {\n            this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n            break;\n          }\n        }\n        this.need = this.lbits;\n        this.tree = this.ltree;\n        this.tree_index = this.ltree_index;\n\n        this.mode = IC_LEN;\n      case IC_LEN:\n        // i: get length/literal/eob next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n\n        if (e == 0) {\n          // literal\n          this.lit = this.tree[tindex + 2];\n          this.mode = IC_LIT;\n          break;\n        }\n        if ((e & 16) != 0) {\n          // length\n          this.get = e & 15;\n          this.len = this.tree[tindex + 2];\n          this.mode = IC_LENEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        if ((e & 32) != 0) {\n          // end of block\n          this.mode = IC_WASH;\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid literal/length code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_LENEXT:\n        // i: getting length extra (have base)\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.len += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.need = this.dbits;\n        this.tree = this.dtree;\n        this.tree_index = this.dtree_index;\n        this.mode = IC_DIST;\n      case IC_DIST:\n        // i: get distance next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n        if ((e & 16) != 0) {\n          // distance\n          this.get = e & 15;\n          this.dist = this.tree[tindex + 2];\n          this.mode = IC_DISTEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid distance code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_DISTEXT:\n        // i: getting distance extra\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.dist += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.mode = IC_COPY;\n      case IC_COPY:\n        // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while (f < 0) {\n          // modulo window size-\"while\" instead\n          f += s.end; // of \"if\" handles invalid distances\n        }\n        while (this.len != 0) {\n\n          if (m == 0) {\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.write = q;r = s.inflate_flush(z, r);\n              q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n              if (q == s.end && s.read != 0) {\n                q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n              }\n\n              if (m == 0) {\n                s.bitb = b;s.bitk = k;\n                z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n            }\n          }\n\n          s.window[q++] = s.window[f++];m--;\n\n          if (f == s.end) f = 0;\n          this.len--;\n        }\n        this.mode = IC_START;\n        break;\n      case IC_LIT:\n        // o: got literal, waiting for output space\n        if (m == 0) {\n          if (q == s.end && s.read != 0) {\n            q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n          }\n          if (m == 0) {\n            s.write = q;r = s.inflate_flush(z, r);\n            q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.bitb = b;s.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              s.write = q;\n              return s.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        s.window[q++] = this.lit;m--;\n\n        this.mode = IC_START;\n        break;\n      case IC_WASH:\n        // o: got eob, possibly more output\n        if (k > 7) {\n          // return unused byte, if any\n          k -= 8;\n          n++;\n          p--; // can always return one\n        }\n\n        s.write = q;r = s.inflate_flush(z, r);\n        q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n        if (s.read != s.write) {\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          return s.inflate_flush(z, r);\n        }\n        this.mode = IC_END;\n      case IC_END:\n        r = Z_STREAM_END;\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_BADCODE:\n        // x: got error\n\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n    }\n  }\n};\n\nInfCodes.prototype.free = function (z) {}\n//  ZFREE(z, c);\n\n\n// Called with number of bytes left to write in window at least 258\n// (the maximum string length) and number of input bytes available\n// at least ten.  The ten bytes are six bytes for the longest length/\n// distance pair plus four bytes for overloading the bit buffer.\n\n;InfCodes.prototype.inflate_fast = function (bl, bd, tl, tl_index, td, td_index, s, z) {\n  var t; // temporary pointer\n  var tp; // temporary pointer (int[])\n  var tp_index; // temporary pointer\n  var e; // extra bits or operation\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var ml; // mask for literal/length tree\n  var md; // mask for distance tree\n  var c; // bytes to copy\n  var d; // distance back to copy from\n  var r; // copy source pointer\n\n  var tp_index_t_3; // (tp_index+t)*3\n\n  // load input, output, bit values\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // initialize masks\n  ml = inflate_mask[bl];\n  md = inflate_mask[bd];\n\n  // do until not enough input or output space for fast loop\n  do {\n    // assume called with m >= 258 && n >= 10\n    // get literal/length code\n    while (k < 20) {\n      // max bits for literal/length code\n      n--;\n      b |= (z.next_in[p++] & 0xff) << k;k += 8;\n    }\n\n    t = b & ml;\n    tp = tl;\n    tp_index = tl_index;\n    tp_index_t_3 = (tp_index + t) * 3;\n    if ((e = tp[tp_index_t_3]) == 0) {\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      s.window[q++] = tp[tp_index_t_3 + 2];\n      m--;\n      continue;\n    }\n    do {\n\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      if ((e & 16) != 0) {\n        e &= 15;\n        c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n        b >>= e;k -= e;\n\n        // decode distance base of block to copy\n        while (k < 15) {\n          // max bits for distance code\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;k += 8;\n        }\n\n        t = b & md;\n        tp = td;\n        tp_index = td_index;\n        tp_index_t_3 = (tp_index + t) * 3;\n        e = tp[tp_index_t_3];\n\n        do {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          if ((e & 16) != 0) {\n            // get extra bits to add to distance base\n            e &= 15;\n            while (k < e) {\n              // get extra bits (up to 13)\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;k += 8;\n            }\n\n            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n            b >>= e;k -= e;\n\n            // do the copy\n            m -= c;\n            if (q >= d) {\n              // offset before dest\n              //  just copy\n              r = q - d;\n              if (q - r > 0 && 2 > q - r) {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              } else {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              }\n            } else {\n              // else offset after destination\n              r = q - d;\n              do {\n                r += s.end; // force pointer in window\n              } while (r < 0); // covers invalid distances\n              e = s.end - r;\n              if (c > e) {\n                // if source crosses,\n                c -= e; // wrapped copy\n                if (q - r > 0 && e > q - r) {\n                  do {\n                    s.window[q++] = s.window[r++];\n                  } while (--e != 0);\n                } else {\n                  arrayCopy(s.window, r, s.window, q, e);\n                  q += e;r += e;e = 0;\n                }\n                r = 0; // copy rest from start of window\n              }\n            }\n\n            // copy all or what's left\n            do {\n              s.window[q++] = s.window[r++];\n            } while (--c != 0);\n            break;\n          } else if ((e & 64) == 0) {\n            t += tp[tp_index_t_3 + 2];\n            t += b & inflate_mask[e];\n            tp_index_t_3 = (tp_index + t) * 3;\n            e = tp[tp_index_t_3];\n          } else {\n            z.msg = \"invalid distance code\";\n\n            c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n\n            return Z_DATA_ERROR;\n          }\n        } while (true);\n        break;\n      }\n\n      if ((e & 64) == 0) {\n        t += tp[tp_index_t_3 + 2];\n        t += b & inflate_mask[e];\n        tp_index_t_3 = (tp_index + t) * 3;\n        if ((e = tp[tp_index_t_3]) == 0) {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          s.window[q++] = tp[tp_index_t_3 + 2];\n          m--;\n          break;\n        }\n      } else if ((e & 32) != 0) {\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_STREAM_END;\n      } else {\n        z.msg = \"invalid literal/length code\";\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_DATA_ERROR;\n      }\n    } while (true);\n  } while (m >= 258 && n >= 10);\n\n  // not enough input or output--restore pointers and return\n  c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n  s.bitb = b;s.bitk = k;\n  z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n  s.write = q;\n\n  return Z_OK;\n};\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {}\n\nInfTree.prototype.huft_build = function (b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n  // Given a list of code lengths and a maximum table size, make a set of\n  // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n  // if the given code set is incomplete (the tables are still built in this\n  // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n  // lengths), or Z_MEM_ERROR if not enough memory.\n\n  var a; // counter for codes of length k\n  var f; // i repeats in table every f entries\n  var g; // maximum code length\n  var h; // table level\n  var i; // counter, current code\n  var j; // counter\n  var k; // number of bits in current code\n  var l; // bits per table (returned in m)\n  var mask; // (1 << w) - 1, to avoid cc -O bug on HP\n  var p; // pointer into c[], b[], or v[]\n  var q; // points to current table\n  var w; // bits before this table == (l * h)\n  var xp; // pointer into x\n  var y; // number of dummy codes added\n  var z; // number of entries in current table\n\n  // Generate counts for each bit length\n\n  p = 0;i = n;\n  do {\n    this.c[b[bindex + p]]++;p++;i--; // assume all entries <= BMAX\n  } while (i != 0);\n\n  if (this.c[0] == n) {\n    // null input--all zero length codes\n    t[0] = -1;\n    m[0] = 0;\n    return Z_OK;\n  }\n\n  // Find minimum and maximum length, bound *m by those\n  l = m[0];\n  for (j = 1; j <= BMAX; j++) {\n    if (this.c[j] != 0) break;\n  }k = j; // minimum code length\n  if (l < j) {\n    l = j;\n  }\n  for (i = BMAX; i != 0; i--) {\n    if (this.c[i] != 0) break;\n  }\n  g = i; // maximum code length\n  if (l > i) {\n    l = i;\n  }\n  m[0] = l;\n\n  // Adjust last length count to fill out codes, if needed\n  for (y = 1 << j; j < i; j++, y <<= 1) {\n    if ((y -= this.c[j]) < 0) {\n      return Z_DATA_ERROR;\n    }\n  }\n  if ((y -= this.c[i]) < 0) {\n    return Z_DATA_ERROR;\n  }\n  this.c[i] += y;\n\n  // Generate starting offsets into the value table for each length\n  this.x[1] = j = 0;\n  p = 1;xp = 2;\n  while (--i != 0) {\n    // note that i == g from above\n    this.x[xp] = j += this.c[p];\n    xp++;\n    p++;\n  }\n\n  // Make a table of values in order of bit lengths\n  i = 0;p = 0;\n  do {\n    if ((j = b[bindex + p]) != 0) {\n      this.v[this.x[j]++] = i;\n    }\n    p++;\n  } while (++i < n);\n  n = this.x[g]; // set n to length of v\n\n  // Generate the Huffman codes and for each, make the table entries\n  this.x[0] = i = 0; // first Huffman code is zero\n  p = 0; // grab values in bit order\n  h = -1; // no tables yet--level -1\n  w = -l; // bits decoded == (l * h)\n  this.u[0] = 0; // just to keep compilers happy\n  q = 0; // ditto\n  z = 0; // ditto\n\n  // go through the bit lengths (k already is bits in shortest code)\n  for (; k <= g; k++) {\n    a = this.c[k];\n    while (a-- != 0) {\n      // here i is the Huffman code of length k bits for value *p\n      // make tables up to required level\n      while (k > w + l) {\n        h++;\n        w += l; // previous table always l bits\n        // compute minimum size table less than or equal to l bits\n        z = g - w;\n        z = z > l ? l : z; // table size upper limit\n        if ((f = 1 << (j = k - w)) > a + 1) {\n          // try a k-w bit table\n          // too few codes for k-w bit table\n          f -= a + 1; // deduct codes from patterns left\n          xp = k;\n          if (j < z) {\n            while (++j < z) {\n              // try smaller tables up to z bits\n              if ((f <<= 1) <= this.c[++xp]) break; // enough codes to use up j bits\n              f -= this.c[xp]; // else deduct codes from patterns\n            }\n          }\n        }\n        z = 1 << j; // table entries for j-bit table\n\n        // allocate new table\n        if (this.hn[0] + z > MANY) {\n          // (note: doesn't matter for fixed)\n          return Z_DATA_ERROR; // overflow of MANY\n        }\n        this.u[h] = q = /*hp+*/this.hn[0]; // DEBUG\n        this.hn[0] += z;\n\n        // connect to last table, if there is one\n        if (h != 0) {\n          this.x[h] = i; // save pattern for backing up\n          this.r[0] = j; // bits in this table\n          this.r[1] = l; // bits to dump before this table\n          j = i >>> w - l;\n          this.r[2] = q - this.u[h - 1] - j; // offset to this table\n          arrayCopy(this.r, 0, hp, (this.u[h - 1] + j) * 3, 3); // connect to last table\n        } else {\n          t[0] = q; // first table is returned result\n        }\n      }\n\n      // set up table entry in r\n      this.r[1] = k - w;\n      if (p >= n) {\n        this.r[0] = 128 + 64; // out of values--invalid code\n      } else if (v[p] < s) {\n        this.r[0] = this.v[p] < 256 ? 0 : 32 + 64; // 256 is end-of-block\n        this.r[2] = this.v[p++]; // simple code is just the value\n      } else {\n        this.r[0] = e[this.v[p] - s] + 16 + 64; // non-simple--look up in lists\n        this.r[2] = d[this.v[p++] - s];\n      }\n\n      // fill code-like entries with r\n      f = 1 << k - w;\n      for (j = i >>> w; j < z; j += f) {\n        arrayCopy(this.r, 0, hp, (q + j) * 3, 3);\n      }\n\n      // backwards increment the k-bit code i\n      for (j = 1 << k - 1; (i & j) != 0; j >>>= 1) {\n        i ^= j;\n      }\n      i ^= j;\n\n      // backup over finished tables\n      mask = (1 << w) - 1; // needed on HP, cc -O bug\n      while ((i & mask) != this.x[h]) {\n        h--; // don't need to update q\n        w -= l;\n        mask = (1 << w) - 1;\n      }\n    }\n  }\n  // Return Z_BUF_ERROR if we were given an incomplete table\n  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n};\n\nInfTree.prototype.inflate_trees_bits = function (c, bb, tb, hp, z) {\n  var result;\n  this.initWorkArea(19);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n  if (result == Z_DATA_ERROR) {\n    z.msg = \"oversubscribed dynamic bit lengths tree\";\n  } else if (result == Z_BUF_ERROR || bb[0] == 0) {\n    z.msg = \"incomplete dynamic bit lengths tree\";\n    result = Z_DATA_ERROR;\n  }\n  return result;\n};\n\nInfTree.prototype.inflate_trees_dynamic = function (nl, nd, c, bl, bd, tl, td, hp, z) {\n  var result;\n\n  // build literal/length tree\n  this.initWorkArea(288);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n  if (result != Z_OK || bl[0] == 0) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed literal/length tree\";\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"incomplete literal/length tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  // build distance tree\n  this.initWorkArea(288);\n  result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n  if (result != Z_OK || bd[0] == 0 && nl > 257) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed distance tree\";\n    } else if (result == Z_BUF_ERROR) {\n      z.msg = \"incomplete distance tree\";\n      result = Z_DATA_ERROR;\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"empty distance tree with lengths\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  return Z_OK;\n};\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n  bl[0] = fixed_bl;\n  bd[0] = fixed_bd;\n  tl[0] = fixed_tl;\n  td[0] = fixed_td;\n  return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function (vsize) {\n  if (this.hn == null) {\n    this.hn = new Int32Array(1);\n    this.v = new Int32Array(vsize);\n    this.c = new Int32Array(BMAX + 1);\n    this.r = new Int32Array(3);\n    this.u = new Int32Array(BMAX);\n    this.x = new Int32Array(BMAX + 1);\n  }\n  if (this.v.length < vsize) {\n    this.v = new Int32Array(vsize);\n  }\n  for (var i = 0; i < vsize; i++) {\n    this.v[i] = 0;\n  }\n  for (var i = 0; i < BMAX + 1; i++) {\n    this.c[i] = 0;\n  }\n  for (var i = 0; i < 3; i++) {\n    this.r[i] = 0;\n  }\n  //  for(int i=0; i<BMAX; i++){u[i]=0;}\n  arrayCopy(this.c, 0, this.u, 0, BMAX);\n  //  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n  arrayCopy(this.c, 0, this.x, 0, BMAX + 1);\n};\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = typeof testArray.subarray === 'function';\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n  if (count == 0) {\n    return;\n  }\n  if (!src) {\n    throw \"Undef src\";\n  } else if (!dest) {\n    throw \"Undef dest\";\n  }\n\n  if (srcOffset == 0 && count == src.length) {\n    arrayCopy_fast(src, dest, destOffset);\n  } else if (hasSubarray) {\n    arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);\n  } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n    arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n  } else {\n    arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n  }\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n  // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n  for (var i = 0; i < count; ++i) {\n    dest[destOffset + i] = src[srcOffset + i];\n  }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n  dest.set(src, destOffset);\n}\n\n// largest prime smaller than 65536\nvar ADLER_BASE = 65521;\n// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX = 5552;\n\nfunction adler32(adler, /* byte[] */buf, index, len) {\n  if (buf == null) {\n    return 1;\n  }\n\n  var s1 = adler & 0xffff;\n  var s2 = adler >> 16 & 0xffff;\n  var k;\n\n  while (len > 0) {\n    k = len < ADLER_NMAX ? len : ADLER_NMAX;\n    len -= k;\n    while (k >= 16) {\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      k -= 16;\n    }\n    if (k != 0) {\n      do {\n        s1 += buf[index++] & 0xff;s2 += s1;\n      } while (--k != 0);\n    }\n    s1 %= ADLER_BASE;\n    s2 %= ADLER_BASE;\n  }\n  return s2 << 16 | s1;\n}\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n  if (!start) {\n    buffer = new Uint8Array(buffer);\n  } else {\n    buffer = new Uint8Array(buffer, start, length);\n  }\n\n  var z = new ZStream();\n  z.inflateInit(DEF_WBITS, true);\n  z.next_in = buffer;\n  z.next_in_index = 0;\n  z.avail_in = buffer.length;\n\n  var oBlockList = [];\n  var totalSize = 0;\n  while (true) {\n    var obuf = new Uint8Array(32000);\n    z.next_out = obuf;\n    z.next_out_index = 0;\n    z.avail_out = obuf.length;\n    var status = z.inflate(Z_NO_FLUSH);\n    if (status != Z_OK && status != Z_STREAM_END) {\n      throw z.msg;\n    }\n    if (z.avail_out != 0) {\n      var newob = new Uint8Array(obuf.length - z.avail_out);\n      arrayCopy(obuf, 0, newob, 0, obuf.length - z.avail_out);\n      obuf = newob;\n    }\n    oBlockList.push(obuf);\n    totalSize += obuf.length;\n    if (status == Z_STREAM_END) {\n      break;\n    }\n  }\n\n  if (afterUncOffset) {\n    afterUncOffset[0] = (start || 0) + z.next_in_index;\n  }\n\n  if (oBlockList.length == 1) {\n    return oBlockList[0].buffer;\n  } else {\n    var out = new Uint8Array(totalSize);\n    var cursor = 0;\n    for (var i = 0; i < oBlockList.length; ++i) {\n      var b = oBlockList[i];\n      arrayCopy(b, 0, out, cursor, b.length);\n      cursor += b.length;\n    }\n    return out.buffer;\n  }\n}\n\nexports.jszlib_inflate_buffer = jszlib_inflate_buffer;\nexports.arrayCopy = arrayCopy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3ZlbmRvci9pbmZsYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy92ZW5kb3IvaW5mbGF0ZS5qcz82OTAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIEphdmFzY3JpcHQgWkxpYlxuLy8gQnkgVGhvbWFzIERvd24gMjAxMC0yMDExXG4vL1xuLy8gQmFzZWQgdmVyeSBoZWF2aWx5IG9uIHBvcnRpb25zIG9mIGp6bGliIChieSB5bW5rQGpjcmFmdC5jb20pLCB3aG8gaW5cbi8vIHR1cm4gY3JlZGl0cyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyIGZvciB0aGUgb3JpZ2luYWwgemxpYiBjb2RlLlxuLy9cbi8vIGluZmxhdGUuanM6IFpMaWIgaW5mbGF0ZSBjb2RlXG4vL1xuXG4vL1xuLy8gU2hhcmVkIGNvbnN0YW50c1xuLy9cblxudmFyIE1BWF9XQklUUz0xNTsgLy8gMzJLIExaNzcgd2luZG93XG52YXIgREVGX1dCSVRTPU1BWF9XQklUUztcbnZhciBNQVhfTUVNX0xFVkVMPTk7XG52YXIgTUFOWT0xNDQwO1xudmFyIEJNQVggPSAxNTtcblxuLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxudmFyIFBSRVNFVF9ESUNUPTB4MjA7XG5cbnZhciBaX05PX0ZMVVNIPTA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIPTE7XG52YXIgWl9TWU5DX0ZMVVNIPTI7XG52YXIgWl9GVUxMX0ZMVVNIPTM7XG52YXIgWl9GSU5JU0g9NDtcblxudmFyIFpfREVGTEFURUQ9ODtcblxudmFyIFpfT0s9MDtcbnZhciBaX1NUUkVBTV9FTkQ9MTtcbnZhciBaX05FRURfRElDVD0yO1xudmFyIFpfRVJSTk89LTE7XG52YXIgWl9TVFJFQU1fRVJST1I9LTI7XG52YXIgWl9EQVRBX0VSUk9SPS0zO1xudmFyIFpfTUVNX0VSUk9SPS00O1xudmFyIFpfQlVGX0VSUk9SPS01O1xudmFyIFpfVkVSU0lPTl9FUlJPUj0tNjtcblxudmFyIE1FVEhPRD0wOyAgIC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXG52YXIgRkxBRz0xOyAgICAgLy8gd2FpdGluZyBmb3IgZmxhZyBieXRlXG52YXIgRElDVDQ9MjsgICAgLy8gZm91ciBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDM9MzsgICAgLy8gdGhyZWUgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QyPTQ7ICAgIC8vIHR3byBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDE9NTsgICAgLy8gb25lIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERJQ1QwPTY7ICAgIC8vIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5XG52YXIgQkxPQ0tTPTc7ICAgLy8gZGVjb21wcmVzc2luZyBibG9ja3NcbnZhciBDSEVDSzQ9ODsgICAvLyBmb3VyIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0szPTk7ICAgLy8gdGhyZWUgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzI9MTA7ICAvLyB0d28gY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzE9MTE7ICAvLyBvbmUgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERPTkU9MTI7ICAgIC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXG52YXIgQkFEPTEzOyAgICAgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcblxudmFyIGluZmxhdGVfbWFzayA9IFsweDAwMDAwMDAwLCAweDAwMDAwMDAxLCAweDAwMDAwMDAzLCAweDAwMDAwMDA3LCAweDAwMDAwMDBmLCAweDAwMDAwMDFmLCAweDAwMDAwMDNmLCAweDAwMDAwMDdmLCAweDAwMDAwMGZmLCAweDAwMDAwMWZmLCAweDAwMDAwM2ZmLCAweDAwMDAwN2ZmLCAweDAwMDAwZmZmLCAweDAwMDAxZmZmLCAweDAwMDAzZmZmLCAweDAwMDA3ZmZmLCAweDAwMDBmZmZmXTtcblxudmFyIElCX1RZUEU9MDsgIC8vIGdldCB0eXBlIGJpdHMgKDMsIGluY2x1ZGluZyBlbmQgYml0KVxudmFyIElCX0xFTlM9MTsgIC8vIGdldCBsZW5ndGhzIGZvciBzdG9yZWRcbnZhciBJQl9TVE9SRUQ9MjsvLyBwcm9jZXNzaW5nIHN0b3JlZCBibG9ja1xudmFyIElCX1RBQkxFPTM7IC8vIGdldCB0YWJsZSBsZW5ndGhzXG52YXIgSUJfQlRSRUU9NDsgLy8gZ2V0IGJpdCBsZW5ndGhzIHRyZWUgZm9yIGEgZHluYW1pYyBibG9ja1xudmFyIElCX0RUUkVFPTU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9DT0RFUz02OyAvLyBwcm9jZXNzaW5nIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EUlk9NzsgICAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xudmFyIElCX0RPTkU9ODsgIC8vIGZpbmlzaGVkIGxhc3QgYmxvY2ssIGRvbmVcbnZhciBJQl9CQUQ9OTsgICAvLyBvdCBhIGRhdGEgZXJyb3ItLXN0dWNrIGhlcmVcblxudmFyIGZpeGVkX2JsID0gOTtcbnZhciBmaXhlZF9iZCA9IDU7XG5cbnZhciBmaXhlZF90bCA9IFtcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MixcbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MCxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI0LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDQsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA4LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NixcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQwLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMCxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjgsXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMixcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUyLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNixcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODQsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDgsXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk2LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY0LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjgsXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OCxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTIsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgwLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ0LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA0LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MixcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM2LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTYsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIwLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OCxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MixcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NCxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MixcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI2LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDYsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjEwLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OCxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQyLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMixcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzAsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNCxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU0LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOCxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODYsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTAsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk4LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY2LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzAsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MCxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTQsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgyLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ2LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA2LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NCxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM4LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTgsXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIyLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MCxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NCxcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MyxcblxuICAgIDgwLDcsMTAsIDAsOCw5NiwgMCw4LDMyLCAwLDksMTYxLFxuICAgIDAsOCwwLCAwLDgsMTI4LCAwLDgsNjQsIDAsOSwyMjUsXG4gICAgODAsNyw2LCAwLDgsODgsIDAsOCwyNCwgMCw5LDE0NSxcbiAgICA4Myw3LDU5LCAwLDgsMTIwLCAwLDgsNTYsIDAsOSwyMDksXG4gICAgODEsNywxNywgMCw4LDEwNCwgMCw4LDQwLCAwLDksMTc3LFxuICAgIDAsOCw4LCAwLDgsMTM2LCAwLDgsNzIsIDAsOSwyNDEsXG4gICAgODAsNyw0LCAwLDgsODQsIDAsOCwyMCwgODUsOCwyMjcsXG4gICAgODMsNyw0MywgMCw4LDExNiwgMCw4LDUyLCAwLDksMjAxLFxuICAgIDgxLDcsMTMsIDAsOCwxMDAsIDAsOCwzNiwgMCw5LDE2OSxcbiAgICAwLDgsNCwgMCw4LDEzMiwgMCw4LDY4LCAwLDksMjMzLFxuICAgIDgwLDcsOCwgMCw4LDkyLCAwLDgsMjgsIDAsOSwxNTMsXG4gICAgODQsNyw4MywgMCw4LDEyNCwgMCw4LDYwLCAwLDksMjE3LFxuICAgIDgyLDcsMjMsIDAsOCwxMDgsIDAsOCw0NCwgMCw5LDE4NSxcbiAgICAwLDgsMTIsIDAsOCwxNDAsIDAsOCw3NiwgMCw5LDI0OSxcbiAgICA4MCw3LDMsIDAsOCw4MiwgMCw4LDE4LCA4NSw4LDE2MyxcbiAgICA4Myw3LDM1LCAwLDgsMTE0LCAwLDgsNTAsIDAsOSwxOTcsXG4gICAgODEsNywxMSwgMCw4LDk4LCAwLDgsMzQsIDAsOSwxNjUsXG4gICAgMCw4LDIsIDAsOCwxMzAsIDAsOCw2NiwgMCw5LDIyOSxcbiAgICA4MCw3LDcsIDAsOCw5MCwgMCw4LDI2LCAwLDksMTQ5LFxuICAgIDg0LDcsNjcsIDAsOCwxMjIsIDAsOCw1OCwgMCw5LDIxMyxcbiAgICA4Miw3LDE5LCAwLDgsMTA2LCAwLDgsNDIsIDAsOSwxODEsXG4gICAgMCw4LDEwLCAwLDgsMTM4LCAwLDgsNzQsIDAsOSwyNDUsXG4gICAgODAsNyw1LCAwLDgsODYsIDAsOCwyMiwgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE4LCAwLDgsNTQsIDAsOSwyMDUsXG4gICAgODEsNywxNSwgMCw4LDEwMiwgMCw4LDM4LCAwLDksMTczLFxuICAgIDAsOCw2LCAwLDgsMTM0LCAwLDgsNzAsIDAsOSwyMzcsXG4gICAgODAsNyw5LCAwLDgsOTQsIDAsOCwzMCwgMCw5LDE1NyxcbiAgICA4NCw3LDk5LCAwLDgsMTI2LCAwLDgsNjIsIDAsOSwyMjEsXG4gICAgODIsNywyNywgMCw4LDExMCwgMCw4LDQ2LCAwLDksMTg5LFxuICAgIDAsOCwxNCwgMCw4LDE0MiwgMCw4LDc4LCAwLDksMjUzLFxuICAgIDk2LDcsMjU2LCAwLDgsODEsIDAsOCwxNywgODUsOCwxMzEsXG4gICAgODIsNywzMSwgMCw4LDExMywgMCw4LDQ5LCAwLDksMTk1LFxuICAgIDgwLDcsMTAsIDAsOCw5NywgMCw4LDMzLCAwLDksMTYzLFxuICAgIDAsOCwxLCAwLDgsMTI5LCAwLDgsNjUsIDAsOSwyMjcsXG4gICAgODAsNyw2LCAwLDgsODksIDAsOCwyNSwgMCw5LDE0NyxcbiAgICA4Myw3LDU5LCAwLDgsMTIxLCAwLDgsNTcsIDAsOSwyMTEsXG4gICAgODEsNywxNywgMCw4LDEwNSwgMCw4LDQxLCAwLDksMTc5LFxuICAgIDAsOCw5LCAwLDgsMTM3LCAwLDgsNzMsIDAsOSwyNDMsXG4gICAgODAsNyw0LCAwLDgsODUsIDAsOCwyMSwgODAsOCwyNTgsXG4gICAgODMsNyw0MywgMCw4LDExNywgMCw4LDUzLCAwLDksMjAzLFxuICAgIDgxLDcsMTMsIDAsOCwxMDEsIDAsOCwzNywgMCw5LDE3MSxcbiAgICAwLDgsNSwgMCw4LDEzMywgMCw4LDY5LCAwLDksMjM1LFxuICAgIDgwLDcsOCwgMCw4LDkzLCAwLDgsMjksIDAsOSwxNTUsXG4gICAgODQsNyw4MywgMCw4LDEyNSwgMCw4LDYxLCAwLDksMjE5LFxuICAgIDgyLDcsMjMsIDAsOCwxMDksIDAsOCw0NSwgMCw5LDE4NyxcbiAgICAwLDgsMTMsIDAsOCwxNDEsIDAsOCw3NywgMCw5LDI1MSxcbiAgICA4MCw3LDMsIDAsOCw4MywgMCw4LDE5LCA4NSw4LDE5NSxcbiAgICA4Myw3LDM1LCAwLDgsMTE1LCAwLDgsNTEsIDAsOSwxOTksXG4gICAgODEsNywxMSwgMCw4LDk5LCAwLDgsMzUsIDAsOSwxNjcsXG4gICAgMCw4LDMsIDAsOCwxMzEsIDAsOCw2NywgMCw5LDIzMSxcbiAgICA4MCw3LDcsIDAsOCw5MSwgMCw4LDI3LCAwLDksMTUxLFxuICAgIDg0LDcsNjcsIDAsOCwxMjMsIDAsOCw1OSwgMCw5LDIxNSxcbiAgICA4Miw3LDE5LCAwLDgsMTA3LCAwLDgsNDMsIDAsOSwxODMsXG4gICAgMCw4LDExLCAwLDgsMTM5LCAwLDgsNzUsIDAsOSwyNDcsXG4gICAgODAsNyw1LCAwLDgsODcsIDAsOCwyMywgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE5LCAwLDgsNTUsIDAsOSwyMDcsXG4gICAgODEsNywxNSwgMCw4LDEwMywgMCw4LDM5LCAwLDksMTc1LFxuICAgIDAsOCw3LCAwLDgsMTM1LCAwLDgsNzEsIDAsOSwyMzksXG4gICAgODAsNyw5LCAwLDgsOTUsIDAsOCwzMSwgMCw5LDE1OSxcbiAgICA4NCw3LDk5LCAwLDgsMTI3LCAwLDgsNjMsIDAsOSwyMjMsXG4gICAgODIsNywyNywgMCw4LDExMSwgMCw4LDQ3LCAwLDksMTkxLFxuICAgIDAsOCwxNSwgMCw4LDE0MywgMCw4LDc5LCAwLDksMjU1XG5dO1xudmFyIGZpeGVkX3RkID0gW1xuICAgIDgwLDUsMSwgODcsNSwyNTcsIDgzLDUsMTcsIDkxLDUsNDA5NyxcbiAgICA4MSw1LDUsIDg5LDUsMTAyNSwgODUsNSw2NSwgOTMsNSwxNjM4NSxcbiAgICA4MCw1LDMsIDg4LDUsNTEzLCA4NCw1LDMzLCA5Miw1LDgxOTMsXG4gICAgODIsNSw5LCA5MCw1LDIwNDksIDg2LDUsMTI5LCAxOTIsNSwyNDU3NyxcbiAgICA4MCw1LDIsIDg3LDUsMzg1LCA4Myw1LDI1LCA5MSw1LDYxNDUsXG4gICAgODEsNSw3LCA4OSw1LDE1MzcsIDg1LDUsOTcsIDkzLDUsMjQ1NzcsXG4gICAgODAsNSw0LCA4OCw1LDc2OSwgODQsNSw0OSwgOTIsNSwxMjI4OSxcbiAgICA4Miw1LDEzLCA5MCw1LDMwNzMsIDg2LDUsMTkzLCAxOTIsNSwyNDU3N1xuXTtcblxuICAvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxuICB2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgICAgICAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbiAgXTtcblxuICAvLyBzZWUgbm90ZSAjMTMgYWJvdmUgYWJvdXQgMjU4XG4gIHZhciBjcGxleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMixcbiAgICAgICAgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgMTEyLCAxMTIgIC8vIDExMj09aW52YWxpZFxuICBdO1xuXG4gdmFyIGNwZGlzdCA9IFsgLy8gQ29weSBvZmZzZXRzIGZvciBkaXN0YW5jZSBjb2RlcyAwLi4yOVxuICAgICAgICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gICAgICAgIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgICAgICAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3N1xuICBdO1xuXG4gIHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXG4gICAgICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsXG4gICAgICAgIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLFxuICAgICAgICAxMiwgMTIsIDEzLCAxM107XG5cbi8vXG4vLyBaU3RyZWFtLmphdmFcbi8vXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG59XG5cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih3LCBub3dyYXApIHtcbiAgICBpZiAoIXcpIHtcblx0dyA9IERFRl9XQklUUztcbiAgICB9XG4gICAgaWYgKG5vd3JhcCkge1xuXHRub3dyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc3RhdGUgPSBuZXcgSW5mbGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLmlzdGF0ZS5pbmZsYXRlSW5pdCh0aGlzLCBub3dyYXA/LXc6dyk7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZSh0aGlzLCBmKTtcbn1cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB2YXIgcmV0PWlzdGF0ZS5pbmZsYXRlRW5kKHRoaXMpO1xuICAgIHRoaXMuaXN0YXRlID0gbnVsbDtcbiAgICByZXR1cm4gcmV0O1xufVxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbigpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU3luYyh0aGlzKTtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCl7XG4gICAgLy8gaWYoaXN0YXRlID09IG51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xufVxuXG4vKlxuXG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGJvb2xlYW4gbm93cmFwKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUywgbm93cmFwKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMpe1xuICAgIHJldHVybiBkZWZsYXRlSW5pdChsZXZlbCwgYml0cywgZmFsc2UpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBpbnQgYml0cywgYm9vbGVhbiBub3dyYXApe1xuICAgIGRzdGF0ZT1uZXcgRGVmbGF0ZSgpO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZUluaXQodGhpcywgbGV2ZWwsIG5vd3JhcD8tYml0czpiaXRzKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGUoaW50IGZsdXNoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpe1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGUodGhpcywgZmx1c2gpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUVuZCgpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGludCByZXQ9ZHN0YXRlLmRlZmxhdGVFbmQoKTtcbiAgICBkc3RhdGU9bnVsbDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVBhcmFtcyhpbnQgbGV2ZWwsIGludCBzdHJhdGVneSl7XG4gICAgaWYoZHN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoaXMsIGxldmVsLCBzdHJhdGVneSk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlU2V0RGljdGlvbmFyeSAoYnl0ZVtdIGRpY3Rpb25hcnksIGludCBkaWN0TGVuZ3RoKXtcbiAgICBpZihkc3RhdGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xuICB9XG5cbiovXG5cbi8qXG4gIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAgLy8gdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICAvLyB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9vdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAgdm9pZCBmbHVzaF9wZW5kaW5nKCl7XG4gICAgaW50IGxlbj1kc3RhdGUucGVuZGluZztcblxuICAgIGlmKGxlbj5hdmFpbF9vdXQpIGxlbj1hdmFpbF9vdXQ7XG4gICAgaWYobGVuPT0wKSByZXR1cm47XG5cbiAgICBpZihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoPD1kc3RhdGUucGVuZGluZ19vdXQgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8PW5leHRfb3V0X2luZGV4IHx8XG4gICAgICAgZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDwoZHN0YXRlLnBlbmRpbmdfb3V0K2xlbikgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8KG5leHRfb3V0X2luZGV4K2xlbikpe1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGgrXCIsIFwiK2RzdGF0ZS5wZW5kaW5nX291dCtcblx0XHRcdCBcIiwgXCIrbmV4dF9vdXQubGVuZ3RoK1wiLCBcIituZXh0X291dF9pbmRleCtcIiwgXCIrbGVuKTtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihcImF2YWlsX291dD1cIithdmFpbF9vdXQpO1xuICAgIH1cblxuICAgIFN5c3RlbS5hcnJheWNvcHkoZHN0YXRlLnBlbmRpbmdfYnVmLCBkc3RhdGUucGVuZGluZ19vdXQsXG5cdFx0ICAgICBuZXh0X291dCwgbmV4dF9vdXRfaW5kZXgsIGxlbik7XG5cbiAgICBuZXh0X291dF9pbmRleCs9bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nX291dCs9bGVuO1xuICAgIHRvdGFsX291dCs9bGVuO1xuICAgIGF2YWlsX291dC09bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nLT1sZW47XG4gICAgaWYoZHN0YXRlLnBlbmRpbmc9PTApe1xuICAgICAgZHN0YXRlLnBlbmRpbmdfb3V0PTA7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICAvLyBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICAvLyB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICAvLyBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9pbiBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAgLy8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gIGludCByZWFkX2J1ZihieXRlW10gYnVmLCBpbnQgc3RhcnQsIGludCBzaXplKSB7XG4gICAgaW50IGxlbj1hdmFpbF9pbjtcblxuICAgIGlmKGxlbj5zaXplKSBsZW49c2l6ZTtcbiAgICBpZihsZW49PTApIHJldHVybiAwO1xuXG4gICAgYXZhaWxfaW4tPWxlbjtcblxuICAgIGlmKGRzdGF0ZS5ub2hlYWRlcj09MCkge1xuICAgICAgYWRsZXI9X2FkbGVyLmFkbGVyMzIoYWRsZXIsIG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGxlbik7XG4gICAgfVxuICAgIFN5c3RlbS5hcnJheWNvcHkobmV4dF9pbiwgbmV4dF9pbl9pbmRleCwgYnVmLCBzdGFydCwgbGVuKTtcbiAgICBuZXh0X2luX2luZGV4ICArPSBsZW47XG4gICAgdG90YWxfaW4gKz0gbGVuO1xuICAgIHJldHVybiBsZW47XG4gIH1cblxuICBwdWJsaWMgdm9pZCBmcmVlKCl7XG4gICAgbmV4dF9pbj1udWxsO1xuICAgIG5leHRfb3V0PW51bGw7XG4gICAgbXNnPW51bGw7XG4gICAgX2FkbGVyPW51bGw7XG4gIH1cbn1cbiovXG5cblxuLy9cbi8vIEluZmxhdGUuamF2YVxuLy9cblxuZnVuY3Rpb24gSW5mbGF0ZSgpIHtcbiAgICB0aGlzLndhcyA9IFswXTtcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVJlc2V0ID0gZnVuY3Rpb24oeikge1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgXG4gICAgei50b3RhbF9pbiA9IHoudG90YWxfb3V0ID0gMDtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgei5pc3RhdGUubW9kZSA9IHouaXN0YXRlLm5vd3JhcCE9MCA/IEJMT0NLUyA6IE1FVEhPRDtcbiAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgbnVsbCk7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbih6KXtcbiAgICBpZih0aGlzLmJsb2NrcyAhPSBudWxsKVxuICAgICAgdGhpcy5ibG9ja3MuZnJlZSh6KTtcbiAgICB0aGlzLmJsb2Nrcz1udWxsO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHosIHcpe1xuICAgIHoubXNnID0gbnVsbDtcbiAgICB0aGlzLmJsb2NrcyA9IG51bGw7XG5cbiAgICAvLyBoYW5kbGUgdW5kb2N1bWVudGVkIG5vd3JhcCBvcHRpb24gKG5vIHpsaWIgaGVhZGVyIG9yIGNoZWNrKVxuICAgIGxldCBub3dyYXAgPSAwO1xuICAgIGlmKHcgPCAwKXtcbiAgICAgIHcgPSAtIHc7XG4gICAgICBub3dyYXAgPSAxO1xuICAgIH1cblxuICAgIC8vIHNldCB3aW5kb3cgc2l6ZVxuICAgIGlmKHc8OCB8fHc+MTUpe1xuICAgICAgdGhpcy5pbmZsYXRlRW5kKHopO1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICB0aGlzLndiaXRzPXc7XG5cbiAgICB6LmlzdGF0ZS5ibG9ja3M9bmV3IEluZkJsb2Nrcyh6LCBcblx0XHRcdFx0ICB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBudWxsIDogdGhpcyxcblx0XHRcdFx0ICAxPDx3KTtcblxuICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgdGhpcy5pbmZsYXRlUmVzZXQoeik7XG4gICAgcmV0dXJuIFpfT0s7XG4gIH1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpe1xuICAgIHZhciByLCBiO1xuXG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwgfHwgei5uZXh0X2luID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgZiA9IGYgPT0gWl9GSU5JU0ggPyBaX0JVRl9FUlJPUiA6IFpfT0s7XG4gICAgciA9IFpfQlVGX0VSUk9SO1xuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAoei5pc3RhdGUubW9kZSl7XG4gICAgICBjYXNlIE1FVEhPRDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgaWYoKCh6LmlzdGF0ZS5tZXRob2QgPSB6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGYpIT1aX0RFRkxBVEVEKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZigoei5pc3RhdGUubWV0aG9kPj40KSs4PnouaXN0YXRlLndiaXRzKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwiaW52YWxpZCB3aW5kb3cgc2l6ZVwiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RkxBRztcbiAgICAgIGNhc2UgRkxBRzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgYiA9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGZmO1xuXG4gICAgICAgIGlmKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KStiKSAlIDMxKSE9MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW5jb3JyZWN0IGhlYWRlciBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKGImUFJFU0VUX0RJQ1QpPT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUNDtcbiAgICAgIGNhc2UgRElDVDQ6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQ9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwyNCkmMHhmZjAwMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMztcbiAgICAgIGNhc2UgRElDVDM6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MTYpJjB4ZmYwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QyO1xuICAgICAgY2FzZSBESUNUMjpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDw4KSYweGZmMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDE7XG4gICAgICBjYXNlIERJQ1QxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkICs9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpO1xuICAgICAgICB6LmFkbGVyID0gei5pc3RhdGUubmVlZDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QwO1xuICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICBjYXNlIERJQ1QwOlxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB6Lm1zZyA9IFwibmVlZCBkaWN0aW9uYXJ5XCI7XG4gICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7ICAgICAgIC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgY2FzZSBCTE9DS1M6XG5cbiAgICAgICAgciA9IHouaXN0YXRlLmJsb2Nrcy5wcm9jKHosIHIpO1xuICAgICAgICBpZihyID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAgICAgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIgPT0gWl9PSyl7XG4gICAgICAgICAgciA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYociAhPSBaX1NUUkVBTV9FTkQpe1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBmO1xuICAgICAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgei5pc3RhdGUud2FzKTtcbiAgICAgICAgaWYoei5pc3RhdGUubm93cmFwIT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlPURPTkU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZT1DSEVDSzQ7XG4gICAgICBjYXNlIENIRUNLNDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZD0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDI0KSYweGZmMDAwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPUNIRUNLMztcbiAgICAgIGNhc2UgQ0hFQ0szOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDE2KSYweGZmMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMjtcbiAgICAgIGNhc2UgQ0hFQ0syOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDgpJjB4ZmYwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMTtcbiAgICAgIGNhc2UgQ0hFQ0sxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTtcblxuICAgICAgICBpZigoKHouaXN0YXRlLndhc1swXSkpICE9ICgoei5pc3RhdGUubmVlZCkpKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbmNvcnJlY3QgZGF0YSBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHosICBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4PTA7XG4gICAgdmFyIGxlbmd0aCA9IGRpY3RMZW5ndGg7XG4gICAgaWYoej09bnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsfHwgei5pc3RhdGUubW9kZSAhPSBESUNUMClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcblxuICAgIGlmKHouX2FkbGVyLmFkbGVyMzIoMSwgZGljdGlvbmFyeSwgMCwgZGljdExlbmd0aCkhPXouYWRsZXIpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG5cbiAgICB6LmFkbGVyID0gei5fYWRsZXIuYWRsZXIzMigwLCBudWxsLCAwLCAwKTtcblxuICAgIGlmKGxlbmd0aCA+PSAoMTw8ei5pc3RhdGUud2JpdHMpKXtcbiAgICAgIGxlbmd0aCA9ICgxPDx6LmlzdGF0ZS53Yml0cyktMTtcbiAgICAgIGluZGV4PWRpY3RMZW5ndGggLSBsZW5ndGg7XG4gICAgfVxuICAgIHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcbiAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgIHJldHVybiBaX09LO1xuICB9XG5cbi8vICBzdGF0aWMgcHJpdmF0ZSBieXRlW10gbWFyayA9IHsoYnl0ZSkwLCAoYnl0ZSkwLCAoYnl0ZSkweGZmLCAoYnl0ZSkweGZmfTtcbnZhciBtYXJrID0gWzAsIDAsIDI1NSwgMjU1XVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKHope1xuICAgIHZhciBuOyAgICAgICAvLyBudW1iZXIgb2YgYnl0ZXMgdG8gbG9vayBhdFxuICAgIHZhciBwOyAgICAgICAvLyBwb2ludGVyIHRvIGJ5dGVzXG4gICAgdmFyIG07ICAgICAgIC8vIG51bWJlciBvZiBtYXJrZXIgYnl0ZXMgZm91bmQgaW4gYSByb3dcbiAgICB2YXIgciwgdzsgICAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcblxuICAgIC8vIHNldCB1cFxuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGlmKHouaXN0YXRlLm1vZGUgIT0gQkFEKXtcbiAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwO1xuICAgIH1cbiAgICBpZigobj16LmF2YWlsX2luKT09MClcbiAgICAgIHJldHVybiBaX0JVRl9FUlJPUjtcbiAgICBwPXoubmV4dF9pbl9pbmRleDtcbiAgICBtPXouaXN0YXRlLm1hcmtlcjtcblxuICAgIC8vIHNlYXJjaFxuICAgIHdoaWxlIChuIT0wICYmIG0gPCA0KXtcbiAgICAgIGlmKHoubmV4dF9pbltwXSA9PSBtYXJrW21dKXtcbiAgICAgICAgbSsrO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih6Lm5leHRfaW5bcF0hPTApe1xuICAgICAgICBtID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIG0gPSA0IC0gbTtcbiAgICAgIH1cbiAgICAgIHArKzsgbi0tO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmVcbiAgICB6LnRvdGFsX2luICs9IHAtei5uZXh0X2luX2luZGV4O1xuICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XG4gICAgei5hdmFpbF9pbiA9IG47XG4gICAgei5pc3RhdGUubWFya2VyID0gbTtcblxuICAgIC8vIHJldHVybiBubyBqb3kgb3Igc2V0IHVwIHRvIHJlc3RhcnQgb24gYSBuZXcgYmxvY2tcbiAgICBpZihtICE9IDQpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcj16LnRvdGFsX2luOyAgdz16LnRvdGFsX291dDtcbiAgICB0aGlzLmluZmxhdGVSZXNldCh6KTtcbiAgICB6LnRvdGFsX2luPXI7ICB6LnRvdGFsX291dCA9IHc7XG4gICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICByZXR1cm4gWl9PSztcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxuICAvLyBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLiBQUFAgdXNlcyBaX1NZTkNfRkxVU0hcbiAgLy8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxuICAvLyBkZWNvbXByZXNzaW5nLCBQUFAgY2hlY2tzIHRoYXQgYXQgdGhlIGVuZCBvZiBpbnB1dCBwYWNrZXQsIGluZmxhdGUgaXNcbiAgLy8gd2FpdGluZyBmb3IgdGhlc2UgbGVuZ3RoIGJ5dGVzLlxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVN5bmNQb2ludCA9IGZ1bmN0aW9uKHope1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsIHx8IHouaXN0YXRlLmJsb2NrcyA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiB6LmlzdGF0ZS5ibG9ja3Muc3luY19wb2ludCgpO1xufVxuXG5cbi8vXG4vLyBJbmZCbG9ja3MuamF2YVxuLy9cblxudmFyIElORkJMT0NLU19CT1JERVIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07XG5cbmZ1bmN0aW9uIEluZkJsb2Nrcyh6LCBjaGVja2ZuLCB3KSB7XG4gICAgdGhpcy5odWZ0cz1uZXcgSW50MzJBcnJheShNQU5ZKjMpO1xuICAgIHRoaXMud2luZG93PW5ldyBVaW50OEFycmF5KHcpO1xuICAgIHRoaXMuZW5kPXc7XG4gICAgdGhpcy5jaGVja2ZuID0gY2hlY2tmbjtcbiAgICB0aGlzLm1vZGUgPSBJQl9UWVBFO1xuICAgIHRoaXMucmVzZXQoeiwgbnVsbCk7XG5cbiAgICB0aGlzLmxlZnQgPSAwOyAgICAgICAgICAgIC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5IFxuXG4gICAgdGhpcy50YWJsZSA9IDA7ICAgICAgICAgICAvLyB0YWJsZSBsZW5ndGhzICgxNCBiaXRzKSBcbiAgICB0aGlzLmluZGV4ID0gMDsgICAgICAgICAgIC8vIGluZGV4IGludG8gYmxlbnMgKG9yIGJvcmRlcikgXG4gICAgdGhpcy5ibGVucyA9IG51bGw7ICAgICAgICAgLy8gYml0IGxlbmd0aHMgb2YgY29kZXMgXG4gICAgdGhpcy5iYj1uZXcgSW50MzJBcnJheSgxKTsgLy8gYml0IGxlbmd0aCB0cmVlIGRlcHRoIFxuICAgIHRoaXMudGI9bmV3IEludDMyQXJyYXkoMSk7IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZSBcblxuICAgIHRoaXMuY29kZXMgPSBuZXcgSW5mQ29kZXMoKTtcblxuICAgIHRoaXMubGFzdCA9IDA7ICAgICAgICAgICAgLy8gdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIHRoZSBsYXN0IGJsb2NrIFxuXG4gIC8vIG1vZGUgaW5kZXBlbmRlbnQgaW5mb3JtYXRpb24gXG4gICAgdGhpcy5iaXRrID0gMDsgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXIgXG4gICAgdGhpcy5iaXRiID0gMDsgICAgICAgICAgICAvLyBiaXQgYnVmZmVyIFxuICAgIHRoaXMucmVhZCA9IDA7ICAgICAgICAgICAgLy8gd2luZG93IHJlYWQgcG9pbnRlciBcbiAgICB0aGlzLndyaXRlID0gMDsgICAgICAgICAgIC8vIHdpbmRvdyB3cml0ZSBwb2ludGVyIFxuICAgIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAvLyBjaGVjayBvbiBvdXRwdXQgXG5cbiAgICB0aGlzLmluZnRyZWU9bmV3IEluZlRyZWUoKTtcbn1cblxuXG5cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHosIGMpe1xuICAgIGlmKGMpIGNbMF09dGhpcy5jaGVjaztcbiAgICBpZih0aGlzLm1vZGU9PUlCX0NPREVTKXtcbiAgICAgIHRoaXMuY29kZXMuZnJlZSh6KTtcbiAgICB9XG4gICAgdGhpcy5tb2RlPUlCX1RZUEU7XG4gICAgdGhpcy5iaXRrPTA7XG4gICAgdGhpcy5iaXRiPTA7XG4gICAgdGhpcy5yZWFkPXRoaXMud3JpdGU9MDtcblxuICAgIGlmKHRoaXMuY2hlY2tmbilcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKDAsIG51bGwsIDAsIDApO1xuICB9XG5cbiBJbmZCbG9ja3MucHJvdG90eXBlLnByb2MgPSBmdW5jdGlvbih6LCByKXtcbiAgICB2YXIgdDsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIGI7ICAgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG5cbiAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcbiAgICB7cD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO31cbiAgICB7cT10aGlzLndyaXRlO209KHE8dGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO31cblxuICAgIC8vIHByb2Nlc3MgaW5wdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlKHRydWUpe1xuICAgICAgc3dpdGNoICh0aGlzLm1vZGUpe1xuICAgICAgY2FzZSBJQl9UWVBFOlxuXG5cdHdoaWxlKGs8KDMpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXHR0ID0gKGIgJiA3KTtcblx0dGhpcy5sYXN0ID0gdCAmIDE7XG5cblx0c3dpdGNoICh0ID4+PiAxKXtcbiAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZWQgXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG4gICAgICAgICAgdCA9IGsgJiA3OyAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gYnl0ZSBib3VuZGFyeVxuXG4gICAgICAgICAge2I+Pj49KHQpO2stPSh0KTt9XG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfTEVOUzsgICAgICAgICAgICAgICAgICAvLyBnZXQgbGVuZ3RoIG9mIHN0b3JlZCBibG9ja1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkXG4gICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICAgIHZhciBiZD1uZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgICAgdmFyIHRsPVtdO1xuXHQgICAgICB2YXIgdGQ9W107XG5cblx0ICAgICAgaW5mbGF0ZV90cmVlc19maXhlZChibCwgYmQsIHRsLCB0ZCwgeik7XG4gICAgICAgICAgICAgIHRoaXMuY29kZXMuaW5pdChibFswXSwgYmRbMF0sIHRsWzBdLCAwLCB0ZFswXSwgMCwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG5cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9DT0RFUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljXG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cblxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX1RBQkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWxcblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuICAgICAgICAgIHRoaXMubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBibG9jayB0eXBlXCI7XG4gICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0YnJlYWs7XG4gICAgICBjYXNlIElCX0xFTlM6XG5cdHdoaWxlKGs8KDMyKSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHRpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSl7XG5cdCAgdGhpcy5tb2RlID0gQkFEO1xuXHQgIHoubXNnID0gXCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXCI7XG5cdCAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0dGhpcy5sZWZ0ID0gKGIgJiAweGZmZmYpO1xuXHRiID0gayA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW1wIGJpdHNcblx0dGhpcy5tb2RlID0gbGVmdCE9MCA/IElCX1NUT1JFRCA6ICh0aGlzLmxhc3QhPTAgPyBJQl9EUlkgOiBJQl9UWVBFKTtcblx0YnJlYWs7XG4gICAgICBjYXNlIElCX1NUT1JFRDpcblx0aWYgKG4gPT0gMCl7XG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgd3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblxuXHRpZihtPT0wKXtcblx0ICBpZihxPT1lbmQmJnJlYWQhPTApe1xuXHQgICAgcT0wOyBtPShxPHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICB9XG5cdCAgaWYobT09MCl7XG5cdCAgICB0aGlzLndyaXRlPXE7IFxuXHQgICAgcj10aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIHE9dGhpcy53cml0ZTsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgICAgaWYocT09dGhpcy5lbmQgJiYgdGhpcy5yZWFkICE9IDApe1xuXHQgICAgICBxPTA7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICAgIH1cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRyPVpfT0s7XG5cblx0dCA9IHRoaXMubGVmdDtcblx0aWYodD5uKSB0ID0gbjtcblx0aWYodD5tKSB0ID0gbTtcblx0YXJyYXlDb3B5KHoubmV4dF9pbiwgcCwgd2luZG93LCBxLCB0KTtcblx0cCArPSB0OyAgbiAtPSB0O1xuXHRxICs9IHQ7ICBtIC09IHQ7XG5cdGlmICgodGhpcy5sZWZ0IC09IHQpICE9IDApXG5cdCAgYnJlYWs7XG5cdHRoaXMubW9kZSA9ICh0aGlzLmxhc3QgIT0gMCA/IElCX0RSWSA6IElCX1RZUEUpO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfVEFCTEU6XG5cblx0d2hpbGUoazwoMTQpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMudGFibGUgPSB0ID0gKGIgJiAweDNmZmYpO1xuXHRpZiAoKHQgJiAweDFmKSA+IDI5IHx8ICgodCA+PiA1KSAmIDB4MWYpID4gMjkpXG5cdCAge1xuXHQgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgei5tc2cgPSBcInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCI7XG5cdCAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0dCA9IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKTtcblx0aWYodGhpcy5ibGVucz09bnVsbCB8fCB0aGlzLmJsZW5zLmxlbmd0aDx0KXtcblx0ICAgIHRoaXMuYmxlbnM9bmV3IEludDMyQXJyYXkodCk7XG5cdH1cblx0ZWxzZXtcblx0ICBmb3IodmFyIGk9MDsgaTx0OyBpKyspe1xuICAgICAgICAgICAgICB0aGlzLmJsZW5zW2ldPTA7XG4gICAgICAgICAgfVxuXHR9XG5cblx0e2I+Pj49KDE0KTtrLT0oMTQpO31cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0dGhpcy5tb2RlID0gSUJfQlRSRUU7XG4gICAgICBjYXNlIElCX0JUUkVFOlxuXHR3aGlsZSAodGhpcy5pbmRleCA8IDQgKyAodGhpcy50YWJsZSA+Pj4gMTApKXtcblx0ICB3aGlsZShrPCgzKSl7XG5cdCAgICBpZihuIT0wKXtcblx0ICAgICAgcj1aX09LO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9O1xuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgays9ODtcblx0ICB9XG5cblx0ICB0aGlzLmJsZW5zW0lORkJMT0NLU19CT1JERVJbdGhpcy5pbmRleCsrXV0gPSBiJjc7XG5cblx0ICB7Yj4+Pj0oMyk7ay09KDMpO31cblx0fVxuXG5cdHdoaWxlKHRoaXMuaW5kZXggPCAxOSl7XG5cdCAgdGhpcy5ibGVuc1tJTkZCTE9DS1NfQk9SREVSW3RoaXMuaW5kZXgrK11dID0gMDtcblx0fVxuXG5cdHRoaXMuYmJbMF0gPSA3O1xuXHR0ID0gdGhpcy5pbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyh0aGlzLmJsZW5zLCB0aGlzLmJiLCB0aGlzLnRiLCB0aGlzLmh1ZnRzLCB6KTtcblx0aWYgKHQgIT0gWl9PSyl7XG5cdCAgciA9IHQ7XG5cdCAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKXtcblx0ICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICB9XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB3cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXG5cdHRoaXMuaW5kZXggPSAwO1xuXHR0aGlzLm1vZGUgPSBJQl9EVFJFRTtcbiAgICAgIGNhc2UgSUJfRFRSRUU6XG5cdHdoaWxlICh0cnVlKXtcblx0ICB0ID0gdGhpcy50YWJsZTtcblx0ICBpZighKHRoaXMuaW5kZXggPCAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZikpKXtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblxuXHQgIHZhciBoOyAvL2ludFtdXG5cdCAgdmFyIGksIGosIGM7XG5cblx0ICB0ID0gdGhpcy5iYlswXTtcblxuXHQgIHdoaWxlKGs8KHQpKXtcblx0ICAgIGlmKG4hPTApe1xuXHQgICAgICByPVpfT0s7XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47XG5cdCAgICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH07XG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICBrKz04O1xuXHQgIH1cblxuLy9cdCAgaWYgKHRoaXMudGJbMF09PS0xKXtcbi8vICAgICAgICAgICAgZGxvZyhcIm51bGwuLi5cIik7XG4vL1x0ICB9XG5cblx0ICB0PXRoaXMuaHVmdHNbKHRoaXMudGJbMF0rKGIgJiBpbmZsYXRlX21hc2tbdF0pKSozKzFdO1xuXHQgIGM9dGhpcy5odWZ0c1sodGhpcy50YlswXSsoYiAmIGluZmxhdGVfbWFza1t0XSkpKjMrMl07XG5cblx0ICBpZiAoYyA8IDE2KXtcblx0ICAgIGI+Pj49KHQpO2stPSh0KTtcblx0ICAgIHRoaXMuYmxlbnNbdGhpcy5pbmRleCsrXSA9IGM7XG5cdCAgfVxuXHQgIGVsc2UgeyAvLyBjID09IDE2Li4xOFxuXHQgICAgaSA9IGMgPT0gMTggPyA3IDogYyAtIDE0O1xuXHQgICAgaiA9IGMgPT0gMTggPyAxMSA6IDM7XG5cblx0ICAgIHdoaWxlKGs8KHQraSkpe1xuXHQgICAgICBpZihuIT0wKXtcblx0XHRyPVpfT0s7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZXtcblx0XHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHRcdHouYXZhaWxfaW49bjtcblx0XHR6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0XHR0aGlzLndyaXRlPXE7XG5cdFx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICB9O1xuXHQgICAgICBuLS07XG5cdCAgICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgICAgays9ODtcblx0ICAgIH1cblxuXHQgICAgYj4+Pj0odCk7ay09KHQpO1xuXG5cdCAgICBqICs9IChiICYgaW5mbGF0ZV9tYXNrW2ldKTtcblxuXHQgICAgYj4+Pj0oaSk7ay09KGkpO1xuXG5cdCAgICBpID0gdGhpcy5pbmRleDtcblx0ICAgIHQgPSB0aGlzLnRhYmxlO1xuXHQgICAgaWYgKGkgKyBqID4gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpIHx8XG5cdFx0KGMgPT0gMTYgJiYgaSA8IDEpKXtcblx0ICAgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgICAgIHoubXNnID0gXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCI7XG5cdCAgICAgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblxuXHQgICAgYyA9IGMgPT0gMTYgPyB0aGlzLmJsZW5zW2ktMV0gOiAwO1xuXHQgICAgZG97XG5cdCAgICAgIHRoaXMuYmxlbnNbaSsrXSA9IGM7XG5cdCAgICB9XG5cdCAgICB3aGlsZSAoLS1qIT0wKTtcblx0ICAgIHRoaXMuaW5kZXggPSBpO1xuXHQgIH1cblx0fVxuXG5cdHRoaXMudGJbMF09LTE7XG5cdHtcblx0ICAgIHZhciBibD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciBiZD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciB0bD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciB0ZD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIGJsWzBdID0gOTsgICAgICAgICAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xuXHQgICAgYmRbMF0gPSA2OyAgICAgICAgIC8vIG11c3QgYmUgPD0gOSBmb3IgbG9va2FoZWFkIGFzc3VtcHRpb25zXG5cblx0ICAgIHQgPSB0aGlzLnRhYmxlO1xuXHQgICAgdCA9IHRoaXMuaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMoMjU3ICsgKHQgJiAweDFmKSwgXG5cdFx0XHRcdFx0ICAgICAgMSArICgodCA+PiA1KSAmIDB4MWYpLFxuXHRcdFx0XHRcdCAgICAgIHRoaXMuYmxlbnMsIGJsLCBiZCwgdGwsIHRkLCB0aGlzLmh1ZnRzLCB6KTtcblxuXHQgICAgaWYgKHQgIT0gWl9PSyl7XG5cdCAgICAgICAgaWYgKHQgPT0gWl9EQVRBX0VSUk9SKXtcblx0ICAgICAgICAgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgICAgICAgICB0aGlzLm1vZGUgPSBCQUQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHIgPSB0O1xuXG5cdCAgICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuY29kZXMuaW5pdChibFswXSwgYmRbMF0sIHRoaXMuaHVmdHMsIHRsWzBdLCB0aGlzLmh1ZnRzLCB0ZFswXSwgeik7XG5cdH1cblx0dGhpcy5tb2RlID0gSUJfQ09ERVM7XG4gICAgICBjYXNlIElCX0NPREVTOlxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjsgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblxuXHRpZiAoKHIgPSB0aGlzLmNvZGVzLnByb2ModGhpcywgeiwgcikpICE9IFpfU1RSRUFNX0VORCl7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblx0fVxuXHRyID0gWl9PSztcblx0dGhpcy5jb2Rlcy5mcmVlKHopO1xuXG5cdHA9ei5uZXh0X2luX2luZGV4OyBuPXouYXZhaWxfaW47Yj10aGlzLmJpdGI7az10aGlzLmJpdGs7XG5cdHE9dGhpcy53cml0ZTttID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cblx0aWYgKHRoaXMubGFzdD09MCl7XG5cdCAgdGhpcy5tb2RlID0gSUJfVFlQRTtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQl9EUlk7XG4gICAgICBjYXNlIElCX0RSWTpcblx0dGhpcy53cml0ZT1xOyBcblx0ciA9IHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTsgXG5cdHE9dGhpcy53cml0ZTsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHRpZiAodGhpcy5yZWFkICE9IHRoaXMud3JpdGUpe1xuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXHR9XG5cdHRoaXMubW9kZSA9IERPTkU7XG4gICAgICBjYXNlIElCX0RPTkU6XG5cdHIgPSBaX1NUUkVBTV9FTkQ7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG4gICAgICBjYXNlIElCX0JBRDpcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblxuICAgICAgZGVmYXVsdDpcblx0ciA9IFpfU1RSRUFNX0VSUk9SO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbih6KXtcbiAgICB0aGlzLnJlc2V0KHosIG51bGwpO1xuICAgIHRoaXMud2luZG93PW51bGw7XG4gICAgdGhpcy5odWZ0cz1udWxsO1xufVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLnNldF9kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZCwgc3RhcnQsIG4pe1xuICAgIGFycmF5Q29weShkLCBzdGFydCwgd2luZG93LCAwLCBuKTtcbiAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gbjtcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBcbkluZkJsb2Nrcy5wcm90b3R5cGUuc3luY19wb2ludCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PSBJQl9MRU5TO1xufVxuXG4gIC8vIGNvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBzbGlkaW5nIHdpbmRvdyB0byB0aGUgb3V0cHV0IGFyZWFcbkluZkJsb2Nrcy5wcm90b3R5cGUuaW5mbGF0ZV9mbHVzaCA9IGZ1bmN0aW9uKHosIHIpe1xuICAgIHZhciBuO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuXG4gICAgLy8gbG9jYWwgY29waWVzIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcG9pbnRlcnNcbiAgICBwID0gei5uZXh0X291dF9pbmRleDtcbiAgICBxID0gdGhpcy5yZWFkO1xuXG4gICAgLy8gY29tcHV0ZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xuICAgIG4gPSAoKHEgPD0gdGhpcy53cml0ZSA/IHRoaXMud3JpdGUgOiB0aGlzLmVuZCkgLSBxKTtcbiAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgaWYgKG4hPTAgJiYgciA9PSBaX0JVRl9FUlJPUikgciA9IFpfT0s7XG5cbiAgICAvLyB1cGRhdGUgY291bnRlcnNcbiAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgIHoudG90YWxfb3V0ICs9IG47XG5cbiAgICAvLyB1cGRhdGUgY2hlY2sgaW5mb3JtYXRpb25cbiAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKHRoaXMuY2hlY2ssIHRoaXMud2luZG93LCBxLCBuKTtcblxuICAgIC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcbiAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgIHAgKz0gbjtcbiAgICBxICs9IG47XG5cbiAgICAvLyBzZWUgaWYgbW9yZSB0byBjb3B5IGF0IGJlZ2lubmluZyBvZiB3aW5kb3dcbiAgICBpZiAocSA9PSB0aGlzLmVuZCl7XG4gICAgICAvLyB3cmFwIHBvaW50ZXJzXG4gICAgICBxID0gMDtcbiAgICAgIGlmICh0aGlzLndyaXRlID09IHRoaXMuZW5kKVxuICAgICAgICB0aGlzLndyaXRlID0gMDtcblxuICAgICAgLy8gY29tcHV0ZSBieXRlcyB0byBjb3B5XG4gICAgICBuID0gdGhpcy53cml0ZSAtIHE7XG4gICAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgICBpZiAobiE9MCAmJiByID09IFpfQlVGX0VSUk9SKSByID0gWl9PSztcblxuICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgICAgei50b3RhbF9vdXQgKz0gbjtcblxuICAgICAgLy8gdXBkYXRlIGNoZWNrIGluZm9ybWF0aW9uXG4gICAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcblx0ei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIodGhpcy5jaGVjaywgdGhpcy53aW5kb3csIHEsIG4pO1xuXG4gICAgICAvLyBjb3B5XG4gICAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgICAgcCArPSBuO1xuICAgICAgcSArPSBuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBwb2ludGVyc1xuICAgIHoubmV4dF9vdXRfaW5kZXggPSBwO1xuICAgIHRoaXMucmVhZCA9IHE7XG5cbiAgICAvLyBkb25lXG4gICAgcmV0dXJuIHI7XG4gIH1cblxuLy9cbi8vIEluZkNvZGVzLmphdmFcbi8vXG5cbnZhciBJQ19TVEFSVD0wOyAgLy8geDogc2V0IHVwIGZvciBMRU5cbnZhciBJQ19MRU49MTsgICAgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XG52YXIgSUNfTEVORVhUPTI7IC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXG52YXIgSUNfRElTVD0zOyAgIC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XG52YXIgSUNfRElTVEVYVD00Oy8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcbnZhciBJQ19DT1BZPTU7ICAgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmcgZm9yIHNwYWNlXG52YXIgSUNfTElUPTY7ICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2VcbnZhciBJQ19XQVNIPTc7ICAgLy8gbzogZ290IGVvYiwgcG9zc2libHkgc3RpbGwgb3V0cHV0IHdhaXRpbmdcbnZhciBJQ19FTkQ9ODsgICAgLy8geDogZ290IGVvYiBhbmQgYWxsIGRhdGEgZmx1c2hlZFxudmFyIElDX0JBRENPREU9OTsvLyB4OiBnb3QgZXJyb3JcblxuZnVuY3Rpb24gSW5mQ29kZXMoKSB7XG59XG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgeikge1xuICAgIHRoaXMubW9kZT1JQ19TVEFSVDtcbiAgICB0aGlzLmxiaXRzPWJsO1xuICAgIHRoaXMuZGJpdHM9YmQ7XG4gICAgdGhpcy5sdHJlZT10bDtcbiAgICB0aGlzLmx0cmVlX2luZGV4PXRsX2luZGV4O1xuICAgIHRoaXMuZHRyZWUgPSB0ZDtcbiAgICB0aGlzLmR0cmVlX2luZGV4PXRkX2luZGV4O1xuICAgIHRoaXMudHJlZT1udWxsO1xufVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUucHJvYyA9IGZ1bmN0aW9uKHMsIHosIHIpeyBcbiAgICB2YXIgajsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlciAoaW50W10pXG4gICAgdmFyIHRpbmRleDsgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciBlOyAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYj0wOyAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgaz0wOyAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwPTA7ICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgZjsgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cblxuICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxuICAgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcbiAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0IGFuZCBvdXRwdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKXtcblx0Ly8gd2FpdGluZyBmb3IgXCJpOlwiPWlucHV0LCBcIm86XCI9b3V0cHV0LCBcIng6XCI9bm90aGluZ1xuICAgICAgY2FzZSBJQ19TVEFSVDogICAgICAgICAvLyB4OiBzZXQgdXAgZm9yIExFTlxuXHRpZiAobSA+PSAyNTggJiYgbiA+PSAxMCl7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXHQgIHIgPSB0aGlzLmluZmxhdGVfZmFzdCh0aGlzLmxiaXRzLCB0aGlzLmRiaXRzLCBcblx0XHRcdCAgIHRoaXMubHRyZWUsIHRoaXMubHRyZWVfaW5kZXgsIFxuXHRcdFx0ICAgdGhpcy5kdHJlZSwgdGhpcy5kdHJlZV9pbmRleCxcblx0XHRcdCAgIHMsIHopO1xuXG5cdCAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuXHQgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgIGlmIChyICE9IFpfT0spe1xuXHQgICAgdGhpcy5tb2RlID0gciA9PSBaX1NUUkVBTV9FTkQgPyBJQ19XQVNIIDogSUNfQkFEQ09ERTtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXHR0aGlzLm5lZWQgPSB0aGlzLmxiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmx0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXg9dGhpcy5sdHJlZV9pbmRleDtcblxuXHR0aGlzLm1vZGUgPSBJQ19MRU47XG4gICAgICBjYXNlIElDX0xFTjogICAgICAgICAgIC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGluZGV4PSh0aGlzLnRyZWVfaW5kZXgrKGImaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj4+PSh0aGlzLnRyZWVbdGluZGV4KzFdKTtcblx0ay09KHRoaXMudHJlZVt0aW5kZXgrMV0pO1xuXG5cdGU9dGhpcy50cmVlW3RpbmRleF07XG5cblx0aWYoZSA9PSAwKXsgICAgICAgICAgICAgICAvLyBsaXRlcmFsXG5cdCAgdGhpcy5saXQgPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0xJVDtcblx0ICBicmVhaztcblx0fVxuXHRpZigoZSAmIDE2KSE9MCApeyAgICAgICAgICAvLyBsZW5ndGhcblx0ICB0aGlzLmdldCA9IGUgJiAxNTtcblx0ICB0aGlzLmxlbiA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfTEVORVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiAzMikhPTApeyAgICAgICAgICAgICAgIC8vIGVuZCBvZiBibG9ja1xuXHQgIHRoaXMubW9kZSA9IElDX1dBU0g7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfQkFEQ09ERTsgICAgICAgIC8vIGludmFsaWQgY29kZVxuXHR6Lm1zZyA9IFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCI7XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfTEVORVhUOiAgICAgICAgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcblx0aiA9IHRoaXMuZ2V0O1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMubGVuICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcblxuXHRiPj49ajtcblx0ay09ajtcblxuXHR0aGlzLm5lZWQgPSB0aGlzLmRiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmR0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXggPSB0aGlzLmR0cmVlX2luZGV4O1xuXHR0aGlzLm1vZGUgPSBJQ19ESVNUO1xuICAgICAgY2FzZSBJQ19ESVNUOiAgICAgICAgICAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRpbmRleD0odGhpcy50cmVlX2luZGV4KyhiICYgaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj49dGhpcy50cmVlW3RpbmRleCsxXTtcblx0ay09dGhpcy50cmVlW3RpbmRleCsxXTtcblxuXHRlID0gKHRoaXMudHJlZVt0aW5kZXhdKTtcblx0aWYoKGUgJiAxNikhPTApeyAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlXG5cdCAgdGhpcy5nZXQgPSBlICYgMTU7XG5cdCAgdGhpcy5kaXN0ID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19ESVNURVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19CQURDT0RFOyAgICAgICAgLy8gaW52YWxpZCBjb2RlXG5cdHoubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIjtcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19ESVNURVhUOiAgICAgICAvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXG5cdGogPSB0aGlzLmdldDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLmRpc3QgKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xuXG5cdGI+Pj1qO1xuXHRrLT1qO1xuXG5cdHRoaXMubW9kZSA9IElDX0NPUFk7XG4gICAgICBjYXNlIElDX0NPUFk6ICAgICAgICAgIC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxuICAgICAgICBmID0gcSAtIHRoaXMuZGlzdDtcbiAgICAgICAgd2hpbGUoZiA8IDApeyAgICAgLy8gbW9kdWxvIHdpbmRvdyBzaXplLVwid2hpbGVcIiBpbnN0ZWFkXG4gICAgICAgICAgZiArPSBzLmVuZDsgICAgIC8vIG9mIFwiaWZcIiBoYW5kbGVzIGludmFsaWQgZGlzdGFuY2VzXG5cdH1cblx0d2hpbGUgKHRoaXMubGVuIT0wKXtcblxuXHQgIGlmKG09PTApe1xuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXG5cdCAgICAgIGlmKG09PTApe1xuXHRcdHMuYml0Yj1iO3MuYml0az1rO1xuXHRcdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0XHRzLndyaXRlPXE7XG5cdFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICB9ICBcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzLndpbmRvd1txKytdPXMud2luZG93W2YrK107IG0tLTtcblxuXHQgIGlmIChmID09IHMuZW5kKVxuICAgICAgICAgICAgZiA9IDA7XG5cdCAgdGhpcy5sZW4tLTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX0xJVDogICAgICAgICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2Vcblx0aWYobT09MCl7XG5cdCAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICBpZihtPT0wKXtcblx0ICAgIHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICBzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHMud2luZG93W3ErK109dGhpcy5saXQ7IG0tLTtcblxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX1dBU0g6ICAgICAgICAgICAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBtb3JlIG91dHB1dFxuXHRpZiAoayA+IDcpeyAgICAgICAgLy8gcmV0dXJuIHVudXNlZCBieXRlLCBpZiBhbnlcblx0ICBrIC09IDg7XG5cdCAgbisrO1xuXHQgIHAtLTsgICAgICAgICAgICAgLy8gY2FuIGFsd2F5cyByZXR1cm4gb25lXG5cdH1cblxuXHRzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHRpZiAocy5yZWFkICE9IHMud3JpdGUpe1xuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0VORDtcbiAgICAgIGNhc2UgSUNfRU5EOlxuXHRyID0gWl9TVFJFQU1fRU5EO1xuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19CQURDT0RFOiAgICAgICAvLyB4OiBnb3QgZXJyb3JcblxuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBkZWZhdWx0OlxuXHRyID0gWl9TVFJFQU1fRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbkluZkNvZGVzLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oeil7XG4gICAgLy8gIFpGUkVFKHosIGMpO1xufVxuXG4gIC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcbiAgLy8gKHRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGgpIGFuZCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgYXZhaWxhYmxlXG4gIC8vIGF0IGxlYXN0IHRlbi4gIFRoZSB0ZW4gYnl0ZXMgYXJlIHNpeCBieXRlcyBmb3IgdGhlIGxvbmdlc3QgbGVuZ3RoL1xuICAvLyBkaXN0YW5jZSBwYWlyIHBsdXMgZm91ciBieXRlcyBmb3Igb3ZlcmxvYWRpbmcgdGhlIGJpdCBidWZmZXIuXG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbmZsYXRlX2Zhc3QgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyICAgdHA7ICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyIChpbnRbXSlcbiAgICB2YXIgdHBfaW5kZXg7ICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgZTsgICAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYjsgICAgICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgbWw7ICAgICAgICAgICAgICAgLy8gbWFzayBmb3IgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHZhciBtZDsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciBkaXN0YW5jZSB0cmVlXG4gICAgdmFyIGM7ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGNvcHlcbiAgICB2YXIgZDsgICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cbiAgICB2YXIgcjsgICAgICAgICAgICAgICAgLy8gY29weSBzb3VyY2UgcG9pbnRlclxuXG4gICAgdmFyIHRwX2luZGV4X3RfMzsgICAgIC8vICh0cF9pbmRleCt0KSozXG5cbiAgICAvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcbiAgICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG4gICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBtYXNrc1xuICAgIG1sID0gaW5mbGF0ZV9tYXNrW2JsXTtcbiAgICBtZCA9IGluZmxhdGVfbWFza1tiZF07XG5cbiAgICAvLyBkbyB1bnRpbCBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBzcGFjZSBmb3IgZmFzdCBsb29wXG4gICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGNhbGxlZCB3aXRoIG0gPj0gMjU4ICYmIG4gPj0gMTBcbiAgICAgIC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXG4gICAgICB3aGlsZShrPCgyMCkpeyAgICAgICAgICAgICAgLy8gbWF4IGJpdHMgZm9yIGxpdGVyYWwvbGVuZ3RoIGNvZGVcblx0bi0tO1xuXHRifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcbiAgICAgIH1cblxuICAgICAgdD0gYiZtbDtcbiAgICAgIHRwPXRsOyBcbiAgICAgIHRwX2luZGV4PXRsX2luZGV4O1xuICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuICAgICAgaWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT0gMCl7XG5cdGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0cy53aW5kb3dbcSsrXSA9IHRwW3RwX2luZGV4X3RfMysyXTtcblx0bS0tO1xuXHRjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvIHtcblxuXHRiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdGlmKChlJjE2KSE9MCl7XG5cdCAgZSAmPSAxNTtcblx0ICBjID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGIgJiBpbmZsYXRlX21hc2tbZV0pO1xuXG5cdCAgYj4+PWU7IGstPWU7XG5cblx0ICAvLyBkZWNvZGUgZGlzdGFuY2UgYmFzZSBvZiBibG9jayB0byBjb3B5XG5cdCAgd2hpbGUoazwoMTUpKXsgICAgICAgICAgIC8vIG1heCBiaXRzIGZvciBkaXN0YW5jZSBjb2RlXG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcblx0ICB9XG5cblx0ICB0PSBiJm1kO1xuXHQgIHRwPXRkO1xuXHQgIHRwX2luZGV4PXRkX2luZGV4O1xuICAgICAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICBlID0gdHBbdHBfaW5kZXhfdF8zXTtcblxuXHQgIGRvIHtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgaWYoKGUmMTYpIT0wKXtcblx0ICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2Vcblx0ICAgICAgZSAmPSAxNTtcblx0ICAgICAgd2hpbGUoazwoZSkpeyAgICAgICAgIC8vIGdldCBleHRyYSBiaXRzICh1cCB0byAxMylcblx0XHRuLS07XG5cdFx0Ynw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG5cdCAgICAgIH1cblxuXHQgICAgICBkID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGImaW5mbGF0ZV9tYXNrW2VdKTtcblxuXHQgICAgICBiPj49KGUpOyBrLT0oZSk7XG5cblx0ICAgICAgLy8gZG8gdGhlIGNvcHlcblx0ICAgICAgbSAtPSBjO1xuXHQgICAgICBpZiAocSA+PSBkKXsgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XG5cdFx0Ly8gIGp1c3QgY29weVxuXHRcdHI9cS1kO1xuXHRcdGlmKHEtcj4wICYmIDI+KHEtcikpeyAgICAgICAgICAgXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIG1pbmltdW0gY291bnQgaXMgdGhyZWUsXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIHNvIHVucm9sbCBsb29wIGEgbGl0dGxlXG5cdFx0ICBjLT0yO1xuXHRcdH1cblx0XHRlbHNle1xuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtIGNvdW50IGlzIHRocmVlLFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGwgbG9vcCBhIGxpdHRsZVxuXHRcdCAgYy09Mjtcblx0XHR9XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZXsgICAgICAgICAgICAgICAgICAvLyBlbHNlIG9mZnNldCBhZnRlciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICAgIHI9cS1kO1xuICAgICAgICAgICAgICAgIGRve1xuICAgICAgICAgICAgICAgICAgcis9cy5lbmQ7ICAgICAgICAgIC8vIGZvcmNlIHBvaW50ZXIgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgfXdoaWxlKHI8MCk7ICAgICAgICAgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXG5cdFx0ZT1zLmVuZC1yO1xuXHRcdGlmKGM+ZSl7ICAgICAgICAgICAgIC8vIGlmIHNvdXJjZSBjcm9zc2VzLFxuXHRcdCAgYy09ZTsgICAgICAgICAgICAgIC8vIHdyYXBwZWQgY29weVxuXHRcdCAgaWYocS1yPjAgJiYgZT4ocS1yKSl7ICAgICAgICAgICBcblx0XHQgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdCAgICB3aGlsZSgtLWUhPTApO1xuXHRcdCAgfVxuXHRcdCAgZWxzZXtcblx0XHQgICAgYXJyYXlDb3B5KHMud2luZG93LCByLCBzLndpbmRvdywgcSwgZSk7XG5cdFx0ICAgIHErPWU7IHIrPWU7IGU9MDtcblx0XHQgIH1cblx0XHQgIHIgPSAwOyAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdCBmcm9tIHN0YXJ0IG9mIHdpbmRvd1xuXHRcdH1cblxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gY29weSBhbGwgb3Igd2hhdCdzIGxlZnRcbiAgICAgICAgICAgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdHdoaWxlKC0tYyE9MCk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZigoZSY2NCk9PTApe1xuXHQgICAgICB0Kz10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICAgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICAgICAgZT10cFt0cF9pbmRleF90XzNdO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgei5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiO1xuXG5cdCAgICAgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG5cdCAgICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHMud3JpdGU9cTtcblxuXHQgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuXHQgICAgfVxuXHQgIH1cblx0ICB3aGlsZSh0cnVlKTtcblx0ICBicmVhaztcblx0fVxuXG5cdGlmKChlJjY0KT09MCl7XG5cdCAgdCs9dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgIGlmKChlPXRwW3RwX2luZGV4X3RfM10pPT0wKXtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgcy53aW5kb3dbcSsrXT10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICBtLS07XG5cdCAgICBicmVhaztcblx0ICB9XG5cdH1cblx0ZWxzZSBpZigoZSYzMikhPTApe1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG4gXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblxuXHQgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG5cdH1cblx0ZWxzZXtcblx0ICB6Lm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiO1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXG5cdCAgcmV0dXJuIFpfREFUQV9FUlJPUjtcblx0fVxuICAgICAgfSBcbiAgICAgIHdoaWxlKHRydWUpO1xuICAgIH0gXG4gICAgd2hpbGUobT49MjU4ICYmIG4+PSAxMCk7XG5cbiAgICAvLyBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dC0tcmVzdG9yZSBwb2ludGVycyBhbmQgcmV0dXJuXG4gICAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cbiAgICBzLmJpdGI9YjtzLmJpdGs9aztcbiAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG4gICAgcy53cml0ZT1xO1xuXG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbi8vXG4vLyBJbmZUcmVlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZlRyZWUoKSB7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmh1ZnRfYnVpbGQgPSBmdW5jdGlvbihiLCBiaW5kZXgsIG4sIHMsIGQsIGUsIHQsIG0sIGhwLCBobiwgdikge1xuXG4gICAgLy8gR2l2ZW4gYSBsaXN0IG9mIGNvZGUgbGVuZ3RocyBhbmQgYSBtYXhpbXVtIHRhYmxlIHNpemUsIG1ha2UgYSBzZXQgb2ZcbiAgICAvLyB0YWJsZXMgdG8gZGVjb2RlIHRoYXQgc2V0IG9mIGNvZGVzLiAgUmV0dXJuIFpfT0sgb24gc3VjY2VzcywgWl9CVUZfRVJST1JcbiAgICAvLyBpZiB0aGUgZ2l2ZW4gY29kZSBzZXQgaXMgaW5jb21wbGV0ZSAodGhlIHRhYmxlcyBhcmUgc3RpbGwgYnVpbHQgaW4gdGhpc1xuICAgIC8vIGNhc2UpLCBaX0RBVEFfRVJST1IgaWYgdGhlIGlucHV0IGlzIGludmFsaWQgKGFuIG92ZXItc3Vic2NyaWJlZCBzZXQgb2ZcbiAgICAvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXG5cbiAgICB2YXIgYTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXG4gICAgdmFyIGY7ICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHJlcGVhdHMgaW4gdGFibGUgZXZlcnkgZiBlbnRyaWVzXG4gICAgdmFyIGc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgdmFyIGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSBsZXZlbFxuICAgIHZhciBpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlciwgY3VycmVudCBjb2RlXG4gICAgdmFyIGo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcbiAgICB2YXIgbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcGVyIHRhYmxlIChyZXR1cm5lZCBpbiBtKVxuICAgIHZhciBtYXNrOyAgICAgICAgICAgICAgICAgICAgLy8gKDEgPDwgdykgLSAxLCB0byBhdm9pZCBjYyAtTyBidWcgb24gSFBcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMgdG8gY3VycmVudCB0YWJsZVxuICAgIHZhciB3OyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBiZWZvcmUgdGhpcyB0YWJsZSA9PSAobCAqIGgpXG4gICAgdmFyIHhwOyAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGludG8geFxuICAgIHZhciB5OyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXG4gICAgdmFyIHo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXG5cbiAgICAvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxuXG4gICAgcCA9IDA7IGkgPSBuO1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY1tiW2JpbmRleCtwXV0rKzsgcCsrOyBpLS07ICAgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcbiAgICB9d2hpbGUoaSE9MCk7XG5cbiAgICBpZih0aGlzLmNbMF0gPT0gbil7ICAgICAgICAgICAgICAgIC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xuICAgICAgdFswXSA9IC0xO1xuICAgICAgbVswXSA9IDA7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvLyBGaW5kIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoLCBib3VuZCAqbSBieSB0aG9zZVxuICAgIGwgPSBtWzBdO1xuICAgIGZvciAoaiA9IDE7IGogPD0gQk1BWDsgaisrKVxuICAgICAgaWYodGhpcy5jW2pdIT0wKSBicmVhaztcbiAgICBrID0gajsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5pbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA8IGope1xuICAgICAgbCA9IGo7XG4gICAgfVxuICAgIGZvciAoaSA9IEJNQVg7IGkhPTA7IGktLSl7XG4gICAgICBpZih0aGlzLmNbaV0hPTApIGJyZWFrO1xuICAgIH1cbiAgICBnID0gaTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA+IGkpe1xuICAgICAgbCA9IGk7XG4gICAgfVxuICAgIG1bMF0gPSBsO1xuXG4gICAgLy8gQWRqdXN0IGxhc3QgbGVuZ3RoIGNvdW50IHRvIGZpbGwgb3V0IGNvZGVzLCBpZiBuZWVkZWRcbiAgICBmb3IgKHkgPSAxIDw8IGo7IGogPCBpOyBqKyssIHkgPDw9IDEpe1xuICAgICAgaWYgKCh5IC09IHRoaXMuY1tqXSkgPCAwKXtcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh5IC09IHRoaXMuY1tpXSkgPCAwKXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHRoaXMuY1tpXSArPSB5O1xuXG4gICAgLy8gR2VuZXJhdGUgc3RhcnRpbmcgb2Zmc2V0cyBpbnRvIHRoZSB2YWx1ZSB0YWJsZSBmb3IgZWFjaCBsZW5ndGhcbiAgICB0aGlzLnhbMV0gPSBqID0gMDtcbiAgICBwID0gMTsgIHhwID0gMjtcbiAgICB3aGlsZSAoLS1pIT0wKSB7ICAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgaSA9PSBnIGZyb20gYWJvdmVcbiAgICAgIHRoaXMueFt4cF0gPSAoaiArPSB0aGlzLmNbcF0pO1xuICAgICAgeHArKztcbiAgICAgIHArKztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgdGFibGUgb2YgdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhzXG4gICAgaSA9IDA7IHAgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmICgoaiA9IGJbYmluZGV4K3BdKSAhPSAwKXtcbiAgICAgICAgdGhpcy52W3RoaXMueFtqXSsrXSA9IGk7XG4gICAgICB9XG4gICAgICBwKys7XG4gICAgfVxuICAgIHdoaWxlICgrK2kgPCBuKTtcbiAgICBuID0gdGhpcy54W2ddOyAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBuIHRvIGxlbmd0aCBvZiB2XG5cbiAgICAvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcbiAgICB0aGlzLnhbMF0gPSBpID0gMDsgICAgICAgICAgICAgICAgIC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXG4gICAgcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiB2YWx1ZXMgaW4gYml0IG9yZGVyXG4gICAgaCA9IC0xOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcbiAgICB3ID0gLWw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGRlY29kZWQgPT0gKGwgKiBoKVxuICAgIHRoaXMudVswXSA9IDA7ICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCB0byBrZWVwIGNvbXBpbGVycyBoYXBweVxuICAgIHEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdHRvXG4gICAgeiA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl0dG9cblxuICAgIC8vIGdvIHRocm91Z2ggdGhlIGJpdCBsZW5ndGhzIChrIGFscmVhZHkgaXMgYml0cyBpbiBzaG9ydGVzdCBjb2RlKVxuICAgIGZvciAoOyBrIDw9IGc7IGsrKyl7XG4gICAgICBhID0gdGhpcy5jW2tdO1xuICAgICAgd2hpbGUgKGEtLSE9MCl7XG5cdC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXG5cdC8vIG1ha2UgdGFibGVzIHVwIHRvIHJlcXVpcmVkIGxldmVsXG4gICAgICAgIHdoaWxlIChrID4gdyArIGwpe1xuICAgICAgICAgIGgrKztcbiAgICAgICAgICB3ICs9IGw7ICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0YWJsZSBhbHdheXMgbCBiaXRzXG5cdCAgLy8gY29tcHV0ZSBtaW5pbXVtIHNpemUgdGFibGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGwgYml0c1xuICAgICAgICAgIHogPSBnIC0gdztcbiAgICAgICAgICB6ID0gKHogPiBsKSA/IGwgOiB6OyAgICAgICAgLy8gdGFibGUgc2l6ZSB1cHBlciBsaW1pdFxuICAgICAgICAgIGlmKChmPTE8PChqPWstdykpPmErMSl7ICAgICAvLyB0cnkgYSBrLXcgYml0IHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvbyBmZXcgY29kZXMgZm9yIGstdyBiaXQgdGFibGVcbiAgICAgICAgICAgIGYgLT0gYSArIDE7ICAgICAgICAgICAgICAgLy8gZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnMgbGVmdFxuICAgICAgICAgICAgeHAgPSBrO1xuICAgICAgICAgICAgaWYoaiA8IHope1xuICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgeil7ICAgICAgICAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXG4gICAgICAgICAgICAgICAgaWYoKGYgPDw9IDEpIDw9IHRoaXMuY1srK3hwXSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcbiAgICAgICAgICAgICAgICBmIC09IHRoaXMuY1t4cF07ICAgICAgICAgICAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXG4gICAgICAgICAgICAgIH1cblx0ICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeiA9IDEgPDwgajsgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGVudHJpZXMgZm9yIGotYml0IHRhYmxlXG5cblx0ICAvLyBhbGxvY2F0ZSBuZXcgdGFibGVcbiAgICAgICAgICBpZiAodGhpcy5oblswXSArIHogPiBNQU5ZKXsgICAgICAgLy8gKG5vdGU6IGRvZXNuJ3QgbWF0dGVyIGZvciBmaXhlZClcbiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7ICAgICAgIC8vIG92ZXJmbG93IG9mIE1BTllcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51W2hdID0gcSA9IC8qaHArKi8gdGhpcy5oblswXTsgICAvLyBERUJVR1xuICAgICAgICAgIHRoaXMuaG5bMF0gKz0gejtcbiBcblx0ICAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZVxuXHQgIGlmKGghPTApe1xuICAgICAgICAgICAgdGhpcy54W2hdPWk7ICAgICAgICAgICAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcbiAgICAgICAgICAgIHRoaXMuclswXT1qOyAgICAgLy8gYml0cyBpbiB0aGlzIHRhYmxlXG4gICAgICAgICAgICB0aGlzLnJbMV09bDsgICAgIC8vIGJpdHMgdG8gZHVtcCBiZWZvcmUgdGhpcyB0YWJsZVxuICAgICAgICAgICAgaj1pPj4+KHcgLSBsKTtcbiAgICAgICAgICAgIHRoaXMuclsyXSA9IChxIC0gdGhpcy51W2gtMV0gLSBqKTsgICAgICAgICAgICAgICAvLyBvZmZzZXQgdG8gdGhpcyB0YWJsZVxuICAgICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsICh0aGlzLnVbaC0xXStqKSozLCAzKTsgLy8gY29ubmVjdCB0byBsYXN0IHRhYmxlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0WzBdID0gcTsgICAgICAgICAgICAgICAvLyBmaXJzdCB0YWJsZSBpcyByZXR1cm5lZCByZXN1bHRcblx0ICB9XG4gICAgICAgIH1cblxuXHQvLyBzZXQgdXAgdGFibGUgZW50cnkgaW4gclxuICAgICAgICB0aGlzLnJbMV0gPSAoayAtIHcpO1xuICAgICAgICBpZiAocCA+PSBuKXtcbiAgICAgICAgICB0aGlzLnJbMF0gPSAxMjggKyA2NDsgICAgICAvLyBvdXQgb2YgdmFsdWVzLS1pbnZhbGlkIGNvZGVcblx0fVxuICAgICAgICBlbHNlIGlmICh2W3BdIDwgcyl7XG4gICAgICAgICAgdGhpcy5yWzBdID0gKHRoaXMudltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgIC8vIDI1NiBpcyBlbmQtb2YtYmxvY2tcbiAgICAgICAgICB0aGlzLnJbMl0gPSB0aGlzLnZbcCsrXTsgICAgICAgICAgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRoaXMuclswXT0oZVt0aGlzLnZbcF0tc10rMTYrNjQpOyAvLyBub24tc2ltcGxlLS1sb29rIHVwIGluIGxpc3RzXG4gICAgICAgICAgdGhpcy5yWzJdPWRbdGhpcy52W3ArK10gLSBzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXG4gICAgICAgIGY9MTw8KGstdyk7XG4gICAgICAgIGZvciAoaj1pPj4+dztqPHo7ais9Zil7XG4gICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsIChxK2opKjMsIDMpO1xuXHR9XG5cblx0Ly8gYmFja3dhcmRzIGluY3JlbWVudCB0aGUgay1iaXQgY29kZSBpXG4gICAgICAgIGZvciAoaiA9IDEgPDwgKGsgLSAxKTsgKGkgJiBqKSE9MDsgaiA+Pj49IDEpe1xuICAgICAgICAgIGkgXj0gajtcblx0fVxuICAgICAgICBpIF49IGo7XG5cblx0Ly8gYmFja3VwIG92ZXIgZmluaXNoZWQgdGFibGVzXG4gICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7ICAgICAgLy8gbmVlZGVkIG9uIEhQLCBjYyAtTyBidWdcbiAgICAgICAgd2hpbGUgKChpICYgbWFzaykgIT0gdGhpcy54W2hdKXtcbiAgICAgICAgICBoLS07ICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXG4gICAgICAgICAgdyAtPSBsO1xuICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxuICAgIHJldHVybiB5ICE9IDAgJiYgZyAhPSAxID8gWl9CVUZfRVJST1IgOiBaX09LO1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbmZsYXRlX3RyZWVzX2JpdHMgPSBmdW5jdGlvbihjLCBiYiwgdGIsIGhwLCB6KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgxOSk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCAxOSwgMTksIG51bGwsIG51bGwsIHRiLCBiYiwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG5cbiAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICB9XG4gICAgZWxzZSBpZihyZXN1bHQgPT0gWl9CVUZfRVJST1IgfHwgYmJbMF0gPT0gMCl7XG4gICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5mbGF0ZV90cmVlc19keW5hbWljID0gZnVuY3Rpb24obmwsIG5kLCBjLCBibCwgYmQsIHRsLCB0ZCwgaHAsIHopIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gYnVpbGQgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDI4OCk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCBubCwgMjU3LCBjcGxlbnMsIGNwbGV4dCwgdGwsIGJsLCBocCwgdGhpcy5obiwgdGhpcy52KTtcbiAgICBpZiAocmVzdWx0ICE9IFpfT0sgfHwgYmxbMF0gPT0gMCl7XG4gICAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBidWlsZCBkaXN0YW5jZSB0cmVlXG4gICAgdGhpcy5pbml0V29ya0FyZWEoMjg4KTtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgdGhpcy5obiwgdGhpcy52KTtcblxuICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT0gMCAmJiBubCA+IDI1Nykpe1xuICAgICAgaWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgZGlzdGFuY2UgdHJlZVwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ID09IFpfQlVGX0VSUk9SKSB7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGRpc3RhbmNlIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpfT0s7XG59XG4vKlxuICBzdGF0aWMgaW50IGluZmxhdGVfdHJlZXNfZml4ZWQoaW50W10gYmwsICAvL2xpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXSBiZCwgIC8vZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXVtdIHRsLC8vbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdW10gdGQsLy9kaXN0YW5jZSB0cmVlIHJlc3VsdCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpTdHJlYW0geiAgLy9mb3IgbWVtb3J5IGFsbG9jYXRpb25cblx0XHRcdFx0ICl7XG5cbiovXG5cbmZ1bmN0aW9uIGluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQsIHopIHtcbiAgICBibFswXT1maXhlZF9ibDtcbiAgICBiZFswXT1maXhlZF9iZDtcbiAgICB0bFswXT1maXhlZF90bDtcbiAgICB0ZFswXT1maXhlZF90ZDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5pdFdvcmtBcmVhID0gZnVuY3Rpb24odnNpemUpe1xuICAgIGlmKHRoaXMuaG49PW51bGwpe1xuICAgICAgICB0aGlzLmhuPW5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICB0aGlzLnY9bmV3IEludDMyQXJyYXkodnNpemUpO1xuICAgICAgICB0aGlzLmM9bmV3IEludDMyQXJyYXkoQk1BWCsxKTtcbiAgICAgICAgdGhpcy5yPW5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICB0aGlzLnU9bmV3IEludDMyQXJyYXkoQk1BWCk7XG4gICAgICAgIHRoaXMueD1uZXcgSW50MzJBcnJheShCTUFYKzEpO1xuICAgIH1cbiAgICBpZih0aGlzLnYubGVuZ3RoPHZzaXplKXsgXG4gICAgICAgIHRoaXMudj1uZXcgSW50MzJBcnJheSh2c2l6ZSk7IFxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTx2c2l6ZTsgaSsrKXt0aGlzLnZbaV09MDt9XG4gICAgZm9yKHZhciBpPTA7IGk8Qk1BWCsxOyBpKyspe3RoaXMuY1tpXT0wO31cbiAgICBmb3IodmFyIGk9MDsgaTwzOyBpKyspe3RoaXMucltpXT0wO31cbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYOyBpKyspe3VbaV09MDt9XG4gICAgYXJyYXlDb3B5KHRoaXMuYywgMCwgdGhpcy51LCAwLCBCTUFYKTtcbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYKzE7IGkrKyl7eFtpXT0wO31cbiAgICBhcnJheUNvcHkodGhpcy5jLCAwLCB0aGlzLngsIDAsIEJNQVgrMSk7XG59XG5cbnZhciB0ZXN0QXJyYXkgPSBuZXcgVWludDhBcnJheSgxKTtcbnZhciBoYXNTdWJhcnJheSA9ICh0eXBlb2YgdGVzdEFycmF5LnN1YmFycmF5ID09PSAnZnVuY3Rpb24nKTtcbnZhciBoYXNTbGljZSA9IGZhbHNlOyAvKiAodHlwZW9mIHRlc3RBcnJheS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyk7ICovIC8vIENocm9tZSBzbGljZSBwZXJmb3JtYW5jZSBpcyBzbyBkaXJlIHRoYXQgd2UncmUgY3VycmVudGx5IG5vdCB1c2luZyBpdC4uLlxuXG5mdW5jdGlvbiBhcnJheUNvcHkoc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgICAgdGhyb3cgXCJVbmRlZiBzcmNcIjtcbiAgICB9IGVsc2UgaWYgKCFkZXN0KSB7XG4gICAgICAgIHRocm93IFwiVW5kZWYgZGVzdFwiO1xuICAgIH1cblxuICAgIGlmIChzcmNPZmZzZXQgPT0gMCAmJiBjb3VudCA9PSBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KHNyYywgZGVzdCwgZGVzdE9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChoYXNTdWJhcnJheSkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChzcmMuc3ViYXJyYXkoc3JjT2Zmc2V0LCBzcmNPZmZzZXQgKyBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpOyBcbiAgICB9IGVsc2UgaWYgKHNyYy5CWVRFU19QRVJfRUxFTUVOVCA9PSAxICYmIGNvdW50ID4gMTAwKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0ICsgc3JjT2Zmc2V0LCBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpO1xuICAgIH0gZWxzZSB7IFxuICAgICAgICBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpIHtcblxuICAgIC8vIGRsb2coJ19zbG93IGNhbGw6IHNyY09mZnNldD0nICsgc3JjT2Zmc2V0ICsgJzsgZGVzdE9mZnNldD0nICsgZGVzdE9mZnNldCArICc7IGNvdW50PScgKyBjb3VudCk7XG5cbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIGldID0gc3JjW3NyY09mZnNldCArIGldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlDb3B5X2Zhc3Qoc3JjLCBkZXN0LCBkZXN0T2Zmc2V0KSB7XG4gICAgZGVzdC5zZXQoc3JjLCBkZXN0T2Zmc2V0KTtcbn1cblxuXG4gIC8vIGxhcmdlc3QgcHJpbWUgc21hbGxlciB0aGFuIDY1NTM2XG52YXIgQURMRVJfQkFTRT02NTUyMTsgXG4gIC8vIE5NQVggaXMgdGhlIGxhcmdlc3QgbiBzdWNoIHRoYXQgMjU1bihuKzEpLzIgKyAobisxKShCQVNFLTEpIDw9IDJeMzItMVxudmFyIEFETEVSX05NQVg9NTU1MjtcblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgLyogYnl0ZVtdICovIGJ1ZiwgIGluZGV4LCBsZW4pe1xuICAgIGlmKGJ1ZiA9PSBudWxsKXsgcmV0dXJuIDE7IH1cblxuICAgIHZhciBzMT1hZGxlciYweGZmZmY7XG4gICAgdmFyIHMyPShhZGxlcj4+MTYpJjB4ZmZmZjtcbiAgICB2YXIgaztcblxuICAgIHdoaWxlKGxlbiA+IDApIHtcbiAgICAgIGs9bGVuPEFETEVSX05NQVg/bGVuOkFETEVSX05NQVg7XG4gICAgICBsZW4tPWs7XG4gICAgICB3aGlsZShrPj0xNil7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBrLT0xNjtcbiAgICAgIH1cbiAgICAgIGlmKGshPTApe1xuICAgICAgICBkb3tcbiAgICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSgtLWshPTApO1xuICAgICAgfVxuICAgICAgczElPUFETEVSX0JBU0U7XG4gICAgICBzMiU9QURMRVJfQkFTRTtcbiAgICB9XG4gICAgcmV0dXJuIChzMjw8MTYpfHMxO1xufVxuXG5cblxuZnVuY3Rpb24ganN6bGliX2luZmxhdGVfYnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCwgYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XG4gICAgei5pbmZsYXRlSW5pdChERUZfV0JJVFMsIHRydWUpO1xuICAgIHoubmV4dF9pbiA9IGJ1ZmZlcjtcbiAgICB6Lm5leHRfaW5faW5kZXggPSAwO1xuICAgIHouYXZhaWxfaW4gPSBidWZmZXIubGVuZ3RoO1xuXG4gICAgdmFyIG9CbG9ja0xpc3QgPSBbXTtcbiAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgb2J1ZiA9IG5ldyBVaW50OEFycmF5KDMyMDAwKTtcbiAgICAgICAgei5uZXh0X291dCA9IG9idWY7XG4gICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xuICAgICAgICB6LmF2YWlsX291dCA9IG9idWYubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhdHVzID0gei5pbmZsYXRlKFpfTk9fRkxVU0gpO1xuICAgICAgICBpZiAoc3RhdHVzICE9IFpfT0sgJiYgc3RhdHVzICE9IFpfU1RSRUFNX0VORCkge1xuICAgICAgICAgICAgdGhyb3cgei5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHouYXZhaWxfb3V0ICE9IDApIHtcbiAgICAgICAgICAgIHZhciBuZXdvYiA9IG5ldyBVaW50OEFycmF5KG9idWYubGVuZ3RoIC0gei5hdmFpbF9vdXQpO1xuICAgICAgICAgICAgYXJyYXlDb3B5KG9idWYsIDAsIG5ld29iLCAwLCAob2J1Zi5sZW5ndGggLSB6LmF2YWlsX291dCkpO1xuICAgICAgICAgICAgb2J1ZiA9IG5ld29iO1xuICAgICAgICB9XG4gICAgICAgIG9CbG9ja0xpc3QucHVzaChvYnVmKTtcbiAgICAgICAgdG90YWxTaXplICs9IG9idWYubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdHVzID09IFpfU1RSRUFNX0VORCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICAgICAgYWZ0ZXJVbmNPZmZzZXRbMF0gPSAoc3RhcnQgfHwgMCkgKyB6Lm5leHRfaW5faW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF0uYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xuICAgICAgICB2YXIgY3Vyc29yID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG9CbG9ja0xpc3RbaV07XG4gICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcbiAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcbiAgICB9XG59XG5cbmV4cG9ydCB7anN6bGliX2luZmxhdGVfYnVmZmVyLGFycmF5Q29weX0iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbUlBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZJQTtBQXlJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRZQTtBQXdZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyUUE7QUF1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/vendor/inflate.js\n");

/***/ }),

/***/ "../MLVPanel/src/vendor/zlib_and_gzip.min.js":
/*!**********************************************!*\
  !*** .Panel/src/vendor/zlib_and_gzip.min.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function q(b){throw b;}var t=void 0,u=!0,aa=this;function A(b,a){var c=b.split(\".\"),d=aa;!(c[0]in d)&&d.execScript&&d.execScript(\"var \"+c[0]);for(var f;c.length&&(f=c.shift());)!c.length&&a!==t?d[f]=a:d=d[f]?d[f]:d[f]={}};var B=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array;function F(b,a){this.index=\"number\"===typeof a?a:0;this.m=0;this.buffer=b instanceof(B?Uint8Array:Array)?b:new (B?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&q(Error(\"invalid index\"));this.buffer.length<=this.index&&this.f()}F.prototype.f=function(){var b=this.buffer,a,c=b.length,d=new (B?Uint8Array:Array)(c<<1);if(B)d.set(b);else for(a=0;a<c;++a)d[a]=b[a];return this.buffer=d};\nF.prototype.d=function(b,a,c){var d=this.buffer,f=this.index,e=this.m,g=d[f],k;c&&1<a&&(b=8<a?(H[b&255]<<24|H[b>>>8&255]<<16|H[b>>>16&255]<<8|H[b>>>24&255])>>32-a:H[b]>>8-a);if(8>a+e)g=g<<a|b,e+=a;else for(k=0;k<a;++k)g=g<<1|b>>a-k-1&1,8===++e&&(e=0,d[f++]=H[g],g=0,f===d.length&&(d=this.f()));d[f]=g;this.buffer=d;this.m=e;this.index=f};F.prototype.finish=function(){var b=this.buffer,a=this.index,c;0<this.m&&(b[a]<<=8-this.m,b[a]=H[b[a]],a++);B?c=b.subarray(0,a):(b.length=a,c=b);return c};\nvar ba=new (B?Uint8Array:Array)(256),ca;for(ca=0;256>ca;++ca){for(var K=ca,da=K,ea=7,K=K>>>1;K;K>>>=1)da<<=1,da|=K&1,--ea;ba[ca]=(da<<ea&255)>>>0}var H=ba;function ja(b,a,c){var d,f=\"number\"===typeof a?a:a=0,e=\"number\"===typeof c?c:b.length;d=-1;for(f=e&7;f--;++a)d=d>>>8^O[(d^b[a])&255];for(f=e>>3;f--;a+=8)d=d>>>8^O[(d^b[a])&255],d=d>>>8^O[(d^b[a+1])&255],d=d>>>8^O[(d^b[a+2])&255],d=d>>>8^O[(d^b[a+3])&255],d=d>>>8^O[(d^b[a+4])&255],d=d>>>8^O[(d^b[a+5])&255],d=d>>>8^O[(d^b[a+6])&255],d=d>>>8^O[(d^b[a+7])&255];return(d^4294967295)>>>0}\nvar ka=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,\n2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,\n2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,\n2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,\n3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,\n936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],O=B?new Uint32Array(ka):ka;function P(){}P.prototype.getName=function(){return this.name};P.prototype.getData=function(){return this.data};P.prototype.X=function(){return this.Y};A(\"Zlib.GunzipMember\",P);A(\"Zlib.GunzipMember.prototype.getName\",P.prototype.getName);A(\"Zlib.GunzipMember.prototype.getData\",P.prototype.getData);A(\"Zlib.GunzipMember.prototype.getMtime\",P.prototype.X);function la(b){this.buffer=new (B?Uint16Array:Array)(2*b);this.length=0}la.prototype.getParent=function(b){return 2*((b-2)/4|0)};la.prototype.push=function(b,a){var c,d,f=this.buffer,e;c=this.length;f[this.length++]=a;for(f[this.length++]=b;0<c;)if(d=this.getParent(c),f[c]>f[d])e=f[c],f[c]=f[d],f[d]=e,e=f[c+1],f[c+1]=f[d+1],f[d+1]=e,c=d;else break;return this.length};\nla.prototype.pop=function(){var b,a,c=this.buffer,d,f,e;a=c[0];b=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(e=0;;){f=2*e+2;if(f>=this.length)break;f+2<this.length&&c[f+2]>c[f]&&(f+=2);if(c[f]>c[e])d=c[e],c[e]=c[f],c[f]=d,d=c[e+1],c[e+1]=c[f+1],c[f+1]=d;else break;e=f}return{index:b,value:a,length:this.length}};function ma(b){var a=b.length,c=0,d=Number.POSITIVE_INFINITY,f,e,g,k,h,l,s,n,m;for(n=0;n<a;++n)b[n]>c&&(c=b[n]),b[n]<d&&(d=b[n]);f=1<<c;e=new (B?Uint32Array:Array)(f);g=1;k=0;for(h=2;g<=c;){for(n=0;n<a;++n)if(b[n]===g){l=0;s=k;for(m=0;m<g;++m)l=l<<1|s&1,s>>=1;for(m=l;m<f;m+=h)e[m]=g<<16|n;++k}++g;k<<=1;h<<=1}return[e,c,d]};function na(b,a){this.k=qa;this.I=0;this.input=B&&b instanceof Array?new Uint8Array(b):b;this.b=0;a&&(a.lazy&&(this.I=a.lazy),\"number\"===typeof a.compressionType&&(this.k=a.compressionType),a.outputBuffer&&(this.a=B&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),\"number\"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (B?Uint8Array:Array)(32768))}var qa=2,ra={NONE:0,v:1,o:qa,aa:3},sa=[],S;\nfor(S=0;288>S;S++)switch(u){case 143>=S:sa.push([S+48,8]);break;case 255>=S:sa.push([S-144+400,9]);break;case 279>=S:sa.push([S-256+0,7]);break;case 287>=S:sa.push([S-280+192,8]);break;default:q(\"invalid literal: \"+S)}\nna.prototype.g=function(){var b,a,c,d,f=this.input;switch(this.k){case 0:c=0;for(d=f.length;c<d;){a=B?f.subarray(c,c+65535):f.slice(c,c+65535);c+=a.length;var e=a,g=c===d,k=t,h=t,l=t,s=t,n=t,m=this.a,p=this.b;if(B){for(m=new Uint8Array(this.a.buffer);m.length<=p+e.length+5;)m=new Uint8Array(m.length<<1);m.set(this.a)}k=g?1:0;m[p++]=k|0;h=e.length;l=~h+65536&65535;m[p++]=h&255;m[p++]=h>>>8&255;m[p++]=l&255;m[p++]=l>>>8&255;if(B)m.set(e,p),p+=e.length,m=m.subarray(0,p);else{s=0;for(n=e.length;s<n;++s)m[p++]=\ne[s];m.length=p}this.b=p;this.a=m}break;case 1:var r=new F(B?new Uint8Array(this.a.buffer):this.a,this.b);r.d(1,1,u);r.d(1,2,u);var v=ta(this,f),x,Q,y;x=0;for(Q=v.length;x<Q;x++)if(y=v[x],F.prototype.d.apply(r,sa[y]),256<y)r.d(v[++x],v[++x],u),r.d(v[++x],5),r.d(v[++x],v[++x],u);else if(256===y)break;this.a=r.finish();this.b=this.a.length;break;case qa:var E=new F(B?new Uint8Array(this.a.buffer):this.a,this.b),Ja,R,X,Y,Z,pb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa,Ka,ga,La,oa,wa=Array(19),\nMa,$,pa,C,Na;Ja=qa;E.d(1,1,u);E.d(Ja,2,u);R=ta(this,f);fa=ua(this.V,15);Ka=va(fa);ga=ua(this.U,7);La=va(ga);for(X=286;257<X&&0===fa[X-1];X--);for(Y=30;1<Y&&0===ga[Y-1];Y--);var Oa=X,Pa=Y,J=new (B?Uint32Array:Array)(Oa+Pa),w,L,z,ha,I=new (B?Uint32Array:Array)(316),G,D,M=new (B?Uint8Array:Array)(19);for(w=L=0;w<Oa;w++)J[L++]=fa[w];for(w=0;w<Pa;w++)J[L++]=ga[w];if(!B){w=0;for(ha=M.length;w<ha;++w)M[w]=0}w=G=0;for(ha=J.length;w<ha;w+=L){for(L=1;w+L<ha&&J[w+L]===J[w];++L);z=L;if(0===J[w])if(3>z)for(;0<\nz--;)I[G++]=0,M[0]++;else for(;0<z;)D=138>z?z:138,D>z-3&&D<z&&(D=z-3),10>=D?(I[G++]=17,I[G++]=D-3,M[17]++):(I[G++]=18,I[G++]=D-11,M[18]++),z-=D;else if(I[G++]=J[w],M[J[w]]++,z--,3>z)for(;0<z--;)I[G++]=J[w],M[J[w]]++;else for(;0<z;)D=6>z?z:6,D>z-3&&D<z&&(D=z-3),I[G++]=16,I[G++]=D-3,M[16]++,z-=D}b=B?I.subarray(0,G):I.slice(0,G);oa=ua(M,7);for(C=0;19>C;C++)wa[C]=oa[pb[C]];for(Z=19;4<Z&&0===wa[Z-1];Z--);Ma=va(oa);E.d(X-257,5,u);E.d(Y-1,5,u);E.d(Z-4,4,u);for(C=0;C<Z;C++)E.d(wa[C],3,u);C=0;for(Na=b.length;C<\nNa;C++)if($=b[C],E.d(Ma[$],oa[$],u),16<=$){C++;switch($){case 16:pa=2;break;case 17:pa=3;break;case 18:pa=7;break;default:q(\"invalid code: \"+$)}E.d(b[C],pa,u)}var Qa=[Ka,fa],Ra=[La,ga],N,Sa,ia,za,Ta,Ua,Va,Wa;Ta=Qa[0];Ua=Qa[1];Va=Ra[0];Wa=Ra[1];N=0;for(Sa=R.length;N<Sa;++N)if(ia=R[N],E.d(Ta[ia],Ua[ia],u),256<ia)E.d(R[++N],R[++N],u),za=R[++N],E.d(Va[za],Wa[za],u),E.d(R[++N],R[++N],u);else if(256===ia)break;this.a=E.finish();this.b=this.a.length;break;default:q(\"invalid compression type\")}return this.a};\nfunction xa(b,a){this.length=b;this.P=a}\nvar ya=function(){function b(a){switch(u){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,\na-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:q(\"invalid length: \"+a)}}var a=[],c,d;for(c=3;258>=c;c++)d=b(c),a[c]=d[2]<<24|d[1]<<\n16|d[0];return a}(),Aa=B?new Uint32Array(ya):ya;\nfunction ta(b,a){function c(a,c){var b=a.P,d=[],e=0,f;f=Aa[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-\n65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=\nb:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:q(\"invalid distance\")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,k;h=0;for(k=d.length;h<k;++h)m[p++]=d[h];v[d[0]]++;x[d[3]]++;r=a.length+c-1;n=null}var d,f,e,g,k,h={},l,s,n,m=B?new Uint16Array(2*a.length):[],p=0,r=0,v=new (B?Uint32Array:Array)(286),x=new (B?Uint32Array:Array)(30),Q=b.I,y;if(!B){for(e=0;285>=e;)v[e++]=0;for(e=0;29>=e;)x[e++]=0}v[256]=1;d=0;for(f=a.length;d<f;++d){e=k=0;\nfor(g=3;e<g&&d+e!==f;++e)k=k<<8|a[d+e];h[k]===t&&(h[k]=[]);l=h[k];if(!(0<r--)){for(;0<l.length&&32768<d-l[0];)l.shift();if(d+3>=f){n&&c(n,-1);e=0;for(g=f-d;e<g;++e)y=a[d+e],m[p++]=y,++v[y];break}0<l.length?(s=Ba(a,d,l),n?n.length<s.length?(y=a[d-1],m[p++]=y,++v[y],c(s,0)):c(n,-1):s.length<Q?n=s:c(s,0)):n?c(n,-1):(y=a[d],m[p++]=y,++v[y])}l.push(d)}m[p++]=256;v[256]++;b.V=v;b.U=x;return B?m.subarray(0,p):m}\nfunction Ba(b,a,c){var d,f,e=0,g,k,h,l,s=b.length;k=0;l=c.length;a:for(;k<l;k++){d=c[l-k-1];g=3;if(3<e){for(h=e;3<h;h--)if(b[d+h-1]!==b[a+h-1])continue a;g=e}for(;258>g&&a+g<s&&b[d+g]===b[a+g];)++g;g>e&&(f=d,e=g);if(258===g)break}return new xa(e,a-f)}\nfunction ua(b,a){var c=b.length,d=new la(572),f=new (B?Uint8Array:Array)(c),e,g,k,h,l;if(!B)for(h=0;h<c;h++)f[h]=0;for(h=0;h<c;++h)0<b[h]&&d.push(h,b[h]);e=Array(d.length/2);g=new (B?Uint32Array:Array)(d.length/2);if(1===e.length)return f[d.pop().index]=1,f;h=0;for(l=d.length/2;h<l;++h)e[h]=d.pop(),g[h]=e[h].value;k=Ca(g,g.length,a);h=0;for(l=e.length;h<l;++h)f[e[h].index]=k[h];return f}\nfunction Ca(b,a,c){function d(b){var c=h[b][l[b]];c===a?(d(b+1),d(b+1)):--g[c];++l[b]}var f=new (B?Uint16Array:Array)(c),e=new (B?Uint8Array:Array)(c),g=new (B?Uint8Array:Array)(a),k=Array(c),h=Array(c),l=Array(c),s=(1<<c)-a,n=1<<c-1,m,p,r,v,x;f[c-1]=a;for(p=0;p<c;++p)s<n?e[p]=0:(e[p]=1,s-=n),s<<=1,f[c-2-p]=(f[c-1-p]/2|0)+a;f[0]=e[0];k[0]=Array(f[0]);h[0]=Array(f[0]);for(p=1;p<c;++p)f[p]>2*f[p-1]+e[p]&&(f[p]=2*f[p-1]+e[p]),k[p]=Array(f[p]),h[p]=Array(f[p]);for(m=0;m<a;++m)g[m]=c;for(r=0;r<f[c-1];++r)k[c-\n1][r]=b[r],h[c-1][r]=r;for(m=0;m<c;++m)l[m]=0;1===e[c-1]&&(--g[0],++l[c-1]);for(p=c-2;0<=p;--p){v=m=0;x=l[p+1];for(r=0;r<f[p];r++)v=k[p+1][x]+k[p+1][x+1],v>b[m]?(k[p][r]=v,h[p][r]=a,x+=2):(k[p][r]=b[m],h[p][r]=m,++m);l[p]=0;1===e[p]&&d(p)}return g}\nfunction va(b){var a=new (B?Uint16Array:Array)(b.length),c=[],d=[],f=0,e,g,k,h;e=0;for(g=b.length;e<g;e++)c[b[e]]=(c[b[e]]|0)+1;e=1;for(g=16;e<=g;e++)d[e]=f,f+=c[e]|0,f<<=1;e=0;for(g=b.length;e<g;e++){f=d[b[e]];d[b[e]]+=1;k=a[e]=0;for(h=b[e];k<h;k++)a[e]=a[e]<<1|f&1,f>>>=1}return a};function Da(b,a){this.input=b;this.b=this.c=0;this.i={};a&&(a.flags&&(this.i=a.flags),\"string\"===typeof a.filename&&(this.filename=a.filename),\"string\"===typeof a.comment&&(this.A=a.comment),a.deflateOptions&&(this.l=a.deflateOptions));this.l||(this.l={})}\nDa.prototype.g=function(){var b,a,c,d,f,e,g,k,h=new (B?Uint8Array:Array)(32768),l=0,s=this.input,n=this.c,m=this.filename,p=this.A;h[l++]=31;h[l++]=139;h[l++]=8;b=0;this.i.fname&&(b|=Ea);this.i.fcomment&&(b|=Fa);this.i.fhcrc&&(b|=Ga);h[l++]=b;a=(Date.now?Date.now():+new Date)/1E3|0;h[l++]=a&255;h[l++]=a>>>8&255;h[l++]=a>>>16&255;h[l++]=a>>>24&255;h[l++]=0;h[l++]=Ha;if(this.i.fname!==t){g=0;for(k=m.length;g<k;++g)e=m.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}if(this.i.comment){g=\n0;for(k=p.length;g<k;++g)e=p.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}this.i.fhcrc&&(c=ja(h,0,l)&65535,h[l++]=c&255,h[l++]=c>>>8&255);this.l.outputBuffer=h;this.l.outputIndex=l;f=new na(s,this.l);h=f.g();l=f.b;B&&(l+8>h.buffer.byteLength?(this.a=new Uint8Array(l+8),this.a.set(new Uint8Array(h.buffer)),h=this.a):h=new Uint8Array(h.buffer));d=ja(s,t,t);h[l++]=d&255;h[l++]=d>>>8&255;h[l++]=d>>>16&255;h[l++]=d>>>24&255;k=s.length;h[l++]=k&255;h[l++]=k>>>8&255;h[l++]=k>>>16&255;h[l++]=\nk>>>24&255;this.c=n;B&&l<h.length&&(this.a=h=h.subarray(0,l));return h};var Ha=255,Ga=2,Ea=8,Fa=16;A(\"Zlib.Gzip\",Da);A(\"Zlib.Gzip.prototype.compress\",Da.prototype.g);function T(b,a){this.p=[];this.q=32768;this.e=this.j=this.c=this.u=0;this.input=B?new Uint8Array(b):b;this.w=!1;this.r=Ia;this.L=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.q=a.bufferSize),a.bufferType&&(this.r=a.bufferType),a.resize&&(this.L=a.resize);switch(this.r){case Xa:this.b=32768;this.a=new (B?Uint8Array:Array)(32768+this.q+258);break;case Ia:this.b=0;this.a=new (B?Uint8Array:Array)(this.q);this.f=this.T;this.B=this.Q;this.s=this.S;break;default:q(Error(\"invalid inflate mode\"))}}\nvar Xa=0,Ia=1,Ya={N:Xa,M:Ia};\nT.prototype.h=function(){for(;!this.w;){var b=U(this,3);b&1&&(this.w=u);b>>>=1;switch(b){case 0:var a=this.input,c=this.c,d=this.a,f=this.b,e=t,g=t,k=t,h=d.length,l=t;this.e=this.j=0;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (first byte)\"));g=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (second byte)\"));g|=e<<8;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (first byte)\"));k=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (second byte)\"));k|=\ne<<8;g===~k&&q(Error(\"invalid uncompressed block header: length verify\"));c+g>a.length&&q(Error(\"input buffer is broken\"));switch(this.r){case Xa:for(;f+g>d.length;){l=h-f;g-=l;if(B)d.set(a.subarray(c,c+l),f),f+=l,c+=l;else for(;l--;)d[f++]=a[c++];this.b=f;d=this.f();f=this.b}break;case Ia:for(;f+g>d.length;)d=this.f({F:2});break;default:q(Error(\"invalid inflate mode\"))}if(B)d.set(a.subarray(c,c+g),f),f+=g,c+=g;else for(;g--;)d[f++]=a[c++];this.c=c;this.b=f;this.a=d;break;case 1:this.s(Za,$a);break;\ncase 2:ab(this);break;default:q(Error(\"unknown BTYPE: \"+b))}}return this.B()};\nvar bb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],cb=B?new Uint16Array(bb):bb,db=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],eb=B?new Uint16Array(db):db,fb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],gb=B?new Uint8Array(fb):fb,hb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ib=B?new Uint16Array(hb):hb,jb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,\n10,11,11,12,12,13,13],kb=B?new Uint8Array(jb):jb,lb=new (B?Uint8Array:Array)(288),V,mb;V=0;for(mb=lb.length;V<mb;++V)lb[V]=143>=V?8:255>=V?9:279>=V?7:8;var Za=ma(lb),nb=new (B?Uint8Array:Array)(30),ob,qb;ob=0;for(qb=nb.length;ob<qb;++ob)nb[ob]=5;var $a=ma(nb);function U(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g;d<a;)g=f[e++],g===t&&q(Error(\"input buffer is broken\")),c|=g<<d,d+=8;g=c&(1<<a)-1;b.j=c>>>a;b.e=d-a;b.c=e;return g}\nfunction rb(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g=a[0],k=a[1],h,l,s;d<k;){h=f[e++];if(h===t)break;c|=h<<d;d+=8}l=g[c&(1<<k)-1];s=l>>>16;b.j=c>>s;b.e=d-s;b.c=e;return l&65535}\nfunction ab(b){function a(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=rb(this,b),d){case 16:for(f=3+U(this,2);f--;)c[g++]=e;break;case 17:for(f=3+U(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+U(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var c=U(b,5)+257,d=U(b,5)+1,f=U(b,4)+4,e=new (B?Uint8Array:Array)(cb.length),g,k,h,l;for(l=0;l<f;++l)e[cb[l]]=U(b,3);g=ma(e);k=new (B?Uint8Array:Array)(c);h=new (B?Uint8Array:Array)(d);b.s(ma(a.call(b,c,g,k)),ma(a.call(b,d,g,h)))}\nT.prototype.s=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length-258,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(this.b=d,c=this.f(),d=this.b),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d>=f&&(this.b=d,c=this.f(),d=this.b);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.S=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(c=this.f(),f=c.length),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d+h>f&&(c=this.f(),f=c.length);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.f=function(){var b=new (B?Uint8Array:Array)(this.b-32768),a=this.b-32768,c,d,f=this.a;if(B)b.set(f.subarray(32768,b.length));else{c=0;for(d=b.length;c<d;++c)b[c]=f[c+32768]}this.p.push(b);this.u+=b.length;if(B)f.set(f.subarray(a,a+32768));else for(c=0;32768>c;++c)f[c]=f[a+c];this.b=32768;return f};\nT.prototype.T=function(b){var a,c=this.input.length/this.c+1|0,d,f,e,g=this.input,k=this.a;b&&(\"number\"===typeof b.F&&(c=b.F),\"number\"===typeof b.O&&(c+=b.O));2>c?(d=(g.length-this.c)/this.C[2],e=258*(d/2)|0,f=e<k.length?k.length+e:k.length<<1):f=k.length*c;B?(a=new Uint8Array(f),a.set(k)):a=k;return this.a=a};\nT.prototype.B=function(){var b=0,a=this.a,c=this.p,d,f=new (B?Uint8Array:Array)(this.u+(this.b-32768)),e,g,k,h;if(0===c.length)return B?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);e=0;for(g=c.length;e<g;++e){d=c[e];k=0;for(h=d.length;k<h;++k)f[b++]=d[k]}e=32768;for(g=this.b;e<g;++e)f[b++]=a[e];this.p=[];return this.buffer=f};\nT.prototype.Q=function(){var b,a=this.b;B?this.L?(b=new Uint8Array(a),b.set(this.a.subarray(0,a))):b=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),b=this.a);return this.buffer=b};function sb(b){this.input=b;this.c=0;this.t=[];this.D=!1}sb.prototype.W=function(){this.D||this.h();return this.t.slice()};\nsb.prototype.h=function(){for(var b=this.input.length;this.c<b;){var a=new P,c=t,d=t,f=t,e=t,g=t,k=t,h=t,l=t,s=t,n=this.input,m=this.c;a.G=n[m++];a.H=n[m++];(31!==a.G||139!==a.H)&&q(Error(\"invalid file signature:\"+a.G+\",\"+a.H));a.z=n[m++];switch(a.z){case 8:break;default:q(Error(\"unknown compression method: \"+a.z))}a.n=n[m++];l=n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24;a.Y=new Date(1E3*l);a.ea=n[m++];a.da=n[m++];0<(a.n&4)&&(a.$=n[m++]|n[m++]<<8,m+=a.$);if(0<(a.n&Ea)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=\nString.fromCharCode(g);a.name=h.join(\"\")}if(0<(a.n&Fa)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=String.fromCharCode(g);a.A=h.join(\"\")}0<(a.n&Ga)&&(a.R=ja(n,0,m)&65535,a.R!==(n[m++]|n[m++]<<8)&&q(Error(\"invalid header crc16\")));c=n[n.length-4]|n[n.length-3]<<8|n[n.length-2]<<16|n[n.length-1]<<24;n.length-m-4-4<512*c&&(e=c);d=new T(n,{index:m,bufferSize:e});a.data=f=d.h();m=d.c;a.ba=s=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;ja(f,t,t)!==s&&q(Error(\"invalid CRC-32 checksum: 0x\"+ja(f,t,t).toString(16)+\n\" / 0x\"+s.toString(16)));a.ca=c=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;(f.length&4294967295)!==c&&q(Error(\"invalid input size: \"+(f.length&4294967295)+\" / \"+c));this.t.push(a);this.c=m}this.D=u;var p=this.t,r,v,x=0,Q=0,y;r=0;for(v=p.length;r<v;++r)Q+=p[r].data.length;if(B){y=new Uint8Array(Q);for(r=0;r<v;++r)y.set(p[r].data,x),x+=p[r].data.length}else{y=[];for(r=0;r<v;++r)y[r]=p[r].data;y=Array.prototype.concat.apply([],y)}return y};A(\"Zlib.Gunzip\",sb);A(\"Zlib.Gunzip.prototype.decompress\",sb.prototype.h);A(\"Zlib.Gunzip.prototype.getMembers\",sb.prototype.W);function tb(b){if(\"string\"===typeof b){var a=b.split(\"\"),c,d;c=0;for(d=a.length;c<d;c++)a[c]=(a[c].charCodeAt(0)&255)>>>0;b=a}for(var f=1,e=0,g=b.length,k,h=0;0<g;){k=1024<g?1024:g;g-=k;do f+=b[h++],e+=f;while(--k);f%=65521;e%=65521}return(e<<16|f)>>>0};function ub(b,a){var c,d;this.input=b;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.Z=a.verify);c=b[this.c++];d=b[this.c++];switch(c&15){case vb:this.method=vb;break;default:q(Error(\"unsupported compression method\"))}0!==((c<<8)+d)%31&&q(Error(\"invalid fcheck flag:\"+((c<<8)+d)%31));d&32&&q(Error(\"fdict flag is not supported\"));this.K=new T(b,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}\nub.prototype.h=function(){var b=this.input,a,c;a=this.K.h();this.c=this.K.c;this.Z&&(c=(b[this.c++]<<24|b[this.c++]<<16|b[this.c++]<<8|b[this.c++])>>>0,c!==tb(a)&&q(Error(\"invalid adler-32 checksum\")));return a};var vb=8;function wb(b,a){this.input=b;this.a=new (B?Uint8Array:Array)(32768);this.k=W.o;var c={},d;if((a||!(a={}))&&\"number\"===typeof a.compressionType)this.k=a.compressionType;for(d in a)c[d]=a[d];c.outputBuffer=this.a;this.J=new na(this.input,c)}var W=ra;\nwb.prototype.g=function(){var b,a,c,d,f,e,g,k=0;g=this.a;b=vb;switch(b){case vb:a=Math.LOG2E*Math.log(32768)-8;break;default:q(Error(\"invalid compression method\"))}c=a<<4|b;g[k++]=c;switch(b){case vb:switch(this.k){case W.NONE:f=0;break;case W.v:f=1;break;case W.o:f=2;break;default:q(Error(\"unsupported compression type\"))}break;default:q(Error(\"invalid compression method\"))}d=f<<6|0;g[k++]=d|31-(256*c+d)%31;e=tb(this.input);this.J.b=k;g=this.J.g();k=g.length;B&&(g=new Uint8Array(g.buffer),g.length<=\nk+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,k+4));g[k++]=e>>24&255;g[k++]=e>>16&255;g[k++]=e>>8&255;g[k++]=e&255;return g};function xb(b,a){var c,d,f,e;if(Object.keys)c=Object.keys(a);else for(d in c=[],f=0,a)c[f++]=d;f=0;for(e=c.length;f<e;++f)d=c[f],A(b+\".\"+d,a[d])};A(\"Zlib.Inflate\",ub);A(\"Zlib.Inflate.prototype.decompress\",ub.prototype.h);xb(\"Zlib.Inflate.BufferType\",{ADAPTIVE:Ya.M,BLOCK:Ya.N});A(\"Zlib.Deflate\",wb);A(\"Zlib.Deflate.compress\",function(b,a){return(new wb(b,a)).g()});A(\"Zlib.Deflate.prototype.compress\",wb.prototype.g);xb(\"Zlib.Deflate.CompressionType\",{NONE:W.NONE,FIXED:W.v,DYNAMIC:W.o});}).call(this); //@ sourceMappingURL=zlib_and_gzip.min.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLm1pbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uUGFuZWwvc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLm1pbi5qcz9mNGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSB6bGliLmpzIDIwMTIgLSBpbWF5YSBbIGh0dHBzOi8vZ2l0aHViLmNvbS9pbWF5YS96bGliLmpzIF0gVGhlIE1JVCBMaWNlbnNlICovKGZ1bmN0aW9uKCkgeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBxKGIpe3Rocm93IGI7fXZhciB0PXZvaWQgMCx1PSEwLGFhPXRoaXM7ZnVuY3Rpb24gQShiLGEpe3ZhciBjPWIuc3BsaXQoXCIuXCIpLGQ9YWE7IShjWzBdaW4gZCkmJmQuZXhlY1NjcmlwdCYmZC5leGVjU2NyaXB0KFwidmFyIFwiK2NbMF0pO2Zvcih2YXIgZjtjLmxlbmd0aCYmKGY9Yy5zaGlmdCgpKTspIWMubGVuZ3RoJiZhIT09dD9kW2ZdPWE6ZD1kW2ZdP2RbZl06ZFtmXT17fX07dmFyIEI9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBVaW50OEFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5O2Z1bmN0aW9uIEYoYixhKXt0aGlzLmluZGV4PVwibnVtYmVyXCI9PT10eXBlb2YgYT9hOjA7dGhpcy5tPTA7dGhpcy5idWZmZXI9YiBpbnN0YW5jZW9mKEI/VWludDhBcnJheTpBcnJheSk/YjpuZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpOzIqdGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZxKEVycm9yKFwiaW52YWxpZCBpbmRleFwiKSk7dGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZ0aGlzLmYoKX1GLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYSxjPWIubGVuZ3RoLGQ9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGM8PDEpO2lmKEIpZC5zZXQoYik7ZWxzZSBmb3IoYT0wO2E8YzsrK2EpZFthXT1iW2FdO3JldHVybiB0aGlzLmJ1ZmZlcj1kfTtcbkYucHJvdG90eXBlLmQ9ZnVuY3Rpb24oYixhLGMpe3ZhciBkPXRoaXMuYnVmZmVyLGY9dGhpcy5pbmRleCxlPXRoaXMubSxnPWRbZl0saztjJiYxPGEmJihiPTg8YT8oSFtiJjI1NV08PDI0fEhbYj4+PjgmMjU1XTw8MTZ8SFtiPj4+MTYmMjU1XTw8OHxIW2I+Pj4yNCYyNTVdKT4+MzItYTpIW2JdPj44LWEpO2lmKDg+YStlKWc9Zzw8YXxiLGUrPWE7ZWxzZSBmb3Ioaz0wO2s8YTsrK2spZz1nPDwxfGI+PmEtay0xJjEsOD09PSsrZSYmKGU9MCxkW2YrK109SFtnXSxnPTAsZj09PWQubGVuZ3RoJiYoZD10aGlzLmYoKSkpO2RbZl09Zzt0aGlzLmJ1ZmZlcj1kO3RoaXMubT1lO3RoaXMuaW5kZXg9Zn07Ri5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYT10aGlzLmluZGV4LGM7MDx0aGlzLm0mJihiW2FdPDw9OC10aGlzLm0sYlthXT1IW2JbYV1dLGErKyk7Qj9jPWIuc3ViYXJyYXkoMCxhKTooYi5sZW5ndGg9YSxjPWIpO3JldHVybiBjfTtcbnZhciBiYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjU2KSxjYTtmb3IoY2E9MDsyNTY+Y2E7KytjYSl7Zm9yKHZhciBLPWNhLGRhPUssZWE9NyxLPUs+Pj4xO0s7Sz4+Pj0xKWRhPDw9MSxkYXw9SyYxLC0tZWE7YmFbY2FdPShkYTw8ZWEmMjU1KT4+PjB9dmFyIEg9YmE7ZnVuY3Rpb24gamEoYixhLGMpe3ZhciBkLGY9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6YT0wLGU9XCJudW1iZXJcIj09PXR5cGVvZiBjP2M6Yi5sZW5ndGg7ZD0tMTtmb3IoZj1lJjc7Zi0tOysrYSlkPWQ+Pj44Xk9bKGReYlthXSkmMjU1XTtmb3IoZj1lPj4zO2YtLTthKz04KWQ9ZD4+PjheT1soZF5iW2FdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErMV0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSsyXSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzNdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErNF0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSs1XSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzZdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErN10pJjI1NV07cmV0dXJuKGReNDI5NDk2NzI5NSk+Pj4wfVxudmFyIGthPVswLDE5OTY5NTk4OTQsMzk5MzkxOTc4OCwyNTY3NTI0Nzk0LDEyNDYzNDEzNywxODg2MDU3NjE1LDM5MTU2MjE2ODUsMjY1NzM5MjAzNSwyNDkyNjgyNzQsMjA0NDUwODMyNCwzNzcyMTE1MjMwLDI1NDcxNzc4NjQsMTYyOTQxOTk1LDIxMjU1NjEwMjEsMzg4NzYwNzA0NywyNDI4NDQ0MDQ5LDQ5ODUzNjU0OCwxNzg5OTI3NjY2LDQwODkwMTY2NDgsMjIyNzA2MTIxNCw0NTA1NDg4NjEsMTg0MzI1ODYwMyw0MTA3NTgwNzUzLDIyMTE2Nzc2MzksMzI1ODgzOTkwLDE2ODQ3NzcxNTIsNDI1MTEyMjA0MiwyMzIxOTI2NjM2LDMzNTYzMzQ4NywxNjYxMzY1NDY1LDQxOTUzMDI3NTUsMjM2NjExNTMxNyw5OTcwNzMwOTYsMTI4MTk1Mzg4NiwzNTc5ODU1MzMyLDI3MjQ2ODgyNDIsMTAwNjg4ODE0NSwxMjU4NjA3Njg3LDM1MjQxMDE2MjksMjc2ODk0MjQ0Myw5MDEwOTc3MjIsMTExOTAwMDY4NCwzNjg2NTE3MjA2LDI4OTgwNjU3MjgsODUzMDQ0NDUxLDExNzIyNjYxMDEsMzcwNTAxNTc1OSxcbjI4ODI2MTY2NjUsNjUxNzY3OTgwLDEzNzM1MDM1NDYsMzM2OTU1NDMwNCwzMjE4MTA0NTk4LDU2NTUwNzI1MywxNDU0NjIxNzMxLDM0ODUxMTE3MDUsMzA5OTQzNjMwMyw2NzEyNjY5NzQsMTU5NDE5ODAyNCwzMzIyNzMwOTMwLDI5NzAzNDc4MTIsNzk1ODM1NTI3LDE0ODMyMzAyMjUsMzI0NDM2NzI3NSwzMDYwMTQ5NTY1LDE5OTQxNDYxOTIsMzExNTg1MzQsMjU2MzkwNzc3Miw0MDIzNzE3OTMwLDE5MDc0NTk0NjUsMTEyNjM3MjE1LDI2ODAxNTMyNTMsMzkwNDQyNzA1OSwyMDEzNzc2MjkwLDI1MTcyMjAzNiwyNTE3MjE1Mzc0LDM3NzU4MzAwNDAsMjEzNzY1Njc2MywxNDEzNzY4MTMsMjQzOTI3NzcxOSwzODY1MjcxMjk3LDE4MDIxOTU0NDQsNDc2ODY0ODY2LDIyMzgwMDEzNjgsNDA2NjUwODg3OCwxODEyMzcwOTI1LDQ1MzA5MjczMSwyMTgxNjI1MDI1LDQxMTE0NTEyMjMsMTcwNjA4ODkwMiwzMTQwNDI3MDQsMjM0NDUzMjIwMiw0MjQwMDE3NTMyLDE2NTg2NTgyNzEsMzY2NjE5OTc3LFxuMjM2MjY3MDMyMyw0MjI0OTk0NDA1LDEzMDM1MzU5NjAsOTg0OTYxNDg2LDI3NDcwMDcwOTIsMzU2OTAzNzUzOCwxMjU2MTcwODE3LDEwMzc2MDQzMTEsMjc2NTIxMDczMywzNTU0MDc5OTk1LDExMzEwMTQ1MDYsODc5Njc5OTk2LDI5MDkyNDM0NjIsMzY2Mzc3MTg1NiwxMTQxMTI0NDY3LDg1NTg0MjI3NywyODUyODAxNjMxLDM3MDg2NDg2NDksMTM0MjUzMzk0OCw2NTQ0NTkzMDYsMzE4ODM5NjA0OCwzMzczMDE1MTc0LDE0NjY0Nzk5MDksNTQ0MTc5NjM1LDMxMTA1MjM5MTMsMzQ2MjUyMjAxNSwxNTkxNjcxMDU0LDcwMjEzODc3NiwyOTY2NDYwNDUwLDMzNTI3OTk0MTIsMTUwNDkxODgwNyw3ODM1NTE4NzMsMzA4MjY0MDQ0MywzMjMzNDQyOTg5LDM5ODgyOTIzODQsMjU5NjI1NDY0Niw2MjMxNzA2OCwxOTU3ODEwODQyLDM5Mzk4NDU5NDUsMjY0NzgxNjExMSw4MTQ3MDk5NywxOTQzODAzNTIzLDM4MTQ5MTg5MzAsMjQ4OTU5NjgwNCwyMjUyNzQ0MzAsMjA1Mzc5MDM3NiwzODI2MTc1NzU1LFxuMjQ2NjkwNjAxMywxNjc4MTY3NDMsMjA5NzY1MTM3Nyw0MDI3NTUyNTgwLDIyNjU0OTAzODYsNTAzNDQ0MDcyLDE3NjIwNTA4MTQsNDE1MDQxNzI0NSwyMTU0MTI5MzU1LDQyNjUyMjIyNSwxODUyNTA3ODc5LDQyNzUzMTM1MjYsMjMxMjMxNzkyMCwyODI3NTM2MjYsMTc0MjU1NTg1Miw0MTg5NzA4MTQzLDIzOTQ4Nzc5NDUsMzk3OTE3NzYzLDE2MjIxODM2MzcsMzYwNDM5MDg4OCwyNzE0ODY2NTU4LDk1MzcyOTczMiwxMzQwMDc2NjI2LDM1MTg3MTk5ODUsMjc5NzM2MDk5OSwxMDY4ODI4MzgxLDEyMTk2Mzg4NTksMzYyNDc0MTg1MCwyOTM2Njc1MTQ4LDkwNjE4NTQ2MiwxMDkwODEyNTEyLDM3NDc2NzIwMDMsMjgyNTM3OTY2OSw4MjkzMjkxMzUsMTE4MTMzNTE2MSwzNDEyMTc3ODA0LDMxNjA4MzQ4NDIsNjI4MDg1NDA4LDEzODI2MDUzNjYsMzQyMzM2OTEwOSwzMTM4MDc4NDY3LDU3MDU2MjIzMywxNDI2NDAwODE1LDMzMTczMTY1NDIsMjk5ODczMzYwOCw3MzMyMzk5NTQsMTU1NTI2MTk1NixcbjMyNjg5MzU1OTEsMzA1MDM2MDYyNSw3NTI0NTk0MDMsMTU0MTMyMDIyMSwyNjA3MDcxOTIwLDM5NjU5NzMwMzAsMTk2OTkyMjk3Miw0MDczNTQ5OCwyNjE3ODM3MjI1LDM5NDM1NzcxNTEsMTkxMzA4Nzg3Nyw4MzkwODM3MSwyNTEyMzQxNjM0LDM4MDM3NDA2OTIsMjA3NTIwODYyMiwyMTMyNjExMTIsMjQ2MzI3MjYwMywzODU1OTkwMjg1LDIwOTQ4NTQwNzEsMTk4OTU4ODgxLDIyNjIwMjkwMTIsNDA1NzI2MDYxMCwxNzU5MzU5OTkyLDUzNDQxNDE5MCwyMTc2NzE4NTQxLDQxMzkzMjkxMTUsMTg3MzgzNjAwMSw0MTQ2NjQ1NjcsMjI4MjI0ODkzNCw0Mjc5MjAwMzY4LDE3MTE2ODQ1NTQsMjg1MjgxMTE2LDI0MDU4MDE3MjcsNDE2NzIxNjc0NSwxNjM0NDY3Nzk1LDM3NjIyOTcwMSwyNjg1MDY3ODk2LDM2MDgwMDc0MDYsMTMwODkxODYxMiw5NTY1NDM5MzgsMjgwODU1NTEwNSwzNDk1OTU4MjYzLDEyMzE2MzYzMDEsMTA0NzQyNzAzNSwyOTMyOTU5ODE4LDM2NTQ3MDM4MzYsMTA4ODM1OTI3MCxcbjkzNjkxOEUzLDI4NDc3MTQ4OTksMzczNjgzNzgyOSwxMjAyOTAwODYzLDgxNzIzMzg5NywzMTgzMzQyMTA4LDM0MDEyMzcxMzAsMTQwNDI3NzU1Miw2MTU4MTgxNTAsMzEzNDIwNzQ5MywzNDUzNDIxMjAzLDE0MjM4NTc0NDksNjAxNDUwNDMxLDMwMDk4Mzc2MTQsMzI5NDcxMDQ1NiwxNTY3MTAzNzQ2LDcxMTkyODcyNCwzMDIwNjY4NDcxLDMyNzIzODAwNjUsMTUxMDMzNDIzNSw3NTUxNjcxMTddLE89Qj9uZXcgVWludDMyQXJyYXkoa2EpOmthO2Z1bmN0aW9uIFAoKXt9UC5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O1AucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfTtQLnByb3RvdHlwZS5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWX07QShcIlpsaWIuR3VuemlwTWVtYmVyXCIsUCk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXROYW1lXCIsUC5wcm90b3R5cGUuZ2V0TmFtZSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXREYXRhXCIsUC5wcm90b3R5cGUuZ2V0RGF0YSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXRNdGltZVwiLFAucHJvdG90eXBlLlgpO2Z1bmN0aW9uIGxhKGIpe3RoaXMuYnVmZmVyPW5ldyAoQj9VaW50MTZBcnJheTpBcnJheSkoMipiKTt0aGlzLmxlbmd0aD0wfWxhLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oYil7cmV0dXJuIDIqKChiLTIpLzR8MCl9O2xhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGIsYSl7dmFyIGMsZCxmPXRoaXMuYnVmZmVyLGU7Yz10aGlzLmxlbmd0aDtmW3RoaXMubGVuZ3RoKytdPWE7Zm9yKGZbdGhpcy5sZW5ndGgrK109YjswPGM7KWlmKGQ9dGhpcy5nZXRQYXJlbnQoYyksZltjXT5mW2RdKWU9ZltjXSxmW2NdPWZbZF0sZltkXT1lLGU9ZltjKzFdLGZbYysxXT1mW2QrMV0sZltkKzFdPWUsYz1kO2Vsc2UgYnJlYWs7cmV0dXJuIHRoaXMubGVuZ3RofTtcbmxhLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYixhLGM9dGhpcy5idWZmZXIsZCxmLGU7YT1jWzBdO2I9Y1sxXTt0aGlzLmxlbmd0aC09MjtjWzBdPWNbdGhpcy5sZW5ndGhdO2NbMV09Y1t0aGlzLmxlbmd0aCsxXTtmb3IoZT0wOzspe2Y9MiplKzI7aWYoZj49dGhpcy5sZW5ndGgpYnJlYWs7ZisyPHRoaXMubGVuZ3RoJiZjW2YrMl0+Y1tmXSYmKGYrPTIpO2lmKGNbZl0+Y1tlXSlkPWNbZV0sY1tlXT1jW2ZdLGNbZl09ZCxkPWNbZSsxXSxjW2UrMV09Y1tmKzFdLGNbZisxXT1kO2Vsc2UgYnJlYWs7ZT1mfXJldHVybntpbmRleDpiLHZhbHVlOmEsbGVuZ3RoOnRoaXMubGVuZ3RofX07ZnVuY3Rpb24gbWEoYil7dmFyIGE9Yi5sZW5ndGgsYz0wLGQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGYsZSxnLGssaCxsLHMsbixtO2ZvcihuPTA7bjxhOysrbiliW25dPmMmJihjPWJbbl0pLGJbbl08ZCYmKGQ9YltuXSk7Zj0xPDxjO2U9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShmKTtnPTE7az0wO2ZvcihoPTI7Zzw9Yzspe2ZvcihuPTA7bjxhOysrbilpZihiW25dPT09Zyl7bD0wO3M9aztmb3IobT0wO208ZzsrK20pbD1sPDwxfHMmMSxzPj49MTtmb3IobT1sO208ZjttKz1oKWVbbV09Zzw8MTZ8bjsrK2t9KytnO2s8PD0xO2g8PD0xfXJldHVybltlLGMsZF19O2Z1bmN0aW9uIG5hKGIsYSl7dGhpcy5rPXFhO3RoaXMuST0wO3RoaXMuaW5wdXQ9QiYmYiBpbnN0YW5jZW9mIEFycmF5P25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy5iPTA7YSYmKGEubGF6eSYmKHRoaXMuST1hLmxhenkpLFwibnVtYmVyXCI9PT10eXBlb2YgYS5jb21wcmVzc2lvblR5cGUmJih0aGlzLms9YS5jb21wcmVzc2lvblR5cGUpLGEub3V0cHV0QnVmZmVyJiYodGhpcy5hPUImJmEub3V0cHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXk/bmV3IFVpbnQ4QXJyYXkoYS5vdXRwdXRCdWZmZXIpOmEub3V0cHV0QnVmZmVyKSxcIm51bWJlclwiPT09dHlwZW9mIGEub3V0cHV0SW5kZXgmJih0aGlzLmI9YS5vdXRwdXRJbmRleCkpO3RoaXMuYXx8KHRoaXMuYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpKX12YXIgcWE9MixyYT17Tk9ORTowLHY6MSxvOnFhLGFhOjN9LHNhPVtdLFM7XG5mb3IoUz0wOzI4OD5TO1MrKylzd2l0Y2godSl7Y2FzZSAxNDM+PVM6c2EucHVzaChbUys0OCw4XSk7YnJlYWs7Y2FzZSAyNTU+PVM6c2EucHVzaChbUy0xNDQrNDAwLDldKTticmVhaztjYXNlIDI3OT49UzpzYS5wdXNoKFtTLTI1NiswLDddKTticmVhaztjYXNlIDI4Nz49UzpzYS5wdXNoKFtTLTI4MCsxOTIsOF0pO2JyZWFrO2RlZmF1bHQ6cShcImludmFsaWQgbGl0ZXJhbDogXCIrUyl9XG5uYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGY9dGhpcy5pbnB1dDtzd2l0Y2godGhpcy5rKXtjYXNlIDA6Yz0wO2ZvcihkPWYubGVuZ3RoO2M8ZDspe2E9Qj9mLnN1YmFycmF5KGMsYys2NTUzNSk6Zi5zbGljZShjLGMrNjU1MzUpO2MrPWEubGVuZ3RoO3ZhciBlPWEsZz1jPT09ZCxrPXQsaD10LGw9dCxzPXQsbj10LG09dGhpcy5hLHA9dGhpcy5iO2lmKEIpe2ZvcihtPW5ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpO20ubGVuZ3RoPD1wK2UubGVuZ3RoKzU7KW09bmV3IFVpbnQ4QXJyYXkobS5sZW5ndGg8PDEpO20uc2V0KHRoaXMuYSl9az1nPzE6MDttW3ArK109a3wwO2g9ZS5sZW5ndGg7bD1+aCs2NTUzNiY2NTUzNTttW3ArK109aCYyNTU7bVtwKytdPWg+Pj44JjI1NTttW3ArK109bCYyNTU7bVtwKytdPWw+Pj44JjI1NTtpZihCKW0uc2V0KGUscCkscCs9ZS5sZW5ndGgsbT1tLnN1YmFycmF5KDAscCk7ZWxzZXtzPTA7Zm9yKG49ZS5sZW5ndGg7czxuOysrcyltW3ArK109XG5lW3NdO20ubGVuZ3RoPXB9dGhpcy5iPXA7dGhpcy5hPW19YnJlYWs7Y2FzZSAxOnZhciByPW5ldyBGKEI/bmV3IFVpbnQ4QXJyYXkodGhpcy5hLmJ1ZmZlcik6dGhpcy5hLHRoaXMuYik7ci5kKDEsMSx1KTtyLmQoMSwyLHUpO3ZhciB2PXRhKHRoaXMsZikseCxRLHk7eD0wO2ZvcihRPXYubGVuZ3RoO3g8UTt4KyspaWYoeT12W3hdLEYucHJvdG90eXBlLmQuYXBwbHkocixzYVt5XSksMjU2PHkpci5kKHZbKyt4XSx2WysreF0sdSksci5kKHZbKyt4XSw1KSxyLmQodlsrK3hdLHZbKyt4XSx1KTtlbHNlIGlmKDI1Nj09PXkpYnJlYWs7dGhpcy5hPXIuZmluaXNoKCk7dGhpcy5iPXRoaXMuYS5sZW5ndGg7YnJlYWs7Y2FzZSBxYTp2YXIgRT1uZXcgRihCP25ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpOnRoaXMuYSx0aGlzLmIpLEphLFIsWCxZLFoscGI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGZhLEthLGdhLExhLG9hLHdhPUFycmF5KDE5KSxcbk1hLCQscGEsQyxOYTtKYT1xYTtFLmQoMSwxLHUpO0UuZChKYSwyLHUpO1I9dGEodGhpcyxmKTtmYT11YSh0aGlzLlYsMTUpO0thPXZhKGZhKTtnYT11YSh0aGlzLlUsNyk7TGE9dmEoZ2EpO2ZvcihYPTI4NjsyNTc8WCYmMD09PWZhW1gtMV07WC0tKTtmb3IoWT0zMDsxPFkmJjA9PT1nYVtZLTFdO1ktLSk7dmFyIE9hPVgsUGE9WSxKPW5ldyAoQj9VaW50MzJBcnJheTpBcnJheSkoT2ErUGEpLHcsTCx6LGhhLEk9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMTYpLEcsRCxNPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgxOSk7Zm9yKHc9TD0wO3c8T2E7dysrKUpbTCsrXT1mYVt3XTtmb3Iodz0wO3c8UGE7dysrKUpbTCsrXT1nYVt3XTtpZighQil7dz0wO2ZvcihoYT1NLmxlbmd0aDt3PGhhOysrdylNW3ddPTB9dz1HPTA7Zm9yKGhhPUoubGVuZ3RoO3c8aGE7dys9TCl7Zm9yKEw9MTt3K0w8aGEmJkpbdytMXT09PUpbd107KytMKTt6PUw7aWYoMD09PUpbd10paWYoMz56KWZvcig7MDxcbnotLTspSVtHKytdPTAsTVswXSsrO2Vsc2UgZm9yKDswPHo7KUQ9MTM4Pno/ejoxMzgsRD56LTMmJkQ8eiYmKEQ9ei0zKSwxMD49RD8oSVtHKytdPTE3LElbRysrXT1ELTMsTVsxN10rKyk6KElbRysrXT0xOCxJW0crK109RC0xMSxNWzE4XSsrKSx6LT1EO2Vsc2UgaWYoSVtHKytdPUpbd10sTVtKW3ddXSsrLHotLSwzPnopZm9yKDswPHotLTspSVtHKytdPUpbd10sTVtKW3ddXSsrO2Vsc2UgZm9yKDswPHo7KUQ9Nj56P3o6NixEPnotMyYmRDx6JiYoRD16LTMpLElbRysrXT0xNixJW0crK109RC0zLE1bMTZdKyssei09RH1iPUI/SS5zdWJhcnJheSgwLEcpOkkuc2xpY2UoMCxHKTtvYT11YShNLDcpO2ZvcihDPTA7MTk+QztDKyspd2FbQ109b2FbcGJbQ11dO2ZvcihaPTE5OzQ8WiYmMD09PXdhW1otMV07Wi0tKTtNYT12YShvYSk7RS5kKFgtMjU3LDUsdSk7RS5kKFktMSw1LHUpO0UuZChaLTQsNCx1KTtmb3IoQz0wO0M8WjtDKyspRS5kKHdhW0NdLDMsdSk7Qz0wO2ZvcihOYT1iLmxlbmd0aDtDPFxuTmE7QysrKWlmKCQ9YltDXSxFLmQoTWFbJF0sb2FbJF0sdSksMTY8PSQpe0MrKztzd2l0Y2goJCl7Y2FzZSAxNjpwYT0yO2JyZWFrO2Nhc2UgMTc6cGE9MzticmVhaztjYXNlIDE4OnBhPTc7YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBjb2RlOiBcIiskKX1FLmQoYltDXSxwYSx1KX12YXIgUWE9W0thLGZhXSxSYT1bTGEsZ2FdLE4sU2EsaWEsemEsVGEsVWEsVmEsV2E7VGE9UWFbMF07VWE9UWFbMV07VmE9UmFbMF07V2E9UmFbMV07Tj0wO2ZvcihTYT1SLmxlbmd0aDtOPFNhOysrTilpZihpYT1SW05dLEUuZChUYVtpYV0sVWFbaWFdLHUpLDI1NjxpYSlFLmQoUlsrK05dLFJbKytOXSx1KSx6YT1SWysrTl0sRS5kKFZhW3phXSxXYVt6YV0sdSksRS5kKFJbKytOXSxSWysrTl0sdSk7ZWxzZSBpZigyNTY9PT1pYSlicmVhazt0aGlzLmE9RS5maW5pc2goKTt0aGlzLmI9dGhpcy5hLmxlbmd0aDticmVhaztkZWZhdWx0OnEoXCJpbnZhbGlkIGNvbXByZXNzaW9uIHR5cGVcIil9cmV0dXJuIHRoaXMuYX07XG5mdW5jdGlvbiB4YShiLGEpe3RoaXMubGVuZ3RoPWI7dGhpcy5QPWF9XG52YXIgeWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3N3aXRjaCh1KXtjYXNlIDM9PT1hOnJldHVyblsyNTcsYS0zLDBdO2Nhc2UgND09PWE6cmV0dXJuWzI1OCxhLTQsMF07Y2FzZSA1PT09YTpyZXR1cm5bMjU5LGEtNSwwXTtjYXNlIDY9PT1hOnJldHVyblsyNjAsYS02LDBdO2Nhc2UgNz09PWE6cmV0dXJuWzI2MSxhLTcsMF07Y2FzZSA4PT09YTpyZXR1cm5bMjYyLGEtOCwwXTtjYXNlIDk9PT1hOnJldHVyblsyNjMsYS05LDBdO2Nhc2UgMTA9PT1hOnJldHVyblsyNjQsYS0xMCwwXTtjYXNlIDEyPj1hOnJldHVyblsyNjUsYS0xMSwxXTtjYXNlIDE0Pj1hOnJldHVyblsyNjYsYS0xMywxXTtjYXNlIDE2Pj1hOnJldHVyblsyNjcsYS0xNSwxXTtjYXNlIDE4Pj1hOnJldHVyblsyNjgsYS0xNywxXTtjYXNlIDIyPj1hOnJldHVyblsyNjksYS0xOSwyXTtjYXNlIDI2Pj1hOnJldHVyblsyNzAsYS0yMywyXTtjYXNlIDMwPj1hOnJldHVyblsyNzEsYS0yNywyXTtjYXNlIDM0Pj1hOnJldHVyblsyNzIsXG5hLTMxLDJdO2Nhc2UgNDI+PWE6cmV0dXJuWzI3MyxhLTM1LDNdO2Nhc2UgNTA+PWE6cmV0dXJuWzI3NCxhLTQzLDNdO2Nhc2UgNTg+PWE6cmV0dXJuWzI3NSxhLTUxLDNdO2Nhc2UgNjY+PWE6cmV0dXJuWzI3NixhLTU5LDNdO2Nhc2UgODI+PWE6cmV0dXJuWzI3NyxhLTY3LDRdO2Nhc2UgOTg+PWE6cmV0dXJuWzI3OCxhLTgzLDRdO2Nhc2UgMTE0Pj1hOnJldHVyblsyNzksYS05OSw0XTtjYXNlIDEzMD49YTpyZXR1cm5bMjgwLGEtMTE1LDRdO2Nhc2UgMTYyPj1hOnJldHVyblsyODEsYS0xMzEsNV07Y2FzZSAxOTQ+PWE6cmV0dXJuWzI4MixhLTE2Myw1XTtjYXNlIDIyNj49YTpyZXR1cm5bMjgzLGEtMTk1LDVdO2Nhc2UgMjU3Pj1hOnJldHVyblsyODQsYS0yMjcsNV07Y2FzZSAyNTg9PT1hOnJldHVyblsyODUsYS0yNTgsMF07ZGVmYXVsdDpxKFwiaW52YWxpZCBsZW5ndGg6IFwiK2EpfX12YXIgYT1bXSxjLGQ7Zm9yKGM9MzsyNTg+PWM7YysrKWQ9YihjKSxhW2NdPWRbMl08PDI0fGRbMV08PFxuMTZ8ZFswXTtyZXR1cm4gYX0oKSxBYT1CP25ldyBVaW50MzJBcnJheSh5YSk6eWE7XG5mdW5jdGlvbiB0YShiLGEpe2Z1bmN0aW9uIGMoYSxjKXt2YXIgYj1hLlAsZD1bXSxlPTAsZjtmPUFhW2EubGVuZ3RoXTtkW2UrK109ZiY2NTUzNTtkW2UrK109Zj4+MTYmMjU1O2RbZSsrXT1mPj4yNDt2YXIgZztzd2l0Y2godSl7Y2FzZSAxPT09YjpnPVswLGItMSwwXTticmVhaztjYXNlIDI9PT1iOmc9WzEsYi0yLDBdO2JyZWFrO2Nhc2UgMz09PWI6Zz1bMixiLTMsMF07YnJlYWs7Y2FzZSA0PT09YjpnPVszLGItNCwwXTticmVhaztjYXNlIDY+PWI6Zz1bNCxiLTUsMV07YnJlYWs7Y2FzZSA4Pj1iOmc9WzUsYi03LDFdO2JyZWFrO2Nhc2UgMTI+PWI6Zz1bNixiLTksMl07YnJlYWs7Y2FzZSAxNj49YjpnPVs3LGItMTMsMl07YnJlYWs7Y2FzZSAyND49YjpnPVs4LGItMTcsM107YnJlYWs7Y2FzZSAzMj49YjpnPVs5LGItMjUsM107YnJlYWs7Y2FzZSA0OD49YjpnPVsxMCxiLTMzLDRdO2JyZWFrO2Nhc2UgNjQ+PWI6Zz1bMTEsYi00OSw0XTticmVhaztjYXNlIDk2Pj1iOmc9WzEyLGItXG42NSw1XTticmVhaztjYXNlIDEyOD49YjpnPVsxMyxiLTk3LDVdO2JyZWFrO2Nhc2UgMTkyPj1iOmc9WzE0LGItMTI5LDZdO2JyZWFrO2Nhc2UgMjU2Pj1iOmc9WzE1LGItMTkzLDZdO2JyZWFrO2Nhc2UgMzg0Pj1iOmc9WzE2LGItMjU3LDddO2JyZWFrO2Nhc2UgNTEyPj1iOmc9WzE3LGItMzg1LDddO2JyZWFrO2Nhc2UgNzY4Pj1iOmc9WzE4LGItNTEzLDhdO2JyZWFrO2Nhc2UgMTAyND49YjpnPVsxOSxiLTc2OSw4XTticmVhaztjYXNlIDE1MzY+PWI6Zz1bMjAsYi0xMDI1LDldO2JyZWFrO2Nhc2UgMjA0OD49YjpnPVsyMSxiLTE1MzcsOV07YnJlYWs7Y2FzZSAzMDcyPj1iOmc9WzIyLGItMjA0OSwxMF07YnJlYWs7Y2FzZSA0MDk2Pj1iOmc9WzIzLGItMzA3MywxMF07YnJlYWs7Y2FzZSA2MTQ0Pj1iOmc9WzI0LGItNDA5NywxMV07YnJlYWs7Y2FzZSA4MTkyPj1iOmc9WzI1LGItNjE0NSwxMV07YnJlYWs7Y2FzZSAxMjI4OD49YjpnPVsyNixiLTgxOTMsMTJdO2JyZWFrO2Nhc2UgMTYzODQ+PVxuYjpnPVsyNyxiLTEyMjg5LDEyXTticmVhaztjYXNlIDI0NTc2Pj1iOmc9WzI4LGItMTYzODUsMTNdO2JyZWFrO2Nhc2UgMzI3Njg+PWI6Zz1bMjksYi0yNDU3NywxM107YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBkaXN0YW5jZVwiKX1mPWc7ZFtlKytdPWZbMF07ZFtlKytdPWZbMV07ZFtlKytdPWZbMl07dmFyIGgsaztoPTA7Zm9yKGs9ZC5sZW5ndGg7aDxrOysraCltW3ArK109ZFtoXTt2W2RbMF1dKys7eFtkWzNdXSsrO3I9YS5sZW5ndGgrYy0xO249bnVsbH12YXIgZCxmLGUsZyxrLGg9e30sbCxzLG4sbT1CP25ldyBVaW50MTZBcnJheSgyKmEubGVuZ3RoKTpbXSxwPTAscj0wLHY9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgyODYpLHg9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMCksUT1iLkkseTtpZighQil7Zm9yKGU9MDsyODU+PWU7KXZbZSsrXT0wO2ZvcihlPTA7Mjk+PWU7KXhbZSsrXT0wfXZbMjU2XT0xO2Q9MDtmb3IoZj1hLmxlbmd0aDtkPGY7KytkKXtlPWs9MDtcbmZvcihnPTM7ZTxnJiZkK2UhPT1mOysrZSlrPWs8PDh8YVtkK2VdO2hba109PT10JiYoaFtrXT1bXSk7bD1oW2tdO2lmKCEoMDxyLS0pKXtmb3IoOzA8bC5sZW5ndGgmJjMyNzY4PGQtbFswXTspbC5zaGlmdCgpO2lmKGQrMz49Zil7biYmYyhuLC0xKTtlPTA7Zm9yKGc9Zi1kO2U8ZzsrK2UpeT1hW2QrZV0sbVtwKytdPXksKyt2W3ldO2JyZWFrfTA8bC5sZW5ndGg/KHM9QmEoYSxkLGwpLG4/bi5sZW5ndGg8cy5sZW5ndGg/KHk9YVtkLTFdLG1bcCsrXT15LCsrdlt5XSxjKHMsMCkpOmMobiwtMSk6cy5sZW5ndGg8UT9uPXM6YyhzLDApKTpuP2MobiwtMSk6KHk9YVtkXSxtW3ArK109eSwrK3ZbeV0pfWwucHVzaChkKX1tW3ArK109MjU2O3ZbMjU2XSsrO2IuVj12O2IuVT14O3JldHVybiBCP20uc3ViYXJyYXkoMCxwKTptfVxuZnVuY3Rpb24gQmEoYixhLGMpe3ZhciBkLGYsZT0wLGcsayxoLGwscz1iLmxlbmd0aDtrPTA7bD1jLmxlbmd0aDthOmZvcig7azxsO2srKyl7ZD1jW2wtay0xXTtnPTM7aWYoMzxlKXtmb3IoaD1lOzM8aDtoLS0paWYoYltkK2gtMV0hPT1iW2EraC0xXSljb250aW51ZSBhO2c9ZX1mb3IoOzI1OD5nJiZhK2c8cyYmYltkK2ddPT09YlthK2ddOykrK2c7Zz5lJiYoZj1kLGU9Zyk7aWYoMjU4PT09ZylicmVha31yZXR1cm4gbmV3IHhhKGUsYS1mKX1cbmZ1bmN0aW9uIHVhKGIsYSl7dmFyIGM9Yi5sZW5ndGgsZD1uZXcgbGEoNTcyKSxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KShjKSxlLGcsayxoLGw7aWYoIUIpZm9yKGg9MDtoPGM7aCsrKWZbaF09MDtmb3IoaD0wO2g8YzsrK2gpMDxiW2hdJiZkLnB1c2goaCxiW2hdKTtlPUFycmF5KGQubGVuZ3RoLzIpO2c9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShkLmxlbmd0aC8yKTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGZbZC5wb3AoKS5pbmRleF09MSxmO2g9MDtmb3IobD1kLmxlbmd0aC8yO2g8bDsrK2gpZVtoXT1kLnBvcCgpLGdbaF09ZVtoXS52YWx1ZTtrPUNhKGcsZy5sZW5ndGgsYSk7aD0wO2ZvcihsPWUubGVuZ3RoO2g8bDsrK2gpZltlW2hdLmluZGV4XT1rW2hdO3JldHVybiBmfVxuZnVuY3Rpb24gQ2EoYixhLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9aFtiXVtsW2JdXTtjPT09YT8oZChiKzEpLGQoYisxKSk6LS1nW2NdOysrbFtiXX12YXIgZj1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGMpLGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGMpLGc9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGEpLGs9QXJyYXkoYyksaD1BcnJheShjKSxsPUFycmF5KGMpLHM9KDE8PGMpLWEsbj0xPDxjLTEsbSxwLHIsdix4O2ZbYy0xXT1hO2ZvcihwPTA7cDxjOysrcClzPG4/ZVtwXT0wOihlW3BdPTEscy09biksczw8PTEsZltjLTItcF09KGZbYy0xLXBdLzJ8MCkrYTtmWzBdPWVbMF07a1swXT1BcnJheShmWzBdKTtoWzBdPUFycmF5KGZbMF0pO2ZvcihwPTE7cDxjOysrcClmW3BdPjIqZltwLTFdK2VbcF0mJihmW3BdPTIqZltwLTFdK2VbcF0pLGtbcF09QXJyYXkoZltwXSksaFtwXT1BcnJheShmW3BdKTtmb3IobT0wO208YTsrK20pZ1ttXT1jO2ZvcihyPTA7cjxmW2MtMV07KytyKWtbYy1cbjFdW3JdPWJbcl0saFtjLTFdW3JdPXI7Zm9yKG09MDttPGM7KyttKWxbbV09MDsxPT09ZVtjLTFdJiYoLS1nWzBdLCsrbFtjLTFdKTtmb3IocD1jLTI7MDw9cDstLXApe3Y9bT0wO3g9bFtwKzFdO2ZvcihyPTA7cjxmW3BdO3IrKyl2PWtbcCsxXVt4XStrW3ArMV1beCsxXSx2PmJbbV0/KGtbcF1bcl09dixoW3BdW3JdPWEseCs9Mik6KGtbcF1bcl09YlttXSxoW3BdW3JdPW0sKyttKTtsW3BdPTA7MT09PWVbcF0mJmQocCl9cmV0dXJuIGd9XG5mdW5jdGlvbiB2YShiKXt2YXIgYT1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGIubGVuZ3RoKSxjPVtdLGQ9W10sZj0wLGUsZyxrLGg7ZT0wO2ZvcihnPWIubGVuZ3RoO2U8ZztlKyspY1tiW2VdXT0oY1tiW2VdXXwwKSsxO2U9MTtmb3IoZz0xNjtlPD1nO2UrKylkW2VdPWYsZis9Y1tlXXwwLGY8PD0xO2U9MDtmb3IoZz1iLmxlbmd0aDtlPGc7ZSsrKXtmPWRbYltlXV07ZFtiW2VdXSs9MTtrPWFbZV09MDtmb3IoaD1iW2VdO2s8aDtrKyspYVtlXT1hW2VdPDwxfGYmMSxmPj4+PTF9cmV0dXJuIGF9O2Z1bmN0aW9uIERhKGIsYSl7dGhpcy5pbnB1dD1iO3RoaXMuYj10aGlzLmM9MDt0aGlzLmk9e307YSYmKGEuZmxhZ3MmJih0aGlzLmk9YS5mbGFncyksXCJzdHJpbmdcIj09PXR5cGVvZiBhLmZpbGVuYW1lJiYodGhpcy5maWxlbmFtZT1hLmZpbGVuYW1lKSxcInN0cmluZ1wiPT09dHlwZW9mIGEuY29tbWVudCYmKHRoaXMuQT1hLmNvbW1lbnQpLGEuZGVmbGF0ZU9wdGlvbnMmJih0aGlzLmw9YS5kZWZsYXRlT3B0aW9ucykpO3RoaXMubHx8KHRoaXMubD17fSl9XG5EYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGYsZSxnLGssaD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpLGw9MCxzPXRoaXMuaW5wdXQsbj10aGlzLmMsbT10aGlzLmZpbGVuYW1lLHA9dGhpcy5BO2hbbCsrXT0zMTtoW2wrK109MTM5O2hbbCsrXT04O2I9MDt0aGlzLmkuZm5hbWUmJihifD1FYSk7dGhpcy5pLmZjb21tZW50JiYoYnw9RmEpO3RoaXMuaS5maGNyYyYmKGJ8PUdhKTtoW2wrK109YjthPShEYXRlLm5vdz9EYXRlLm5vdygpOituZXcgRGF0ZSkvMUUzfDA7aFtsKytdPWEmMjU1O2hbbCsrXT1hPj4+OCYyNTU7aFtsKytdPWE+Pj4xNiYyNTU7aFtsKytdPWE+Pj4yNCYyNTU7aFtsKytdPTA7aFtsKytdPUhhO2lmKHRoaXMuaS5mbmFtZSE9PXQpe2c9MDtmb3Ioaz1tLmxlbmd0aDtnPGs7KytnKWU9bS5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfWlmKHRoaXMuaS5jb21tZW50KXtnPVxuMDtmb3Ioaz1wLmxlbmd0aDtnPGs7KytnKWU9cC5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfXRoaXMuaS5maGNyYyYmKGM9amEoaCwwLGwpJjY1NTM1LGhbbCsrXT1jJjI1NSxoW2wrK109Yz4+PjgmMjU1KTt0aGlzLmwub3V0cHV0QnVmZmVyPWg7dGhpcy5sLm91dHB1dEluZGV4PWw7Zj1uZXcgbmEocyx0aGlzLmwpO2g9Zi5nKCk7bD1mLmI7QiYmKGwrOD5oLmJ1ZmZlci5ieXRlTGVuZ3RoPyh0aGlzLmE9bmV3IFVpbnQ4QXJyYXkobCs4KSx0aGlzLmEuc2V0KG5ldyBVaW50OEFycmF5KGguYnVmZmVyKSksaD10aGlzLmEpOmg9bmV3IFVpbnQ4QXJyYXkoaC5idWZmZXIpKTtkPWphKHMsdCx0KTtoW2wrK109ZCYyNTU7aFtsKytdPWQ+Pj44JjI1NTtoW2wrK109ZD4+PjE2JjI1NTtoW2wrK109ZD4+PjI0JjI1NTtrPXMubGVuZ3RoO2hbbCsrXT1rJjI1NTtoW2wrK109az4+PjgmMjU1O2hbbCsrXT1rPj4+MTYmMjU1O2hbbCsrXT1cbms+Pj4yNCYyNTU7dGhpcy5jPW47QiYmbDxoLmxlbmd0aCYmKHRoaXMuYT1oPWguc3ViYXJyYXkoMCxsKSk7cmV0dXJuIGh9O3ZhciBIYT0yNTUsR2E9MixFYT04LEZhPTE2O0EoXCJabGliLkd6aXBcIixEYSk7QShcIlpsaWIuR3ppcC5wcm90b3R5cGUuY29tcHJlc3NcIixEYS5wcm90b3R5cGUuZyk7ZnVuY3Rpb24gVChiLGEpe3RoaXMucD1bXTt0aGlzLnE9MzI3Njg7dGhpcy5lPXRoaXMuaj10aGlzLmM9dGhpcy51PTA7dGhpcy5pbnB1dD1CP25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy53PSExO3RoaXMucj1JYTt0aGlzLkw9ITE7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEuYnVmZmVyU2l6ZSYmKHRoaXMucT1hLmJ1ZmZlclNpemUpLGEuYnVmZmVyVHlwZSYmKHRoaXMucj1hLmJ1ZmZlclR5cGUpLGEucmVzaXplJiYodGhpcy5MPWEucmVzaXplKTtzd2l0Y2godGhpcy5yKXtjYXNlIFhhOnRoaXMuYj0zMjc2ODt0aGlzLmE9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKDMyNzY4K3RoaXMucSsyNTgpO2JyZWFrO2Nhc2UgSWE6dGhpcy5iPTA7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnEpO3RoaXMuZj10aGlzLlQ7dGhpcy5CPXRoaXMuUTt0aGlzLnM9dGhpcy5TO2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgaW5mbGF0ZSBtb2RlXCIpKX19XG52YXIgWGE9MCxJYT0xLFlhPXtOOlhhLE06SWF9O1xuVC5wcm90b3R5cGUuaD1mdW5jdGlvbigpe2Zvcig7IXRoaXMudzspe3ZhciBiPVUodGhpcywzKTtiJjEmJih0aGlzLnc9dSk7Yj4+Pj0xO3N3aXRjaChiKXtjYXNlIDA6dmFyIGE9dGhpcy5pbnB1dCxjPXRoaXMuYyxkPXRoaXMuYSxmPXRoaXMuYixlPXQsZz10LGs9dCxoPWQubGVuZ3RoLGw9dDt0aGlzLmU9dGhpcy5qPTA7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IExFTiAoZmlyc3QgYnl0ZSlcIikpO2c9ZTtlPWFbYysrXTtlPT09dCYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOIChzZWNvbmQgYnl0ZSlcIikpO2d8PWU8PDg7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKGZpcnN0IGJ5dGUpXCIpKTtrPWU7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKHNlY29uZCBieXRlKVwiKSk7a3w9XG5lPDw4O2c9PT1+ayYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogbGVuZ3RoIHZlcmlmeVwiKSk7YytnPmEubGVuZ3RoJiZxKEVycm9yKFwiaW5wdXQgYnVmZmVyIGlzIGJyb2tlblwiKSk7c3dpdGNoKHRoaXMucil7Y2FzZSBYYTpmb3IoO2YrZz5kLmxlbmd0aDspe2w9aC1mO2ctPWw7aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytsKSxmKSxmKz1sLGMrPWw7ZWxzZSBmb3IoO2wtLTspZFtmKytdPWFbYysrXTt0aGlzLmI9ZjtkPXRoaXMuZigpO2Y9dGhpcy5ifWJyZWFrO2Nhc2UgSWE6Zm9yKDtmK2c+ZC5sZW5ndGg7KWQ9dGhpcy5mKHtGOjJ9KTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGluZmxhdGUgbW9kZVwiKSl9aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytnKSxmKSxmKz1nLGMrPWc7ZWxzZSBmb3IoO2ctLTspZFtmKytdPWFbYysrXTt0aGlzLmM9Yzt0aGlzLmI9Zjt0aGlzLmE9ZDticmVhaztjYXNlIDE6dGhpcy5zKFphLCRhKTticmVhaztcbmNhc2UgMjphYih0aGlzKTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bmtub3duIEJUWVBFOiBcIitiKSl9fXJldHVybiB0aGlzLkIoKX07XG52YXIgYmI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGNiPUI/bmV3IFVpbnQxNkFycmF5KGJiKTpiYixkYj1bMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwyNTgsMjU4XSxlYj1CP25ldyBVaW50MTZBcnJheShkYik6ZGIsZmI9WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDBdLGdiPUI/bmV3IFVpbnQ4QXJyYXkoZmIpOmZiLGhiPVsxLDIsMyw0LDUsNyw5LDEzLDE3LDI1LDMzLDQ5LDY1LDk3LDEyOSwxOTMsMjU3LDM4NSw1MTMsNzY5LDEwMjUsMTUzNywyMDQ5LDMwNzMsNDA5Nyw2MTQ1LDgxOTMsMTIyODksMTYzODUsMjQ1NzddLGliPUI/bmV3IFVpbnQxNkFycmF5KGhiKTpoYixqYj1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCxcbjEwLDExLDExLDEyLDEyLDEzLDEzXSxrYj1CP25ldyBVaW50OEFycmF5KGpiKTpqYixsYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjg4KSxWLG1iO1Y9MDtmb3IobWI9bGIubGVuZ3RoO1Y8bWI7KytWKWxiW1ZdPTE0Mz49Vj84OjI1NT49Vj85OjI3OT49Vj83Ojg7dmFyIFphPW1hKGxiKSxuYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzApLG9iLHFiO29iPTA7Zm9yKHFiPW5iLmxlbmd0aDtvYjxxYjsrK29iKW5iW29iXT01O3ZhciAkYT1tYShuYik7ZnVuY3Rpb24gVShiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc7ZDxhOylnPWZbZSsrXSxnPT09dCYmcShFcnJvcihcImlucHV0IGJ1ZmZlciBpcyBicm9rZW5cIikpLGN8PWc8PGQsZCs9ODtnPWMmKDE8PGEpLTE7Yi5qPWM+Pj5hO2IuZT1kLWE7Yi5jPWU7cmV0dXJuIGd9XG5mdW5jdGlvbiByYihiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc9YVswXSxrPWFbMV0saCxsLHM7ZDxrOyl7aD1mW2UrK107aWYoaD09PXQpYnJlYWs7Y3w9aDw8ZDtkKz04fWw9Z1tjJigxPDxrKS0xXTtzPWw+Pj4xNjtiLmo9Yz4+cztiLmU9ZC1zO2IuYz1lO3JldHVybiBsJjY1NTM1fVxuZnVuY3Rpb24gYWIoYil7ZnVuY3Rpb24gYShhLGIsYyl7dmFyIGQsZSxmLGc7Zm9yKGc9MDtnPGE7KXN3aXRjaChkPXJiKHRoaXMsYiksZCl7Y2FzZSAxNjpmb3IoZj0zK1UodGhpcywyKTtmLS07KWNbZysrXT1lO2JyZWFrO2Nhc2UgMTc6Zm9yKGY9MytVKHRoaXMsMyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7Y2FzZSAxODpmb3IoZj0xMStVKHRoaXMsNyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7ZGVmYXVsdDplPWNbZysrXT1kfXJldHVybiBjfXZhciBjPVUoYiw1KSsyNTcsZD1VKGIsNSkrMSxmPVUoYiw0KSs0LGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGNiLmxlbmd0aCksZyxrLGgsbDtmb3IobD0wO2w8ZjsrK2wpZVtjYltsXV09VShiLDMpO2c9bWEoZSk7az1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoYyk7aD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoZCk7Yi5zKG1hKGEuY2FsbChiLGMsZyxrKSksbWEoYS5jYWxsKGIsZCxnLGgpKSl9XG5ULnByb3RvdHlwZS5zPWZ1bmN0aW9uKGIsYSl7dmFyIGM9dGhpcy5hLGQ9dGhpcy5iO3RoaXMuQz1iO2Zvcih2YXIgZj1jLmxlbmd0aC0yNTgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpLGNbZCsrXT1lO2Vsc2V7Zz1lLTI1NztoPWViW2ddOzA8Z2JbZ10mJihoKz1VKHRoaXMsZ2JbZ10pKTtlPXJiKHRoaXMsYSk7az1pYltlXTswPGtiW2VdJiYoays9VSh0aGlzLGtiW2VdKSk7ZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpO2Zvcig7aC0tOyljW2RdPWNbZCsrLWtdfWZvcig7ODw9dGhpcy5lOyl0aGlzLmUtPTgsdGhpcy5jLS07dGhpcy5iPWR9O1xuVC5wcm90b3R5cGUuUz1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuYSxkPXRoaXMuYjt0aGlzLkM9Yjtmb3IodmFyIGY9Yy5sZW5ndGgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCksY1tkKytdPWU7ZWxzZXtnPWUtMjU3O2g9ZWJbZ107MDxnYltnXSYmKGgrPVUodGhpcyxnYltnXSkpO2U9cmIodGhpcyxhKTtrPWliW2VdOzA8a2JbZV0mJihrKz1VKHRoaXMsa2JbZV0pKTtkK2g+ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCk7Zm9yKDtoLS07KWNbZF09Y1tkKysta119Zm9yKDs4PD10aGlzLmU7KXRoaXMuZS09OCx0aGlzLmMtLTt0aGlzLmI9ZH07XG5ULnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKHRoaXMuYi0zMjc2OCksYT10aGlzLmItMzI3NjgsYyxkLGY9dGhpcy5hO2lmKEIpYi5zZXQoZi5zdWJhcnJheSgzMjc2OCxiLmxlbmd0aCkpO2Vsc2V7Yz0wO2ZvcihkPWIubGVuZ3RoO2M8ZDsrK2MpYltjXT1mW2MrMzI3NjhdfXRoaXMucC5wdXNoKGIpO3RoaXMudSs9Yi5sZW5ndGg7aWYoQilmLnNldChmLnN1YmFycmF5KGEsYSszMjc2OCkpO2Vsc2UgZm9yKGM9MDszMjc2OD5jOysrYylmW2NdPWZbYStjXTt0aGlzLmI9MzI3Njg7cmV0dXJuIGZ9O1xuVC5wcm90b3R5cGUuVD1mdW5jdGlvbihiKXt2YXIgYSxjPXRoaXMuaW5wdXQubGVuZ3RoL3RoaXMuYysxfDAsZCxmLGUsZz10aGlzLmlucHV0LGs9dGhpcy5hO2ImJihcIm51bWJlclwiPT09dHlwZW9mIGIuRiYmKGM9Yi5GKSxcIm51bWJlclwiPT09dHlwZW9mIGIuTyYmKGMrPWIuTykpOzI+Yz8oZD0oZy5sZW5ndGgtdGhpcy5jKS90aGlzLkNbMl0sZT0yNTgqKGQvMil8MCxmPWU8ay5sZW5ndGg/ay5sZW5ndGgrZTprLmxlbmd0aDw8MSk6Zj1rLmxlbmd0aCpjO0I/KGE9bmV3IFVpbnQ4QXJyYXkoZiksYS5zZXQoaykpOmE9aztyZXR1cm4gdGhpcy5hPWF9O1xuVC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBiPTAsYT10aGlzLmEsYz10aGlzLnAsZCxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnUrKHRoaXMuYi0zMjc2OCkpLGUsZyxrLGg7aWYoMD09PWMubGVuZ3RoKXJldHVybiBCP3RoaXMuYS5zdWJhcnJheSgzMjc2OCx0aGlzLmIpOnRoaXMuYS5zbGljZSgzMjc2OCx0aGlzLmIpO2U9MDtmb3IoZz1jLmxlbmd0aDtlPGc7KytlKXtkPWNbZV07az0wO2ZvcihoPWQubGVuZ3RoO2s8aDsrK2spZltiKytdPWRba119ZT0zMjc2ODtmb3IoZz10aGlzLmI7ZTxnOysrZSlmW2IrK109YVtlXTt0aGlzLnA9W107cmV0dXJuIHRoaXMuYnVmZmVyPWZ9O1xuVC5wcm90b3R5cGUuUT1mdW5jdGlvbigpe3ZhciBiLGE9dGhpcy5iO0I/dGhpcy5MPyhiPW5ldyBVaW50OEFycmF5KGEpLGIuc2V0KHRoaXMuYS5zdWJhcnJheSgwLGEpKSk6Yj10aGlzLmEuc3ViYXJyYXkoMCxhKToodGhpcy5hLmxlbmd0aD5hJiYodGhpcy5hLmxlbmd0aD1hKSxiPXRoaXMuYSk7cmV0dXJuIHRoaXMuYnVmZmVyPWJ9O2Z1bmN0aW9uIHNiKGIpe3RoaXMuaW5wdXQ9Yjt0aGlzLmM9MDt0aGlzLnQ9W107dGhpcy5EPSExfXNiLnByb3RvdHlwZS5XPWZ1bmN0aW9uKCl7dGhpcy5EfHx0aGlzLmgoKTtyZXR1cm4gdGhpcy50LnNsaWNlKCl9O1xuc2IucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5pbnB1dC5sZW5ndGg7dGhpcy5jPGI7KXt2YXIgYT1uZXcgUCxjPXQsZD10LGY9dCxlPXQsZz10LGs9dCxoPXQsbD10LHM9dCxuPXRoaXMuaW5wdXQsbT10aGlzLmM7YS5HPW5bbSsrXTthLkg9blttKytdOygzMSE9PWEuR3x8MTM5IT09YS5IKSYmcShFcnJvcihcImludmFsaWQgZmlsZSBzaWduYXR1cmU6XCIrYS5HK1wiLFwiK2EuSCkpO2Euej1uW20rK107c3dpdGNoKGEueil7Y2FzZSA4OmJyZWFrO2RlZmF1bHQ6cShFcnJvcihcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kOiBcIithLnopKX1hLm49blttKytdO2w9blttKytdfG5bbSsrXTw8OHxuW20rK108PDE2fG5bbSsrXTw8MjQ7YS5ZPW5ldyBEYXRlKDFFMypsKTthLmVhPW5bbSsrXTthLmRhPW5bbSsrXTswPChhLm4mNCkmJihhLiQ9blttKytdfG5bbSsrXTw8OCxtKz1hLiQpO2lmKDA8KGEubiZFYSkpe2g9W107Zm9yKGs9MDswPChnPW5bbSsrXSk7KWhbaysrXT1cblN0cmluZy5mcm9tQ2hhckNvZGUoZyk7YS5uYW1lPWguam9pbihcIlwiKX1pZigwPChhLm4mRmEpKXtoPVtdO2ZvcihrPTA7MDwoZz1uW20rK10pOyloW2srK109U3RyaW5nLmZyb21DaGFyQ29kZShnKTthLkE9aC5qb2luKFwiXCIpfTA8KGEubiZHYSkmJihhLlI9amEobiwwLG0pJjY1NTM1LGEuUiE9PShuW20rK118blttKytdPDw4KSYmcShFcnJvcihcImludmFsaWQgaGVhZGVyIGNyYzE2XCIpKSk7Yz1uW24ubGVuZ3RoLTRdfG5bbi5sZW5ndGgtM108PDh8bltuLmxlbmd0aC0yXTw8MTZ8bltuLmxlbmd0aC0xXTw8MjQ7bi5sZW5ndGgtbS00LTQ8NTEyKmMmJihlPWMpO2Q9bmV3IFQobix7aW5kZXg6bSxidWZmZXJTaXplOmV9KTthLmRhdGE9Zj1kLmgoKTttPWQuYzthLmJhPXM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7amEoZix0LHQpIT09cyYmcShFcnJvcihcImludmFsaWQgQ1JDLTMyIGNoZWNrc3VtOiAweFwiK2phKGYsdCx0KS50b1N0cmluZygxNikrXG5cIiAvIDB4XCIrcy50b1N0cmluZygxNikpKTthLmNhPWM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7KGYubGVuZ3RoJjQyOTQ5NjcyOTUpIT09YyYmcShFcnJvcihcImludmFsaWQgaW5wdXQgc2l6ZTogXCIrKGYubGVuZ3RoJjQyOTQ5NjcyOTUpK1wiIC8gXCIrYykpO3RoaXMudC5wdXNoKGEpO3RoaXMuYz1tfXRoaXMuRD11O3ZhciBwPXRoaXMudCxyLHYseD0wLFE9MCx5O3I9MDtmb3Iodj1wLmxlbmd0aDtyPHY7KytyKVErPXBbcl0uZGF0YS5sZW5ndGg7aWYoQil7eT1uZXcgVWludDhBcnJheShRKTtmb3Iocj0wO3I8djsrK3IpeS5zZXQocFtyXS5kYXRhLHgpLHgrPXBbcl0uZGF0YS5sZW5ndGh9ZWxzZXt5PVtdO2ZvcihyPTA7cjx2Oysrcil5W3JdPXBbcl0uZGF0YTt5PUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10seSl9cmV0dXJuIHl9O0EoXCJabGliLkd1bnppcFwiLHNiKTtBKFwiWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29tcHJlc3NcIixzYi5wcm90b3R5cGUuaCk7QShcIlpsaWIuR3VuemlwLnByb3RvdHlwZS5nZXRNZW1iZXJzXCIsc2IucHJvdG90eXBlLlcpO2Z1bmN0aW9uIHRiKGIpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYil7dmFyIGE9Yi5zcGxpdChcIlwiKSxjLGQ7Yz0wO2ZvcihkPWEubGVuZ3RoO2M8ZDtjKyspYVtjXT0oYVtjXS5jaGFyQ29kZUF0KDApJjI1NSk+Pj4wO2I9YX1mb3IodmFyIGY9MSxlPTAsZz1iLmxlbmd0aCxrLGg9MDswPGc7KXtrPTEwMjQ8Zz8xMDI0Omc7Zy09aztkbyBmKz1iW2grK10sZSs9Zjt3aGlsZSgtLWspO2YlPTY1NTIxO2UlPTY1NTIxfXJldHVybihlPDwxNnxmKT4+PjB9O2Z1bmN0aW9uIHViKGIsYSl7dmFyIGMsZDt0aGlzLmlucHV0PWI7dGhpcy5jPTA7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEudmVyaWZ5JiYodGhpcy5aPWEudmVyaWZ5KTtjPWJbdGhpcy5jKytdO2Q9Ylt0aGlzLmMrK107c3dpdGNoKGMmMTUpe2Nhc2UgdmI6dGhpcy5tZXRob2Q9dmI7YnJlYWs7ZGVmYXVsdDpxKEVycm9yKFwidW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX0wIT09KChjPDw4KStkKSUzMSYmcShFcnJvcihcImludmFsaWQgZmNoZWNrIGZsYWc6XCIrKChjPDw4KStkKSUzMSkpO2QmMzImJnEoRXJyb3IoXCJmZGljdCBmbGFnIGlzIG5vdCBzdXBwb3J0ZWRcIikpO3RoaXMuSz1uZXcgVChiLHtpbmRleDp0aGlzLmMsYnVmZmVyU2l6ZTphLmJ1ZmZlclNpemUsYnVmZmVyVHlwZTphLmJ1ZmZlclR5cGUscmVzaXplOmEucmVzaXplfSl9XG51Yi5wcm90b3R5cGUuaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuaW5wdXQsYSxjO2E9dGhpcy5LLmgoKTt0aGlzLmM9dGhpcy5LLmM7dGhpcy5aJiYoYz0oYlt0aGlzLmMrK108PDI0fGJbdGhpcy5jKytdPDwxNnxiW3RoaXMuYysrXTw8OHxiW3RoaXMuYysrXSk+Pj4wLGMhPT10YihhKSYmcShFcnJvcihcImludmFsaWQgYWRsZXItMzIgY2hlY2tzdW1cIikpKTtyZXR1cm4gYX07dmFyIHZiPTg7ZnVuY3Rpb24gd2IoYixhKXt0aGlzLmlucHV0PWI7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgzMjc2OCk7dGhpcy5rPVcubzt2YXIgYz17fSxkO2lmKChhfHwhKGE9e30pKSYmXCJudW1iZXJcIj09PXR5cGVvZiBhLmNvbXByZXNzaW9uVHlwZSl0aGlzLms9YS5jb21wcmVzc2lvblR5cGU7Zm9yKGQgaW4gYSljW2RdPWFbZF07Yy5vdXRwdXRCdWZmZXI9dGhpcy5hO3RoaXMuSj1uZXcgbmEodGhpcy5pbnB1dCxjKX12YXIgVz1yYTtcbndiLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGIsYSxjLGQsZixlLGcsaz0wO2c9dGhpcy5hO2I9dmI7c3dpdGNoKGIpe2Nhc2UgdmI6YT1NYXRoLkxPRzJFKk1hdGgubG9nKDMyNzY4KS04O2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX1jPWE8PDR8YjtnW2srK109Yztzd2l0Y2goYil7Y2FzZSB2Yjpzd2l0Y2godGhpcy5rKXtjYXNlIFcuTk9ORTpmPTA7YnJlYWs7Y2FzZSBXLnY6Zj0xO2JyZWFrO2Nhc2UgVy5vOmY9MjticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlXCIpKX1icmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZFwiKSl9ZD1mPDw2fDA7Z1trKytdPWR8MzEtKDI1NipjK2QpJTMxO2U9dGIodGhpcy5pbnB1dCk7dGhpcy5KLmI9aztnPXRoaXMuSi5nKCk7az1nLmxlbmd0aDtCJiYoZz1uZXcgVWludDhBcnJheShnLmJ1ZmZlciksZy5sZW5ndGg8PVxuays0JiYodGhpcy5hPW5ldyBVaW50OEFycmF5KGcubGVuZ3RoKzQpLHRoaXMuYS5zZXQoZyksZz10aGlzLmEpLGc9Zy5zdWJhcnJheSgwLGsrNCkpO2dbaysrXT1lPj4yNCYyNTU7Z1trKytdPWU+PjE2JjI1NTtnW2srK109ZT4+OCYyNTU7Z1trKytdPWUmMjU1O3JldHVybiBnfTtmdW5jdGlvbiB4YihiLGEpe3ZhciBjLGQsZixlO2lmKE9iamVjdC5rZXlzKWM9T2JqZWN0LmtleXMoYSk7ZWxzZSBmb3IoZCBpbiBjPVtdLGY9MCxhKWNbZisrXT1kO2Y9MDtmb3IoZT1jLmxlbmd0aDtmPGU7KytmKWQ9Y1tmXSxBKGIrXCIuXCIrZCxhW2RdKX07QShcIlpsaWIuSW5mbGF0ZVwiLHViKTtBKFwiWmxpYi5JbmZsYXRlLnByb3RvdHlwZS5kZWNvbXByZXNzXCIsdWIucHJvdG90eXBlLmgpO3hiKFwiWmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGVcIix7QURBUFRJVkU6WWEuTSxCTE9DSzpZYS5OfSk7QShcIlpsaWIuRGVmbGF0ZVwiLHdiKTtBKFwiWmxpYi5EZWZsYXRlLmNvbXByZXNzXCIsZnVuY3Rpb24oYixhKXtyZXR1cm4obmV3IHdiKGIsYSkpLmcoKX0pO0EoXCJabGliLkRlZmxhdGUucHJvdG90eXBlLmNvbXByZXNzXCIsd2IucHJvdG90eXBlLmcpO3hiKFwiWmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZVwiLHtOT05FOlcuTk9ORSxGSVhFRDpXLnYsRFlOQU1JQzpXLm99KTt9KS5jYWxsKHRoaXMpOyAvL0Agc291cmNlTWFwcGluZ1VSTD16bGliX2FuZF9nemlwLm1pbi5qcy5tYXBcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/vendor/zlib_and_gzip.min.js\n");

/***/ }),

/***/ "./lanceotron/src/capture_compare_track.js":
/*!*************************************************!*\
  !*** ./lanceotron/src/capture_compare_track.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CaptureCompareTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getDecodeFunction(sample_size) {\n\tvar max = sample_size * 2;\n\treturn function (tokens, feature) {\n\t\tfeature.data = [];\n\t\tfor (var i = 0; i < max; i += 2) {\n\t\t\tfeature.data.push([parseFloat(tokens[i]), parseFloat(tokens[i + 1])]);\n\t\t}\n\t};\n}\n\nvar CaptureCompareTrack = function (_MLVBedTrack) {\n\t_inherits(CaptureCompareTrack, _MLVBedTrack);\n\n\tfunction CaptureCompareTrack(config) {\n\t\t_classCallCheck(this, CaptureCompareTrack);\n\n\t\tconfig.format = \"feature\";\n\t\tif (!config.colors) {\n\t\t\tconfig.colors = [\"#FF0000\", \"#0000FF\", \"#008000\"];\n\t\t}\n\t\treturn _possibleConstructorReturn(this, (CaptureCompareTrack.__proto__ || Object.getPrototypeOf(CaptureCompareTrack)).call(this, config));\n\t}\n\n\t_createClass(CaptureCompareTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tif (this.config.url && this.config.url.endsWith(\".gz\")) {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, getDecodeFunction(this.config.conditions.length));\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, getDecodeFunction(this.config.conditions.length));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\t\t\tvar max = this.config.initial_y_max * 4;\n\t\t\tvar min = this.config.initial_y_max / 6;\n\t\t\tvar val = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tvar feature_div = $(\"<div>\");\n\t\t\tdialog.fixed_scale_check = $(\"<input>\").attr({ type: \"checkbox\" }).prop(\"checked\", !dialog.config.dynamic_scale).click(function (e) {\n\t\t\t\tvar dyn = true;\n\t\t\t\tif ($(this).prop(\"checked\")) {\n\t\t\t\t\tdyn = false;\n\t\t\t\t}\n\t\t\t\tdialog.config.dynamic_scale = dyn;\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"dynamic_scale\", dyn);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t\tdialog.scale_slider.slider(dyn ? \"disable\" : \"enable\");\n\t\t\t\tdialog.max_y_input.attr(\"disabled\", dyn);\n\t\t\t});\n\n\t\t\tfeature_div.append(dialog.fixed_scale_check).append(\"<label>Fixed Scale</label><br>\");\n\t\t\tdialog.scale_slider = $(\"<div>\").slider({\n\t\t\t\tmax: max,\n\t\t\t\tmin: min,\n\t\t\t\tstep: (max - min) / 100,\n\t\t\t\tvalue: val,\n\t\t\t\tslide: function slide(e, ui) {\n\t\t\t\t\tdialog.config.y_max = ui.value;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"y_max\", ui.value);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t\tdialog.max_y_input.val(ui.value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tdialog.max_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar y = dialog.max_y_input.val();\n\t\t\t\ty = parseFloat(y);\n\t\t\t\tvar s = dialog.scale_slider;\n\t\t\t\tvar max = s.slider(\"option\", \"max\");\n\t\t\t\tvar min = s.slider(\"option\", \"min\");\n\t\t\t\tif (y > max) {\n\t\t\t\t\ts.slider(\"option\", \"max\", y);\n\t\t\t\t} else if (y < min) {\n\t\t\t\t\ts.slider(\"option\", \"min\", y);\n\t\t\t\t}\n\n\t\t\t\ts.slider(\"option\", \"step\", (max - min) / 100);\n\t\t\t\ts.slider(\"option\", \"value\", y);\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"y_max\", y);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).width(50).val(val);\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>Track Height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tfeature_div.append(dialog.scale_slider.css(\"margin-bottom\", \"4px\")).append(\"<span>Max Y:</span>\").append(dialog.max_y_input).appendTo(dialog.div);\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tvar sd_name = \"sd-ra-name-\" + dialog.id;\n\t\t\tvar sd_div = $(\"<div>\").append(\"<label>Display SD as:</label><br>\");\n\t\t\tvar is_box = false;\n\t\t\tif (!this.config.display_sd || this.config.display_sd == \"box\") {\n\t\t\t\tis_box = true;\n\t\t\t}\n\t\t\tsd_div.append($(\"<input>\").attr({ type: \"radio\", value: \"box\", checked: is_box, name: sd_name }));\n\t\t\tsd_div.append($(\"<span>\").text(\"Box\"));\n\t\t\tsd_div.append($(\"<input>\").attr({ type: \"radio\", value: \"bar\", checked: this.config.display_sd === \"bar\", name: sd_name }));\n\t\t\tsd_div.append($(\"<span>\").text(\"Bar\"));\n\t\t\tsd_div.appendTo(dialog.div);\n\n\t\t\t$(\"input[name='\" + sd_name + \"']\").click(function (e) {\n\t\t\t\tvar display_sd = $(\"input[name='\" + sd_name + \"']:checked\").val();\n\t\t\t\tdialog.config.display_sd = display_sd;\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"display_sd\", display_sd);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t});\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tvar color_div = $(\"<div class='t-d-div'></div>\").appendTo(dialog.div);\n\t\t\tcolor_div.append(\"<label>Sample Colors</label><br>\");\n\n\t\t\tfor (var x = 0; x < this.config.conditions.length; x++) {\n\t\t\t\tvar d = $(\"<div>\");\n\t\t\t\tvar color_input = $(\"<input>\").attr({ type: \"color\" }).data(\"index\", x).val(this.config.colors[x]).height(20).width(20).css({ \"margin-right\": \"3px\", \"padding\": \"0px\" }).change(function (e) {\n\t\t\t\t\tvar color = $(this).val();\n\t\t\t\t\tdialog.config.colors[$(this).data(\"index\")] = color;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"colors\", dialog.config.colors);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\td.append(color_input).append($(\"<span>\").text(this.config.conditions[x])).appendTo(color_div);\n\t\t\t}\n\n\t\t\tif (dialog.config.dynamic_scale) {\n\t\t\t\tdialog.scale_slider.slider(\"disable\");\n\t\t\t\tdialog.max_y_input.slider(\"disable\");\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"calculateMaxY\",\n\t\tvalue: function calculateMaxY(options) {\n\t\t\tvar count = 0;\n\t\t\tvar y_max = 0;\n\t\t\tvar s_s = this.config.conditions.length;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = options.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\tif (x_pos > count) {\n\t\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\t\t\tvar y = feature.data[i][0] + feature.data[i][1];\n\t\t\t\t\t\t\tif (y > y_max) {\n\t\t\t\t\t\t\t\ty_max = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn y_max;\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar features = options.features;\n\t\t\tvar sparse = false;\n\t\t\tvar interval = 1;\n\t\t\t/*if (features.length> 1.5*options.pixelWidth){\r\n   \tinterval += Math.floor(features.length/options.pixelWidth)\r\n   }*/\n\n\t\t\tvar top = this.config.discrete ? options.top : 0;\n\t\t\tvar bot = this.config.discrete ? parseInt(top) + parseInt(this.config.height) : options.pixelHeight;\n\t\t\tif (this.config.display_difference) {}\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bot;\n\t\t\tvar ctx = options.context;\n\t\t\tvar prev_x = null;\n\t\t\tvar prev_y = [];\n\t\t\tvar colors = this.config.colors;\n\t\t\tvar y_max = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tif (this.config.dynamic_scale) {\n\t\t\t\ty_max = this.calculateMaxY(options);\n\t\t\t}\n\t\t\tvar wig_height = this.config.discrete ? this.config.height : options.pixelHeight;\n\t\t\tvar s_s = this.config.conditions.length;\n\t\t\tvar display_bar = false;\n\t\t\tvar display_box = true;\n\t\t\tif (this.config.display_sd === \"bar\") {\n\t\t\t\tdisplay_box = false;\n\t\t\t\tif (options.bpPerPixel < 100) {\n\t\t\t\t\tdisplay_bar = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0;\n\t\t\tvar drawn = 0;\n\n\t\t\tfor (var x = 0; x < features.length; x += interval) {\n\n\t\t\t\tvar feature = features[x];\n\n\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\tif (x_pos > count) {\n\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\tdrawn++;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlen = len / options.bpPerPixel;\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tvar t_y = [];\n\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\tvar y_pos = wig_height - feature.data[i][0] / y_max * wig_height + top;\n\t\t\t\t\ty_pos = y_pos;\n\t\t\t\t\tif (this.config.asline && prev_x != null) {\n\t\t\t\t\t\tctx.strokeStyle = colors[i];\n\t\t\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(prev_x, prev_y[i]);\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.lineTo(x_pos, y_pos);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\t\t\tctx.strokeStyle = colors[i];\n\t\t\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\t\t\tctx.fillRect(x_pos - len / 2, y_pos, len, this.bottom - y_pos);\n\n\t\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tvar sd = feature.data[i][1] / y_max * wig_height;\n\n\t\t\t\t\tif (display_box) {\n\t\t\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\t\t\tctx.fillRect(x_pos - len / 2, y_pos - sd, len, 2 * sd);\n\t\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\t} else if (display_bar) {\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(x_pos - 4, y_pos - sd);\n\t\t\t\t\t\tctx.lineTo(x_pos + 4, y_pos - sd);\n\t\t\t\t\t\tctx.moveTo(x_pos, y_pos - sd);\n\t\t\t\t\t\tctx.lineTo(x_pos, y_pos + sd);\n\t\t\t\t\t\tctx.moveTo(x_pos - 4, y_pos + sd);\n\t\t\t\t\t\tctx.lineTo(x_pos + 4, y_pos + sd);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\tt_y.push(y_pos);\n\t\t\t\t}\n\t\t\t\tprev_y = t_y;\n\t\t\t\tprev_x = x_pos;\n\t\t\t}\n\n\t\t\tif (this.config.exclusion_zone) {\n\t\t\t\tvar bpStart = options.bpStart;\n\t\t\t\tvar bpEnd = options.bpStart + options.bpPerPixel * options.pixelWidth;\n\t\t\t\tvar ex = this.config.exclusion_zone;\n\n\t\t\t\tif (ex[0] > bpStart && ex[0] < bpEnd || ex[1] > bpStart && ex[1] < bpEnd) {\n\t\t\t\t\tvar ex_st = (ex[0] - bpStart) / options.bpPerPixel;\n\t\t\t\t\tex_st = ex_st < 0 ? 0 : ex_st;\n\t\t\t\t\tvar ex_en = (ex[1] - bpStart) / options.bpPerPixel;\n\t\t\t\t\tex_en = ex_en > options.pixelWidth ? options.pixelWidth : ex_en;\n\t\t\t\t\tctx.fillStyle = \"white\";\n\t\t\t\t\tctx.strokeStyle = \"grey\";\n\n\t\t\t\t\tctx.rect(ex_st, this.top + 1, ex_en - ex_st, this.config.height - 1);\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tex = this.config.viewpoint;\n\t\t\t\tif (ex) {\n\t\t\t\t\tif (ex[0] > bpStart && ex[0] < bpEnd || ex[1] > bpStart && ex[1] < bpEnd) {\n\t\t\t\t\t\tvar _ex_st = (ex[0] - bpStart) / options.bpPerPixel;\n\t\t\t\t\t\t_ex_st = _ex_st < 0 ? 0 : _ex_st;\n\t\t\t\t\t\tvar _ex_en = (ex[1] - bpStart) / options.bpPerPixel;\n\t\t\t\t\t\t_ex_en = _ex_en > options.pixelWidth ? options.pixelWidth : _ex_en;\n\t\t\t\t\t\tctx.fillStyle = \"grey\";\n\t\t\t\t\t\tctx.fillRect(_ex_st, this.top + 1, _ex_en - _ex_st, this.config.height - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.max_y = y_max;\n\n\t\t\treturn this.config.discrete ? bot : null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tvar bot = this.bottom;\n\t\t\tvar top = this.top;\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\t\t\tvar max_y = this.max_y;\n\t\t\tvar min_y = 0;\n\t\t\tvar range = max_y - min_y;\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(20, top);\n\t\t\tctx.moveTo(0, bot);\n\t\t\tctx.lineTo(20, bot);\n\t\t\tctx.font = \"12px Arial\";\n\t\t\tctx.stroke();\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(max_y.toFixed(2), 20, top);\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(min_y, 20, bot);\n\t\t\tctx.font = \"14px Arial\";\n\t\t\tvar text = this.config.legend_label ? this.config.legend_label : \"Condition\";\n\t\t\tctx.fillText(text, 10, top + 30);\n\t\t\tctx.font = \"12px Arial\";\n\t\t\tvar colors = this.config.colors;\n\t\t\tfor (var i = 0; i < this.config.conditions.length; i++) {\n\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\tctx.fillRect(10, top + 40 + i * 30, 20, 20);\n\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\tctx.fillRect(10, top + 49 + i * 30, 20, 2);\n\t\t\t\tctx.fillStyle = \"black\";\n\t\t\t\tctx.fillText(this.config.conditions[i], 31, top + 55 + i * 30);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}]);\n\n\treturn CaptureCompareTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"capture_compare\"] = CaptureCompareTrack;\n_tracks.MLVTrack.track_types[\"capture_compare\"] = {\n\t\"class\": CaptureCompareTrack\n};\n\nexports.CaptureCompareTrack = CaptureCompareTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9jYXB0dXJlX2NvbXBhcmVfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvY2FwdHVyZV9jb21wYXJlX3RyYWNrLmpzP2QzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERlY29kZUZ1bmN0aW9uKHNhbXBsZV9zaXplKXtcclxuXHRsZXQgbWF4ID0gc2FtcGxlX3NpemUqMlxyXG5cdHJldHVybiBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0XHRmZWF0dXJlLmRhdGE9W107XHJcblx0XHRmb3IgKGxldCBpPTA7aTxtYXg7aSs9Mil7XHJcblx0XHRcdGZlYXR1cmUuZGF0YS5wdXNoKFtwYXJzZUZsb2F0KHRva2Vuc1tpXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsxXSldKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgQ2FwdHVyZUNvbXBhcmVUcmFjayBleHRlbmRzIE1MVkJlZFRyYWNre1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcclxuICAgIFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuICAgIFx0aWYgKCFjb25maWcuY29sb3JzKXtcclxuICAgIFx0XHRjb25maWcuY29sb3JzPVtcIiNGRjAwMDBcIixcIiMwMDAwRkZcIixcIiMwMDgwMDBcIl1cclxuICAgIFx0fVxyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcudXJsICYmIHRoaXMuY29uZmlnLnVybC5lbmRzV2l0aChcIi5nelwiKSl7XHJcblx0XHRcdHRoaXMuZmVhdHVyZV9zb3VyY2UgPSBuZXcgVGFiaXhCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGdldERlY29kZUZ1bmN0aW9uKHRoaXMuY29uZmlnLmNvbmRpdGlvbnMubGVuZ3RoKSk7XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZ2V0RGVjb2RlRnVuY3Rpb24odGhpcy5jb25maWcuY29uZGl0aW9ucy5sZW5ndGgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGlhbG9nKXtcclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGRpYWxvZy5kaXYuZW1wdHkoKTtcclxuXHRcdGxldCBtYXg9dGhpcy5jb25maWcuaW5pdGlhbF95X21heCo0O1xyXG5cdFx0bGV0IG1pbiA9dGhpcy5jb25maWcuaW5pdGlhbF95X21heC82O1xyXG5cdFx0bGV0IHZhbCA9IHRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRsZXQgZmVhdHVyZV9kaXY9ICAkKFwiPGRpdj5cIik7XHJcblx0XHRkaWFsb2cuZml4ZWRfc2NhbGVfY2hlY2sgPSAkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwiY2hlY2tib3hcIn0pXHJcblx0XHRcdFx0LnByb3AoXCJjaGVja2VkXCIsIWRpYWxvZy5jb25maWcuZHluYW1pY19zY2FsZSlcclxuXHRcdFx0XHQuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRsZXQgZHluPXRydWU7XHJcblx0XHRcdFx0XHRpZiAoJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiKSl7XHJcblx0XHRcdFx0XHRcdGR5bj1mYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGRpYWxvZy5jb25maWcuZHluYW1pY19zY2FsZT1keW47XHJcbiAgICAgICAgICAgXHRcdFx0aWYgKGRpYWxvZy5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBcdFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJkeW5hbWljX3NjYWxlXCIsZHluKTtcclxuICAgICAgICAgICAgICAgIFx0XHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgICAgIFx0XHRcdGRpYWxvZy5zY2FsZV9zbGlkZXIuc2xpZGVyKGR5bj9cImRpc2FibGVcIjpcImVuYWJsZVwiKTtcclxuICAgICAgICAgICAgXHRcdGRpYWxvZy5tYXhfeV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkeW4pO1xyXG5cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRmZWF0dXJlX2Rpdi5hcHBlbmQoZGlhbG9nLmZpeGVkX3NjYWxlX2NoZWNrKS5hcHBlbmQoXCI8bGFiZWw+Rml4ZWQgU2NhbGU8L2xhYmVsPjxicj5cIik7XHJcbiAgICBcdGRpYWxvZy5zY2FsZV9zbGlkZXI9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICBcdFx0bWF4Om1heCxcclxuICAgICAgIFx0XHRtaW46bWluLFxyXG4gICAgICAgXHRcdHN0ZXA6KG1heC1taW4pLzEwMCxcclxuICAgICAgIFx0XHR2YWx1ZTp2YWwsXHJcbiAgICAgICBcdFx0c2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgXHRcdGRpYWxvZy5jb25maWcueV9tYXg9dWkudmFsdWVcclxuICAgICAgICAgICBcdFx0aWYgKGRpYWxvZy5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwieV9tYXhcIix1aS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgIFx0XHRkaWFsb2cubWF4X3lfaW5wdXQudmFsKHVpLnZhbHVlKVxyXG4gICAgICAgXHRcdH0gXHJcbiAgICBcdH0pO1xyXG4gICAgXHRkaWFsb2cubWF4X3lfaW5wdXQ9JChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1kaWFsb2cubWF4X3lfaW5wdXQudmFsKCk7XHJcbiAgICAgICAgICAgICAgICB5PXBhcnNlRmxvYXQoeSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcyA9IGRpYWxvZy5zY2FsZV9zbGlkZXI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gcy5zbGlkZXIoXCJvcHRpb25cIixcIm1heFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBzLnNsaWRlcihcIm9wdGlvblwiLFwibWluXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoeT5tYXgpe1xyXG4gICAgICAgICAgICAgICAgXHRzLnNsaWRlcihcIm9wdGlvblwiLFwibWF4XCIseSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlICBpZih5PG1pbil7XHJcbiAgICAgICAgICAgICAgICBcdHMuc2xpZGVyKFwib3B0aW9uXCIsXCJtaW5cIix5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHMuc2xpZGVyKFwib3B0aW9uXCIsXCJzdGVwXCIsKG1heC1taW4pLzEwMCk7XHJcbiAgICAgICAgICAgICAgICBzLnNsaWRlcihcIm9wdGlvblwiLFwidmFsdWVcIix5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcInlfbWF4XCIseSk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KS53aWR0aCg1MCkudmFsKHZhbCk7XHJcbiAgICAgICAgICBcclxuXHJcblxyXG4gICAgXHRcdGxldCBoZWlnaHRfZGl2PSQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIik7XHJcbiAgICAgICAgXHRcclxuXHRcdFx0aGVpZ2h0X2Rpdi5hcHBlbmQoXCI8bGFiZWw+VHJhY2sgSGVpZ2h0OjwvbGFiZWw+XCIpLmFwcGVuZFRvKGRpYWxvZy5kaXYpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGhlaWdodF9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG4gICAgICAgICAgICAgICAgbWluOiAxMCxcclxuICAgICAgICAgICAgICAgIG1heDogNTAwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ZGlhbG9nLmNvbmZpZy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29uZmlnLmhlaWdodD0gdWkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJoZWlnaHRcIixkaWFsb2cuY29uZmlnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY3NzKHtcIm1hcmdpblwiOlwiNXB4IDNweFwifSk7XHJcblxyXG5cclxuICAgICAgICAgICAgaGVpZ2h0X3NsaWRlci5hcHBlbmRUbyhoZWlnaHRfZGl2KTtcclxuICAgICAgICBcclxuXHJcbiAgIFx0XHRkaWFsb2cuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcbiAgICBcdGZlYXR1cmVfZGl2LmFwcGVuZChkaWFsb2cuc2NhbGVfc2xpZGVyLmNzcyhcIm1hcmdpbi1ib3R0b21cIixcIjRweFwiKSkuYXBwZW5kKFwiPHNwYW4+TWF4IFk6PC9zcGFuPlwiKS5hcHBlbmQoZGlhbG9nLm1heF95X2lucHV0KS5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuXHRcdGRpYWxvZy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgIFx0bGV0IHNkX25hbWU9IFwic2QtcmEtbmFtZS1cIitkaWFsb2cuaWQ7XHJcbiAgICBcdGxldCBzZF9kaXY9ICAkKFwiPGRpdj5cIikuYXBwZW5kKFwiPGxhYmVsPkRpc3BsYXkgU0QgYXM6PC9sYWJlbD48YnI+XCIpO1xyXG4gICAgXHRsZXQgaXNfYm94PWZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZGlzcGxheV9zZCB8fCB0aGlzLmNvbmZpZy5kaXNwbGF5X3NkPT1cImJveFwiKXtcclxuXHRcdFx0aXNfYm94PXRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNkX2Rpdi5hcHBlbmQoJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcInJhZGlvXCIsdmFsdWU6XCJib3hcIixjaGVja2VkOmlzX2JveCxuYW1lOnNkX25hbWV9KSlcclxuICAgICAgICBzZF9kaXYuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChcIkJveFwiKSk7XHJcbiAgICAgICAgc2RfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImJhclwiLGNoZWNrZWQ6dGhpcy5jb25maWcuZGlzcGxheV9zZD09PVwiYmFyXCIsbmFtZTpzZF9uYW1lfSkpXHJcbiAgICAgICAgc2RfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJCYXJcIikpO1xyXG4gICAgICAgIHNkX2Rpdi5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAkKFwiaW5wdXRbbmFtZT0nXCIrc2RfbmFtZStcIiddXCIpLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlfc2Q9JChcImlucHV0W25hbWU9J1wiK3NkX25hbWUrXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgZGlhbG9nLmNvbmZpZy5kaXNwbGF5X3NkPWRpc3BsYXlfc2Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhbG9nLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5X3NkXCIsZGlzcGxheV9zZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuXHRcdGRpYWxvZy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgICAgICBsZXQgY29sb3JfZGl2PSQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcbiAgICAgICAgY29sb3JfZGl2LmFwcGVuZChcIjxsYWJlbD5TYW1wbGUgQ29sb3JzPC9sYWJlbD48YnI+XCIpO1xyXG4gICAgICAgXHJcblx0XHRmb3IgKGxldCB4PTA7eDx0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDt4Kyspe1xyXG5cdFx0XHRsZXQgZD0gJChcIjxkaXY+XCIpO1xyXG5cdFx0XHRsZXQgY29sb3JfaW5wdXQ9JChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcImNvbG9yXCJ9KS5kYXRhKFwiaW5kZXhcIix4KS52YWwodGhpcy5jb25maWcuY29sb3JzW3hdKS5oZWlnaHQoMjApLndpZHRoKDIwKVxyXG5cdFx0XHQuY3NzKHtcIm1hcmdpbi1yaWdodFwiOlwiM3B4XCIsXCJwYWRkaW5nXCI6XCIwcHhcIn0pXHJcbiAgICAgICAgXHQuY2hhbmdlKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBcdGxldCBjb2xvciA9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgIFx0ZGlhbG9nLmNvbmZpZy5jb2xvcnNbJCh0aGlzKS5kYXRhKFwiaW5kZXhcIildPWNvbG9yO1xyXG4gICAgICAgICAgICBcdGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJjb2xvcnNcIixkaWFsb2cuY29uZmlnLmNvbG9ycyk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICBcdCBcdH0pO1xyXG4gICAgICAgXHQgXHRkLmFwcGVuZChjb2xvcl9pbnB1dCkuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dCh0aGlzLmNvbmZpZy5jb25kaXRpb25zW3hdKSkuYXBwZW5kVG8oY29sb3JfZGl2KVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQgIGlmIChkaWFsb2cuY29uZmlnLmR5bmFtaWNfc2NhbGUpe1xyXG4gICAgICAgICAgICBcdGRpYWxvZy5zY2FsZV9zbGlkZXIuc2xpZGVyKFwiZGlzYWJsZVwiKTtcclxuICAgICAgICAgICAgXHRkaWFsb2cubWF4X3lfaW5wdXQuc2xpZGVyKFwiZGlzYWJsZVwiKVxyXG4gICAgICAgICAgICB9XHJcblx0XHRcclxuXHRcdFx0XHRcclxuXHR9XHJcblxyXG5cclxuXHRjYWxjdWxhdGVNYXhZKG9wdGlvbnMpe1xyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgeV9tYXg9MDtcclxuXHRcdGxldCBzX3MgPSB0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGZlYXR1cmUgb2Ygb3B0aW9ucy5mZWF0dXJlcyl7XHJcblx0XHRcdGxldCBsZW4gPSBmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0XHJcblx0XHRcdGxldCB4X3BvcyA9IChmZWF0dXJlLnN0YXJ0KyhsZW4vMiktb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdGlmICh4X3Bvcz5jb3VudCl7XHJcblx0XHRcdFx0Y291bnQ9TWF0aC5mbG9vcih4X3BvcykrMTtcclxuXHRcdFx0XHRmb3IgKGxldCBpPTA7aTxzX3M7aSsrKXtcclxuXHRcdFx0XHRcdGxldCB5PWZlYXR1cmUuZGF0YVtpXVswXStmZWF0dXJlLmRhdGFbaV1bMV07XHJcblx0XHRcdFx0XHRpZiAoeT55X21heCl7XHJcblx0XHRcdFx0XHRcdHlfbWF4PXk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geV9tYXg7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKXtcclxuXHRcdGxldCBmZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XHJcblx0XHRsZXQgc3BhcnNlPWZhbHNlO1xyXG5cdFx0bGV0IGludGVydmFsPTFcclxuXHRcdC8qaWYgKGZlYXR1cmVzLmxlbmd0aD4gMS41Km9wdGlvbnMucGl4ZWxXaWR0aCl7XHJcblx0XHRcdGludGVydmFsICs9IE1hdGguZmxvb3IoZmVhdHVyZXMubGVuZ3RoL29wdGlvbnMucGl4ZWxXaWR0aClcclxuXHRcdH0qL1xyXG5cclxuXHRcdFxyXG5cdFx0XHJcblx0XHRsZXQgdG9wID0gdGhpcy5jb25maWcuZGlzY3JldGU/b3B0aW9ucy50b3A6MDtcclxuXHRcdGxldCBib3QgPXRoaXMuY29uZmlnLmRpc2NyZXRlP3BhcnNlSW50KHRvcCkrcGFyc2VJbnQodGhpcy5jb25maWcuaGVpZ2h0KTpvcHRpb25zLnBpeGVsSGVpZ2h0O1xyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmRpc3BsYXlfZGlmZmVyZW5jZSl7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0dGhpcy50b3A9dG9wO1xyXG5cdFx0dGhpcy5ib3R0b209Ym90O1xyXG5cdFx0bGV0IGN0eD1vcHRpb25zLmNvbnRleHQ7XHJcblx0XHRsZXQgcHJldl94PW51bGw7XHJcblx0XHRsZXQgcHJldl95PVtdO1xyXG5cdFx0bGV0IGNvbG9ycz0gdGhpcy5jb25maWcuY29sb3JzXHJcblx0XHRsZXQgeV9tYXggPXRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRpZiAodGhpcy5jb25maWcuZHluYW1pY19zY2FsZSl7XHJcblx0XHRcdHlfbWF4PXRoaXMuY2FsY3VsYXRlTWF4WShvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGxldCB3aWdfaGVpZ2h0ID0gdGhpcy5jb25maWcuZGlzY3JldGU/dGhpcy5jb25maWcuaGVpZ2h0Om9wdGlvbnMucGl4ZWxIZWlnaHQ7XHJcblx0XHRsZXQgc19zID0gdGhpcy5jb25maWcuY29uZGl0aW9ucy5sZW5ndGg7XHJcblx0XHRsZXQgZGlzcGxheV9iYXI9ZmFsc2U7XHJcblx0XHRsZXQgZGlzcGxheV9ib3g9IHRydWU7XHJcblx0XHRpZiAodGhpcy5jb25maWcuZGlzcGxheV9zZCA9PT0gXCJiYXJcIil7XHJcblx0XHRcdGRpc3BsYXlfYm94PWZhbHNlO1xyXG5cdFx0XHRpZiAob3B0aW9ucy5icFBlclBpeGVsPDEwMCl7XHJcblx0XHRcdFx0ZGlzcGxheV9iYXI9dHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHRcdGxldCBjb3VudD0wO1xyXG5cdFx0bGV0IGRyYXduPTA7XHJcblxyXG5cdFx0XHJcblx0XHJcblx0XHRmb3IgKGxldCB4PTA7eDxmZWF0dXJlcy5sZW5ndGg7eCs9aW50ZXJ2YWwpe1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGZlYXR1cmUgPWZlYXR1cmVzW3hdO1xyXG5cdFx0XHJcblx0XHRcdGxldCBsZW4gPSBmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0XHJcblx0XHRcdGxldCB4X3BvcyA9IChmZWF0dXJlLnN0YXJ0KyhsZW4vMiktb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdGlmICh4X3Bvcz5jb3VudCl7XHJcblx0XHRcdFx0Y291bnQ9TWF0aC5mbG9vcih4X3BvcykrMTtcclxuXHRcdFx0XHRkcmF3bisrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGVuID0gbGVuL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHRcdFx0aWYgKGxlbjwxKXtcclxuXHRcdFx0XHRsZW4gPSAxO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCB0X3k9W107XHJcblx0XHRcdGZvciAobGV0IGk9MDtpPHNfcztpKyspe1xyXG5cdFx0XHRcdGxldCB5X3Bvcz13aWdfaGVpZ2h0LSgoZmVhdHVyZS5kYXRhW2ldWzBdL3lfbWF4KSp3aWdfaGVpZ2h0KSt0b3A7XHJcblx0XHRcdFx0eV9wb3M9eV9wb3NcclxuXHRcdFx0XHRpZiAodGhpcy5jb25maWcuYXNsaW5lICYmIHByZXZfeCE9bnVsbCl7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9Y29sb3JzW2ldO1xyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1jb2xvcnNbaV07XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHByZXZfeCxwcmV2X3lbaV0pO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aD0xXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHhfcG9zLHlfcG9zKTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2V7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPWNvbG9yc1tpXTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1jb2xvcnNbaV07XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC40O1x0XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeF9wb3MtKGxlbi8yKSx5X3BvcyxsZW4sdGhpcy5ib3R0b20teV9wb3MpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBzZCA9IChmZWF0dXJlLmRhdGFbaV1bMV0veV9tYXgpKndpZ19oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGlmIChkaXNwbGF5X2JveCl7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC40O1x0XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeF9wb3MtKGxlbi8yKSx5X3Bvcy1zZCxsZW4sMipzZCk7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MS4wO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoZGlzcGxheV9iYXIpe1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcy00LHlfcG9zLXNkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MrNCx5X3Bvcy1zZCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHhfcG9zLHlfcG9zLXNkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MseV9wb3Mrc2QpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcy00LHlfcG9zK3NkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MrNCx5X3BvcytzZCk7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRfeS5wdXNoKHlfcG9zKVxyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfeT10X3k7XHJcblx0XHRcdHByZXZfeD14X3BvcztcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmV4Y2x1c2lvbl96b25lKXtcclxuXHRcdFx0bGV0IGJwU3RhcnQgPSBvcHRpb25zLmJwU3RhcnQ7XHJcblx0XHRcdGxldCBicEVuZD0gb3B0aW9ucy5icFN0YXJ0KyhvcHRpb25zLmJwUGVyUGl4ZWwqb3B0aW9ucy5waXhlbFdpZHRoKTtcclxuXHRcdFx0bGV0IGV4ID0gdGhpcy5jb25maWcuZXhjbHVzaW9uX3pvbmU7XHJcblx0XHRcclxuXHRcdFx0aWYgKChleFswXT5icFN0YXJ0ICYmIGV4WzBdPGJwRW5kKSB8fCAoZXhbMV0+YnBTdGFydCAmJiBleFsxXTxicEVuZCkpe1xyXG5cdFx0XHRcdGxldCBleF9zdD0oZXhbMF0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdGV4X3N0PWV4X3N0PDA/MDpleF9zdDtcclxuXHRcdFx0XHRsZXQgZXhfZW49IChleFsxXS1icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFx0ZXhfZW49IGV4X2VuPm9wdGlvbnMucGl4ZWxXaWR0aD9vcHRpb25zLnBpeGVsV2lkdGg6ZXhfZW47XHJcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1cIndoaXRlXCI7XHJcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlPVwiZ3JleVwiO1xyXG5cclxuXHRcdFx0XHRjdHgucmVjdChleF9zdCx0aGlzLnRvcCsxLGV4X2VuLWV4X3N0LHRoaXMuY29uZmlnLmhlaWdodC0xKTtcclxuXHRcdFx0XHRjdHguZmlsbCgpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRleD0gdGhpcy5jb25maWcudmlld3BvaW50O1xyXG5cdFx0XHRpZiAoZXgpe1xyXG5cdFx0XHRcdGlmICgoZXhbMF0+YnBTdGFydCAmJiBleFswXTxicEVuZCkgfHwgKGV4WzFdPmJwU3RhcnQgJiYgZXhbMV08YnBFbmQpKXtcclxuXHRcdFx0XHRcdGxldCBleF9zdD0oZXhbMF0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdFx0ZXhfc3Q9ZXhfc3Q8MD8wOmV4X3N0O1xyXG5cdFx0XHRcdFx0bGV0IGV4X2VuPSAoZXhbMV0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdFx0ZXhfZW49IGV4X2VuPm9wdGlvbnMucGl4ZWxXaWR0aD9vcHRpb25zLnBpeGVsV2lkdGg6ZXhfZW47XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPVwiZ3JleVwiO1xyXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGV4X3N0LHRoaXMudG9wKzEsZXhfZW4tZXhfc3QsdGhpcy5jb25maWcuaGVpZ2h0LTEpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0XHJcblx0XHRcdFx0XHJcblxyXG5cdFx0dGhpcy5tYXhfeT15X21heDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZGlzY3JldGU/Ym90Om51bGxcclxuXHRcdFx0XHRcclxuXHR9XHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGxldCBib3Q9IHRoaXMuYm90dG9tO1xyXG5cdFx0bGV0IHRvcCA9IHRoaXMudG9wO1xyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5yZWN0KDAsdG9wLDEyMCxib3QtdG9wKTtcclxuXHRcdGN0eC5jbGlwKCk7XHJcblx0XHRsZXQgbWF4X3k9IHRoaXMubWF4X3k7XHJcblx0XHRsZXQgbWluX3k9MDtcclxuXHRcdGxldCByYW5nZT1tYXhfeS1taW5feTtcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCx0b3ApO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLGJvdCk7XHJcblx0XHRjdHgubGluZVRvKDIwLGJvdCk7XHJcblx0XHRjdHguZm9udD1cIjEycHggQXJpYWxcIjtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdGN0eC5maWxsVGV4dChtYXhfeS50b0ZpeGVkKDIpLDIwLHRvcCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KG1pbl95LDIwLGJvdCk7XHJcblx0XHRjdHguZm9udD1cIjE0cHggQXJpYWxcIjtcclxuXHRcdGxldCB0ZXh0PSB0aGlzLmNvbmZpZy5sZWdlbmRfbGFiZWw/dGhpcy5jb25maWcubGVnZW5kX2xhYmVsOlwiQ29uZGl0aW9uXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LDEwLHRvcCszMCk7XHJcblx0XHRjdHguZm9udD1cIjEycHggQXJpYWxcIjtcclxuXHRcdGxldCBjb2xvcnMgPSB0aGlzLmNvbmZpZy5jb2xvcnM7XHJcblx0XHRmb3IgKGxldCBpPTA7aTx0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDtpKyspe1xyXG5cdFx0XHRjdHguZmlsbFN0eWxlPSBjb2xvcnNbaV07XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYT0wLjQ7XHJcblx0XHRcdGN0eC5maWxsUmVjdCgxMCx0b3ArNDArKGkqMzApLDIwLDIwKTtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KDEwLHRvcCs0OSsoaSozMCksMjAsMik7XHJcblx0XHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0XHRjdHguZmlsbFRleHQodGhpcy5jb25maWcuY29uZGl0aW9uc1tpXSwzMSx0b3ArNTUrKGkqMzApKTtcclxuXHRcdH1cclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0fVxyXG5cclxuXHRcclxufVxyXG5cclxuTUxWVHJhY2suY3VzdG9tX3RyYWNrc1tcImNhcHR1cmVfY29tcGFyZVwiXT1DYXB0dXJlQ29tcGFyZVRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1tcImNhcHR1cmVfY29tcGFyZVwiXT17XHJcblx0XCJjbGFzc1wiOkNhcHR1cmVDb21wYXJlVHJhY2tcclxufVxyXG5cclxuXHJcbmV4cG9ydCB7Q2FwdHVyZUNvbXBhcmVUcmFja307XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVRBO0FBQ0E7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE3V0E7QUFDQTtBQWlYQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/capture_compare_track.js\n");

/***/ }),

/***/ "./lanceotron/src/custom_annotation_track.js":
/*!***************************************************!*\
  !*** ./lanceotron/src/custom_annotation_track.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CustomAnnotationTrack = exports.PeakModelTrack = exports.MLVSmoothWigTrack = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CustomGeneFeatureSource = function (_FeatureSource) {\n\t_inherits(CustomGeneFeatureSource, _FeatureSource);\n\n\tfunction CustomGeneFeatureSource(config) {\n\t\t_classCallCheck(this, CustomGeneFeatureSource);\n\n\t\tconfig.sourceType = \"custom\";\n\t\tconfig.featureHeight = config.featureHeight ? config.featureHeight : 12;\n\n\t\tvar _this = _possibleConstructorReturn(this, (CustomGeneFeatureSource.__proto__ || Object.getPrototypeOf(CustomGeneFeatureSource)).call(this, config));\n\n\t\t_this.header = true;\n\t\treturn _this;\n\t}\n\n\t_createClass(CustomGeneFeatureSource, [{\n\t\tkey: \"retrieveFeatures\",\n\t\tvalue: function retrieveFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar self = this;\n\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\tvar url = self.config.url + \"/\" + chr + \"/\" + bpStart + \"/\" + bpEnd;\n\t\t\t\t$.ajax({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdataType: \"json\"\n\t\t\t\t}).done(function (features) {\n\t\t\t\t\tfulfill(features);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn CustomGeneFeatureSource;\n}(_feature.FeatureSource);\n\nvar CustomAnnotationTrack = function (_MLVBedTrack) {\n\t_inherits(CustomAnnotationTrack, _MLVBedTrack);\n\n\tfunction CustomAnnotationTrack(config) {\n\t\t_classCallCheck(this, CustomAnnotationTrack);\n\n\t\tconfig.format = \"feature\";\n\t\treturn _possibleConstructorReturn(this, (CustomAnnotationTrack.__proto__ || Object.getPrototypeOf(CustomAnnotationTrack)).call(this, config));\n\t}\n\n\t_createClass(CustomAnnotationTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tthis.feature_source = new CustomGeneFeatureSource(this.config);\n\t\t}\n\t}]);\n\n\treturn CustomAnnotationTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks['custom_annotation'] = CustomAnnotationTrack;\n_tracks.MLVTrack.track_types['custom_annotation'] = {\n\t\"class\": CustomAnnotationTrack\n};\n\nvar decode_function = function decode_function(tokens, feature) {\n\tfeature.id = parseInt(tokens[0]);\n};\n\nvar PeakModelTrack = function (_MLVBedTrack2) {\n\t_inherits(PeakModelTrack, _MLVBedTrack2);\n\n\tfunction PeakModelTrack(config) {\n\t\t_classCallCheck(this, PeakModelTrack);\n\n\t\tconfig.format = \"feature\";\n\t\treturn _possibleConstructorReturn(this, (PeakModelTrack.__proto__ || Object.getPrototypeOf(PeakModelTrack)).call(this, config));\n\t}\n\n\t_createClass(PeakModelTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t}\n\t}]);\n\n\treturn PeakModelTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"peak_model_track\"] = PeakModelTrack;\n_tracks.MLVTrack.track_types[\"peak_model_track\"] = {\n\t\"class\": PeakModelTrack\n};\n\nvar MLVFeatureTrack = function (_MLVBedTrack3) {\n\t_inherits(MLVFeatureTrack, _MLVBedTrack3);\n\n\tfunction MLVFeatureTrack() {\n\t\t_classCallCheck(this, MLVFeatureTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVFeatureTrack.__proto__ || Object.getPrototypeOf(MLVFeatureTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVFeatureTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tvar url = this.config.url;\n\t\t\tif (url.endsWith(\".bb\") || url.endsWith(\".bigbed\")) {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, decode_function);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setYField\",\n\t\tvalue: function setYField(view, y_field) {\n\t\t\tthis.data_view = view;\n\t\t\tthis.config.featureHeight = 5;\n\t\t\tthis.config.displayMode = \"EXPANDED\";\n\t\t\tthis.y_field = y_field;\n\t\t\tif (view) {\n\t\t\t\tthis.min_max = view.getMinMax(y_field.field);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn _get(MLVFeatureTrack.prototype.__proto__ || Object.getPrototypeOf(MLVFeatureTrack.prototype), \"getFeatureAt\", this).call(this, genomicLocation, chr, coord, bpPerPixel, ctx);\n\t\t\t}\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tvar height = this.config.height - 12;\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = bot - (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tif (coord.y >= y_val && coord.y <= y_val + 5) {\n\t\t\t\t\t\treturn feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar top = this.top;\n\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(20, top);\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(this.min_max[1].toFixed(2), 20, this.top);\n\n\t\t\tctx.moveTo(0, bot);\n\t\t\tctx.lineTo(20, bot);\n\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(this.min_max[0], 20, bot);\n\n\t\t\tctx.textBaseLine = \"middle\";\n\t\t\tctx.fillText(this.y_field.name, 3, top + this.config.height / 2);\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\n\t\t\tif (!this.y_field) {\n\t\t\t\t_get(MLVFeatureTrack.prototype.__proto__ || Object.getPrototypeOf(MLVFeatureTrack.prototype), \"drawFeatures\", this).call(this, options);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\n\t\t\tthis.bottom = this.top + this.config.height;\n\t\t\tvar bottom = this.bottom - 12;\n\t\t\tvar height = bottom - this.top;\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar feature = _step2.value;\n\n\t\t\t\t\tif (this.filter_function && !this.filter_function(feature)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar x_pos = (feature.start - options.bpStart) / options.bpPerPixel;\n\n\t\t\t\t\tvar len = (feature.end - feature.start) / options.bpPerPixel;\n\n\t\t\t\t\tif (len < 2) {\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t}\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tfeature.color = this.config.color;\n\t\t\t\t\tif (this.color_function) {\n\t\t\t\t\t\tfeature.color = this.color_function(feature);\n\t\t\t\t\t}\n\t\t\t\t\tvar y_pos = bottom - y_val;\n\t\t\t\t\tctx.fillStyle = feature.color;\n\t\t\t\t\tctx.fillRect(x_pos, y_pos, len, 4);\n\t\t\t\t\tthis.renderFeatureLabel(ctx, feature, x_pos, x_pos + len, y_pos, 0, options.pixelWidth);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn MLVFeatureTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_feature_track\"] = {\n\t\"class\": MLVFeatureTrack\n};\n\nvar MLVSmoothWigTrack = function (_MLVWigTrack) {\n\t_inherits(MLVSmoothWigTrack, _MLVWigTrack);\n\n\tfunction MLVSmoothWigTrack() {\n\t\t_classCallCheck(this, MLVSmoothWigTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVSmoothWigTrack.__proto__ || Object.getPrototypeOf(MLVSmoothWigTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVSmoothWigTrack, [{\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar self = this,\n\t\t\t    features = options.features,\n\t\t\t    color = self.config.color,\n\t\t\t    ctx = options.context,\n\t\t\t    bpPerPixel = options.bpPerPixel,\n\t\t\t    bpStart = options.bpStart,\n\t\t\t    pixelWidth = options.pixelWidth,\n\t\t\t    pixelHeight = options.pixelHeight,\n\t\t\t    y_offset = this.config.discrete ? options.top : 0,\n\t\t\t    bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n\t\t\t    featureValueMinimum = void 0,\n\t\t\t    featureValueMaximum = void 0,\n\t\t\t    featureValueRange = void 0,\n\t\t\t    $dataRangeTrackLabel = void 0,\n\t\t\t    str = void 0,\n\t\t\t    min = void 0,\n\t\t\t    max = void 0;\n\t\t\tif (this.config.group) {\n\t\t\t\tpixelHeight = options.height;\n\t\t\t} else if (this.config.discrete) {\n\t\t\t\tpixelHeight = this.config.height;\n\t\t\t}\n\n\t\t\tif (!color) {\n\t\t\t\tcolor = \"black\";\n\t\t\t}\n\t\t\tself.prev_coords = { x: 0, y: 0 };\n\n\t\t\tif (features) {\n\t\t\t\tif (self.scale_link_to) {\n\t\t\t\t\tvar t = self.scale_link_to.config;\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tself.config.scale = t.scale;\n\t\t\t\t\t\tself.max_y = self.scale_link_to.max_y;\n\t\t\t\t\t\tself.min_y = self.scale_link_to.min_y;\n\t\t\t\t\t}\n\t\t\t\t} else if (self.set_scale) {\n\t\t\t\t\tself.min_y = self.set_scale.min;\n\t\t\t\t\tself.max_y = self.set_scale.max;\n\t\t\t\t} else if (self.max_y === undefined && self.config.scale === \"automatic\" || self.config.scale === \"dynamic\") {\n\t\t\t\t\tvar s = autoscale(features);\n\t\t\t\t\tself.min_y = s.min;\n\t\t\t\t\tself.max_y = s.max;\n\t\t\t\t} else if (self.config.scale === \"fixed\") {\n\t\t\t\t\tself.min_y = self.config.min_y;\n\t\t\t\t\tself.max_y = self.config.max_y;\n\t\t\t\t}\n\n\t\t\t\tfeatureValueRange = self.max_y - self.min_y;\n\n\t\t\t\t//$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\n\t\t\t\t//\n\t\t\t\t//min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\n\t\t\t\t//max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\n\t\t\t\t//str = '[' + min + ' - ' + max + ']';\n\t\t\t\t//\n\t\t\t\t//$dataRangeTrackLabel.text(str);\n\t\t\t\tvar prev_x = 0;\n\t\t\t\tvar prev_y = 0;\n\t\t\t\tctx.globalAlpha = this.config.opacity ? this.config.opacity : 1;\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tvar b = y_offset + pixelHeight;\n\t\t\t\t\tself.smooths = Array(pixelWidth).fill(b);\n\t\t\t\t}\n\t\t\t\tif (self.is_line) {\n\t\t\t\t\tvar y = (1.0 - self.config.value / featureValueRange) * pixelHeight;\n\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, 0, y, pixelWidth, y, { \"strokeStyle\": self.config.color, \"lineWidth\": self.config.width ? self.config.width : 1 });\n\t\t\t\t} else {\n\t\t\t\t\tfeatures.forEach(renderFeature);\n\t\t\t\t}\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tvar win_pixels = Math.round(self.config.smooth / bpPerPixel);\n\t\t\t\t\tvar h_win = win_pixels / 2;\n\t\t\t\t\tvar total = 0;\n\t\t\t\t\tfor (var n = 0; n < win_pixels; n++) {\n\t\t\t\t\t\ttotal = total + self.smooths[n];\n\t\t\t\t\t}\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(h_win, total / win_pixels);\n\t\t\t\t\tfor (var _n = h_win + 1; _n < pixelWidth - h_win; _n++) {\n\t\t\t\t\t\ttotal = total - self.smooths[_n - h_win - 1] + self.smooths[_n + h_win];\n\t\t\t\t\t\t//console.log(n+\":\"+self.smooths[n]);\n\t\t\t\t\t\tctx.lineTo(_n, total / win_pixels);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.strokeStyle = \"red\";\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\tif (self.config.thresholds) {\n\t\t\t\t\tvar _y = y_offset + (1.0 - self.config.thresholds[options.chr] / featureValueRange) * pixelHeight;\n\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, 0, _y, pixelWidth, _y, { \"strokeStyle\": \"black\", \"lineWidth\": 1 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction renderFeature(feature, index, featureList) {\n\n\t\t\t\tvar yUnitless, heightUnitLess, x, y, width, height, rectEnd, rectBaseline;\n\n\t\t\t\tif (feature.end < bpStart) return;\n\t\t\t\tif (feature.start > bpEnd) return;\n\n\t\t\t\tx = Math.floor((feature.start - bpStart) / bpPerPixel);\n\t\t\t\trectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\n\t\t\t\twidth = Math.max(0, rectEnd - x);\n\n\t\t\t\t//height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\n\t\t\t\t//rectBaseline = pixelHeight - height;\n\t\t\t\t//canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\n\n\t\t\t\tif (signsDiffer(self.min_y, self.max_y)) {\n\n\t\t\t\t\tif (feature.value < 0) {\n\t\t\t\t\t\tyUnitless = self.max_y / featureValueRange;\n\t\t\t\t\t\theightUnitLess = -feature.value / featureValueRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyUnitless = (self.max_y - feature.value) / featureValueRange;\n\t\t\t\t\t\theightUnitLess = feature.value / featureValueRange;\n\t\t\t\t\t}\n\t\t\t\t} else if (self.min_y < 0) {\n\t\t\t\t\tyUnitless = 0;\n\t\t\t\t\theightUnitLess = -feature.value / featureValueRange;\n\t\t\t\t} else {\n\t\t\t\t\tyUnitless = 1.0 - (feature.value - self.min_y) / featureValueRange;\n\t\t\t\t\theightUnitLess = (feature.value + self.min_y) / featureValueRange;\n\t\t\t\t}\n\n\t\t\t\ty = yUnitless * pixelHeight + y_offset;\n\t\t\t\ty = y < y_offset ? y_offset : y;\n\t\t\t\theight = heightUnitLess * pixelHeight;\n\t\t\t\theight = height > pixelHeight ? pixelHeight : height;\n\n\t\t\t\t//canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\n\t\t\t\tif (self.config.display === 'line') {\n\t\t\t\t\tif (self.prev_coords.x) {\n\t\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, x, y, self.prev_coords.x, self.prev_coords.y, { \"strokeStyle\": color, \"lineWidth\": 3 });\n\t\t\t\t\t}\n\t\t\t\t\tself.prev_coords.x = x;\n\t\t\t\t\tself.prev_coords.y = y;\n\t\t\t\t} else {\n\t\t\t\t\t_tracks.Graphics.fillRect(ctx, x, y, width, height, { fillStyle: color });\n\t\t\t\t}\n\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tfor (var a = x; a < x + width; a++) {\n\t\t\t\t\t\tself.smooths[a] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction autoscale(features) {\n\t\t\t\tvar min = 0,\n\t\t\t\t    max = -Number.MAX_VALUE;\n\t\t\t\tfeatures.forEach(function (f) {\n\t\t\t\t\tmin = Math.min(min, f.value);\n\t\t\t\t\tmax = Math.max(max, f.value);\n\t\t\t\t});\n\t\t\t\treturn { min: min, max: max };\n\t\t\t}\n\n\t\t\tfunction signsDiffer(a, b) {\n\t\t\t\treturn a > 0 && b < 0 || a < 0 && b > 0;\n\t\t\t}\n\t\t\tthis.top = y_offset;\n\t\t\tthis.bottom = y_offset + pixelHeight;\n\t\t\tif (this.config.discrete) {\n\t\t\t\treturn this.bottom;\n\t\t\t} else {\n\t\t\t\tthis.top = 0;\n\t\t\t\tthis.bottom = 0;\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn MLVSmoothWigTrack;\n}(_tracks.MLVWigTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_smooth_wig_track\"] = {\n\t\"class\": MLVSmoothWigTrack\n};\n\nexports.MLVSmoothWigTrack = MLVSmoothWigTrack;\nexports.PeakModelTrack = PeakModelTrack;\nexports.CustomAnnotationTrack = CustomAnnotationTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9jdXN0b21fYW5ub3RhdGlvbl90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9jdXN0b21fYW5ub3RhdGlvbl90cmFjay5qcz84NTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RmVhdHVyZVNvdXJjZSxCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2ssTUxWV2lnVHJhY2ssR3JhcGhpY3N9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQ3VzdG9tR2VuZUZlYXR1cmVTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNle1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRjb25maWcuc291cmNlVHlwZT1cImN1c3RvbVwiO1xyXG5cdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9Y29uZmlnLmZlYXR1cmVIZWlnaHQ/Y29uZmlnLmZlYXR1cmVIZWlnaHQ6MTI7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5oZWFkZXI9dHJ1ZTtcclxuXHR9XHJcblxyXG5cdHJldHJpZXZlRmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cdFx0XHRsZXQgdXJsID0gc2VsZi5jb25maWcudXJsK1wiL1wiK2NocitcIi9cIiticFN0YXJ0K1wiL1wiK2JwRW5kO1xyXG5cdFx0XHQgJC5hamF4KHtcclxuXHQgICAgICAgICAgICB1cmw6dXJsLFxyXG5cdCAgICAgICAgICAgIGRhdGFUeXBlOlwianNvblwiXHJcblx0ICAgICAgICB9KVxyXG5cdCAgICAgICAgLmRvbmUoZmVhdHVyZXM9PntcclxuXHQgICAgICAgIFx0ZnVsZmlsbChmZWF0dXJlcyk7XHJcblx0ICAgICAgICBcdH0pXHQgICAgICAgICAgIFxyXG5cdCAgICAgIH0pOyAgIFx0XHJcblx0fVxyXG5cdFxyXG59XHJcblxyXG5jbGFzcyBDdXN0b21Bbm5vdGF0aW9uVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0fVxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPSBuZXcgQ3VzdG9tR2VuZUZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpXHJcblx0fVxyXG5cdFx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3NbJ2N1c3RvbV9hbm5vdGF0aW9uJ109Q3VzdG9tQW5ub3RhdGlvblRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1snY3VzdG9tX2Fubm90YXRpb24nXT17XHJcblx0XCJjbGFzc1wiOkN1c3RvbUFubm90YXRpb25UcmFja1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5sZXQgZGVjb2RlX2Z1bmN0aW9uPSBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0ZmVhdHVyZS5pZD1wYXJzZUludCh0b2tlbnNbMF0pO1xyXG59O1xyXG5cclxuXHJcbmNsYXNzIFBlYWtNb2RlbFRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG4gICAgXHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiO1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcdFxyXG5cdH1cdFxyXG59XHJcblxyXG5NTFZUcmFjay5jdXN0b21fdHJhY2tzW1wicGVha19tb2RlbF90cmFja1wiXT1QZWFrTW9kZWxUcmFjaztcclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJwZWFrX21vZGVsX3RyYWNrXCJdPXtcclxuXHRcImNsYXNzXCI6UGVha01vZGVsVHJhY2tcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVkZlYXR1cmVUcmFjayBleHRlbmRzIE1MVkJlZFRyYWNre1xyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRsZXQgdXJsID0gdGhpcy5jb25maWcudXJsO1xyXG5cdFx0aWYgKHVybC5lbmRzV2l0aChcIi5iYlwiKSB8fCB1cmwuZW5kc1dpdGgoXCIuYmlnYmVkXCIpKXtcclxuXHRcdFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBCaWdCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBUYWJpeEJlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRzZXRZRmllbGQodmlldyx5X2ZpZWxkKXtcclxuXHRcdHRoaXMuZGF0YV92aWV3PXZpZXc7XHJcblx0XHR0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0PTU7XHJcblx0XHR0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZT1cIkVYUEFOREVEXCI7XHJcblx0XHR0aGlzLnlfZmllbGQ9eV9maWVsZDtcclxuXHRcdGlmICh2aWV3KXtcclxuXHRcdFx0dGhpcy5taW5fbWF4PXZpZXcuZ2V0TWluTWF4KHlfZmllbGQuZmllbGQpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCl7XHJcblx0XHRpZiAoIXRoaXMueV9maWVsZCl7XHJcblx0XHRcdHJldHVybiBzdXBlci5nZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCk7XHJcblx0XHR9XHJcblx0XHRcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMiAqIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgbGV0IGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmNvbmZpZy5oZWlnaHQtMTI7XHJcblx0XHRsZXQgcmFuZ2UgPSB0aGlzLm1pbl9tYXhbMV0tdGhpcy5taW5fbWF4WzBdO1xyXG5cdFx0bGV0IGZpZWxkID0gdGhpcy55X2ZpZWxkLmZpZWxkO1xyXG5cdFx0bGV0IGJvdCA9dGhpcy5ib3R0b20tMTI7XHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIGZlYXR1cmVMaXN0KXtcclxuXHRcdFx0bGV0IGl0ZW0gPSB0aGlzLmRhdGFfdmlldy5nZXRJdGVtQnlJZChmZWF0dXJlLmlkKTtcclxuXHRcdFx0aWYgKCFpdGVtKXtcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPWJvdC0oKChpdGVtW2ZpZWxkXS10aGlzLm1pbl9tYXhbMF0pL3JhbmdlKSpoZWlnaHQpO1xyXG5cdFx0XHRpZiAoY29vcmQueSA+PXlfdmFsICYmIGNvb3JkLnk8PXlfdmFsKzUpe1xyXG5cdFx0XHRcdHJldHVybiBmZWF0dXJlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGlmICghdGhpcy55X2ZpZWxkKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGJvdD0gdGhpcy5ib3R0b20tMTI7XHJcblx0XHRsZXQgdG9wID0gdGhpcy50b3A7XHJcblx0XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LnJlY3QoMCx0b3AsMTIwLGJvdC10b3ApO1xyXG5cdFx0Y3R4LmNsaXAoKTtcclxuXHRcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdFxyXG5cdFx0XHRcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCx0b3ApO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZT1cInRvcFwiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWluX21heFsxXS50b0ZpeGVkKDIpLDIwLHRoaXMudG9wKTtcclxuXHJcblx0XHRjdHgubW92ZVRvKDAsYm90KTtcclxuXHRcdGN0eC5saW5lVG8oMjAsYm90KTtcclxuXHJcblx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0aGlzLm1pbl9tYXhbMF0sMjAsYm90KTtcclxuXHJcblx0XHRjdHgudGV4dEJhc2VMaW5lPVwibWlkZGxlXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0aGlzLnlfZmllbGQubmFtZSwzLHRvcCsodGhpcy5jb25maWcuaGVpZ2h0LzIpKTtcclxuXHRcdFxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHJcblx0fVxyXG5cclxuXHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpe1xyXG5cdFxyXG5cdFx0aWYgKCF0aGlzLnlfZmllbGQpe1xyXG5cdFx0XHRzdXBlci5kcmF3RmVhdHVyZXMob3B0aW9ucyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGxldCByYW5nZSA9IHRoaXMubWluX21heFsxXS10aGlzLm1pbl9tYXhbMF07XHJcblx0XHRsZXQgZmllbGQgPSB0aGlzLnlfZmllbGQuZmllbGQ7XHJcblx0XHRsZXQgY3R4PW9wdGlvbnMuY29udGV4dDtcclxuXHRcdHRoaXMudG9wPW9wdGlvbnMudG9wO1xyXG5cdFxyXG5cclxuXHRcdHRoaXMuYm90dG9tPXRoaXMudG9wK3RoaXMuY29uZmlnLmhlaWdodDtcclxuXHRcdGxldCBib3R0b20gPSB0aGlzLmJvdHRvbS0xMjtcclxuXHRcdGxldCBoZWlnaHQgPWJvdHRvbS10aGlzLnRvcDtcclxuXHRcdGZvciAobGV0IGZlYXR1cmUgb2Ygb3B0aW9ucy5mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZmVhdHVyZSkpe1xyXG4gICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9wb3MgPSAoZmVhdHVyZS5zdGFydC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHJcblx0XHRcdGxldCBsZW4gPSAoZmVhdHVyZS5lbmQtZmVhdHVyZS5zdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGxlbjwyKXtcclxuXHRcdFx0XHRsZW4gPSAyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBpdGVtID0gdGhpcy5kYXRhX3ZpZXcuZ2V0SXRlbUJ5SWQoZmVhdHVyZS5pZCk7XHJcblx0XHRcdGlmICghaXRlbSl7XHJcblx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0bGV0IHlfdmFsID0oKGl0ZW1bZmllbGRdLXRoaXMubWluX21heFswXSkvcmFuZ2UpKmhlaWdodDtcclxuXHRcdFx0ZmVhdHVyZS5jb2xvciA9IHRoaXMuY29uZmlnLmNvbG9yO1xyXG5cdFx0XHRpZiAodGhpcy5jb2xvcl9mdW5jdGlvbil7XHJcbiAgICBcdFx0XHRmZWF0dXJlLmNvbG9yPXRoaXMuY29sb3JfZnVuY3Rpb24oZmVhdHVyZSk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGxldCB5X3Bvcz1ib3R0b20teV92YWw7XHJcblx0XHRcdGN0eC5maWxsU3R5bGU9ZmVhdHVyZS5jb2xvcjtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KHhfcG9zLHlfcG9zLGxlbiw0KVxyXG5cdFx0XHR0aGlzLnJlbmRlckZlYXR1cmVMYWJlbChjdHgsIGZlYXR1cmUsIHhfcG9zLCB4X3BvcytsZW4seV9wb3MgLCAwLCBvcHRpb25zLnBpeGVsV2lkdGgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcblx0fVx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wibWx2X2ZlYXR1cmVfdHJhY2tcIl09e1xyXG5cdFwiY2xhc3NcIjpNTFZGZWF0dXJlVHJhY2tcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVlNtb290aFdpZ1RyYWNrIGV4dGVuZHMgIE1MVldpZ1RyYWNre1xyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXMsXHJcblx0ICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuXHQgICAgY29sb3I9c2VsZi5jb25maWcuY29sb3IsXHJcblx0ICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuXHQgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuXHQgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuXHQgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuXHQgICAgcGl4ZWxIZWlnaHQgPW9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcblx0ICAgIHlfb2Zmc2V0PXRoaXMuY29uZmlnLmRpc2NyZXRlP29wdGlvbnMudG9wOjAsXHJcblx0ICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWluaW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWF4aW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlUmFuZ2UsXHJcblx0ICAgICRkYXRhUmFuZ2VUcmFja0xhYmVsLFxyXG5cdCAgICBzdHIsXHJcblx0ICAgIG1pbixcclxuXHQgICAgbWF4O1xyXG5cdCAgICBpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZih0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0ICAgIFx0XHRwaXhlbEhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ7XHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYoc2VsZi5zZXRfc2NhbGUpe1xyXG5cdCAgICAgICBcdFx0c2VsZi5taW5feT1zZWxmLnNldF9zY2FsZS5taW47XHJcblx0ICAgICAgIFx0XHRzZWxmLm1heF95PXNlbGYuc2V0X3NjYWxlLm1heDtcclxuXHQgICAgICAgfVxyXG5cdCAgICAgICBlbHNlIGlmICggKHNlbGYubWF4X3kgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNvbmZpZy5zY2FsZT09PVwiYXV0b21hdGljXCIpIHx8IHNlbGYuY29uZmlnLnNjYWxlPT09XCJkeW5hbWljXCIpe1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcyA9IGF1dG9zY2FsZShmZWF0dXJlcyk7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzLm1pbjtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeSA9IHMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5zY2FsZT09PVwiZml4ZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95ID0gc2VsZi5jb25maWcubWluX3k7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3k9c2VsZi5jb25maWcubWF4X3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgICAgICAgICBmZWF0dXJlVmFsdWVSYW5nZSA9IHNlbGYubWF4X3kgLSBzZWxmLm1pbl95O1xyXG5cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsID0gJCh0aGlzLnRyYWNrVmlldy50cmFja0RpdikuZmluZCgnLmlndi1kYXRhLXJhbmdlLXRyYWNrLWxhYmVsJyk7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvL21pbiA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5taW4pID09PSB0cmFjay5kYXRhUmFuZ2UubWluKSA/IHRyYWNrLmRhdGFSYW5nZS5taW4gOiB0cmFjay5kYXRhUmFuZ2UubWluLnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9tYXggPSAoTWF0aC5mbG9vcih0cmFjay5kYXRhUmFuZ2UubWF4KSA9PT0gdHJhY2suZGF0YVJhbmdlLm1heCkgPyB0cmFjay5kYXRhUmFuZ2UubWF4IDogdHJhY2suZGF0YVJhbmdlLm1heC50b0ZpeGVkKDIpO1xyXG5cdCAgICAgICAgICAgIC8vc3RyID0gJ1snICsgbWluICsgJyAtICcgKyBtYXggKyAnXSc7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsLnRleHQoc3RyKTtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl94PTA7XHJcblx0ICAgICAgICAgICAgbGV0IHByZXZfeT0wO1xyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAgID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNtb290aCl7XHJcblx0ICAgICAgICAgICAgXHRsZXQgYj0geV9vZmZzZXQrcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLnNtb290aHM9QXJyYXkocGl4ZWxXaWR0aCkuZmlsbChiKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfbGluZSl7ICBcclxuXHQgICAgICAgICAgICAgICAgbGV0IHkgPSAoMS4wIC0gc2VsZi5jb25maWcudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZSkqcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LDAseSxwaXhlbFdpZHRoLHkse1wic3Ryb2tlU3R5bGVcIjpzZWxmLmNvbmZpZy5jb2xvcixcImxpbmVXaWR0aFwiOnNlbGYuY29uZmlnLndpZHRoP3NlbGYuY29uZmlnLndpZHRoOjF9KTtcclxuXHQgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHRmZWF0dXJlcy5mb3JFYWNoKHJlbmRlckZlYXR1cmUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc21vb3RoKXtcclxuXHQgICAgICAgICAgICBcdGxldCB3aW5fcGl4ZWxzPSBNYXRoLnJvdW5kKHNlbGYuY29uZmlnLnNtb290aC9icFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICBcdGxldCBoX3dpbiA9IHdpbl9waXhlbHMvMjtcclxuXHQgICAgICAgICAgICBcdGxldCB0b3RhbD0wO1xyXG5cdCAgICAgICAgICAgIFx0Zm9yIChsZXQgbj0wO248d2luX3BpeGVscztuKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbD10b3RhbCtzZWxmLnNtb290aHNbbl07XHJcblx0ICAgICAgICAgICAgXHR9XHJcblx0ICAgICAgICAgICAgXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0ICAgICAgICAgICAgXHRjdHgubW92ZVRvKGhfd2luLHRvdGFsL3dpbl9waXhlbHMpXHJcblx0ICAgICAgICAgICAgXHRmb3IgKGxldCBuPWhfd2luKzE7bjxwaXhlbFdpZHRoLWhfd2luO24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsPXRvdGFsLXNlbGYuc21vb3Roc1tuLWhfd2luLTFdK3NlbGYuc21vb3Roc1tuK2hfd2luXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuK1wiOlwiK3NlbGYuc21vb3Roc1tuXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8obix0b3RhbC93aW5fcGl4ZWxzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBcdH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgIFx0Y3R4LnN0cm9rZVN0eWxlPVwicmVkXCI7XHJcblx0ICAgICAgICAgICAgXHRjdHguc3Ryb2tlKClcclxuXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xXHJcblx0ICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy50aHJlc2hvbGRzKXtcclxuXHQgICAgICAgICAgICAgXHQgICAgbGV0IHkgPSB5X29mZnNldCsoMS4wIC0gc2VsZi5jb25maWcudGhyZXNob2xkc1tvcHRpb25zLmNocl0vIGZlYXR1cmVWYWx1ZVJhbmdlKSpwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICAgXHQgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsMCx5LHBpeGVsV2lkdGgseSx7XCJzdHJva2VTdHlsZVwiOlwiYmxhY2tcIixcImxpbmVXaWR0aFwiOjF9KTtcclxuXHQgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgICBcclxuXHQgICAgICAgIGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgaW5kZXgsIGZlYXR1cmVMaXN0KSB7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciB5VW5pdGxlc3MsXHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzLFxyXG5cdCAgICAgICAgICAgICAgICB4LFxyXG5cdCAgICAgICAgICAgICAgICB5LFxyXG5cdCAgICAgICAgICAgICAgICB3aWR0aCxcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG5cdCAgICAgICAgICAgICAgICByZWN0RW5kLFxyXG5cdCAgICAgICAgICAgICAgICByZWN0QmFzZWxpbmU7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZCA8IGJwU3RhcnQpIHJldHVybjtcclxuXHQgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdGFydCA+IGJwRW5kKSByZXR1cm47XHJcblxyXG5cdCAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICByZWN0RW5kID0gTWF0aC5mbG9vcigoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwpO1xyXG5cdCAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgcmVjdEVuZCAtIHgpO1xyXG5cclxuXHQgICAgICAgICAgICAvL2hlaWdodCA9ICgoZmVhdHVyZS52YWx1ZSAtIGZlYXR1cmVWYWx1ZU1pbmltdW0pIC8gZmVhdHVyZVZhbHVlUmFuZ2UpICogcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9yZWN0QmFzZWxpbmUgPSBwaXhlbEhlaWdodCAtIGhlaWdodDtcclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdChyZWN0T3JpZ2luLCByZWN0QmFzZWxpbmUsIHJlY3RXaWR0aCwgcmVjdEhlaWdodCwge2ZpbGxTdHlsZTogdHJhY2suY29sb3J9KTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHNpZ25zRGlmZmVyKHNlbGYubWluX3ksIHNlbGYubWF4X3kpKSB7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS52YWx1ZSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IHNlbGYubWF4X3kvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gKChzZWxmLm1heF95IC0gZmVhdHVyZS52YWx1ZSkgLyBmZWF0dXJlVmFsdWVSYW5nZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IGZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5taW5feSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMDtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMS4wIC0gKChmZWF0dXJlLnZhbHVlLXNlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IChmZWF0dXJlLnZhbHVlK3NlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgIFx0eSA9ICh5VW5pdGxlc3MqcGl4ZWxIZWlnaHQpK3lfb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIHk9eTx5X29mZnNldD95X29mZnNldDp5O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHRVbml0TGVzcyAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHQ+cGl4ZWxIZWlnaHQ/cGl4ZWxIZWlnaHQ6aGVpZ2h0XHJcblxyXG5cdCAgICAgICAgICAgIC8vY2FudmFzLmZpbGxSZWN0KHgsIHlVbml0bGVzcyAqIHBpeGVsSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodCwgeyBmaWxsU3R5bGU6IGlndi5yYW5kb21SR0IoNjQsIDI1NSkgfSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRpc3BsYXk9PT0nbGluZScpe1xyXG5cdCAgICAgICAgICAgICAgICAgaWYgKHNlbGYucHJldl9jb29yZHMueCl7XHJcblx0ICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCx4LHksc2VsZi5wcmV2X2Nvb3Jkcy54LHNlbGYucHJldl9jb29yZHMueSx7XCJzdHJva2VTdHlsZVwiOmNvbG9yLFwibGluZVdpZHRoXCI6M30pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzZWxmLnByZXZfY29vcmRzLng9eDtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy55PXk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHQgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBjb2xvcn0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIFx0XHJcblxyXG5cdCAgICAgICAgICAgIFx0XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNtb290aCl7XHJcblx0ICAgICAgICAgICBcdCAgICBmb3IgKGxldCBhPXg7YTx4K3dpZHRoO2ErKyl7XHJcblx0ICAgICAgICAgICBcdCAgICBcdHNlbGYuc21vb3Roc1thXT15O1xyXG5cdCAgICAgICAgICAgXHQgICAgfVxyXG5cdCAgICAgICAgICAgXHJcblx0ICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZmVhdHVyZXMpIHtcclxuICAgICAgICBcdFx0dmFyIG1pbiA9IDAsXHJcbiAgICAgICAgICAgIFx0bWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgXHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgZi52YWx1ZSk7XHJcbiAgICAgICAgICAgXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBmLnZhbHVlKTtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcdHJldHVybiB7bWluOiBtaW4sIG1heDogbWF4fTtcclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHRcdGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIChhID4gMCAmJiBiIDwgMCB8fCBhIDwgMCAmJiBiID4gMCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgXHRcdHRoaXMuYm90dG9tPXlfb2Zmc2V0K3BpeGVsSGVpZ2h0O1xyXG4gICAgXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGVsc2V7XHJcbiAgICBcdFx0XHR0aGlzLnRvcD0wO1xyXG4gICAgXHRcdFx0dGhpcy5ib3R0b209MDtcclxuICAgXHRcdFx0fVx0ICAgIFxyXG5cdH1cclxufVxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJtbHZfc21vb3RoX3dpZ190cmFja1wiXT17XHJcblx0XCJjbGFzc1wiOk1MVlNtb290aFdpZ1RyYWNrXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtNTFZTbW9vdGhXaWdUcmFja31cclxuZXhwb3J0IHtQZWFrTW9kZWxUcmFja307IFxyXG5leHBvcnQge0N1c3RvbUFubm90YXRpb25UcmFja307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBUUE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFHQTtBQUpBO0FBS0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBcEJBO0FBQ0E7QUF1QkE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFQQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUlBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQXZCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1QkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBZUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEwQ0E7QUFDQTs7OztBQXZJQTtBQUNBO0FBeUlBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBeE1BO0FBQ0E7QUEwTUE7QUFDQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/custom_annotation_track.js\n");

/***/ }),

/***/ "./lanceotron/src/deseq_track.js":
/*!***************************************!*\
  !*** ./lanceotron/src/deseq_track.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.DESeqTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DESeqTrack = function (_MLVBigBedTrack) {\n\t_inherits(DESeqTrack, _MLVBigBedTrack);\n\n\tfunction DESeqTrack(config) {\n\t\t_classCallCheck(this, DESeqTrack);\n\n\t\tif (!config.featureHeight) {\n\t\t\tconfig.featureHeight = 12;\n\t\t}\n\t\tconfig.height = 5 + config.deseq_labels.length * (config.featureHeight + 1);\n\t\treturn _possibleConstructorReturn(this, (DESeqTrack.__proto__ || Object.getPrototypeOf(DESeqTrack)).call(this, config));\n\t}\n\n\t_createClass(DESeqTrack, [{\n\t\tkey: \"renderFeature\",\n\t\tvalue: function renderFeature(feature, coord, tc, info) {\n\t\t\tcoord.py = coord.py + (feature.score - 1) * (this.config.featureHeight + 1);\n\t\t\t_get(DESeqTrack.prototype.__proto__ || Object.getPrototypeOf(DESeqTrack.prototype), \"renderFeature\", this).call(this, feature, coord, tc, info);\n\t\t}\n\t}, {\n\t\tkey: \"renderFeatureLabel\",\n\t\tvalue: function renderFeatureLabel() {}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\n\t\t\tvar yOffset = coord.y - this.top - 5;\n\t\t\tif (this.feature_source.featureCache) {\n\t\t\t\tvar tolerance = 2 * bpPerPixel,\n\t\t\t\t    featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\t\tvar row = Math.floor(yOffset / this.config.featureHeight);\n\t\t\t\tif (featureList && featureList.length > 0) {\n\t\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\t\tvar _didIteratorError = false;\n\t\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\t\t\tif (feature.end >= genomicLocation - tolerance && !feature.start <= genomicLocation + tolerance) {\n\t\t\t\t\t\t\t\tif (row == feature.score - 1 && feature.display) {\n\t\t\t\t\t\t\t\t\treturn feature;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t_iteratorError = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\t\t\tvar y = this.top + 5;\n\t\t\tctx.font = \"12px Arial\";\n\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = this.config.deseq_labels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar text = _step2.value;\n\n\n\t\t\t\t\tctx.fillText(text, 3, y);\n\t\t\t\t\ty += this.config.featureHeight + 1;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn DESeqTrack;\n}(_tracks.MLVBigBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"deseq_track\"] = DESeqTrack;\n_tracks.MLVTrack.track_types[\"deseq_track\"] = {\n\t\"class\": DESeqTrack\n};\n\nexports.DESeqTrack = DESeqTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9kZXNlcV90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9kZXNlcV90cmFjay5qcz81NGY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWQmlnQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5jbGFzcyBERVNlcVRyYWNrIGV4dGVuZHMgTUxWQmlnQmVkVHJhY2t7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZy5mZWF0dXJlSGVpZ2h0KXtcclxuXHRcdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9MTI7XHJcblx0XHR9XHJcblx0XHRjb25maWcuaGVpZ2h0PTUrKGNvbmZpZy5kZXNlcV9sYWJlbHMubGVuZ3RoKihjb25maWcuZmVhdHVyZUhlaWdodCsxKSk7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdH1cclxuXHJcblxyXG5cdHJlbmRlckZlYXR1cmUoZmVhdHVyZSxjb29yZCx0YyxpbmZvKXtcclxuXHRcdGNvb3JkLnB5ID0gY29vcmQucHkrKChmZWF0dXJlLnNjb3JlLTEpKih0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KzEpKTtcclxuXHRcdHN1cGVyLnJlbmRlckZlYXR1cmUoZmVhdHVyZSxjb29yZCx0YyxpbmZvKTtcclxuXHR9XHJcblx0cmVuZGVyRmVhdHVyZUxhYmVsKCl7XHJcblx0XHRcclxuXHR9XHJcblxyXG5cdGdldEZlYXR1cmVBdChnZW5vbWljTG9jYXRpb24sIGNociwgY29vcmQsIGJwUGVyUGl4ZWwpIHtcclxuXHRcdGxldCB5T2Zmc2V0PWNvb3JkLnktdGhpcy50b3AtNTtcclxuXHRcdGlmICh0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZSkge1xyXG4gICAgICAgXHRcdHZhciB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbCwgIFxyXG4gICAgICAgIFx0ZmVhdHVyZUxpc3QgPSB0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZS5xdWVyeUZlYXR1cmVzKGNociwgZ2Vub21pY0xvY2F0aW9uIC0gdG9sZXJhbmNlLCBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpO1xyXG4gICAgICAgIFx0bGV0IHJvdyA9IE1hdGguZmxvb3IoeU9mZnNldC90aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KTtcclxuICAgIFx0XHRpZiAoZmVhdHVyZUxpc3QgJiYgZmVhdHVyZUxpc3QubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGZvciAobGV0IGZlYXR1cmUgb2YgZmVhdHVyZUxpc3Qpe1xyXG4gICAgICAgICAgICBcdFx0aWYgKGZlYXR1cmUuZW5kID49IGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSAmJiAhXHJcbiAgICAgICAgICAgICAgICBcdFx0ZmVhdHVyZS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgICAgIFx0XHRcdGlmIChyb3c9PWZlYXR1cmUuc2NvcmUtMSAmJiBmZWF0dXJlLmRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRyZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgIFx0XHRcdH1cclxuICAgICAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0fVxyXG5cclxuICAgIFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxIZWlnaHQsY3R4KXtcclxuXHRcdGxldCB5ID0gdGhpcy50b3ArNTtcclxuXHRcdGN0eC5mb250PVwiMTJweCBBcmlhbFwiO1xyXG5cdFx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Zm9yIChsZXQgdGV4dCBvZiB0aGlzLmNvbmZpZy5kZXNlcV9sYWJlbHMpe1xyXG5cdFx0XHRcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsMyx5KTtcclxuXHRcdFx0eSs9dGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCsxO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG59XHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3NbXCJkZXNlcV90cmFja1wiXT1ERVNlcVRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1tcImRlc2VxX3RyYWNrXCJdPXtcclxuXHRcImNsYXNzXCI6REVTZXFUcmFja1xyXG59XHJcblxyXG5leHBvcnQge0RFU2VxVHJhY2t9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBOzs7O0FBckRBO0FBQ0E7QUFzREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lanceotron/src/deseq_track.js\n");

/***/ }),

/***/ "./lanceotron/src/lanceotron_tracks_index.js":
/*!***************************************************!*\
  !*** ./lanceotron/src/lanceotron_tracks_index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _panel = __webpack_require__(/*! ../../../MLVPanel/src/panel.js */ \"../MLVPanel/src/panel.js\");\n\nvar _simple_browser = __webpack_require__(/*! ../../../MLVPanel/src/extra/simple_browser.js */ \"../MLVPanel/src/extra/simple_browser.js\");\n\n__webpack_require__(/*! ./custom_annotation_track.js */ \"./lanceotron/src/custom_annotation_track.js\");\n\n__webpack_require__(/*! ./capture_compare_track.js */ \"./lanceotron/src/capture_compare_track.js\");\n\n__webpack_require__(/*! ./mlv_deseq_track.js */ \"./lanceotron/src/mlv_deseq_track.js\");\n\n__webpack_require__(/*! ./deseq_track.js */ \"./lanceotron/src/deseq_track.js\");\n\n__webpack_require__(/*! ./mlv_peaky_track.js */ \"./lanceotron/src/mlv_peaky_track.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/extra/ucsc_track.js */ \"../MLVPanel/src/extra/ucsc_track.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/extra/tiled_image_track.js */ \"../MLVPanel/src/extra/tiled_image_track.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/css/mlv_panel.css */ \"../MLVPanel/css/mlv_panel.css\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/bam_track.js */ \"../MLVPanel/src/bam_track.js\");\n\nwindow.MLVPanel = _panel.MLVPanel;\nwindow.SimpleBrowser = _simple_browser.SimpleBrowser;\nwindow.SinglePanelBrowser = _simple_browser.SinglePanelBrowser;\nwindow.MLVTrack = _tracks.MLVTrack;\nwindow.MLVBedTrack = _tracks.MLVBedTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9sYW5jZW90cm9uX3RyYWNrc19pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9sYW5jZW90cm9uX3RyYWNrc19pbmRleC5qcz8xMjFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWUGFuZWx9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvcGFuZWwuanNcIjtcclxuaW1wb3J0IHtTaW1wbGVCcm93c2VyLFNpbmdsZVBhbmVsQnJvd3Nlcn0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9leHRyYS9zaW1wbGVfYnJvd3Nlci5qc1wiO1xyXG5pbXBvcnQgXCIuL2N1c3RvbV9hbm5vdGF0aW9uX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vY2FwdHVyZV9jb21wYXJlX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vbWx2X2Rlc2VxX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vZGVzZXFfdHJhY2suanNcIjtcclxuaW1wb3J0IFwiLi9tbHZfcGVha3lfdHJhY2suanNcIjtcclxuaW1wb3J0IHtNTFZUcmFjayxNTFZCZWRUcmFja30gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy90cmFja3MuanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3RpbGVkX2ltYWdlX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4uLy4uLy4uL01MVlBhbmVsL2Nzcy9tbHZfcGFuZWwuY3NzXCI7XHJcbmltcG9ydCBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9iYW1fdHJhY2suanNcIjtcclxuXHJcbndpbmRvdy5NTFZQYW5lbD1NTFZQYW5lbDtcclxud2luZG93LlNpbXBsZUJyb3dzZXI9U2ltcGxlQnJvd3Nlcjtcclxud2luZG93LlNpbmdsZVBhbmVsQnJvd3NlciA9IFNpbmdsZVBhbmVsQnJvd3Nlcjtcclxud2luZG93Lk1MVlRyYWNrPU1MVlRyYWNrO1xyXG53aW5kb3cuTUxWQmVkVHJhY2sgPSBNTFZCZWRUcmFjazsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lanceotron/src/lanceotron_tracks_index.js\n");

/***/ }),

/***/ "./lanceotron/src/mlv_deseq_track.js":
/*!*******************************************!*\
  !*** ./lanceotron/src/mlv_deseq_track.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.MLVDESeqTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature2 = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getDecodeFunction(sample_size) {\n\tvar max = sample_size * 3;\n\treturn function (tokens, feature) {\n\t\tfeature.data = [];\n\t\tfor (var i = 0; i < max; i += 3) {\n\t\t\tfeature.data.push([parseFloat(tokens[i]), parseFloat(tokens[i + 1]), parseFloat(tokens[i + 2])]);\n\t\t}\n\t};\n}\n\nvar MLVDESeqTrack = function (_MLVBedTrack) {\n\t_inherits(MLVDESeqTrack, _MLVBedTrack);\n\n\tfunction MLVDESeqTrack(config) {\n\t\t_classCallCheck(this, MLVDESeqTrack);\n\n\t\tconfig.format = \"feature\";\n\t\tif (!config.colors) {\n\t\t\tconfig.colors = [\"#FF0000\", \"#0000FF\", \"#008000\"];\n\t\t}\n\t\tif (!config.pvalue_cutoff) {\n\t\t\tconfig.pvalue_cutoff = 0.05;\n\t\t}\n\t\treturn _possibleConstructorReturn(this, (MLVDESeqTrack.__proto__ || Object.getPrototypeOf(MLVDESeqTrack)).call(this, config));\n\t}\n\n\t_createClass(MLVDESeqTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tif (this.config.url && this.config.url.endsWith(\".gz\")) {\n\t\t\t\tthis.feature_source = new _feature2.TabixBedFeatureSource(this.config, getDecodeFunction(this.config.samples.length));\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature2.BigBedFeatureSource(this.config, getDecodeFunction(this.config.samples.length));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tvar pval_div = $(\"<div class='t-d-div'></div>\").append(\"<label>pValue:</label>\").appendTo(dialog.div);\n\t\t\tdialog.pval_slider = $(\"<div>\").slider({\n\t\t\t\tmax: 1,\n\t\t\t\tmin: 0,\n\t\t\t\tstep: 0.01,\n\t\t\t\tvalue: dialog.config.pvalue_cutoff,\n\t\t\t\tslide: function slide(e, ui) {\n\t\t\t\t\tdialog.config.pvalue_cutoff = ui.value;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"pvalue_cutoff\", ui.value);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t\tdialog.pval_input.val(ui.value);\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" }).appendTo(pval_div);\n\t\t\tdialog.pval_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar y = dialog.pval_input.val();\n\t\t\t\ty = parseFloat(y);\n\t\t\t\tif (isNaN(y) || y < 0 || y > 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar s = dialog.pval_slider;\n\n\t\t\t\ts.slider(\"option\", \"value\", y);\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"pvalue_cutoff\", y);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).width(50).val(dialog.config.pvalue_cutoff).appendTo(pval_div);\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar features = options.features;\n\t\t\tvar pval = this.config.pvalue_cutoff;\n\n\t\t\tvar top = options.top;\n\t\t\tvar bot = parseInt(top) + parseInt(this.config.height);\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bot;\n\t\t\tvar ctx = options.context;\n\t\t\tvar colors = this.config.colors;\n\t\t\tvar y_max = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tvar wig_height = this.config.height;\n\t\t\tvar s_s = this.config.samples.length;\n\t\t\tvar count = 0;\n\t\t\tvar drawn = 0;\n\n\t\t\tvar display_features = [];\n\t\t\tthis.max_y_vals = [0, 0, 0];\n\t\t\tthis.min_y_vals = [0, 0, 0];\n\t\t\t//first parse collecting info\n\t\t\tfor (var x = 0; x < features.length; x++) {\n\t\t\t\tvar feature = features[x];\n\n\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\tif (x_pos > count) {\n\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\tdrawn++;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlen = len / options.bpPerPixel;\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tvar t_y = [];\n\t\t\t\tvar filtered_vals = 0;\n\t\t\t\tvar disp_feature = { x_pos: x_pos, len: len, y_vals: [], pvals: [] };\n\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\tif (this.filter_function) {\n\t\t\t\t\t\tfeature.id = feature.data[i][0];\n\t\t\t\t\t\tif (!this.filter_function(feature)) {\n\t\t\t\t\t\t\tfiltered_vals++;\n\t\t\t\t\t\t\tdisp_feature.y_vals.push(false);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar y_val = feature.data[i][1];\n\n\t\t\t\t\tif (y_val > this.max_y_vals[i]) {\n\t\t\t\t\t\tthis.max_y_vals[i] = y_val;\n\t\t\t\t\t} else if (y_val < this.min_y_vals[i]) {\n\t\t\t\t\t\tthis.min_y_vals[i] = y_val;\n\t\t\t\t\t}\n\t\t\t\t\tdisp_feature.y_vals.push(y_val);\n\t\t\t\t\tdisp_feature.pvals.push(feature.data[i][2]);\n\t\t\t\t}\n\t\t\t\tif (filtered_vals !== s_s) {\n\t\t\t\t\tdisplay_features.push(disp_feature);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.centers = [];\n\t\t\tvar y_tops = [];\n\t\t\tvar scale_factors = [];\n\t\t\tvar each = wig_height / s_s;\n\t\t\tfor (var _i = 0; _i < s_s; _i++) {\n\t\t\t\tvar center = this.max_y_vals[_i] / (this.max_y_vals[_i] - this.min_y_vals[_i]) * each + _i * each;\n\t\t\t\tthis.centers.push(center + top);\n\t\t\t\ty_tops.push(top + each * _i);\n\t\t\t\tscale_factors.push(each / (this.max_y_vals[_i] - this.min_y_vals[_i]));\n\t\t\t}\n\t\t\t//ctx.fillStyle=colors[i];\n\t\t\t//ctx.strokeStyle=colors[i];\n\t\t\t//ctx.globalAlpha=0.4;\n\t\t\tctx.globalAlpha = 1.0;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = display_features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar _feature = _step.value;\n\n\n\t\t\t\t\tfor (var _i2 = 0; _i2 < s_s; _i2++) {\n\t\t\t\t\t\tvar _y_val = _feature.y_vals[_i2];\n\t\t\t\t\t\tif (_y_val === false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_y_val = _y_val * scale_factors[_i2];\n\t\t\t\t\t\tctx.fillStyle = this.colorScale(_feature.pvals[_i2]);\n\t\t\t\t\t\tif (_y_val > 0) {\n\t\t\t\t\t\t\tvar y_pos = this.centers[_i2] - _y_val;\n\t\t\t\t\t\t\tvar color = this.config.sample_colors[_i2][0];\n\t\t\t\t\t\t\tif (_feature.pvals[_i2] > pval) {\n\t\t\t\t\t\t\t\tcolor = \"lightgray\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\t\t\tctx.fillRect(_feature.x_pos - _feature.len / 2, y_pos, _feature.len, _y_val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar _color = this.config.sample_colors[_i2][1];\n\t\t\t\t\t\t\tif (_feature.pvals[_i2] > pval) {\n\t\t\t\t\t\t\t\t_color = \"lightgray\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillStyle = _color;\n\t\t\t\t\t\t\tctx.fillRect(_feature.x_pos - _feature.len / 2, this.centers[_i2], _feature.len, -_y_val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bot;\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx, offset) {\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tif (featureList[0]) {\n\t\t\t\tvar p = ctx.getImageData(coord.x, coord.y + offset, 1, 1).data;\n\t\t\t\tif (p[0] === 0 && p[1] === 0 && p[2] === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar feature = featureList[0];\n\t\t\t\tvar each = this.config.height / this.config.samples.length;\n\t\t\t\tvar sample = Math.floor((coord.y - this.top) / each);\n\t\t\t\tvar id = feature.data[sample][0];\n\t\t\t\tfeature.id = id;\n\t\t\t\treturn feature;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"colorScale\",\n\t\tvalue: function colorScale(val, max) {\n\t\t\tvar perc = val / 40 * 100;\n\t\t\tperc = perc > 100 ? 100 : perc;\n\t\t\tvar r,\n\t\t\t    g,\n\t\t\t    b = 0;\n\t\t\tif (perc < 50) {\n\t\t\t\tg = 255;\n\t\t\t\tr = Math.round(5.1 * perc);\n\t\t\t} else {\n\t\t\t\tr = 255;\n\t\t\t\tg = Math.round(510 - 5.10 * perc);\n\t\t\t}\n\t\t\tvar h = r * 0x10000 + g * 0x100 + b * 0x1;\n\t\t\treturn '#' + ('000000' + h.toString(16)).slice(-6);\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tvar bot = this.bottom;\n\t\t\tvar top = this.top;\n\t\t\tvar each = (bot - top) / this.config.samples.length;\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\t\t\tfor (var x = 0; x < this.config.samples.length; x++) {\n\t\t\t\tvar y_pos = top + x * each;\n\t\t\t\tctx.moveTo(0, y_pos);\n\t\t\t\tctx.lineTo(20, y_pos);\n\t\t\t\tctx.textBaseline = \"top\";\n\t\t\t\tctx.fillText(this.max_y_vals[x].toFixed(2), 20, y_pos);\n\n\t\t\t\tctx.moveTo(0, this.centers[x]);\n\t\t\t\tctx.lineTo(20, this.centers[x]);\n\t\t\t\tctx.textBaseLine = \"middle\";\n\t\t\t\tctx.fillText(this.config.samples[x], 3, y_pos + each / 2);\n\n\t\t\t\ty_pos = y_pos + each;\n\t\t\t\tctx.moveTo(0, y_pos);\n\t\t\t\tctx.lineTo(20, y_pos);\n\t\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\t\tctx.fillText(this.min_y_vals[x], 20, y_pos);\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t}]);\n\n\treturn MLVDESeqTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_deseq_track\"] = {\n\t\"class\": MLVDESeqTrack\n};\n\nexports.MLVDESeqTrack = MLVDESeqTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9tbHZfZGVzZXFfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvbWx2X2Rlc2VxX3RyYWNrLmpzPzBjMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERlY29kZUZ1bmN0aW9uKHNhbXBsZV9zaXplKXtcclxuXHRsZXQgbWF4ID0gc2FtcGxlX3NpemUqM1xyXG5cdHJldHVybiBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0XHRmZWF0dXJlLmRhdGE9W107XHJcblx0XHRmb3IgKGxldCBpPTA7aTxtYXg7aSs9Myl7XHJcblx0XHRcdGZlYXR1cmUuZGF0YS5wdXNoKFtwYXJzZUZsb2F0KHRva2Vuc1tpXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsxXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsyXSldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIE1MVkRFU2VxVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcbiAgICBcdGNvbmZpZy5mb3JtYXQ9XCJmZWF0dXJlXCI7XHJcbiAgICBcdGlmICghY29uZmlnLmNvbG9ycyl7XHJcbiAgICBcdFx0Y29uZmlnLmNvbG9ycz1bXCIjRkYwMDAwXCIsXCIjMDAwMEZGXCIsXCIjMDA4MDAwXCJdXHJcbiAgICBcdH1cclxuICAgIFx0aWYgKCFjb25maWcucHZhbHVlX2N1dG9mZil7XHJcbiAgICBcdFx0Y29uZmlnLnB2YWx1ZV9jdXRvZmY9MC4wNTtcclxuICAgIFx0fVxyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcudXJsICYmIHRoaXMuY29uZmlnLnVybC5lbmRzV2l0aChcIi5nelwiKSl7XHJcblx0XHRcdHRoaXMuZmVhdHVyZV9zb3VyY2UgPSBuZXcgVGFiaXhCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGdldERlY29kZUZ1bmN0aW9uKHRoaXMuY29uZmlnLnNhbXBsZXMubGVuZ3RoKSk7XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZ2V0RGVjb2RlRnVuY3Rpb24odGhpcy5jb25maWcuc2FtcGxlcy5sZW5ndGgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGlhbG9nKXtcclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGRpYWxvZy5kaXYuZW1wdHkoKTtcclxuXHRcdFxyXG5cdFx0bGV0IGhlaWdodF9kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuXHJcblx0XHRoZWlnaHRfZGl2LmFwcGVuZChcIjxsYWJlbD5oZWlnaHQ6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcblxyXG5cdFx0bGV0IGhlaWdodF9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG5cdFx0XHRtaW46IDEwLFxyXG5cdFx0XHRtYXg6IDUwMCxcclxuXHRcdFx0dmFsdWU6ZGlhbG9nLmNvbmZpZy5oZWlnaHQsXHJcblx0XHRcdHNsaWRlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG5cdFx0XHRcdGRpYWxvZy5jb25maWcuaGVpZ2h0PSB1aS52YWx1ZTtcclxuXHRcdFx0XHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcImhlaWdodFwiLGRpYWxvZy5jb25maWcuaGVpZ2h0KTtcclxuXHRcdFx0XHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9KS5jc3Moe1wibWFyZ2luXCI6XCI1cHggM3B4XCJ9KTtcclxuXHRcdGhlaWdodF9zbGlkZXIuYXBwZW5kVG8oaGVpZ2h0X2Rpdik7XHJcblxyXG4gICAgICAgIGxldCBwdmFsX2Rpdj0kKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5wVmFsdWU6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcbiAgICAgICAgZGlhbG9nLnB2YWxfc2xpZGVyPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG4gICAgICAgXHRcdG1heDoxLFxyXG4gICAgICAgXHRcdG1pbjowLFxyXG4gICAgICAgXHRcdHN0ZXA6MC4wMSxcclxuICAgICAgIFx0XHR2YWx1ZTpkaWFsb2cuY29uZmlnLnB2YWx1ZV9jdXRvZmYsXHJcbiAgICAgICBcdFx0c2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgXHRcdGRpYWxvZy5jb25maWcucHZhbHVlX2N1dG9mZj11aS52YWx1ZVxyXG4gICAgICAgICAgIFx0XHRpZiAoZGlhbG9nLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJwdmFsdWVfY3V0b2ZmXCIsdWkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgXHRcdH1cclxuICAgICAgICAgICBcdFx0ZGlhbG9nLnB2YWxfaW5wdXQudmFsKHVpLnZhbHVlKVxyXG4gICAgICAgXHRcdH0gXHJcbiAgICBcdH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pLmFwcGVuZFRvKHB2YWxfZGl2KTtcclxuICAgIFx0ZGlhbG9nLnB2YWxfaW5wdXQ9JChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1kaWFsb2cucHZhbF9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHk9cGFyc2VGbG9hdCh5KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTih5KSAgfHwgeTwwIHx8IHk+MSl7XHJcbiAgICAgICAgICAgICAgICBcdHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzID0gZGlhbG9nLnB2YWxfc2xpZGVyO1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzLnNsaWRlcihcIm9wdGlvblwiLFwidmFsdWVcIix5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcInB2YWx1ZV9jdXRvZmZcIix5KTtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgIFx0XHR9XHJcbiAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pLndpZHRoKDUwKS52YWwoZGlhbG9nLmNvbmZpZy5wdmFsdWVfY3V0b2ZmKS5hcHBlbmRUbyhwdmFsX2Rpdik7XHJcbiAgICAgICAgICBcclxuXHRcdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKXtcclxuXHRcdGxldCBmZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XHJcblx0XHRsZXQgcHZhbD0gdGhpcy5jb25maWcucHZhbHVlX2N1dG9mZjtcclxuXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0bGV0IHRvcCA9IG9wdGlvbnMudG9wXHJcblx0XHRsZXQgYm90ID1wYXJzZUludCh0b3ApK3BhcnNlSW50KHRoaXMuY29uZmlnLmhlaWdodClcclxuXHRcdHRoaXMudG9wPXRvcDtcclxuXHRcdHRoaXMuYm90dG9tPWJvdDtcclxuXHRcdGxldCBjdHg9b3B0aW9ucy5jb250ZXh0O1xyXG5cdFx0bGV0IGNvbG9ycz0gdGhpcy5jb25maWcuY29sb3JzXHJcblx0XHRsZXQgeV9tYXggPXRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRsZXQgd2lnX2hlaWdodCA9IHRoaXMuY29uZmlnLmhlaWdodFxyXG5cdFx0bGV0IHNfcyA9IHRoaXMuY29uZmlnLnNhbXBsZXMubGVuZ3RoO1xyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgZHJhd249MDtcclxuXHJcblx0XHRsZXQgZGlzcGxheV9mZWF0dXJlcz1bXTtcclxuXHRcdHRoaXMubWF4X3lfdmFscz1bMCwwLDBdXHJcblx0XHR0aGlzLm1pbl95X3ZhbHM9WzAsMCwwXVxyXG5cdFx0Ly9maXJzdCBwYXJzZSBjb2xsZWN0aW5nIGluZm9cclxuXHRcdGZvciAobGV0IHg9MDt4PGZlYXR1cmVzLmxlbmd0aDt4Kyspe1xyXG5cdFx0XHRsZXQgZmVhdHVyZSA9ZmVhdHVyZXNbeF07XHJcblx0XHRcclxuXHRcdFx0bGV0IGxlbiA9IGZlYXR1cmUuZW5kLWZlYXR1cmUuc3RhcnRcclxuXHRcdFx0bGV0IHhfcG9zID0gKGZlYXR1cmUuc3RhcnQrKGxlbi8yKS1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHRcdFx0aWYgKHhfcG9zPmNvdW50KXtcclxuXHRcdFx0XHRjb3VudD1NYXRoLmZsb29yKHhfcG9zKSsxO1xyXG5cdFx0XHRcdGRyYXduKys7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZW4gPSBsZW4vb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRpZiAobGVuPDEpe1xyXG5cdFx0XHRcdGxlbiA9IDE7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHRfeT1bXTtcclxuXHRcdFx0bGV0IGZpbHRlcmVkX3ZhbHM9MDtcclxuXHRcdFx0bGV0IGRpc3BfZmVhdHVyZT17eF9wb3M6eF9wb3MsbGVuOmxlbix5X3ZhbHM6W10scHZhbHM6W119XHJcblx0XHRcdGZvciAobGV0IGk9MDtpPHNfcztpKyspe1xyXG5cdFx0XHRcdGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbil7XHJcblx0XHRcdFx0XHRmZWF0dXJlLmlkPWZlYXR1cmUuZGF0YVtpXVswXTtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5maWx0ZXJfZnVuY3Rpb24oZmVhdHVyZSkpe1xyXG5cdFx0XHRcdFx0XHRmaWx0ZXJlZF92YWxzKys7XHJcblx0XHRcdFx0XHRcdGRpc3BfZmVhdHVyZS55X3ZhbHMucHVzaChmYWxzZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IHlfdmFsPSBmZWF0dXJlLmRhdGFbaV1bMV07XHJcblx0XHRcdFxyXG5cdFx0XHRcdGlmICh5X3ZhbD50aGlzLm1heF95X3ZhbHNbaV0pe1xyXG5cdFx0XHRcdFx0dGhpcy5tYXhfeV92YWxzW2ldPXlfdmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh5X3ZhbDx0aGlzLm1pbl95X3ZhbHNbaV0pe1xyXG5cdFx0XHRcdFx0dGhpcy5taW5feV92YWxzW2ldPXlfdmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkaXNwX2ZlYXR1cmUueV92YWxzLnB1c2goeV92YWwpO1xyXG5cdFx0XHRcdGRpc3BfZmVhdHVyZS5wdmFscy5wdXNoKGZlYXR1cmUuZGF0YVtpXVsyXSlcclxuXHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGZpbHRlcmVkX3ZhbHMhPT1zX3Mpe1xyXG5cdFx0XHRcdGRpc3BsYXlfZmVhdHVyZXMucHVzaChkaXNwX2ZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcclxuXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcclxuXHRcdHRoaXMuY2VudGVycz1bXTtcclxuXHRcdGxldCB5X3RvcHM9W107XHJcblx0XHRsZXQgc2NhbGVfZmFjdG9ycz1bXTtcclxuXHRcdGxldCBlYWNoID0gd2lnX2hlaWdodC9zX3M7XHJcblx0XHRmb3IgKGxldCBpPTA7aTxzX3M7aSsrKXtcclxuXHRcdFx0bGV0IGNlbnRlcj0oKHRoaXMubWF4X3lfdmFsc1tpXS8odGhpcy5tYXhfeV92YWxzW2ldLXRoaXMubWluX3lfdmFsc1tpXSkpKmVhY2gpKyhpKmVhY2gpO1xyXG5cdFx0XHR0aGlzLmNlbnRlcnMucHVzaChjZW50ZXIrdG9wKTtcclxuXHRcdFx0eV90b3BzLnB1c2godG9wKyhlYWNoKmkpKTtcclxuXHRcdFx0c2NhbGVfZmFjdG9ycy5wdXNoKGVhY2gvKHRoaXMubWF4X3lfdmFsc1tpXS10aGlzLm1pbl95X3ZhbHNbaV0pKTtcclxuXHRcdH1cclxuXHRcdC8vY3R4LmZpbGxTdHlsZT1jb2xvcnNbaV07XHJcblx0XHQvL2N0eC5zdHJva2VTdHlsZT1jb2xvcnNbaV07XHJcblx0XHQvL2N0eC5nbG9iYWxBbHBoYT0wLjQ7XHJcblx0XHRjdHguZ2xvYmFsQWxwaGE9MS4wO1xyXG5cdFx0Zm9yIChsZXQgZmVhdHVyZSBvZiBkaXNwbGF5X2ZlYXR1cmVzKXtcclxuXHRcdFx0XHJcblx0XHRcdGZvciAobGV0IGk9MDtpPHNfcztpKyspe1xyXG5cdFx0XHRcdGxldCB5X3ZhbD0gZmVhdHVyZS55X3ZhbHNbaV07XHJcblx0XHRcdFx0aWYgKHlfdmFsPT09ZmFsc2Upe1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHlfdmFsPXlfdmFsKnNjYWxlX2ZhY3RvcnNbaV07XHJcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZT10aGlzLmNvbG9yU2NhbGUoZmVhdHVyZS5wdmFsc1tpXSlcclxuXHRcdFx0XHRpZiAoeV92YWw+MCl7XHJcblx0XHRcdFx0XHRsZXQgeV9wb3MgPXRoaXMuY2VudGVyc1tpXS15X3ZhbDtcclxuXHRcdFx0XHRcdGxldCBjb2xvciA9IHRoaXMuY29uZmlnLnNhbXBsZV9jb2xvcnNbaV1bMF07XHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS5wdmFsc1tpXT5wdmFsKXtcclxuXHRcdFx0XHRcdFx0Y29sb3I9XCJsaWdodGdyYXlcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9Y29sb3I7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoZmVhdHVyZS54X3Bvcy0oZmVhdHVyZS5sZW4vMikseV9wb3MsZmVhdHVyZS5sZW4seV92YWwpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdGxldCBjb2xvciA9IHRoaXMuY29uZmlnLnNhbXBsZV9jb2xvcnNbaV1bMV07XHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS5wdmFsc1tpXT5wdmFsKXtcclxuXHRcdFx0XHRcdFx0Y29sb3I9XCJsaWdodGdyYXlcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGU9Y29sb3I7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoZmVhdHVyZS54X3Bvcy0oZmVhdHVyZS5sZW4vMiksdGhpcy5jZW50ZXJzW2ldLGZlYXR1cmUubGVuLC15X3ZhbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHJldHVybiBib3RcclxuXHRcdFx0XHRcclxuXHR9XHJcblxyXG5cdGdldEZlYXR1cmVBdChnZW5vbWljTG9jYXRpb24sIGNociwgY29vcmQsIGJwUGVyUGl4ZWwsY3R4LG9mZnNldCl7XHJcblx0XHRcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMiAqIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgbGV0IGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKVxyXG5cdFx0aWYgKGZlYXR1cmVMaXN0WzBdKXtcclxuXHRcdFx0bGV0IHAgPSBjdHguZ2V0SW1hZ2VEYXRhKGNvb3JkLngsIGNvb3JkLnkrb2Zmc2V0LCAxLCAxKS5kYXRhO1xyXG5cdFx0XHRpZihwWzBdPT09MCAmJiBwWzFdPT09MCAmJiBwWzJdPT09MCl7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGZlYXR1cmUgPSBmZWF0dXJlTGlzdFswXTtcclxuXHRcdFx0bGV0IGVhY2ggPSB0aGlzLmNvbmZpZy5oZWlnaHQvdGhpcy5jb25maWcuc2FtcGxlcy5sZW5ndGg7XHJcblx0XHRcdGxldCBzYW1wbGUgPSBNYXRoLmZsb29yKChjb29yZC55LXRoaXMudG9wKS9lYWNoKTtcclxuXHRcdFx0bGV0IGlkID1mZWF0dXJlLmRhdGFbc2FtcGxlXVswXTtcclxuXHRcdFx0ZmVhdHVyZS5pZD1pZFxyXG5cdFx0XHRyZXR1cm4gZmVhdHVyZTtcclxuXHJcblxyXG5cclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Y29sb3JTY2FsZSh2YWwsbWF4KXtcclxuXHRcdGxldCBwZXJjID0odmFsLzQwKSoxMDA7XHJcblx0XHRwZXJjPXBlcmM+MTAwPzEwMDpwZXJjO1xyXG5cdHZhciByLCBnLCBiID0gMDtcclxuXHRpZihwZXJjIDwgNTApe1xyXG5cdFx0ZyA9IDI1NTtcclxuXHRcdHIgPSBNYXRoLnJvdW5kKDUuMSAqIHBlcmMpO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHIgPSAyNTU7XHJcblx0XHRnID0gTWF0aC5yb3VuZCg1MTAgLSA1LjEwICogcGVyYyk7XHJcblx0fVxyXG5cdHZhciBoID0gciAqIDB4MTAwMDAgKyBnICogMHgxMDAgKyBiICogMHgxO1xyXG5cdHJldHVybiAnIycgKyAoJzAwMDAwMCcgKyBoLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpO1xyXG5cclxuXHR9XHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGxldCBib3Q9IHRoaXMuYm90dG9tO1xyXG5cdFx0bGV0IHRvcCA9IHRoaXMudG9wO1xyXG5cdFx0bGV0IGVhY2ggPSAoYm90LXRvcCkvdGhpcy5jb25maWcuc2FtcGxlcy5sZW5ndGg7XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LnJlY3QoMCx0b3AsMTIwLGJvdC10b3ApO1xyXG5cdFx0Y3R4LmNsaXAoKTtcclxuXHRcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdGZvciAobGV0IHg9MDt4PHRoaXMuY29uZmlnLnNhbXBsZXMubGVuZ3RoO3grKyl7XHJcblx0XHRcdGxldCB5X3BvcyA9IHRvcCsoeCplYWNoKTtcclxuXHRcdFx0Y3R4Lm1vdmVUbygwLHlfcG9zKTtcclxuXHRcdFx0Y3R4LmxpbmVUbygyMCx5X3Bvcyk7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWF4X3lfdmFsc1t4XS50b0ZpeGVkKDIpLDIwLHlfcG9zKTtcclxuXHJcblx0XHRcdGN0eC5tb3ZlVG8oMCx0aGlzLmNlbnRlcnNbeF0pO1xyXG5cdFx0XHRjdHgubGluZVRvKDIwLHRoaXMuY2VudGVyc1t4XSk7XHJcblx0XHRcdGN0eC50ZXh0QmFzZUxpbmU9XCJtaWRkbGVcIlxyXG5cdFx0XHRjdHguZmlsbFRleHQodGhpcy5jb25maWcuc2FtcGxlc1t4XSwzLHlfcG9zKyhlYWNoLzIpKTtcclxuXHJcblx0XHRcdHlfcG9zPXlfcG9zK2VhY2g7XHJcblx0XHRcdGN0eC5tb3ZlVG8oMCx5X3Bvcyk7XHJcblx0XHRcdGN0eC5saW5lVG8oMjAseV9wb3MpO1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiXHJcblx0XHRcdGN0eC5maWxsVGV4dCh0aGlzLm1pbl95X3ZhbHNbeF0sMjAseV9wb3MpO1xyXG5cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHJcblxyXG5cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHJcblx0fVxyXG5cclxuXHRcclxufVxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJtbHZfZGVzZXFfdHJhY2tcIl09e1xyXG5cdFwiY2xhc3NcIjpNTFZERVNlcVRyYWNrXHJcbn1cclxuXHJcblxyXG5leHBvcnQge01MVkRFU2VxVHJhY2t9O1xyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUZBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFySEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdUhBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7QUFwU0E7QUFDQTtBQXdTQTtBQUNBO0FBREE7QUFDQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lanceotron/src/mlv_deseq_track.js\n");

/***/ }),

/***/ "./lanceotron/src/mlv_peaky_track.js":
/*!*******************************************!*\
  !*** ./lanceotron/src/mlv_peaky_track.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.MLVPeakyTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar decode_function = function decode_function(tokens, feature) {\n\tfeature.rjmcmc = parseFloat(tokens[0]);\n\tfeature.id = parseInt(tokens[1]);\n};\n\nvar MLVPeakyTrack = function (_MLVBedTrack) {\n\t_inherits(MLVPeakyTrack, _MLVBedTrack);\n\n\tfunction MLVPeakyTrack() {\n\t\t_classCallCheck(this, MLVPeakyTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVPeakyTrack.__proto__ || Object.getPrototypeOf(MLVPeakyTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVPeakyTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tvar url = this.config.url;\n\t\t\tif (url.endsWith(\".bb\") || url.endsWith(\".bigbed\")) {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, decode_function);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn _get(MLVPeakyTrack.prototype.__proto__ || Object.getPrototypeOf(MLVPeakyTrack.prototype), \"getFeatureAt\", this).call(this, genomicLocation, chr, coord, bpPerPixel, ctx);\n\t\t\t}\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tvar height = this.config.height - 12;\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = bot - (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tif (coord.y >= y_val && coord.y <= y_val + 5) {\n\t\t\t\t\t\treturn feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>Track Height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tvar sig_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\tsig_div.append(\"<label>Significance Level:</label>\").appendTo(dialog.div);\n\n\t\t\tthis.sig_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 0,\n\t\t\t\tmax: 1,\n\t\t\t\tstep: 0.01,\n\t\t\t\tvalue: dialog.config.sig_val,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.sig_val = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"sig_val\", dialog.config.sig_val);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\tself.sig_input.val(ui.value);\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\tthis.sig_slider.appendTo(sig_div);\n\t\t\tself.sig_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar sig = $(this).val();\n\t\t\t\tsig = parseFloat(sig);\n\t\t\t\tif (sig >= 0 && sig <= 1) {\n\t\t\t\t\tdialog.config.sig_val = sig;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"sig_val\", sig);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\tself.sig_slider.slider(\"option\", \"value\", sig);\n\t\t\t\t}\n\t\t\t}).appendTo(sig_div).width(40).val(self.config.sig_val);\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\n\t\t\t//ctx.save();\n\t\t\t//ctx.rect(0,top,120,this.bottom-this.top);\n\t\t\t//ctx.clip();\n\n\t\t\tvar sig_val = this.config.sig_val || this.config.sig_val === 0 ? this.config.sig_val : 0.1;\n\n\t\t\tvar bottom = this.bottom - 3;\n\t\t\tvar height = this.config.height / 2;\n\n\t\t\tvar sig_line_y = bottom - (sig_val - 0) / 1 * height;\n\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(sig_val, 20, sig_line_y - 2);\n\n\t\t\t//ctx.restore();\n\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\n\t\t\t/*if (!this.y_field){\r\n   \tsuper.drawFeatures(options);\r\n   \treturn;\r\n   */\n\t\t\tvar range = 1;\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\t\t\tvar sig_val = this.config.sig_val || this.config.sig_val === 0 ? this.config.sig_val : 0.1;\n\n\t\t\tthis.bottom = this.top + this.config.height;\n\t\t\tvar bottom = this.bottom - 3;\n\t\t\tvar height = this.config.height / 2;\n\t\t\tvar bottom2 = this.bottom - height - 3;\n\n\t\t\tvar count = 0;\n\t\t\tvar vp_pos = (this.config.viewpoint - options.bpStart) / options.bpPerPixel;\n\t\t\tvar sig_line_y = bottom - (sig_val - 0) / range * height;\n\t\t\tctx.moveTo(0, sig_line_y);\n\t\t\tctx.strokeStyle = \"gray\";\n\t\t\tctx.lineTo(options.pixelWidth, sig_line_y);\n\t\t\tctx.stroke();\n\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar feature = _step2.value;\n\n\t\t\t\t\tvar sig = feature.rjmcmc >= sig_val;\n\t\t\t\t\tif (this.filter_function && !this.filter_function(feature)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar x_pos = (feature.start - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\t/*if (x_pos>count){\r\n     count=Math.floor(x_pos)+1;\r\n     }\r\n     else{\r\n     continue;\r\n     }*/\n\n\t\t\t\t\tvar len = (feature.end - feature.start) / options.bpPerPixel;\n\n\t\t\t\t\tif (len < 2) {\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = (feature.rjmcmc - 0) / range * height;\n\n\t\t\t\t\tvar y_pos = bottom - y_val;\n\t\t\t\t\tvar color = sig ? \"red\" : \"gray\";\n\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(x_pos, y_pos, 3, 0, 2 * Math.PI, false);\n\t\t\t\t\tctx.fill();\n\n\t\t\t\t\t//remember any features drawn\n\n\t\t\t\t\t//draw the curve\n\n\t\t\t\t\tif (sig) {\n\t\t\t\t\t\tctx.moveTo(x_pos, bottom2);\n\t\t\t\t\t\tctx.bezierCurveTo(x_pos, bottom2 - height, vp_pos, bottom2 - height, vp_pos, bottom2);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\n\t\t\t\t\t//this.renderFeatureLabel(ctx, feature, x_pos, x_pos+len,y_pos , 0, options.pixelWidth);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn MLVPeakyTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_peaky_track\"] = {\n\t\"class\": MLVPeakyTrack\n};\nexports.MLVPeakyTrack = MLVPeakyTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9tbHZfcGVha3lfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvbWx2X3BlYWt5X3RyYWNrLmpzP2MzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtGZWF0dXJlU291cmNlLEJpZ0JlZEZlYXR1cmVTb3VyY2UsVGFiaXhCZWRGZWF0dXJlU291cmNlfSBmcm9tIFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanNcIjtcclxuaW1wb3J0IHtNTFZCZWRUcmFjayxNTFZUcmFja30gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy90cmFja3MuanNcIjtcclxuXHJcbmxldCBkZWNvZGVfZnVuY3Rpb249IGZ1bmN0aW9uKHRva2VucyxmZWF0dXJlKXtcclxuXHRmZWF0dXJlLnJqbWNtYz1wYXJzZUZsb2F0KHRva2Vuc1swXSk7XHJcblx0ZmVhdHVyZS5pZD0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxufTtcclxuXHJcblxyXG5jbGFzcyBNTFZQZWFreVRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdGxldCB1cmwgPSB0aGlzLmNvbmZpZy51cmw7XHJcblx0XHRpZiAodXJsLmVuZHNXaXRoKFwiLmJiXCIpIHx8IHVybC5lbmRzV2l0aChcIi5iaWdiZWRcIikpe1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IFRhYml4QmVkRmVhdHVyZVNvdXJjZSh0aGlzLmNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCl7XHJcblx0XHRpZiAoIXRoaXMueV9maWVsZCl7XHJcblx0XHRcdHJldHVybiBzdXBlci5nZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCk7XHJcblx0XHR9XHJcblx0XHRcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMiAqIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgbGV0IGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmNvbmZpZy5oZWlnaHQtMTI7XHJcblx0XHRsZXQgcmFuZ2UgPSB0aGlzLm1pbl9tYXhbMV0tdGhpcy5taW5fbWF4WzBdO1xyXG5cdFx0bGV0IGZpZWxkID0gdGhpcy55X2ZpZWxkLmZpZWxkO1xyXG5cdFx0bGV0IGJvdCA9dGhpcy5ib3R0b20tMTI7XHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIGZlYXR1cmVMaXN0KXtcclxuXHRcdFx0bGV0IGl0ZW0gPSB0aGlzLmRhdGFfdmlldy5nZXRJdGVtQnlJZChmZWF0dXJlLmlkKTtcclxuXHRcdFx0aWYgKCFpdGVtKXtcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPWJvdC0oKChpdGVtW2ZpZWxkXS10aGlzLm1pbl9tYXhbMF0pL3JhbmdlKSpoZWlnaHQpO1xyXG5cdFx0XHRpZiAoY29vcmQueSA+PXlfdmFsICYmIGNvb3JkLnk8PXlfdmFsKzUpe1xyXG5cdFx0XHRcdHJldHVybiBmZWF0dXJlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHRhZGRFeHRyYUNvbnRyb2xzKGRpYWxvZyl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHRkaWFsb2cuZGl2LmVtcHR5KCk7XHJcblx0XHRcclxuICAgIFx0XHRsZXQgaGVpZ2h0X2Rpdj0kKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpO1xyXG4gICAgICAgIFx0XHJcblx0XHRcdGhlaWdodF9kaXYuYXBwZW5kKFwiPGxhYmVsPlRyYWNrIEhlaWdodDo8L2xhYmVsPlwiKS5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoZWlnaHRfc2xpZGVyID0kKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgICAgICAgICAgIG1pbjogMTAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IDUwMCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOmRpYWxvZy5jb25maWcuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNvbmZpZy5oZWlnaHQ9IHVpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwiaGVpZ2h0XCIsZGlhbG9nLmNvbmZpZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgICAgICBoZWlnaHRfc2xpZGVyLmFwcGVuZFRvKGhlaWdodF9kaXYpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNpZ19kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuICAgICAgICBcdFxyXG5cdFx0XHRzaWdfZGl2LmFwcGVuZChcIjxsYWJlbD5TaWduaWZpY2FuY2UgTGV2ZWw6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2lnX3NsaWRlciA9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IDEsXHJcbiAgICAgICAgICAgICAgICBzdGVwOjAuMDEsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTpkaWFsb2cuY29uZmlnLnNpZ192YWwsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29uZmlnLnNpZ192YWw9IHVpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwic2lnX3ZhbFwiLGRpYWxvZy5jb25maWcuc2lnX3ZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2lnX2lucHV0LnZhbCh1aS52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgICAgICB0aGlzLnNpZ19zbGlkZXIuYXBwZW5kVG8oc2lnX2Rpdik7XHJcbiAgICAgICAgICAgIHNlbGYuc2lnX2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzaWc9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzaWc9cGFyc2VGbG9hdChzaWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZz49MCAmJiBzaWc8PTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jb25maWcuc2lnX3ZhbD0gc2lnO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwic2lnX3ZhbFwiLHNpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2lnX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2lnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSkuYXBwZW5kVG8oc2lnX2Rpdikud2lkdGgoNDApLnZhbChzZWxmLmNvbmZpZy5zaWdfdmFsKTtcclxuXHJcbiAgICAgICAgIFxyXG4gICBcclxuIFx0XHJcblx0XHRcdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxfaGVpZ2h0LGN0eCl7XHJcblx0XHJcblx0XHJcblx0XHQvL2N0eC5zYXZlKCk7XHJcblx0XHQvL2N0eC5yZWN0KDAsdG9wLDEyMCx0aGlzLmJvdHRvbS10aGlzLnRvcCk7XHJcblx0XHQvL2N0eC5jbGlwKCk7XHJcblxyXG5cdFx0bGV0IHNpZ192YWwgPSB0aGlzLmNvbmZpZy5zaWdfdmFsIHx8IHRoaXMuY29uZmlnLnNpZ192YWw9PT0wP3RoaXMuY29uZmlnLnNpZ192YWw6MC4xXHJcblxyXG5cdFxyXG5cclxuXHRcdFxyXG5cdFx0bGV0IGJvdHRvbSA9dGhpcy5ib3R0b20tM1xyXG5cdFx0bGV0IGhlaWdodCA9dGhpcy5jb25maWcuaGVpZ2h0LzI7XHJcblx0XHRcclxuXHJcblx0XHRcclxuXHRcdGxldCBzaWdfbGluZV95ID0gYm90dG9tLSgoKHNpZ192YWwtMCkvMSkqaGVpZ2h0KTtcclxuXHRcclxuXHRcclxuXHJcblx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCJcclxuXHRcdGN0eC5maWxsVGV4dChzaWdfdmFsLDIwLHNpZ19saW5lX3ktMik7XHJcblxyXG5cdFx0Ly9jdHgucmVzdG9yZSgpO1xyXG5cclxuXHRcclxuXHR9XHJcblxyXG5cclxuXHRkcmF3RmVhdHVyZXMob3B0aW9ucyl7XHJcblx0XHJcblx0XHQvKmlmICghdGhpcy55X2ZpZWxkKXtcclxuXHRcdFx0c3VwZXIuZHJhd0ZlYXR1cmVzKG9wdGlvbnMpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHQqL1xyXG5cdFx0bGV0IHJhbmdlID0gMTtcclxuXHRcdGxldCBjdHg9b3B0aW9ucy5jb250ZXh0O1xyXG5cdFx0dGhpcy50b3A9b3B0aW9ucy50b3A7XHJcblx0XHRsZXQgc2lnX3ZhbCA9IHRoaXMuY29uZmlnLnNpZ192YWwgfHwgdGhpcy5jb25maWcuc2lnX3ZhbD09PTA/dGhpcy5jb25maWcuc2lnX3ZhbDowLjFcclxuXHJcblx0XHJcblxyXG5cdFx0dGhpcy5ib3R0b209dGhpcy50b3ArdGhpcy5jb25maWcuaGVpZ2h0O1xyXG5cdFx0bGV0IGJvdHRvbSA9dGhpcy5ib3R0b20tM1xyXG5cdFx0bGV0IGhlaWdodCA9dGhpcy5jb25maWcuaGVpZ2h0LzI7XHJcblx0XHRsZXQgYm90dG9tMj0gdGhpcy5ib3R0b20taGVpZ2h0LTM7XHJcblxyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgdnBfcG9zID0gKHRoaXMuY29uZmlnLnZpZXdwb2ludC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHRcdGxldCBzaWdfbGluZV95ID0gYm90dG9tLSgoKHNpZ192YWwtMCkvcmFuZ2UpKmhlaWdodCk7XHJcblx0XHRjdHgubW92ZVRvKDAsc2lnX2xpbmVfeSk7XHJcblx0XHRjdHguc3Ryb2tlU3R5bGU9XCJncmF5XCI7XHJcblx0XHRjdHgubGluZVRvKG9wdGlvbnMucGl4ZWxXaWR0aCxzaWdfbGluZV95KTtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIG9wdGlvbnMuZmVhdHVyZXMpe1xyXG5cdFx0XHRsZXQgc2lnID0gZmVhdHVyZS5yam1jbWM+PXNpZ192YWw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZmVhdHVyZSkpe1xyXG4gICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9wb3MgPSAoZmVhdHVyZS5zdGFydC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuICAgICAgICAgICAgLyppZiAoeF9wb3M+Y291bnQpe1xyXG5cdFx0XHRcdGNvdW50PU1hdGguZmxvb3IoeF9wb3MpKzE7XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fSovXHJcblxyXG5cclxuXHRcdFx0bGV0IGxlbiA9IChmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobGVuPDIpe1xyXG5cdFx0XHRcdGxlbiA9IDI7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPSgoZmVhdHVyZS5yam1jbWMtMCkvcmFuZ2UpKmhlaWdodDtcclxuXHRcdFxyXG4gICAgXHRcdGxldCB5X3Bvcz1ib3R0b20teV92YWw7XHJcbiAgICBcdFx0bGV0IGNvbG9yICA9IHNpZz9cInJlZFwiOlwiZ3JheVwiXHJcblx0XHRcdGN0eC5maWxsU3R5bGU9Y29sb3I7XHJcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgXHRcdGN0eC5hcmMoeF9wb3MsIHlfcG9zLCAzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICBcdFx0Y3R4LmZpbGwoKVxyXG5cclxuICAgICAgXHRcdFxyXG5cdFx0XHQvL3JlbWVtYmVyIGFueSBmZWF0dXJlcyBkcmF3blxyXG5cdFx0XHRcclxuXHRcdFx0Ly9kcmF3IHRoZSBjdXJ2ZVxyXG5cclxuXHRcdFx0aWYgKHNpZyl7XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcyxib3R0b20yKTtcclxuXHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyh4X3Bvcyxib3R0b20yLWhlaWdodCx2cF9wb3MsYm90dG9tMi1oZWlnaHQsdnBfcG9zLGJvdHRvbTIpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG4gICAgXHJcblx0XHRcdC8vdGhpcy5yZW5kZXJGZWF0dXJlTGFiZWwoY3R4LCBmZWF0dXJlLCB4X3BvcywgeF9wb3MrbGVuLHlfcG9zICwgMCwgb3B0aW9ucy5waXhlbFdpZHRoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xyXG5cdH1cdFxyXG59XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcIm1sdl9wZWFreV90cmFja1wiXT17XHJcblx0XCJjbGFzc1wiOk1MVlBlYWt5VHJhY2tcclxufVxyXG5leHBvcnQge01MVlBlYWt5VHJhY2t9OyBcclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXVCQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQTBCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1RUE7QUFDQTs7OztBQXROQTtBQUNBO0FBd05BO0FBQ0E7QUFEQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lanceotron/src/mlv_peaky_track.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css":
/*!**********************************************************!*\
  !*** ./node_modules/css-loader!.Panel/css/mlv_panel.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../MLV/node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".mlv-track-legend{\\r\\n\\tposition:absolute !important;\\r\\n\\ttop:0px;\\r\\n\\tleft:calc(100% - 155px);\\r\\n\\tborder:0.5px solid black;\\r\\n\\tfont-size:14px;\\r\\n\\tz-index:90;\\r\\n}\\r\\n\\r\\n\\r\\n.mlv-track-legend span{\\r\\n\\tdisplay:inline-block;\\r\\n\\tcursor:pointer;\\r\\n\\tmargin-right:2px;\\r\\n}\\r\\n\\r\\n.mlv-track-legend li{\\r\\n\\twhite-space:nowrap;\\r\\n}\\r\\n\\r\\n.mlv-track-legend-text {\\r\\n\\twhite-space:nowrap;\\r\\n\\toverflow:hidden;\\r\\n\\ttext-overflow:ellipsis;\\r\\n\\twidth: 100px;\\r\\n}\\r\\n\\r\\n\\r\\n.mlv-track-dialog label {\\r\\n\\tfont-weight:bold;\\r\\n\\tmargin-bottom:4px;\\r\\n\\tmargin-top:0px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog input[type=checkbox] {\\r\\n\\theight: 17px;\\r\\n\\twidth: 17px;\\r\\n\\t vertical-align: bottom;\\r\\n  position: relative;\\r\\n  margin-left:2px;\\r\\n  margin-bottom:2px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog span{\\r\\n\\tmargin-right:4px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog .fas{\\r\\n\\tcursor:pointer;\\r\\n\\tfont-size:16px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog hr {\\r\\n\\tmargin-top:10px;\\r\\n\\tmargin-bottom:2px;\\r\\n\\r\\n}\\r\\n\\r\\n.add-track-dialog label{\\r\\n\\tdisplay:block;\\r\\n\\tfont-weight:bold;\\r\\n\\tmargin-top:5px;\\r\\n\\r\\n}\\r\\n\\r\\n.browser-menu-panel button{\\r\\n\\tpadding-top: 2px;\\r\\n    padding-bottom: 2px;\\r\\n    margin-left: 2px;\\r\\n    margin-right: 2px;\\r\\n\\r\\n}\\r\\n\\r\\n.browser-menu-panel{\\r\\n\\toverflow:hidden;\\r\\n\\twhite-space:nowrap;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9NTFZQYW5lbC9jc3MvbWx2X3BhbmVsLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uUGFuZWwvY3NzL21sdl9wYW5lbC5jc3M/YWY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vTUxWL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWx2LXRyYWNrLWxlZ2VuZHtcXHJcXG5cXHRwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O1xcclxcblxcdHRvcDowcHg7XFxyXFxuXFx0bGVmdDpjYWxjKDEwMCUgLSAxNTVweCk7XFxyXFxuXFx0Ym9yZGVyOjAuNXB4IHNvbGlkIGJsYWNrO1xcclxcblxcdGZvbnQtc2l6ZToxNHB4O1xcclxcblxcdHotaW5kZXg6OTA7XFxyXFxufVxcclxcblxcclxcblxcclxcbi5tbHYtdHJhY2stbGVnZW5kIHNwYW57XFxyXFxuXFx0ZGlzcGxheTppbmxpbmUtYmxvY2s7XFxyXFxuXFx0Y3Vyc29yOnBvaW50ZXI7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OjJweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1sdi10cmFjay1sZWdlbmQgbGl7XFxyXFxuXFx0d2hpdGUtc3BhY2U6bm93cmFwO1xcclxcbn1cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWxlZ2VuZC10ZXh0IHtcXHJcXG5cXHR3aGl0ZS1zcGFjZTpub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6aGlkZGVuO1xcclxcblxcdHRleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7XFxyXFxuXFx0d2lkdGg6IDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWRpYWxvZyBsYWJlbCB7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6Ym9sZDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOjRweDtcXHJcXG5cXHRtYXJnaW4tdG9wOjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1sdi10cmFjay1kaWFsb2cgaW5wdXRbdHlwZT1jaGVja2JveF0ge1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHR3aWR0aDogMTdweDtcXHJcXG5cXHQgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIG1hcmdpbi1sZWZ0OjJweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206MnB4O1xcclxcbn1cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWRpYWxvZyBzcGFue1xcclxcblxcdG1hcmdpbi1yaWdodDo0cHg7XFxyXFxufVxcclxcblxcclxcbi5tbHYtdHJhY2stZGlhbG9nIC5mYXN7XFxyXFxuXFx0Y3Vyc29yOnBvaW50ZXI7XFxyXFxuXFx0Zm9udC1zaXplOjE2cHg7XFxyXFxufVxcclxcblxcclxcbi5tbHYtdHJhY2stZGlhbG9nIGhyIHtcXHJcXG5cXHRtYXJnaW4tdG9wOjEwcHg7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbToycHg7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5hZGQtdHJhY2stZGlhbG9nIGxhYmVse1xcclxcblxcdGRpc3BsYXk6YmxvY2s7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6Ym9sZDtcXHJcXG5cXHRtYXJnaW4tdG9wOjVweDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLmJyb3dzZXItbWVudS1wYW5lbCBidXR0b257XFxyXFxuXFx0cGFkZGluZy10b3A6IDJweDtcXHJcXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5icm93c2VyLW1lbnUtcGFuZWx7XFxyXFxuXFx0b3ZlcmZsb3c6aGlkZGVuO1xcclxcblxcdHdoaXRlLXNwYWNlOm5vd3JhcDtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzPzRkYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n\t// get current location\n\tvar location = typeof window !== \"undefined\" && window.location;\n\n\tif (!location) {\n\t\tthrow new Error(\"fixUrls requires window.location\");\n\t}\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t\treturn css;\n\t}\n\n\tvar baseUrl = location.protocol + \"//\" + location.host;\n\tvar currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n This regular expression is just a way to recursively match brackets within\n a string.\n \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n    (  = Start a capturing group\n      (?:  = Start a non-capturing group\n          [^)(]  = Match anything that isn't a parentheses\n          |  = OR\n          \\(  = Match a start parentheses\n              (?:  = Start another non-capturing groups\n                  [^)(]+  = Match anything that isn't a parentheses\n                  |  = OR\n                  \\(  = Match a start parentheses\n                      [^)(]*  = Match anything that isn't a parentheses\n                  \\)  = Match a end parentheses\n              )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n  \\)  = Match a close parens\n \t /gi  = Get all matches, not the first.  Be case insensitive.\n  */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t}).replace(/^'(.*)'$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t});\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t\treturn fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t\t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanM/NmFmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ })

/******/ });