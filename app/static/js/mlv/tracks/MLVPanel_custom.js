/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lanceotron/src/lanceotron_tracks_index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../MLVPanel/css/mlv_panel.css":
/*!********************************!*\
  !*** .Panel/css/mlv_panel.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../MLV/node_modules/css-loader!./mlv_panel.css */ \"./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../MLV/node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvY3NzL21sdl9wYW5lbC5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLlBhbmVsL2Nzcy9tbHZfcGFuZWwuY3NzPzNmNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL01MVi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21sdl9wYW5lbC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL01MVi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9NTFYvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tbHZfcGFuZWwuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vTUxWL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbWx2X3BhbmVsLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/css/mlv_panel.css\n");

/***/ }),

/***/ "../MLVPanel/src/bam.js":
/*!*************************!*\
  !*** .Panel/src/bam.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Coverage = exports.CoverageMap = exports.bgzBlockSize = exports.PairedAlignment = exports.AlignmentContainer = exports.BamAlignment = exports.BamFilter = exports.BamSource = exports.BamReader = exports.loadBamIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"../MLVPanel/src/vendor/inflate.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _zlib_and_gzip = __webpack_require__(/*! ./vendor/zlib_and_gzip.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BAI_MAGIC = 21578050;\nvar TABIX_MAGIC = 21578324;\nvar MAX_HEADER_SIZE = 100000000; // IF the header is larger than this we can't read it !\nvar B_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * @param indexURL\r\n * @param config\r\n * @param tabix\r\n *\r\n * @returns a Promised for the bam or tabix index.  The fulfill function takes the index as an argument.\r\n */\nvar loadBamIndex = function loadBamIndex(indexURL, config, tabix) {\n\n    return new Promise(function (fulfill, reject) {\n\n        var genome = null;\n\n        _igvxhr.igvxhr.loadArrayBuffer(indexURL, {\n            headers: config.headers,\n            withCredentials: config.withCredentials\n        }).then(function (arrayBuffer) {\n\n            var indices = [],\n                magic,\n                nbin,\n                nintv,\n                nref,\n                parser,\n                blockMin = Number.MAX_VALUE,\n                blockMax = 0,\n                binIndex,\n                linearIndex,\n                binNumber,\n                cs,\n                ce,\n                b,\n                i,\n                ref,\n                sequenceIndexMap;\n\n            if (!arrayBuffer) {\n                fulfill(null);\n                return;\n            }\n\n            if (tabix) {\n                var inflate = new _zlib_and_gzip.Zlib.Gunzip(new Uint8Array(arrayBuffer));\n                arrayBuffer = inflate.decompress().buffer;\n            }\n\n            parser = new _bigwig.BinaryParser(new DataView(arrayBuffer));\n\n            magic = parser.getInt();\n\n            if (magic === BAI_MAGIC || tabix && magic === TABIX_MAGIC) {\n\n                nref = parser.getInt();\n\n                if (tabix) {\n                    // Tabix header parameters aren't used, but they must be read to advance the pointer\n                    var format = parser.getInt();\n                    var col_seq = parser.getInt();\n                    var col_beg = parser.getInt();\n                    var col_end = parser.getInt();\n                    var meta = parser.getInt();\n                    var skip = parser.getInt();\n                    var l_nm = parser.getInt();\n\n                    sequenceIndexMap = {};\n                    for (i = 0; i < nref; i++) {\n                        var seq_name = parser.getString();\n\n                        // Translate to \"official\" chr name.\n                        if (genome) seq_name = genome.getChromosomeName(seq_name);\n\n                        sequenceIndexMap[seq_name] = i;\n                    }\n                }\n\n                for (ref = 0; ref < nref; ++ref) {\n\n                    binIndex = {};\n                    linearIndex = [];\n\n                    nbin = parser.getInt();\n\n                    for (b = 0; b < nbin; ++b) {\n\n                        binNumber = parser.getInt();\n\n                        if (binNumber == 37450) {\n                            // This is a psuedo bin, not used but we have to consume the bytes\n                            nchnk = parser.getInt(); // # of chunks for this bin\n                            cs = parser.getVPointer(); // unmapped beg\n                            ce = parser.getVPointer(); // unmapped end\n                            var n_maped = parser.getLong();\n                            var nUnmapped = parser.getLong();\n                        } else {\n\n                            binIndex[binNumber] = [];\n                            var nchnk = parser.getInt(); // # of chunks for this bin\n\n                            for (i = 0; i < nchnk; i++) {\n                                cs = parser.getVPointer();\n                                ce = parser.getVPointer();\n                                if (cs && ce) {\n                                    if (cs.block < blockMin) {\n                                        blockMin = cs.block; // Block containing first alignment\n                                    }\n                                    if (ce.block > blockMax) {\n                                        blockMax = ce.block;\n                                    }\n                                    binIndex[binNumber].push([cs, ce]);\n                                }\n                            }\n                        }\n                    }\n\n                    nintv = parser.getInt();\n                    for (i = 0; i < nintv; i++) {\n                        cs = parser.getVPointer();\n                        linearIndex.push(cs); // Might be null\n                    }\n\n                    if (nbin > 0) {\n                        indices[ref] = {\n                            binIndex: binIndex,\n                            linearIndex: linearIndex\n                        };\n                    }\n                }\n            } else {\n                throw new Error(indexURL + \" is not a \" + (tabix ? \"tabix\" : \"bai\") + \" file\");\n            }\n            fulfill(new BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix));\n        }).catch(reject);\n    });\n};\n\nvar BamIndex = function () {\n    function BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix) {\n        _classCallCheck(this, BamIndex);\n\n        this.firstAlignmentBlock = blockMin;\n        this.indices = indices;\n        this.lastAlignmentBlock = blockMax;\n        this.sequenceIndexMap = sequenceIndexMap;\n        this.tabix = tabix;\n    }\n\n    /**\r\n     * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.\r\n     *\r\n     * @param refId  the sequence dictionary index of the chromosome\r\n     * @param min  genomic start position\r\n     * @param max  genomic end position\r\n     * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}\r\n     */\n\n\n    _createClass(BamIndex, [{\n        key: \"blocksForRange\",\n        value: function blocksForRange(refId, min, max) {\n\n            var bam = this,\n                ba = bam.indices[refId],\n                overlappingBins,\n                chunks,\n                nintv,\n                lowest,\n                minLin,\n                maxLin,\n                vp,\n                i;\n\n            if (!ba) {\n                return [];\n            } else {\n                overlappingBins = BamIndex.reg2bins(min, max);\n                chunks = []; // List of bin #s that might overlap min, max\n\n\n                overlappingBins.forEach(function (bin) {\n\n                    if (ba.binIndex[bin]) {\n                        var binChunks = ba.binIndex[bin],\n                            nchnk = binChunks.length;\n\n                        for (var c = 0; c < nchnk; ++c) {\n                            var cs = binChunks[c][0];\n                            var ce = binChunks[c][1];\n                            chunks.push({ minv: cs, maxv: ce, bin: bin });\n                        }\n                    }\n                });\n\n                // Use the linear index to find the lowest chunk that could contain alignments in the region\n                nintv = ba.linearIndex.length;\n                lowest = null;\n                minLin = Math.min(min >> 14, nintv - 1), maxLin = Math.min(max >> 14, nintv - 1);\n                for (i = minLin; i <= maxLin; ++i) {\n                    vp = ba.linearIndex[i];\n                    if (vp) {\n\n                        if (!lowest || vp.isLessThan(lowest)) {\n                            lowest = vp;\n                        }\n                    }\n                }\n                // Prune chunks that end before the lowest chunk\n                return optimizeChunks(chunks, lowest);\n            }\n        }\n    }], [{\n        key: \"reg2bins\",\n\n\n        /**\r\n         * Calculate the list of bins that may overlap with region [beg, end]\r\n         *\r\n         */\n        value: function reg2bins(beg, end) {\n            var i = 0,\n                k,\n                list = [];\n            if (end >= 1 << 29) end = 1 << 29;\n            --end;\n            list.push(0);\n            for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {\n                list.push(k);\n            }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {\n                list.push(k);\n            }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {\n                list.push(k);\n            }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {\n                list.push(k);\n            }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {\n                list.push(k);\n            }return list;\n        }\n    }]);\n\n    return BamIndex;\n}();\n\nfunction optimizeChunks(chunks, lowest) {\n\n    var mergedChunks = [],\n        lastChunk = null;\n\n    if (chunks.length === 0) return chunks;\n\n    chunks.sort(function (c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n\n    chunks.forEach(function (chunk) {\n\n        if (!lowest || chunk.maxv.isGreaterThan(lowest)) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            } else {\n                if (chunk.minv.block - lastChunk.maxv.block < 65000) {\n                    // Merge chunks that are withing 65k of each other\n                    if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                } else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    });\n\n    return mergedChunks;\n}\n\nvar BGZFile = function () {\n    function BGZFile(config) {\n        _classCallCheck(this, BGZFile);\n\n        this.filePosition = 0;\n        this.config = config;\n    }\n\n    _createClass(BGZFile, [{\n        key: \"nextBlock\",\n        value: function nextBlock() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                    headers: self.config.headers,\n                    range: { start: self.filePosition, size: BLOCK_HEADER_LENGTH },\n                    withCredentials: self.config.withCredentials\n\n                }).then(function (arrayBuffer) {\n\n                    var ba = new Uint8Array(arrayBuffer);\n                    var xlen = ba[11] << 8 | ba[10];\n                    var si1 = ba[12];\n                    var si2 = ba[13];\n                    var slen = ba[15] << 8 | ba[14];\n                    var bsize = ba[17] << 8 | ba[16] + 1;\n\n                    self.filePosition += BLOCK_HEADER_LENGTH;\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, {\n                        headers: self.config.headers,\n                        range: { start: self.filePosition, size: bsize },\n                        withCredentials: self.config.withCredentials\n\n                    }).then(function (arrayBuffer) {\n\n                        var unc = (0, _inflate.jszlib_inflate_buffer)(arrayBuffer);\n\n                        self.filePosition += bsize + 8; // \"8\" for CRC-32 and size of uncompressed data\n\n                        fulfill(unc);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BGZFile;\n}();\n\nvar BAM_MAGIC = 21840194;\nvar SECRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\nvar READ_STRAND_FLAG = 0x10;\nvar MATE_STRAND_FLAG = 0x20;\nvar FIRST_OF_PAIR_FLAG = 0x40;\nvar SECOND_OF_PAIR_FLAG = 0x80;\nvar READ_UNMAPPED_FLAG = 0x4;\nvar MATE_UNMAPPED_FLAG = 0x8;\nvar READ_PAIRED_FLAG = 0x1;\nvar PROPER_PAIR_FLAG = 0x2;\nvar SECONDARY_ALIGNMNET_FLAG = 0x100;\nvar SUPPLEMENTARY_ALIGNMENT_FLAG = 0x800;\n\nvar NOT_PRIMARY_ALIGNMENT_FLAG = 0x100;\nvar READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 0x200;\nvar DUPLICATE_READ_FLAG = 0x400;\nvar SUPPLEMENTARY_FLAG = 0x800;\n\nvar MAX_GZIP_BLOCK_SIZE = 65536; //  APPARENTLY.  Where is this documented???\nvar DEFAULT_SAMPLING_WINDOW_SIZE = 100;\nvar DEFAULT_SAMPLING_DEPTH = 50;\nvar MAXIMUM_SAMPLING_DEPTH = 2500;\n\n/**\r\n * Class for reading a bam file\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar BamReader = function () {\n    function BamReader(config, parent) {\n        _classCallCheck(this, BamReader);\n\n        this.config = config;\n        this.parent = parent;\n        this.ac_class = AlignmentContainer;\n        if (parent.ac_class) {\n            this.ac_class = parent_class;\n        }\n\n        this.filter = config.filter || new BamFilter();\n\n        this.bamPath = config.url;\n        // Todo - deal with Picard convention.  WHY DOES THERE HAVE TO BE 2?\n        this.baiPath = config.indexURL || this.bamPath + \".bai\"; // If there is an indexURL provided, use it!\n        this.headPath = config.headURL || this.bamPath;\n\n        this.samplingWindowSize = config.samplingWindowSize === undefined ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;\n        this.samplingDepth = config.samplingDepth === undefined ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;\n        if (this.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {\n            igv.log(\"Warning: attempt to set sampling depth > maximum value of 2500\");\n            this.samplingDepth = MAXIMUM_SAMPLING_DEPTH;\n        }\n\n        if (config.viewAsPairs) {\n            this.pairsSupported = true;\n        } else {\n            this.pairsSupported = config.pairsSupported === undefined ? true : config.pairsSupported;\n        }\n    }\n\n    _createClass(BamReader, [{\n        key: \"readAlignments\",\n        value: function readAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getChrIndex(self).then(function (chrToIndex) {\n\n                    var chrId = chrToIndex[chr],\n                        alignmentContainer = new self.ac_class(chr, bpStart, bpEnd, self.samplingWindowSize, self.samplingDepth, self.pairsSupported, self.parent);\n\n                    if (chrId === undefined) {\n                        fulfill(alignmentContainer);\n                    } else {\n\n                        getIndex(self).then(function (bamIndex) {\n\n                            var chunks = bamIndex.blocksForRange(chrId, bpStart, bpEnd),\n                                promises = [];\n\n                            if (!chunks) {\n                                fulfill(null);\n                                reject(\"Error reading bam index\");\n                                return;\n                            }\n                            if (chunks.length === 0) {\n                                fulfill(alignmentContainer);\n                                return;\n                            }\n\n                            chunks.forEach(function (c) {\n\n                                promises.push(new Promise(function (fulfill, reject) {\n\n                                    var fetchMin = c.minv.block,\n                                        fetchMax = c.maxv.block + MAX_GZIP_BLOCK_SIZE,\n                                        // Make sure we get the whole block.\n                                    range = { start: fetchMin, size: fetchMax - fetchMin + 1 };\n\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                                        headers: self.config.headers,\n                                        range: range,\n                                        withCredentials: self.config.withCredentials\n                                    }).then(function (compressed) {\n\n                                        var ba = new Uint8Array(new unbgzf(compressed)); //new Uint8Array(igv.unbgzf(compressed)); //, c.maxv.block - c.minv.block + 1));\n                                        decodeBamRecords(ba, c.minv.offset, alignmentContainer, bpStart, bpEnd, chrId, self.filter);\n\n                                        fulfill(alignmentContainer);\n                                    }).catch(function (obj) {\n                                        reject(obj);\n                                    });\n                                }));\n                            });\n\n                            Promise.all(promises).then(function (ignored) {\n                                alignmentContainer.finish();\n                                fulfill(alignmentContainer);\n                            }).catch(function (obj) {\n                                reject(obj);\n                            });\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n\n            function decodeBamRecords(ba, offset, alignmentContainer, min, max, chrId, filter) {\n\n                var blockSize, blockEnd, alignment, blocks, refID, pos, bmn, bin, mq, nl, flag_nc, flag, nc, lseq, mateRefID, matePos, readName, j, p, lengthOnRef, cigar, c, cigarArray, seq, seqBytes;\n\n                while (true) {\n\n                    blockSize = readInt(ba, offset);\n                    blockEnd = offset + blockSize + 4;\n\n                    if (blockEnd > ba.length) {\n                        return;\n                    }\n\n                    alignment = new BamAlignment();\n\n                    refID = readInt(ba, offset + 4);\n                    pos = readInt(ba, offset + 8);\n\n                    if (refID < 0) {\n                        return; // unmapped reads\n                    } else if (refID > chrId || pos > max) {\n                        return; // off right edge, we're done\n                    } else if (refID < chrId) {\n                        continue; // to left of start, not sure this is possible\n                    }\n\n                    bmn = readInt(ba, offset + 12);\n                    bin = (bmn & 0xffff0000) >> 16;\n                    mq = (bmn & 0xff00) >> 8;\n                    nl = bmn & 0xff;\n\n                    flag_nc = readInt(ba, offset + 16);\n                    flag = (flag_nc & 0xffff0000) >> 16;\n                    nc = flag_nc & 0xffff;\n\n                    alignment.flags = flag;\n                    alignment.strand = !(flag & READ_STRAND_FLAG);\n\n                    lseq = readInt(ba, offset + 20);\n\n                    mateRefID = readInt(ba, offset + 24);\n                    matePos = readInt(ba, offset + 28);\n                    alignment.fragmentLength = readInt(ba, offset + 32);\n\n                    readName = '';\n                    for (j = 0; j < nl - 1; ++j) {\n                        readName += String.fromCharCode(ba[offset + 36 + j]);\n                    }\n\n                    p = offset + 36 + nl;\n\n                    lengthOnRef = 0;\n                    cigar = '';\n\n                    cigarArray = [];\n                    for (c = 0; c < nc; ++c) {\n                        var cigop = readInt(ba, p);\n                        var opLen = cigop >> 4;\n                        var opLtr = CIGAR_DECODER[cigop & 0xf];\n                        if (opLtr == 'M' || opLtr == 'EQ' || opLtr == 'X' || opLtr == 'D' || opLtr == 'N' || opLtr == '=') lengthOnRef += opLen;\n                        cigar = cigar + opLen + opLtr;\n                        p += 4;\n\n                        cigarArray.push({ len: opLen, ltr: opLtr });\n                    }\n                    alignment.cigar = cigar;\n                    alignment.lengthOnRef = lengthOnRef;\n\n                    if (alignment.start + alignment.lengthOnRef < min) continue; // Record out-of-range \"to the left\", skip to next one\n\n\n                    seq = '';\n                    seqBytes = lseq + 1 >> 1;\n                    for (j = 0; j < seqBytes; ++j) {\n                        var sb = ba[p + j];\n                        seq += SECRET_DECODER[(sb & 0xf0) >> 4];\n                        seq += SECRET_DECODER[sb & 0x0f];\n                    }\n                    seq = seq.substring(0, lseq); // seq might have one extra character (if lseq is an odd number)\n\n                    p += seqBytes;\n                    alignment.seq = seq;\n\n                    if (lseq === 1 && String.fromCharCode(ba[p + j] + 33) === \"*\") {\n                        // TODO == how to represent this?\n                    } else {\n                        alignment.qual = [];\n                        for (j = 0; j < lseq; ++j) {\n                            alignment.qual.push(ba[p + j]);\n                        }\n                    }\n                    p += lseq;\n\n                    alignment.start = pos;\n                    alignment.mq = mq;\n                    alignment.readName = readName;\n                    alignment.chr = self.indexToChr[refID];\n\n                    if (mateRefID >= 0) {\n                        alignment.mate = {\n                            chr: self.indexToChr[mateRefID],\n                            position: matePos,\n                            strand: !(flag & MATE_STRAND_FLAG)\n                        };\n                    }\n\n                    alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd)); // decode thiese on demand\n                    p += blockEnd;\n\n                    if (!min || alignment.start <= max && alignment.start + alignment.lengthOnRef >= min && filter.pass(alignment)) {\n                        if (chrId === undefined || refID == chrId) {\n                            blocks = makeBlocks(alignment, cigarArray);\n                            alignment.blocks = blocks.blocks;\n                            alignment.insertions = blocks.insertions;\n                            alignmentContainer.push(alignment);\n                        }\n                    }\n                    offset = blockEnd;\n                }\n                // Exits via top of loop.\n            }\n\n            /**\r\n             * Split the alignment record into blocks as specified in the cigarArray.  Each aligned block contains\r\n             * its portion of the read sequence and base quality strings.  A read sequence or base quality string\r\n             * of \"*\" indicates the value is not recorded.  In all other cases the length of the block sequence (block.seq)\r\n             * and quality string (block.qual) must == the block length.\r\n             *\r\n             * NOTE: Insertions are not yet treated // TODO\r\n             *\r\n             * @param record\r\n             * @param cigarArray\r\n             * @returns array of blocks\r\n             */\n            function makeBlocks(record, cigarArray) {\n\n                var blocks = [],\n                    insertions,\n                    seqOffset = 0,\n                    pos = record.start,\n                    len = cigarArray.length,\n                    blockSeq,\n                    blockQuals,\n                    gapType,\n                    minQ = 5,\n                    //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN)\n                maxQ = 20; //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX)\n\n                for (var i = 0; i < len; i++) {\n\n                    var c = cigarArray[i];\n\n                    switch (c.ltr) {\n                        case 'H':\n                            break; // ignore hard clips\n                        case 'P':\n                            break; // ignore pads\n                        case 'S':\n                            seqOffset += c.len;\n                            gapType = 'S';\n                            break; // soft clip read bases\n                        case 'N':\n                            pos += c.len;\n                            gapType = 'N';\n                            break; // reference skip\n                        case 'D':\n                            pos += c.len;\n                            gapType = 'D';\n                            break;\n                        case 'I':\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            if (insertions === undefined) insertions = [];\n                            insertions.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals });\n                            seqOffset += c.len;\n                            break;\n                        case 'M':\n                        case 'EQ':\n                        case '=':\n                        case 'X':\n\n                            blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\n                            blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\n                            blocks.push({ start: pos, len: c.len, seq: blockSeq, qual: blockQuals, gapType: gapType });\n                            seqOffset += c.len;\n                            pos += c.len;\n\n                            break;\n\n                        default:\n                            console.log(\"Error processing cigar element: \" + c.len + c.ltr);\n                    }\n                }\n\n                return { blocks: blocks, insertions: insertions };\n            }\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                getIndex(self).then(function (index) {\n\n                    var len = index.firstAlignmentBlock + MAX_GZIP_BLOCK_SIZE; // Insure we get the complete compressed block containing the header\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.bamPath, {\n                        headers: self.config.headers,\n\n                        range: { start: 0, size: len },\n\n                        withCredentials: self.config.withCredentials\n                    }).then(function (compressedBuffer) {\n\n                        var unc = new unbgzf(compressedBuffer, len),\n                            uncba = new Uint8Array(unc),\n                            magic = readInt(uncba, 0),\n                            samHeaderLen = readInt(uncba, 4),\n                            samHeader = '',\n                            genome = null;\n\n                        for (var i = 0; i < samHeaderLen; ++i) {\n                            samHeader += String.fromCharCode(uncba[i + 8]);\n                        }\n\n                        var nRef = readInt(uncba, samHeaderLen + 8);\n                        var p = samHeaderLen + 12;\n\n                        self.chrToIndex = {};\n                        self.indexToChr = [];\n                        for (var i = 0; i < nRef; ++i) {\n                            var lName = readInt(uncba, p);\n                            var name = '';\n                            for (var j = 0; j < lName - 1; ++j) {\n                                name += String.fromCharCode(uncba[p + 4 + j]);\n                            }\n                            var lRef = readInt(uncba, p + lName + 4);\n                            //dlog(name + ': ' + lRef);\n\n                            if (genome && genome.getChromosomeName) {\n                                name = genome.getChromosomeName(name);\n                            }\n\n                            self.chrToIndex[name] = i;\n                            self.indexToChr.push(name);\n\n                            p = p + 8 + lName;\n                        }\n\n                        fulfill();\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return BamReader;\n}();\n\nfunction getIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.index) {\n            fulfill(bam.index);\n        } else {\n            loadBamIndex(bam.baiPath, bam.config).then(function (index) {\n                bam.index = index;\n\n                fulfill(bam.index);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction getChrIndex(bam) {\n\n    return new Promise(function (fulfill, reject) {\n\n        if (bam.chrToIndex) {\n            fulfill(bam.chrToIndex);\n        } else {\n            bam.readHeader().then(function () {\n                fulfill(bam.chrToIndex);\n            }).catch(reject);\n        }\n    });\n}\n\nfunction readInt(ba, offset) {\n    return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];\n}\n\nfunction readShort(ba, offset) {\n    return ba[offset + 1] << 8 | ba[offset];\n}\n\nvar BamSource = function () {\n    function BamSource(config, parent) {\n        _classCallCheck(this, BamSource);\n\n        this.config = config;\n        this.alignmentContainer = undefined;\n        this.maxRows = config.maxRows || 1000;\n        if (config.seq_url) {\n            this.sequence_source = new _feature.FastaSequence(config.seq_url);\n        }\n        this.parent = parent;\n\n        this.pack_alignments = true;\n\n        if (config.sourceType === \"ga4gh\") {\n            this.bamReader = new igv.Ga4ghAlignmentReader(config);\n        } else {\n            this.bamReader = new BamReader(config, parent);\n        }\n\n        this.viewAsPairs = true;\n    }\n\n    _createClass(BamSource, [{\n        key: \"setViewAsPairs\",\n        value: function setViewAsPairs(bool) {\n            var self = this;\n\n            if (this.viewAsPairs !== bool) {\n                this.viewAsPairs = bool;\n                // TODO -- repair alignments\n                if (this.alignmentContainer) {\n                    var alignmentContainer = this.alignmentContainer,\n                        alignments;\n\n                    if (bool) {\n                        alignments = pairAlignments(alignmentContainer.packedAlignmentRows);\n                    } else {\n                        alignments = unpairAlignments(alignmentContainer.packedAlignmentRows);\n                    }\n                    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, self.maxRows);\n                }\n            }\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments(chr, bpStart, bpEnd) {\n\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n\n                if (self.alignmentContainer && self.alignmentContainer.contains(chr, bpStart, bpEnd)) {\n                    fulfill(self.alignmentContainer);\n                } else {\n\n                    self.bamReader.readAlignments(chr, bpStart, bpEnd).then(function (alignmentContainer) {\n\n                        var maxRows = self.config.maxRows || 500,\n                            alignments = alignmentContainer.alignments;\n\n                        if (!self.viewAsPairs) {\n                            alignments = unpairAlignments([{ alignments: alignments }]);\n                        }\n                        if (self.parent.display_alignments) {\n                            alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, maxRows);\n                        }\n\n                        alignmentContainer.alignments = undefined; // Don't need to hold onto these anymore\n                        self.alignmentContainer = alignmentContainer;\n                        if (self.sequence_source) {\n                            self.sequence_source.getSequence(alignmentContainer.chr, alignmentContainer.start, alignmentContainer.end).then(function (sequence) {\n\n                                if (sequence) {\n\n                                    alignmentContainer.coverageMap.refSeq = sequence; // TODO -- fix this\n                                    alignmentContainer.sequence = sequence; // TODO -- fix this\n\n\n                                    fulfill(alignmentContainer);\n                                }\n                            }).catch(reject);\n                        } else {\n                            fulfill(alignmentContainer);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BamSource;\n}();\n\nfunction pairAlignments(rows) {\n\n    var pairCache = {},\n        result = [];\n\n    rows.forEach(function (row) {\n\n        row.alignments.forEach(function (alignment) {\n\n            var pairedAlignment;\n\n            if (canBePaired(alignment)) {\n\n                pairedAlignment = pairCache[alignment.readName];\n                if (pairedAlignment) {\n                    pairedAlignment.setSecondAlignment(alignment);\n                    pairCache[alignment.readName] = undefined; // Don't need to track this anymore.\n                } else {\n                    pairedAlignment = new igv.PairedAlignment(alignment);\n                    pairCache[alignment.readName] = pairedAlignment;\n                    result.push(pairedAlignment);\n                }\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction unpairAlignments(rows) {\n    var result = [];\n    rows.forEach(function (row) {\n        row.alignments.forEach(function (alignment) {\n            if (alignment instanceof PairedAlignment) {\n                if (alignment.firstAlignment) result.push(alignment.firstAlignment); // shouldn't need the null test\n                if (alignment.secondAlignment) result.push(alignment.secondAlignment);\n            } else {\n                result.push(alignment);\n            }\n        });\n    });\n    return result;\n}\n\nfunction canBePaired(alignment) {\n    return alignment.isPaired() && alignment.isMateMapped() && alignment.chr === alignment.mate.chr && (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());\n}\n\nfunction packAlignmentRows(alignments, start, end, maxRows) {\n\n    if (!alignments) return;\n\n    alignments.sort(function (a, b) {\n        return a.start - b.start;\n    });\n\n    if (alignments.length === 0) {\n\n        return [];\n    } else {\n\n        var bucketList = [],\n            allocatedCount = 0,\n            lastAllocatedCount = 0,\n            nextStart = start,\n            alignmentRow,\n            index,\n            bucket,\n            alignment,\n            alignmentSpace = 4 * 2,\n            packedAlignmentRows = [],\n            bucketStart = Math.max(start, alignments[0].start);\n\n        alignments.forEach(function (alignment) {\n\n            var buckListIndex = Math.max(0, alignment.start - bucketStart);\n            if (bucketList[buckListIndex] === undefined) {\n                bucketList[buckListIndex] = [];\n            }\n            bucketList[buckListIndex].push(alignment);\n        });\n\n        while (allocatedCount < alignments.length && packedAlignmentRows.length < maxRows) {\n\n            alignmentRow = new BamAlignmentRow();\n\n            while (nextStart <= end) {\n\n                bucket = undefined;\n\n                while (!bucket && nextStart <= end) {\n\n                    index = nextStart - bucketStart;\n                    if (bucketList[index] === undefined) {\n                        ++nextStart; // No alignments at this index\n                    } else {\n                        bucket = bucketList[index];\n                    }\n                } // while (bucket)\n\n                if (!bucket) {\n                    break;\n                }\n                alignment = bucket.pop();\n                if (0 === bucket.length) {\n                    bucketList[index] = undefined;\n                }\n\n                alignmentRow.alignments.push(alignment);\n                nextStart = alignment.start + alignment.lengthOnRef + alignmentSpace;\n                ++allocatedCount;\n            } // while (nextStart)\n\n            if (alignmentRow.alignments.length > 0) {\n                packedAlignmentRows.push(alignmentRow);\n            }\n\n            nextStart = bucketStart;\n\n            if (allocatedCount === lastAllocatedCount) break; // Protect from infinite loops\n\n            lastAllocatedCount = allocatedCount;\n        } // while (allocatedCount)\n\n        return packedAlignmentRows;\n    }\n}\n\nvar BamAlignment = function () {\n    function BamAlignment() {\n        _classCallCheck(this, BamAlignment);\n\n        this.hidden = false;\n    }\n\n    _createClass(BamAlignment, [{\n        key: \"isMapped\",\n        value: function isMapped() {\n            return (this.flags & READ_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return (this.flags & READ_PAIRED_FLAG) != 0;\n        }\n    }, {\n        key: \"isProperPair\",\n        value: function isProperPair() {\n            return (this.flags & PROPER_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isFirstOfPair\",\n        value: function isFirstOfPair() {\n            return (this.flags & FIRST_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondOfPair\",\n        value: function isSecondOfPair() {\n            return (this.flags & SECOND_OF_PAIR_FLAG) != 0;\n        }\n    }, {\n        key: \"isSecondary\",\n        value: function isSecondary() {\n            return (this.flags & SECONDARY_ALIGNMNET_FLAG) != 0;\n        }\n    }, {\n        key: \"isSupplementary\",\n        value: function isSupplementary() {\n            return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) != 0;\n        }\n    }, {\n        key: \"isFailsVendorQualityCheck\",\n        value: function isFailsVendorQualityCheck() {\n            return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) != 0;\n        }\n    }, {\n        key: \"isDuplicate\",\n        value: function isDuplicate() {\n            return (this.flags & DUPLICATE_READ_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateMapped\",\n        value: function isMateMapped() {\n            return (this.flags & MATE_UNMAPPED_FLAG) == 0;\n        }\n    }, {\n        key: \"isNegativeStrand\",\n        value: function isNegativeStrand() {\n            return (this.flags & READ_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"isMateNegativeStrand\",\n        value: function isMateNegativeStrand() {\n            return (this.flags & MATE_STRAND_FLAG) != 0;\n        }\n    }, {\n        key: \"tags\",\n        value: function tags() {\n\n            function decodeTags(ba) {\n\n                var p = 0,\n                    len = ba.length,\n                    tags = {};\n\n                while (p < len) {\n                    var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\n                    var type = String.fromCharCode(ba[p + 2]);\n                    var value;\n\n                    if (type == 'A') {\n                        value = String.fromCharCode(ba[p + 3]);\n                        p += 4;\n                    } else if (type === 'i' || type === 'I') {\n                        value = readInt(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'c' || type === 'C') {\n                        value = ba[p + 3];\n                        p += 4;\n                    } else if (type === 's' || type === 'S') {\n                        value = readShort(ba, p + 3);\n                        p += 5;\n                    } else if (type === 'f') {\n                        // TODO 'FIXME need floats';\n                        value = readFloat(ba, p + 3);\n                        p += 7;\n                    } else if (type === 'Z') {\n                        p += 3;\n                        value = '';\n                        for (;;) {\n                            var cc = ba[p++];\n                            if (cc === 0) {\n                                break;\n                            } else {\n                                value += String.fromCharCode(cc);\n                            }\n                        }\n                    } else {\n                        //'Unknown type ' + type;\n                        value = 'Error unknown type: ' + type;\n                        tags[tag] = value;\n                        break;\n                    }\n                    tags[tag] = value;\n                }\n                return tags;\n            }\n\n            if (!this.tagDict) {\n                if (this.tagBA) {\n                    this.tagDict = decodeTags(this.tagBA);\n                    this.tagBA = undefined;\n                } else {\n                    this.tagDict = {}; // Mark so we don't try again.  The record has not tags\n                }\n            }\n            return this.tagDict;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            // if the user clicks on a base next to an insertion, show just the\n            // inserted bases in a popup (like in desktop IGV).\n            var nameValues = [],\n                isFirst,\n                tagDict;\n\n            if (this.insertions) {\n                for (var i = 0; i < this.insertions.length; i += 1) {\n                    var ins_start = this.insertions[i].start;\n                    if (genomicLocation == ins_start || genomicLocation == ins_start - 1) {\n                        nameValues.push({ name: 'Insertion', value: this.insertions[i].seq });\n                        nameValues.push({ name: 'Location', value: ins_start });\n                        return nameValues;\n                    }\n                }\n            }\n\n            nameValues.push({ name: 'Read Name', value: this.readName });\n\n            // Sample\n            // Read group\n            nameValues.push(\"<hr>\");\n\n            // Add 1 to genomic location to map from 0-based computer units to user-based units\n            nameValues.push({ name: 'Alignment Start', value: igv.numberFormatter(1 + this.start), borderTop: true });\n\n            nameValues.push({ name: 'Read Strand', value: true === this.strand ? '(+)' : '(-)', borderTop: true });\n            nameValues.push({ name: 'Cigar', value: this.cigar });\n            nameValues.push({ name: 'Mapped', value: yesNo(this.isMapped()) });\n            nameValues.push({ name: 'Mapping Quality', value: this.mq });\n            nameValues.push({ name: 'Secondary', value: yesNo(this.isSecondary()) });\n            nameValues.push({ name: 'Supplementary', value: yesNo(this.isSupplementary()) });\n            nameValues.push({ name: 'Duplicate', value: yesNo(this.isDuplicate()) });\n            nameValues.push({ name: 'Failed QC', value: yesNo(this.isFailsVendorQualityCheck()) });\n\n            if (this.isPaired()) {\n                nameValues.push(\"<hr>\");\n                nameValues.push({ name: 'First in Pair', value: !this.isSecondOfPair(), borderTop: true });\n                nameValues.push({ name: 'Mate is Mapped', value: yesNo(this.isMateMapped()) });\n                if (this.isMateMapped()) {\n                    nameValues.push({ name: 'Mate Chromosome', value: this.mate.chr });\n                    nameValues.push({ name: 'Mate Start', value: this.mate.position + 1 });\n                    nameValues.push({ name: 'Mate Strand', value: true === this.mate.strand ? '(+)' : '(-)' });\n                    nameValues.push({ name: 'Insert Size', value: this.fragmentLength });\n                    // Mate Start\n                    // Mate Strand\n                    // Insert Size\n                }\n                // First in Pair\n                // Pair Orientation\n            }\n\n            nameValues.push(\"<hr>\");\n            tagDict = this.tags();\n            isFirst = true;\n            for (var key in tagDict) {\n\n                if (tagDict.hasOwnProperty(key)) {\n\n                    if (isFirst) {\n                        nameValues.push({ name: key, value: tagDict[key], borderTop: true });\n                        isFirst = false;\n                    } else {\n                        nameValues.push({ name: key, value: tagDict[key] });\n                    }\n                }\n            }\n\n            return nameValues;\n\n            function yesNo(bool) {\n                return bool ? 'Yes' : 'No';\n            }\n        }\n    }]);\n\n    return BamAlignment;\n}();\n\nfunction readFloat(ba, offset) {\n\n    var dataView = new DataView(ba.buffer),\n        littleEndian = true;\n\n    return dataView.getFloat32(offset, littleEndian);\n}\n\nvar BamFilter = function () {\n    function BamFilter(options) {\n        _classCallCheck(this, BamFilter);\n\n        if (!options) options = {};\n        this.vendorFailed = options.vendorFailed === undefined ? true : options.vendorFailed;\n        this.duplicates = options.duplicates === undefined ? true : options.duplicates;\n        this.secondary = options.secondary || false;\n        this.supplementary = options.supplementary || false;\n        this.mqThreshold = options.mqThreshold === undefined ? 0 : options.mqThreshold;\n    }\n\n    _createClass(BamFilter, [{\n        key: \"pass\",\n        value: function pass(alignment) {\n\n            if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;\n            if (this.duplicates && alignment.isDuplicate()) return false;\n            if (this.secondary && alignment.isSecondary()) return false;\n            if (this.supplementary && alignment.isSupplementary()) return false;\n            if (alignment.mq < this.mqThreshold) return false;\n\n            return true;\n        }\n    }]);\n\n    return BamFilter;\n}();\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\n\nvar unbgzf = function unbgzf(data, lim) {\n    _classCallCheck(this, unbgzf);\n\n    for (var a in data) {\n        console.log(a);\n    }\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nvar AlignmentContainer = function () {\n    function AlignmentContainer(chr, start, end, samplingWindowSize, samplingDepth, pairsSupported, parent) {\n        _classCallCheck(this, AlignmentContainer);\n\n        this.parent = parent;\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.length = end - start;\n        if (!this.parent.cm_class) {\n            this.coverageMap = new CoverageMap(chr, start, end, parent);\n        } else {\n            this.coverageMap = new this.parent.cm_class(chr, start, end, parent);\n        }\n\n        this.alignments = [];\n        this.raw_alignments = [];\n        this.downsampledIntervals = [];\n\n        this.samplingWindowSize = samplingWindowSize === undefined ? 100 : samplingWindowSize;\n        this.samplingDepth = samplingDepth === undefined ? 50 : samplingDepth;\n\n        this.pairsSupported = pairsSupported;\n        this.paired = false; // false until proven otherwise\n        this.pairsCache = {}; // working cache of paired alignments by read name\n\n        this.downsampledReads = new Set();\n\n        this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);\n\n        this.filter = function filter(alignment) {\n            // TODO -- pass this in\n            return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();\n        };\n    }\n\n    _createClass(AlignmentContainer, [{\n        key: \"push\",\n        value: function push(alignment) {\n\n            if (this.filter(alignment) === false) return;\n            if (alignment.tagBA) {\n                alignment.tagBA = decodeTags(alignment.tagBA);\n            }\n            if (this.parent.keep_raw_alignments) {\n                this.raw_alignments.push(alignment);\n            }\n\n            this.coverageMap.incCounts(alignment);\n            if (!this.parent.display_alignments) {\n                return;\n            }\n\n            // Count coverage before any downsampling\n\n            if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {\n                return; // Mate already downsampled -- pairs are treated as a single alignment for downsampling\n            }\n\n            if (alignment.start >= this.currentBucket.end) {\n                finishBucket.call(this);\n                this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);\n            }\n\n            this.currentBucket.addAlignment(alignment);\n        }\n    }, {\n        key: \"forEach\",\n        value: function forEach(callback) {\n            this.alignments.forEach(callback);\n        }\n    }, {\n        key: \"finish\",\n        value: function finish() {\n\n            if (this.currentBucket !== undefined) {\n                finishBucket.call(this);\n            }\n\n            // Need to remove partial pairs whose mate was downsampled\n            if (this.pairsSupported) {\n                var tmp = [],\n                    ds = this.downsampledReads;\n\n                this.alignments.forEach(function (a) {\n                    if (!ds.has(a.readName)) {\n                        tmp.push(a);\n                    }\n                });\n                this.alignments = tmp;\n            }\n\n            this.alignments.sort(function (a, b) {\n                return a.start - b.start;\n            });\n\n            this.pairsCache = undefined;\n            this.downsampledReads = undefined;\n        }\n    }, {\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"hasDownsampledIntervals\",\n        value: function hasDownsampledIntervals() {\n            return this.downsampledIntervals && this.downsampledIntervals.length > 0;\n        }\n    }]);\n\n    return AlignmentContainer;\n}();\n\nfunction finishBucket() {\n    this.alignments = this.alignments.concat(this.currentBucket.alignments);\n    if (this.currentBucket.downsampledCount > 0) {\n        this.downsampledIntervals.push(new DownsampledInterval(this.currentBucket.start, this.currentBucket.end, this.currentBucket.downsampledCount));\n    }\n    this.paired = this.paired || this.currentBucket.paired;\n}\n\nvar DownsampleBucket = function () {\n    function DownsampleBucket(start, end, alignmentContainer) {\n        _classCallCheck(this, DownsampleBucket);\n\n        this.start = start;\n        this.end = end;\n        this.alignments = [];\n        this.downsampledCount = 0;\n        this.samplingDepth = alignmentContainer.samplingDepth;\n        this.pairsSupported = alignmentContainer.pairsSupported;\n        this.downsampledReads = alignmentContainer.downsampledReads;\n        this.pairsCache = alignmentContainer.pairsCache;\n    }\n\n    _createClass(DownsampleBucket, [{\n        key: \"addAlignment\",\n        value: function addAlignment(alignment) {\n\n            var samplingProb, idx, replacedAlignment, pairedAlignment;\n\n            if (this.alignments.length < this.samplingDepth) {\n\n                if (this.pairsSupported && canBePaired(alignment)) {\n                    pairedAlignment = this.pairsCache[alignment.readName];\n                    if (pairedAlignment) {\n                        //Not subject to downsampling, just update the existing alignment\n                        pairedAlignment.setSecondAlignment(alignment);\n                        this.pairsCache[alignment.readName] = undefined; // Don't need to track this anymore. NOTE: Don't \"delete\", causes runtime performance issues\n                    } else {\n                        // First alignment in a pair\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments.push(pairedAlignment);\n                    }\n                } else {\n                    this.alignments.push(alignment);\n                }\n            } else {\n\n                samplingProb = this.samplingDepth / (this.samplingDepth + this.downsampledCount + 1);\n\n                if (Math.random() < samplingProb) {\n\n                    idx = Math.floor(Math.random() * (this.alignments.length - 1));\n                    replacedAlignment = this.alignments[idx]; // To be replaced\n\n                    if (this.pairsSupported && canBePaired(alignment)) {\n\n                        if (this.pairsCache[replacedAlignment.readName] !== undefined) {\n                            this.pairsCache[replacedAlignment.readName] = undefined;\n                        }\n\n                        pairedAlignment = new PairedAlignment(alignment);\n                        this.paired = true;\n                        this.pairsCache[alignment.readName] = pairedAlignment;\n                        this.alignments[idx] = pairedAlignment;\n                    } else {\n                        this.alignments[idx] = alignment;\n                    }\n                    this.downsampledReads.add(replacedAlignment.readName);\n                } else {\n                    this.downsampledReads.add(alignment.readName);\n                }\n\n                this.downsampledCount++;\n            }\n        }\n    }]);\n\n    return DownsampleBucket;\n}();\n\n// TODO -- refactor this to use an object, rather than an array,  if end-start is > some threshold\n\n\nvar CoverageMap = function () {\n    function CoverageMap(chr, start, end, parent) {\n        _classCallCheck(this, CoverageMap);\n\n        this.chr = chr;\n        this.bpStart = start;\n        this.length = end - start;\n        this.parent = parent;\n        this.coverage = new Array(this.length);\n\n        this.maximum = 0;\n    }\n\n    _createClass(CoverageMap, [{\n        key: \"incCounts\",\n        value: function incCounts(alignment) {\n\n            var self = this;\n\n            if (alignment.blocks === undefined) {\n\n                incBlockCount(alignment);\n            } else {\n                alignment.blocks.forEach(function (block) {\n                    incBlockCount(block);\n                });\n            }\n\n            function incBlockCount(block) {\n\n                var key, base, i, j, q;\n\n                for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\n\n                    if (!self.coverage[i]) {\n                        self.coverage[i] = new Coverage();\n                    }\n\n                    base = block.seq.charAt(j);\n                    key = alignment.strand ? \"pos\" + base : \"neg\" + base;\n                    q = block.qual[j];\n\n                    self.coverage[i][key] += 1;\n                    self.coverage[i][\"qual\" + base] += q;\n\n                    self.coverage[i].total += 1;\n                    self.coverage[i].qual += q;\n\n                    self.maximum = Math.max(self.coverage[i].total, self.maximum);\n                }\n            }\n        }\n    }]);\n\n    return CoverageMap;\n}();\n\nCoverageMap.threshold = 0.2;\nCoverageMap.qualityWeight = true;\n\nvar Coverage = function () {\n    function Coverage() {\n        _classCallCheck(this, Coverage);\n\n        this.posA = 0;\n        this.negA = 0;\n\n        this.posT = 0;\n        this.negT = 0;\n\n        this.posC = 0;\n        this.negC = 0;\n        this.posG = 0;\n\n        this.negG = 0;\n\n        this.posN = 0;\n        this.negN = 0;\n\n        this.pos = 0;\n        this.neg = 0;\n\n        this.qualA = 0;\n        this.qualT = 0;\n        this.qualC = 0;\n        this.qualG = 0;\n        this.qualN = 0;\n\n        this.qual = 0;\n\n        this.total = 0;\n    }\n\n    _createClass(Coverage, [{\n        key: \"isMismatch\",\n        value: function isMismatch(refBase) {\n\n            var myself = this,\n                mismatchQualitySum,\n                threshold = CoverageMap.threshold * (CoverageMap.qualityWeight && this.qual ? this.qual : this.total);\n\n            mismatchQualitySum = 0;\n            [\"A\", \"T\", \"C\", \"G\"].forEach(function (base) {\n\n                if (base !== refBase) {\n                    mismatchQualitySum += CoverageMap.qualityWeight && myself.qual ? myself[\"qual\" + base] : myself[\"pos\" + base] + myself[\"neg\" + base];\n                }\n            });\n\n            return mismatchQualitySum >= threshold;\n        }\n    }]);\n\n    return Coverage;\n}();\n\nvar DownsampledInterval = function () {\n    function DownsampledInterval(start, end, counts) {\n        _classCallCheck(this, DownsampledInterval);\n\n        this.start = start;\n        this.end = end;\n        this.counts = counts;\n    }\n\n    _createClass(DownsampledInterval, [{\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n            return [{ name: \"start\", value: this.start + 1 }, { name: \"end\", value: this.end }, { name: \"# downsampled:\", value: this.counts }];\n        }\n    }]);\n\n    return DownsampledInterval;\n}();\n\nvar PairedAlignment = function () {\n    function PairedAlignment(firstAlignment) {\n        _classCallCheck(this, PairedAlignment);\n\n        this.firstAlignment = firstAlignment;\n        this.chr = firstAlignment.chr;\n        this.readName = firstAlignment.readName;\n\n        if (firstAlignment.start < firstAlignment.mate.position) {\n            this.start = firstAlignment.start;\n            this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef); // Approximate\n            this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingEnd = firstAlignment.mate.position;\n        } else {\n            this.start = firstAlignment.mate.position;\n            this.end = firstAlignment.start + firstAlignment.lengthOnRef;\n            this.connectingStart = firstAlignment.mate.position;\n            this.connectingEnd = firstAlignment.start;\n        }\n        this.lengthOnRef = this.end - this.start;\n    }\n\n    _createClass(PairedAlignment, [{\n        key: \"setSecondAlignment\",\n        value: function setSecondAlignment(alignment) {\n\n            // TODO -- check the chrs are equal,  error otherwise\n            this.secondAlignment = alignment;\n\n            if (alignment.start > this.firstAlignment.start) {\n                this.end = alignment.start + alignment.lengthOnRef;\n                this.connectingEnd = alignment.start;\n            } else {\n                this.start = alignment.start;\n                this.connectingStart = alignment.start + alignment.lengthOnRef;\n            }\n            this.lengthOnRef = this.end - this.start;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation) {\n\n            var nameValues = [];\n\n            nameValues = nameValues.concat(this.firstAlignment.popupData(genomicLocation));\n\n            if (this.secondAlignment) {\n                nameValues.push(\"-------------------------------\");\n                nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));\n            }\n            return nameValues;\n        }\n    }, {\n        key: \"isPaired\",\n        value: function isPaired() {\n            return true; // By definition\n        }\n    }, {\n        key: \"firstOfPairStrand\",\n        value: function firstOfPairStrand() {\n            if (this.firstAlignment.isFirstOfPair()) {\n                return this.firstAlignment.strand;\n            } else if (this.secondAlignment) {\n                return this.secondAlignment.strand;\n            } else {\n                return this.firstAlignment.strand; // This assumes inward pointing pairs\n            }\n        }\n    }]);\n\n    return PairedAlignment;\n}();\n\nvar BamAlignmentRow = function () {\n    function BamAlignmentRow() {\n        _classCallCheck(this, BamAlignmentRow);\n\n        this.alignments = [];\n        this.score = undefined;\n    }\n\n    _createClass(BamAlignmentRow, [{\n        key: \"findCenterAlignment\",\n        value: function findCenterAlignment(bpStart, bpEnd) {\n\n            var centerAlignment = undefined;\n\n            // find single alignment that overlaps sort location\n            this.alignments.forEach(function (a) {\n\n                if (undefined === centerAlignment) {\n\n                    if (a.start + a.lengthOnRef < bpStart || a.start > bpEnd) {\n                        // do nothing\n                    } else {\n                        centerAlignment = a;\n                    }\n                }\n            });\n\n            return centerAlignment;\n        }\n    }, {\n        key: \"updateScore\",\n        value: function updateScore(genomicLocation, genomicInterval, sortOption) {\n\n            this.score = this.caculateScore(genomicLocation, 1 + genomicLocation, genomicInterval, sortOption);\n        }\n    }, {\n        key: \"caculateScore\",\n        value: function caculateScore(bpStart, bpEnd, genomicInterval, sortOption) {\n\n            var baseScore, alignment;\n\n            alignment = this.findCenterAlignment(bpStart, bpEnd);\n            if (undefined === alignment) {\n                return Number.MAX_VALUE;\n            }\n\n            if (\"NUCLEOTIDE\" === sortOption.sort) {\n\n                baseScore = undefined;\n\n                alignment.blocks.forEach(function (block) {\n\n                    var sequence = genomicInterval.sequence,\n                        coverageMap = genomicInterval.coverageMap,\n                        reference,\n                        base,\n                        coverage,\n                        count,\n                        phred;\n\n                    if (\"*\" !== block.seq) {\n\n                        for (var i = 0, indexReferenceSequence = block.start - genomicInterval.start, bpBlockSequence = block.start, lengthBlockSequence = block.seq.length; i < lengthBlockSequence; i++, indexReferenceSequence++, bpBlockSequence++) {\n\n                            if (bpStart === bpBlockSequence) {\n\n                                reference = sequence.charAt(indexReferenceSequence);\n                                base = block.seq.charAt(i);\n\n                                if (base === \"=\") {\n                                    base = reference;\n                                }\n\n                                if (base === 'N') {\n                                    baseScore = 2;\n                                } else if (base === reference) {\n                                    baseScore = 3;\n                                } else if (base === \"X\" || base !== reference) {\n\n                                    coverage = coverageMap.coverage[bpBlockSequence - coverageMap.bpStart];\n                                    count = coverage[\"pos\" + base] + coverage[\"neg\" + base];\n                                    phred = coverage.qual ? coverage.qual : 0;\n                                    baseScore = -(count + phred / 1000.0);\n                                } else {\n                                    console.log(\"BamAlignmentRow.caculateScore - huh?\");\n                                }\n                            } // bpStart === bpBlockSequence\n                        } // block.seq.length\n                    } else {\n                        baseScore = 3;\n                    }\n                });\n\n                return undefined === baseScore ? Number.MAX_VALUE : baseScore;\n            } else if (\"STRAND\" === sortOption.sort) {\n\n                return alignment.strand ? 1 : -1;\n            } else if (\"START\" === sortOption.sort) {\n\n                return alignment.start;\n            }\n\n            return Number.MAX_VALUE;\n        }\n    }]);\n\n    return BamAlignmentRow;\n}();\n\nvar bgzBlockSize = function bgzBlockSize(data) {\n    var ba = new Uint8Array(data);\n    var bsize = ba[17] << 8 | ba[16] + 1;\n    return bsize;\n};\n\nfunction decodeTags(ba) {\n\n    var p = 0,\n        len = ba.length,\n        tags = {};\n\n    while (p < len) {\n        var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\n        var type = String.fromCharCode(ba[p + 2]);\n        var value;\n\n        if (type == 'A') {\n            value = String.fromCharCode(ba[p + 3]);\n            p += 4;\n        } else if (type === 'i' || type === 'I') {\n            value = readInt(ba, p + 3);\n            p += 7;\n        } else if (type === 'c' || type === 'C') {\n            value = ba[p + 3];\n            p += 4;\n        } else if (type === 's' || type === 'S') {\n            value = readShort(ba, p + 3);\n            p += 5;\n        } else if (type === 'f') {\n            // TODO 'FIXME need floats';\n            value = readFloat(ba, p + 3);\n            p += 7;\n        } else if (type === 'Z') {\n            p += 3;\n            value = '';\n            for (;;) {\n                var cc = ba[p++];\n                if (cc === 0) {\n                    break;\n                } else {\n                    value += String.fromCharCode(cc);\n                }\n            }\n        } else {\n            //'Unknown type ' + type;\n            value = 'Error unknown type: ' + type;\n            tags[tag] = value;\n            break;\n        }\n        tags[tag] = value;\n    }\n    return tags;\n}\n\nexports.loadBamIndex = loadBamIndex;\nexports.BamReader = BamReader;\nexports.BamSource = BamSource;\nexports.BamFilter = BamFilter;\nexports.BamAlignment = BamAlignment;\nexports.AlignmentContainer = AlignmentContainer;\nexports.PairedAlignment = PairedAlignment;\nexports.bgzBlockSize = bgzBlockSize;\nexports.CoverageMap = CoverageMap;\nexports.Coverage = Coverage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JhbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmFtLmpzP2YzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge2lndnhocn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcbmltcG9ydCB7QmluYXJ5UGFyc2VyfSBmcm9tIFwiLi9iaWd3aWcuanNcIjtcclxuaW1wb3J0IHtqc3psaWJfaW5mbGF0ZV9idWZmZXIsYXJyYXlDb3B5fSBmcm9tIFwiLi92ZW5kb3IvaW5mbGF0ZS5qc1wiO1xyXG5pbXBvcnQge0Zhc3RhU2VxdWVuY2V9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcclxuaW1wb3J0e1psaWJ9IGZyb20gXCIuL3ZlbmRvci96bGliX2FuZF9nemlwLmpzXCI7XHJcblxyXG5cclxuY29uc3QgQkFJX01BR0lDID0gMjE1NzgwNTA7XHJcbmNvbnN0IFRBQklYX01BR0lDID0gMjE1NzgzMjQ7XHJcbmNvbnN0IE1BWF9IRUFERVJfU0laRSA9IDEwMDAwMDAwMDsgICAvLyBJRiB0aGUgaGVhZGVyIGlzIGxhcmdlciB0aGFuIHRoaXMgd2UgY2FuJ3QgcmVhZCBpdCAhXHJcbmNvbnN0IEJfTUFYX0daSVBfQkxPQ0tfU0laRSA9ICgxIDw8IDE2KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhVUkxcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBwYXJhbSB0YWJpeFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZWQgZm9yIHRoZSBiYW0gb3IgdGFiaXggaW5kZXguICBUaGUgZnVsZmlsbCBmdW5jdGlvbiB0YWtlcyB0aGUgaW5kZXggYXMgYW4gYXJndW1lbnQuXHJcbiAgICAgKi9cclxubGV0IGxvYWRCYW1JbmRleCA9IGZ1bmN0aW9uIChpbmRleFVSTCwgY29uZmlnLCB0YWJpeCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGdlbm9tZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKGluZGV4VVJMLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hZ2ljLCBuYmluLCBuaW50diwgbnJlZiwgcGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTWluID0gTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja01heCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmluSW5kZXgsIGxpbmVhckluZGV4LCBiaW5OdW1iZXIsIGNzLCBjZSwgYiwgaSwgcmVmLCBzZXF1ZW5jZUluZGV4TWFwO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGFiaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZSA9IG5ldyBabGliLkd1bnppcChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID0gaW5mbGF0ZS5kZWNvbXByZXNzKCkuYnVmZmVyOyAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFnaWMgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCQUlfTUFHSUMgfHwgKHRhYml4ICYmIG1hZ2ljID09PSBUQUJJWF9NQUdJQykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbnJlZiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJpeCBoZWFkZXIgcGFyYW1ldGVycyBhcmVuJ3QgdXNlZCwgYnV0IHRoZXkgbXVzdCBiZSByZWFkIHRvIGFkdmFuY2UgdGhlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbF9zZXEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xfYmVnID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sX2VuZCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbF9ubSA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSW5kZXhNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5yZWY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcV9uYW1lID0gcGFyc2VyLmdldFN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBcIm9mZmljaWFsXCIgY2hyIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lKSBzZXFfbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShzZXFfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJbmRleE1hcFtzZXFfbmFtZV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHJlZiA9IDA7IHJlZiA8IG5yZWY7ICsrcmVmKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmJpbiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBuYmluOyArK2IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5OdW1iZXIgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbk51bWJlciA9PSAzNzQ1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwc3VlZG8gYmluLCBub3QgdXNlZCBidXQgd2UgaGF2ZSB0byBjb25zdW1lIHRoZSBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5jaG5rID0gcGFyc2VyLmdldEludCgpOyAvLyAjIG9mIGNodW5rcyBmb3IgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpOyAgIC8vIHVubWFwcGVkIGJlZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlID0gcGFyc2VyLmdldFZQb2ludGVyKCk7ICAgLy8gdW5tYXBwZWQgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5fbWFwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVW5tYXBwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmNobmsgPSBwYXJzZXIuZ2V0SW50KCk7IC8vICMgb2YgY2h1bmtzIGZvciB0aGlzIGJpblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmNobms7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZSA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3MgJiYgY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcy5ibG9jayA8IGJsb2NrTWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNaW4gPSBjcy5ibG9jazsgICAgLy8gQmxvY2sgY29udGFpbmluZyBmaXJzdCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZS5ibG9jayA+IGJsb2NrTWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNYXggPSBjZS5ibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0ucHVzaChbY3MsIGNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaW50diA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5pbnR2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gcGFyc2VyLmdldFZQb2ludGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleC5wdXNoKGNzKTsgICAvLyBNaWdodCBiZSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYmluID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1tyZWZdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4OiBiaW5JbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleDogbGluZWFySW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmRleFVSTCArIFwiIGlzIG5vdCBhIFwiICsgKHRhYml4ID8gXCJ0YWJpeFwiIDogXCJiYWlcIikgKyBcIiBmaWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChuZXcgQmFtSW5kZXgoaW5kaWNlcywgYmxvY2tNaW4sIGJsb2NrTWF4LCBzZXF1ZW5jZUluZGV4TWFwLCB0YWJpeCkpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuY2xhc3MgQmFtSW5kZXh7XHJcbiAgICBjb25zdHJ1Y3RvciAoaW5kaWNlcywgYmxvY2tNaW4sYmxvY2tNYXgsIHNlcXVlbmNlSW5kZXhNYXAsIHRhYml4KSB7XHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudEJsb2NrID0gYmxvY2tNaW47XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB0aGlzLmxhc3RBbGlnbm1lbnRCbG9jayA9IGJsb2NrTWF4O1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleE1hcCA9IHNlcXVlbmNlSW5kZXhNYXA7XHJcbiAgICAgICAgdGhpcy50YWJpeCA9IHRhYml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2ggYmxvY2tzIGZvciBhIHBhcnRpY3VsYXIgZ2Vub21pYyByYW5nZS4gIFRoaXMgbWV0aG9kIGlzIHB1YmxpYyBzbyBpdCBjYW4gYmUgdW5pdC10ZXN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlZklkICB0aGUgc2VxdWVuY2UgZGljdGlvbmFyeSBpbmRleCBvZiB0aGUgY2hyb21vc29tZVxyXG4gICAgICogQHBhcmFtIG1pbiAgZ2Vub21pYyBzdGFydCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIG1heCAgZ2Vub21pYyBlbmQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSByZXR1cm4gYW4gYXJyYXkgb2Yge21pbnY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fSwge21heHY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fX1cclxuICAgICAqL1xyXG4gICAgYmxvY2tzRm9yUmFuZ2UocmVmSWQsIG1pbiwgbWF4KSB7XHJcblxyXG4gICAgICAgIHZhciBiYW0gPSB0aGlzLFxyXG4gICAgICAgICAgICBiYSA9IGJhbS5pbmRpY2VzW3JlZklkXSxcclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zLFxyXG4gICAgICAgICAgICBjaHVua3MsXHJcbiAgICAgICAgICAgIG5pbnR2LFxyXG4gICAgICAgICAgICBsb3dlc3QsXHJcbiAgICAgICAgICAgIG1pbkxpbixcclxuICAgICAgICAgICAgbWF4TGluLFxyXG4gICAgICAgICAgICB2cCxcclxuICAgICAgICAgICAgaVxyXG5cclxuICAgICAgICBpZiAoIWJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyA9IEJhbUluZGV4LnJlZzJiaW5zKG1pbiwgbWF4KTtcclxuICAgICAgICAgICAgY2h1bmtzPVtdICAgICAgICAvLyBMaXN0IG9mIGJpbiAjcyB0aGF0IG1pZ2h0IG92ZXJsYXAgbWluLCBtYXhcclxuICAgICAgICAgICBcclxuXHJcblxyXG4gICAgICAgICAgICBvdmVybGFwcGluZ0JpbnMuZm9yRWFjaChmdW5jdGlvbiAoYmluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmluQ2h1bmtzID0gYmEuYmluSW5kZXhbYmluXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmNobmsgPSBiaW5DaHVua3MubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5jaG5rOyArK2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzID0gYmluQ2h1bmtzW2NdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2UgPSBiaW5DaHVua3NbY11bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHttaW52OiBjcywgbWF4djogY2UsIGJpbjogYmlufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGxpbmVhciBpbmRleCB0byBmaW5kIHRoZSBsb3dlc3QgY2h1bmsgdGhhdCBjb3VsZCBjb250YWluIGFsaWdubWVudHMgaW4gdGhlIHJlZ2lvblxyXG4gICAgICAgICAgICBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDtcclxuICAgICAgICAgICAgbG93ZXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgbWluTGluID0gTWF0aC5taW4obWluID4+IDE0LCBuaW50diAtIDEpLCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdnAgPSBiYS5saW5lYXJJbmRleFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh2cCkge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuaXNMZXNzVGhhbihsb3dlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdCA9IHZwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQcnVuZSBjaHVua3MgdGhhdCBlbmQgYmVmb3JlIHRoZSBsb3dlc3QgY2h1bmtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbG93ZXN0KTsgXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGxpc3Qgb2YgYmlucyB0aGF0IG1heSBvdmVybGFwIHdpdGggcmVnaW9uIFtiZWcsIGVuZF1cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWcyYmlucyhiZWcsIGVuZCkge1xyXG4gICAgICAgIHZhciBpID0gMCwgaywgbGlzdCA9IFtdO1xyXG4gICAgICAgIGlmIChlbmQgPj0gMSA8PCAyOSkgICBlbmQgPSAxIDw8IDI5O1xyXG4gICAgICAgIC0tZW5kO1xyXG4gICAgICAgIGxpc3QucHVzaCgwKTtcclxuICAgICAgICBmb3IgKGsgPSAxICsgKGJlZyA+PiAyNik7IGsgPD0gMSArIChlbmQgPj4gMjYpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA5ICsgKGJlZyA+PiAyMyk7IGsgPD0gOSArIChlbmQgPj4gMjMpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA3MyArIChiZWcgPj4gMjApOyBrIDw9IDczICsgKGVuZCA+PiAyMCk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDU4NSArIChiZWcgPj4gMTcpOyBrIDw9IDU4NSArIChlbmQgPj4gMTcpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA0NjgxICsgKGJlZyA+PiAxNCk7IGsgPD0gNDY4MSArIChlbmQgPj4gMTQpOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdCkge1xyXG5cclxuICAgIHZhciBtZXJnZWRDaHVua3MgPSBbXSxcclxuICAgICAgICBsYXN0Q2h1bmsgPSBudWxsO1xyXG5cclxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSByZXR1cm4gY2h1bmtzO1xyXG5cclxuICAgIGNodW5rcy5zb3J0KGZ1bmN0aW9uIChjMCwgYzEpIHtcclxuICAgICAgICB2YXIgZGlmID0gYzAubWludi5ibG9jayAtIGMxLm1pbnYuYmxvY2s7XHJcbiAgICAgICAgaWYgKGRpZiAhPSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGMwLm1pbnYub2Zmc2V0IC0gYzEubWludi5vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XHJcblxyXG4gICAgICAgIGlmICghbG93ZXN0IHx8IGNodW5rLm1heHYuaXNHcmVhdGVyVGhhbihsb3dlc3QpKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjaHVuay5taW52LmJsb2NrIC0gbGFzdENodW5rLm1heHYuYmxvY2spIDwgNjUwMDApIHsgLy8gTWVyZ2UgY2h1bmtzIHRoYXQgYXJlIHdpdGhpbmcgNjVrIG9mIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubWF4di5pc0dyZWF0ZXJUaGFuKGxhc3RDaHVuay5tYXh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2h1bmsubWF4diA9IGNodW5rLm1heHY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENodW5rID0gY2h1bms7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCR1pGaWxle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChjb25maWcpIHtcclxuICAgICAgICB0aGlzLmZpbGVQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgbmV4dEJsb2NrKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHNlbGYuZmlsZVBvc2l0aW9uLCBzaXplOiBCTE9DS19IRUFERVJfTEVOR1RIfSxcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG5cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHhsZW4gPSAoYmFbMTFdIDw8IDgpIHwgKGJhWzEwXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kxID0gYmFbMTJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgICAgIHZhciBzbGVuID0gKGJhWzE1XSA8PCA4KSB8IChiYVsxNF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmZpbGVQb3NpdGlvbiArPSBCTE9DS19IRUFERVJfTEVOR1RIO1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzZWxmLmZpbGVQb3NpdGlvbiwgc2l6ZTogYnNpemV9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuYyA9IGpzemxpYl9pbmZsYXRlX2J1ZmZlcihhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlsZVBvc2l0aW9uICs9IChic2l6ZSArIDgpOyAgLy8gXCI4XCIgZm9yIENSQy0zMiBhbmQgc2l6ZSBvZiB1bmNvbXByZXNzZWQgZGF0YVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiAgICB2YXIgQkFNX01BR0lDID0gMjE4NDAxOTQ7XHJcbiAgICB2YXIgU0VDUkVUX0RFQ09ERVIgPSBbJz0nLCAnQScsICdDJywgJ3gnLCAnRycsICd4JywgJ3gnLCAneCcsICdUJywgJ3gnLCAneCcsICd4JywgJ3gnLCAneCcsICd4JywgJ04nXTtcclxuICAgIHZhciBDSUdBUl9ERUNPREVSID0gWydNJywgJ0knLCAnRCcsICdOJywgJ1MnLCAnSCcsICdQJywgJz0nLCAnWCcsICc/JywgJz8nLCAnPycsICc/JywgJz8nLCAnPycsICc/J107XHJcbiAgICB2YXIgUkVBRF9TVFJBTkRfRkxBRyA9IDB4MTA7XHJcbiAgICB2YXIgTUFURV9TVFJBTkRfRkxBRyA9IDB4MjA7XHJcbiAgICB2YXIgRklSU1RfT0ZfUEFJUl9GTEFHID0gMHg0MDtcclxuICAgIHZhciBTRUNPTkRfT0ZfUEFJUl9GTEFHID0gMHg4MDtcclxuICAgIHZhciBSRUFEX1VOTUFQUEVEX0ZMQUcgPSAweDQ7XHJcbiAgICB2YXIgTUFURV9VTk1BUFBFRF9GTEFHID0gMHg4O1xyXG4gICAgdmFyIFJFQURfUEFJUkVEX0ZMQUcgPSAweDE7XHJcbiAgICB2YXIgUFJPUEVSX1BBSVJfRkxBRyA9IDB4MjtcclxuICAgIHZhciBTRUNPTkRBUllfQUxJR05NTkVUX0ZMQUcgPSAweDEwMDtcclxuICAgIHZhciBTVVBQTEVNRU5UQVJZX0FMSUdOTUVOVF9GTEFHID0gMHg4MDA7XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIE5PVF9QUklNQVJZX0FMSUdOTUVOVF9GTEFHID0gMHgxMDA7XHJcbiAgICB2YXIgUkVBRF9GQUlMU19WRU5ET1JfUVVBTElUWV9DSEVDS19GTEFHID0gMHgyMDA7XHJcbiAgICB2YXIgRFVQTElDQVRFX1JFQURfRkxBRyA9IDB4NDAwO1xyXG4gICAgdmFyIFNVUFBMRU1FTlRBUllfRkxBRyA9IDB4ODAwO1xyXG5cclxuICAgIGNvbnN0IE1BWF9HWklQX0JMT0NLX1NJWkUgPSA2NTUzNjsgICAvLyAgQVBQQVJFTlRMWS4gIFdoZXJlIGlzIHRoaXMgZG9jdW1lbnRlZD8/P1xyXG4gICAgY29uc3QgREVGQVVMVF9TQU1QTElOR19XSU5ET1dfU0laRSA9IDEwMDtcclxuICAgIGNvbnN0IERFRkFVTFRfU0FNUExJTkdfREVQVEggPSA1MDtcclxuICAgIGNvbnN0IE1BWElNVU1fU0FNUExJTkdfREVQVEggPSAyNTAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgZm9yIHJlYWRpbmcgYSBiYW0gZmlsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiBjbGFzcyBCYW1SZWFkZXJ7XHJcbiAgICAgY29uc3RydWN0b3IoY29uZmlnLHBhcmVudCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLnBhcmVudD1wYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5hY19jbGFzcz1BbGlnbm1lbnRDb250YWluZXJcclxuICAgICAgICBpZiAocGFyZW50LmFjX2NsYXNzKXtcclxuICAgICAgICAgICAgdGhpcy5hY19jbGFzcz0gcGFyZW50X2NsYXNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBjb25maWcuZmlsdGVyIHx8IG5ldyBCYW1GaWx0ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYW1QYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICAvLyBUb2RvIC0gZGVhbCB3aXRoIFBpY2FyZCBjb252ZW50aW9uLiAgV0hZIERPRVMgVEhFUkUgSEFWRSBUTyBCRSAyP1xyXG4gICAgICAgIHRoaXMuYmFpUGF0aCA9IGNvbmZpZy5pbmRleFVSTCB8fCB0aGlzLmJhbVBhdGggKyBcIi5iYWlcIjsgLy8gSWYgdGhlcmUgaXMgYW4gaW5kZXhVUkwgcHJvdmlkZWQsIHVzZSBpdCFcclxuICAgICAgICB0aGlzLmhlYWRQYXRoID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5iYW1QYXRoO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ1dpbmRvd1NpemUgPSBjb25maWcuc2FtcGxpbmdXaW5kb3dTaXplID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1NBTVBMSU5HX1dJTkRPV19TSVpFIDogY29uZmlnLnNhbXBsaW5nV2luZG93U2l6ZTtcclxuICAgICAgICB0aGlzLnNhbXBsaW5nRGVwdGggPSBjb25maWcuc2FtcGxpbmdEZXB0aCA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9TQU1QTElOR19ERVBUSCA6IGNvbmZpZy5zYW1wbGluZ0RlcHRoO1xyXG4gICAgICAgIGlmKHRoaXMuc2FtcGxpbmdEZXB0aCA+IE1BWElNVU1fU0FNUExJTkdfREVQVEgpIHtcclxuICAgICAgICAgICAgaWd2LmxvZyhcIldhcm5pbmc6IGF0dGVtcHQgdG8gc2V0IHNhbXBsaW5nIGRlcHRoID4gbWF4aW11bSB2YWx1ZSBvZiAyNTAwXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNhbXBsaW5nRGVwdGggPSBNQVhJTVVNX1NBTVBMSU5HX0RFUFRIO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnNTdXBwb3J0ZWQgPSBjb25maWcucGFpcnNTdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucGFpcnNTdXBwb3J0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZWFkQWxpZ25tZW50cyhjaHIsIGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBnZXRDaHJJbmRleChzZWxmKS50aGVuKGZ1bmN0aW9uIChjaHJUb0luZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNocklkID0gY2hyVG9JbmRleFtjaHJdLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIgPSBuZXcgc2VsZi5hY19jbGFzcyhjaHIsIGJwU3RhcnQsIGJwRW5kLCBzZWxmLnNhbXBsaW5nV2luZG93U2l6ZSwgc2VsZi5zYW1wbGluZ0RlcHRoLCBzZWxmLnBhaXJzU3VwcG9ydGVkLHNlbGYucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoYmFtSW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBiYW1JbmRleC5ibG9ja3NGb3JSYW5nZShjaHJJZCwgYnBTdGFydCwgYnBFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcIkVycm9yIHJlYWRpbmcgYmFtIGluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaE1pbiA9IGMubWludi5ibG9jayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNYXggPSBjLm1heHYuYmxvY2sgKyBNQVhfR1pJUF9CTE9DS19TSVpFLCAgIC8vIE1ha2Ugc3VyZSB3ZSBnZXQgdGhlIHdob2xlIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtzdGFydDogZmV0Y2hNaW4sIHNpemU6IGZldGNoTWF4IC0gZmV0Y2hNaW4gKyAxfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLmJhbVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShuZXcgdW5iZ3pmKGNvbXByZXNzZWQpKTsgLy9uZXcgVWludDhBcnJheShpZ3YudW5iZ3pmKGNvbXByZXNzZWQpKTsgLy8sIGMubWF4di5ibG9jayAtIGMubWludi5ibG9jayArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlQmFtUmVjb3JkcyhiYSwgYy5taW52Lm9mZnNldCwgYWxpZ25tZW50Q29udGFpbmVyLCBicFN0YXJ0LCBicEVuZCwgY2hySWQsIHNlbGYuZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5maW5pc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVCYW1SZWNvcmRzKGJhLCBvZmZzZXQsIGFsaWdubWVudENvbnRhaW5lciwgbWluLCBtYXgsIGNocklkLCBmaWx0ZXIpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBibG9ja0VuZCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIHJlZklELFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICAgICAgYm1uLFxyXG4gICAgICAgICAgICAgICAgYmluLFxyXG4gICAgICAgICAgICAgICAgbXEsXHJcbiAgICAgICAgICAgICAgICBubCxcclxuICAgICAgICAgICAgICAgIGZsYWdfbmMsXHJcbiAgICAgICAgICAgICAgICBmbGFnLFxyXG4gICAgICAgICAgICAgICAgbmMsXHJcbiAgICAgICAgICAgICAgICBsc2VxLFxyXG4gICAgICAgICAgICAgICAgbWF0ZVJlZklELFxyXG4gICAgICAgICAgICAgICAgbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgIHJlYWROYW1lLFxyXG4gICAgICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgICAgIHAsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGhPblJlZixcclxuICAgICAgICAgICAgICAgIGNpZ2FyLFxyXG4gICAgICAgICAgICAgICAgYyxcclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXksXHJcbiAgICAgICAgICAgICAgICBzZXEsXHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplID0gcmVhZEludChiYSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGJsb2NrRW5kID0gb2Zmc2V0ICsgYmxvY2tTaXplICsgNDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbmQgPiBiYS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gbmV3IEJhbUFsaWdubWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZklEID0gcmVhZEludChiYSwgb2Zmc2V0ICsgNCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSByZWFkSW50KGJhLCBvZmZzZXQgKyA4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZWZJRCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAgLy8gdW5tYXBwZWQgcmVhZHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZklEID4gY2hySWQgfHwgcG9zID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBvZmYgcmlnaHQgZWRnZSwgd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmSUQgPCBjaHJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgIC8vIHRvIGxlZnQgb2Ygc3RhcnQsIG5vdCBzdXJlIHRoaXMgaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBibW4gPSByZWFkSW50KGJhLCBvZmZzZXQgKyAxMik7XHJcbiAgICAgICAgICAgICAgICBiaW4gPSAoYm1uICYgMHhmZmZmMDAwMCkgPj4gMTY7XHJcbiAgICAgICAgICAgICAgICBtcSA9IChibW4gJiAweGZmMDApID4+IDg7XHJcbiAgICAgICAgICAgICAgICBubCA9IGJtbiAmIDB4ZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxhZ19uYyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDE2KTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSAoZmxhZ19uYyAmIDB4ZmZmZjAwMDApID4+IDE2O1xyXG4gICAgICAgICAgICAgICAgbmMgPSBmbGFnX25jICYgMHhmZmZmO1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5mbGFncyA9IGZsYWc7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc3RyYW5kID0gIShmbGFnICYgUkVBRF9TVFJBTkRfRkxBRyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbHNlcSA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDIwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRlUmVmSUQgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyNCk7XHJcbiAgICAgICAgICAgICAgICBtYXRlUG9zID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjgpO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmZyYWdtZW50TGVuZ3RoID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMzIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlYWROYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmwgLSAxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkTmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW29mZnNldCArIDM2ICsgal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHAgPSBvZmZzZXQgKyAzNiArIG5sO1xyXG5cclxuICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmID0gMDtcclxuICAgICAgICAgICAgICAgIGNpZ2FyID0gJyc7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBuYzsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpZ29wID0gcmVhZEludChiYSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wTGVuID0gKGNpZ29wID4+IDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcEx0ciA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAweGZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcEx0ciA9PSAnTScgfHwgb3BMdHIgPT0gJ0VRJyB8fCBvcEx0ciA9PSAnWCcgfHwgb3BMdHIgPT0gJ0QnIHx8IG9wTHRyID09ICdOJyB8fCBvcEx0ciA9PSAnPScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmICs9IG9wTGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNpZ2FyID0gY2lnYXIgKyBvcExlbiArIG9wTHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2lnYXJBcnJheS5wdXNoKHtsZW46IG9wTGVuLCBsdHI6IG9wTHRyfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuY2lnYXIgPSBjaWdhcjtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5sZW5ndGhPblJlZiA9IGxlbmd0aE9uUmVmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgPCBtaW4pIGNvbnRpbnVlOyAgLy8gUmVjb3JkIG91dC1vZi1yYW5nZSBcInRvIHRoZSBsZWZ0XCIsIHNraXAgdG8gbmV4dCBvbmVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgc2VxID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcyA9IChsc2VxICsgMSkgPj4gMTtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZXFCeXRlczsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNiID0gYmFbcCArIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcSArPSBTRUNSRVRfREVDT0RFUlsoc2IgJiAweGYwKSA+PiA0XTtcclxuICAgICAgICAgICAgICAgICAgICBzZXEgKz0gU0VDUkVUX0RFQ09ERVJbKHNiICYgMHgwZildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VxID0gc2VxLnN1YnN0cmluZygwLCBsc2VxKTsgIC8vIHNlcSBtaWdodCBoYXZlIG9uZSBleHRyYSBjaGFyYWN0ZXIgKGlmIGxzZXEgaXMgYW4gb2RkIG51bWJlcilcclxuXHJcbiAgICAgICAgICAgICAgICBwICs9IHNlcUJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnNlcSA9IHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxzZXEgPT09IDEgJiYgU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgal0gKyAzMykgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyA9PSBob3cgdG8gcmVwcmVzZW50IHRoaXM/XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQucXVhbCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsc2VxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LnF1YWwucHVzaChiYVtwICsgal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAgKz0gbHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnN0YXJ0ID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Lm1xID0gbXE7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQucmVhZE5hbWUgPSByZWFkTmFtZTtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPSBzZWxmLmluZGV4VG9DaHJbcmVmSURdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRlUmVmSUQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5tYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHI6IHNlbGYuaW5kZXhUb0NoclttYXRlUmVmSURdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYW5kOiAhKGZsYWcgJiBNQVRFX1NUUkFORF9GTEFHKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC50YWdCQSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlci5zbGljZShwLCBibG9ja0VuZCkpOyAgLy8gZGVjb2RlIHRoaWVzZSBvbiBkZW1hbmRcclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFtaW4gfHwgYWxpZ25tZW50LnN0YXJ0IDw9IG1heCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiA+PSBtaW4gJiZcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucGFzcyhhbGlnbm1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkID09PSB1bmRlZmluZWQgfHwgcmVmSUQgPT0gY2hySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0gbWFrZUJsb2NrcyhhbGlnbm1lbnQsIGNpZ2FyQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQuYmxvY2tzID0gYmxvY2tzLmJsb2NrcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Lmluc2VydGlvbnMgPSBibG9ja3MuaW5zZXJ0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBibG9ja0VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFeGl0cyB2aWEgdG9wIG9mIGxvb3AuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdCB0aGUgYWxpZ25tZW50IHJlY29yZCBpbnRvIGJsb2NrcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNpZ2FyQXJyYXkuICBFYWNoIGFsaWduZWQgYmxvY2sgY29udGFpbnNcclxuICAgICAgICAgKiBpdHMgcG9ydGlvbiBvZiB0aGUgcmVhZCBzZXF1ZW5jZSBhbmQgYmFzZSBxdWFsaXR5IHN0cmluZ3MuICBBIHJlYWQgc2VxdWVuY2Ugb3IgYmFzZSBxdWFsaXR5IHN0cmluZ1xyXG4gICAgICAgICAqIG9mIFwiKlwiIGluZGljYXRlcyB0aGUgdmFsdWUgaXMgbm90IHJlY29yZGVkLiAgSW4gYWxsIG90aGVyIGNhc2VzIHRoZSBsZW5ndGggb2YgdGhlIGJsb2NrIHNlcXVlbmNlIChibG9jay5zZXEpXHJcbiAgICAgICAgICogYW5kIHF1YWxpdHkgc3RyaW5nIChibG9jay5xdWFsKSBtdXN0ID09IHRoZSBibG9jayBsZW5ndGguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBJbnNlcnRpb25zIGFyZSBub3QgeWV0IHRyZWF0ZWQgLy8gVE9ET1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHJlY29yZFxyXG4gICAgICAgICAqIEBwYXJhbSBjaWdhckFycmF5XHJcbiAgICAgICAgICogQHJldHVybnMgYXJyYXkgb2YgYmxvY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUJsb2NrcyhyZWNvcmQsIGNpZ2FyQXJyYXkpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBbXSxcclxuICAgICAgICAgICAgICAgIGluc2VydGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzZXFPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVjb3JkLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuID0gY2lnYXJBcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlcSxcclxuICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMsXHJcbiAgICAgICAgICAgICAgICBnYXBUeXBlLFxyXG4gICAgICAgICAgICAgICAgbWluUSA9IDUsICAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUlOKVxyXG4gICAgICAgICAgICAgICAgbWF4USA9IDIwOyAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUFYKVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjID0gY2lnYXJBcnJheVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMubHRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWdub3JlIGhhcmQgY2xpcHNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZ25vcmUgcGFkc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ1MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gc29mdCBjbGlwIHJlYWQgYmFzZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwVHlwZSA9ICdOJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAvLyByZWZlcmVuY2Ugc2tpcFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0QnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ0QnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdJJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU2VxID0gcmVjb3JkLnNlcSA9PT0gXCIqXCIgPyBcIipcIiA6IHJlY29yZC5zZXEuc3Vic3RyKHNlcU9mZnNldCwgYy5sZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1F1YWxzID0gcmVjb3JkLnF1YWwgPyByZWNvcmQucXVhbC5zbGljZShzZXFPZmZzZXQsIGMubGVuKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbnMgPT09IHVuZGVmaW5lZCkgaW5zZXJ0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zLnB1c2goe3N0YXJ0OiBwb3MsIGxlbjogYy5sZW4sIHNlcTogYmxvY2tTZXEsIHF1YWw6IGJsb2NrUXVhbHN9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVEnIDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWCcgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSByZWNvcmQuc2VxID09PSBcIipcIiA/IFwiKlwiIDogcmVjb3JkLnNlcS5zdWJzdHIoc2VxT2Zmc2V0LCBjLmxlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMgPSByZWNvcmQucXVhbCA/IHJlY29yZC5xdWFsLnNsaWNlKHNlcU9mZnNldCwgYy5sZW4pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaCh7c3RhcnQ6IHBvcywgbGVuOiBjLmxlbiwgc2VxOiBibG9ja1NlcSwgcXVhbDogYmxvY2tRdWFscywgZ2FwVHlwZTogZ2FwVHlwZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFPZmZzZXQgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBwcm9jZXNzaW5nIGNpZ2FyIGVsZW1lbnQ6IFwiICsgYy5sZW4gKyBjLmx0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7YmxvY2tzOiBibG9ja3MsIGluc2VydGlvbnM6IGluc2VydGlvbnN9O1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gaW5kZXguZmlyc3RBbGlnbm1lbnRCbG9jayArIE1BWF9HWklQX0JMT0NLX1NJWkU7ICAgLy8gSW5zdXJlIHdlIGdldCB0aGUgY29tcGxldGUgY29tcHJlc3NlZCBibG9jayBjb250YWluaW5nIHRoZSBoZWFkZXJcclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYuYmFtUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiBsZW59LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSBuZXcgdW5iZ3pmKGNvbXByZXNzZWRCdWZmZXIsIGxlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFnaWMgPSByZWFkSW50KHVuY2JhLCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtSGVhZGVyTGVuID0gcmVhZEludCh1bmNiYSwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciA9ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbUhlYWRlckxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuY2JhW2kgKyA4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgblJlZiA9IHJlYWRJbnQodW5jYmEsIHNhbUhlYWRlckxlbiArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gc2FtSGVhZGVyTGVuICsgMTI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyVG9JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhUb0NociA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJlZjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsTmFtZSA9IHJlYWRJbnQodW5jYmEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxOYW1lIC0gMTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5jYmFbcCArIDQgKyBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxSZWYgPSByZWFkSW50KHVuY2JhLCBwICsgbE5hbWUgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kbG9nKG5hbWUgKyAnOiAnICsgbFJlZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lICYmIGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJUb0luZGV4W25hbWVdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFRvQ2hyLnB1c2gobmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIDggKyBsTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5pbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQmFtSW5kZXgoYmFtLmJhaVBhdGgsIGJhbS5jb25maWcpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFtLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2hySW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmNoclRvSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmNoclRvSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFtLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5jaHJUb0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkSW50KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDNdIDw8IDI0KSB8IChiYVtvZmZzZXQgKyAyXSA8PCAxNikgfCAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZFNob3J0KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQmFtU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLHBhcmVudCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmFsaWdubWVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1heFJvd3MgPSBjb25maWcubWF4Um93cyB8fCAxMDAwO1xyXG4gICAgICAgIGlmIChjb25maWcuc2VxX3VybCl7XHJcbiAgICAgICAgICAgIHRoaXMuc2VxdWVuY2Vfc291cmNlPW5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy5zZXFfdXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJlbnQ9cGFyZW50O1xyXG5cclxuICAgICAgICB0aGlzLnBhY2tfYWxpZ25tZW50cz10cnVlO1xyXG4gICAgICAgXHJcblxyXG4gICAgICAgIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJnYTRnaFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFtUmVhZGVyID0gbmV3IGlndi5HYTRnaEFsaWdubWVudFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYW1SZWFkZXIgPSBuZXcgQmFtUmVhZGVyKGNvbmZpZyxwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgc2V0Vmlld0FzUGFpcnMoYm9vbCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmlld0FzUGFpcnMgIT09IGJvb2wpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3QXNQYWlycyA9IGJvb2w7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLS0gcmVwYWlyIGFsaWdubWVudHNcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ25tZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ25tZW50Q29udGFpbmVyID0gdGhpcy5hbGlnbm1lbnRDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9vbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSBwYWlyQWxpZ25tZW50cyhhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gdW5wYWlyQWxpZ25tZW50cyhhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyA9IHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIGFsaWdubWVudENvbnRhaW5lci5zdGFydCwgYWxpZ25tZW50Q29udGFpbmVyLmVuZCwgc2VsZi5tYXhSb3dzKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QWxpZ25tZW50cyhjaHIsIGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuYWxpZ25tZW50Q29udGFpbmVyICYmIHNlbGYuYWxpZ25tZW50Q29udGFpbmVyLmNvbnRhaW5zKGNociwgYnBTdGFydCwgYnBFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmJhbVJlYWRlci5yZWFkQWxpZ25tZW50cyhjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bmN0aW9uIChhbGlnbm1lbnRDb250YWluZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFJvd3MgPSBzZWxmLmNvbmZpZy5tYXhSb3dzIHx8IDUwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IGFsaWdubWVudENvbnRhaW5lci5hbGlnbm1lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYudmlld0FzUGFpcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IHVucGFpckFsaWdubWVudHMoW3thbGlnbm1lbnRzOiBhbGlnbm1lbnRzfV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQuZGlzcGxheV9hbGlnbm1lbnRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzID0gcGFja0FsaWdubWVudFJvd3MoYWxpZ25tZW50cywgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kLCBtYXhSb3dzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5hbGlnbm1lbnRzID0gdW5kZWZpbmVkOyAgLy8gRG9uJ3QgbmVlZCB0byBob2xkIG9udG8gdGhlc2UgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50Q29udGFpbmVyID0gYWxpZ25tZW50Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlcXVlbmNlX3NvdXJjZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlX3NvdXJjZS5nZXRTZXF1ZW5jZShhbGlnbm1lbnRDb250YWluZXIuY2hyLCBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsIGFsaWdubWVudENvbnRhaW5lci5lbmQpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwLnJlZlNlcSA9IHNlcXVlbmNlOyAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnNlcXVlbmNlID0gc2VxdWVuY2U7ICAgICAgICAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiAgICBmdW5jdGlvbiBwYWlyQWxpZ25tZW50cyhyb3dzKSB7XHJcblxyXG4gICAgICAgIHZhciBwYWlyQ2FjaGUgPSB7fSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XHJcblxyXG4gICAgICAgICAgICByb3cuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYW5CZVBhaXJlZChhbGlnbm1lbnQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHBhaXJDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyZWRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXSA9IHVuZGVmaW5lZDsgICAvLyBEb24ndCBuZWVkIHRvIHRyYWNrIHRoaXMgYW55bW9yZS5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IG5ldyBpZ3YuUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYWlyZWRBbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVucGFpckFsaWdubWVudHMocm93cykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICByb3cuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgaW5zdGFuY2VvZiBQYWlyZWRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KSByZXN1bHQucHVzaChhbGlnbm1lbnQuZmlyc3RBbGlnbm1lbnQpOyAgLy8gc2hvdWxkbid0IG5lZWQgdGhlIG51bGwgdGVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50KSByZXN1bHQucHVzaChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbkJlUGFpcmVkKGFsaWdubWVudCkge1xyXG4gICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNQYWlyZWQoKSAmJlxyXG4gICAgICAgICAgICBhbGlnbm1lbnQuaXNNYXRlTWFwcGVkKCkgJiZcclxuICAgICAgICAgICAgYWxpZ25tZW50LmNociA9PT0gYWxpZ25tZW50Lm1hdGUuY2hyICYmXHJcbiAgICAgICAgICAgIChhbGlnbm1lbnQuaXNGaXJzdE9mUGFpcigpIHx8IGFsaWdubWVudC5pc1NlY29uZE9mUGFpcigpKSAmJiAhKGFsaWdubWVudC5pc1NlY29uZGFyeSgpIHx8IGFsaWdubWVudC5pc1N1cHBsZW1lbnRhcnkoKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIHN0YXJ0LCBlbmQsIG1heFJvd3MpIHtcclxuXHJcbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzKSByZXR1cm47XHJcblxyXG4gICAgICAgIGFsaWdubWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1Y2tldExpc3QgPSBbXSxcclxuICAgICAgICAgICAgICAgIGFsbG9jYXRlZENvdW50ID0gMCxcclxuICAgICAgICAgICAgICAgIGxhc3RBbGxvY2F0ZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSBzdGFydCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdyxcclxuICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgYnVja2V0LFxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50U3BhY2UgPSA0ICogMixcclxuICAgICAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MgPSBbXSxcclxuICAgICAgICAgICAgICAgIGJ1Y2tldFN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIGFsaWdubWVudHNbMF0uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYnVja0xpc3RJbmRleCA9IE1hdGgubWF4KDAsIGFsaWdubWVudC5zdGFydCAtIGJ1Y2tldFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGFsbG9jYXRlZENvdW50IDwgYWxpZ25tZW50cy5sZW5ndGggJiYgcGFja2VkQWxpZ25tZW50Um93cy5sZW5ndGggPCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Um93ID0gbmV3IEJhbUFsaWdubWVudFJvdygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U3RhcnQgPD0gZW5kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFidWNrZXQgJiYgbmV4dFN0YXJ0IDw9IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0U3RhcnQgLSBidWNrZXRTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Y2tldExpc3RbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbmV4dFN0YXJ0OyAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudHMgYXQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gYnVja2V0TGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyB3aGlsZSAoYnVja2V0KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1Y2tldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gYnVja2V0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBidWNrZXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldExpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Um93LmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiArIGFsaWdubWVudFNwYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgICsrYWxsb2NhdGVkQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfSAvLyB3aGlsZSAobmV4dFN0YXJ0KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnRSb3cuYWxpZ25tZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFja2VkQWxpZ25tZW50Um93cy5wdXNoKGFsaWdubWVudFJvdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gYnVja2V0U3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbG9jYXRlZENvdW50ID09PSBsYXN0QWxsb2NhdGVkQ291bnQpIGJyZWFrOyAgIC8vIFByb3RlY3QgZnJvbSBpbmZpbml0ZSBsb29wc1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RBbGxvY2F0ZWRDb3VudCA9IGFsbG9jYXRlZENvdW50O1xyXG5cclxuICAgICAgICAgICAgfSAvLyB3aGlsZSAoYWxsb2NhdGVkQ291bnQpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFja2VkQWxpZ25tZW50Um93cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbmNsYXNzIEJhbUFsaWdubWVudHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpc01hcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1VOTUFQUEVEX0ZMQUcpID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYWlyZWQgKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfUEFJUkVEX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQcm9wZXJQYWlyICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBQUk9QRVJfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmlyc3RPZlBhaXIoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgRklSU1RfT0ZfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2Vjb25kT2ZQYWlyKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFNFQ09ORF9PRl9QQUlSX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNTZWNvbmRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgU0VDT05EQVJZX0FMSUdOTU5FVF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU3VwcGxlbWVudGFyeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBTVVBQTEVNRU5UQVJZX0FMSUdOTUVOVF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUkVBRF9GQUlMU19WRU5ET1JfUVVBTElUWV9DSEVDS19GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRHVwbGljYXRlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIERVUExJQ0FURV9SRUFEX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXRlTWFwcGVkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIE1BVEVfVU5NQVBQRURfRkxBRykgPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc05lZ2F0aXZlU3RyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfU1RSQU5EX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXRlTmVnYXRpdmVTdHJhbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgTUFURV9TVFJBTkRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0YWdzKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVUYWdzKGJhKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcCA9IDAsXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBiYS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB0YWdzID0ge307XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocCA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcF0pICsgU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAyXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ0EnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaScgfHwgdHlwZSA9PT0gJ0knKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkSW50KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA3O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYycgfHwgdHlwZSA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYVtwICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncycgfHwgdHlwZSA9PT0gJ1MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkU2hvcnQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gJ0ZJWE1FIG5lZWQgZmxvYXRzJztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRGbG9hdChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1onKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNjID0gYmFbcCsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLydVbmtub3duIHR5cGUgJyArIHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnRXJyb3IgdW5rbm93biB0eXBlOiAnICsgdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YWdzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ0RpY3QpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFnQkEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRGljdCA9IGRlY29kZVRhZ3ModGhpcy50YWdCQSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0JBID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdEaWN0ID0ge307ICAvLyBNYXJrIHNvIHdlIGRvbid0IHRyeSBhZ2Fpbi4gIFRoZSByZWNvcmQgaGFzIG5vdCB0YWdzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnRGljdDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgdXNlciBjbGlja3Mgb24gYSBiYXNlIG5leHQgdG8gYW4gaW5zZXJ0aW9uLCBzaG93IGp1c3QgdGhlXHJcbiAgICAgICAgLy8gaW5zZXJ0ZWQgYmFzZXMgaW4gYSBwb3B1cCAobGlrZSBpbiBkZXNrdG9wIElHVikuXHJcbiAgICAgICAgdmFyIG5hbWVWYWx1ZXMgPSBbXSwgaXNGaXJzdCwgdGFnRGljdDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5pbnNlcnRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmluc2VydGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnNfc3RhcnQgPSB0aGlzLmluc2VydGlvbnNbaV0uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZihnZW5vbWljTG9jYXRpb24gPT0gaW5zX3N0YXJ0IHx8IGdlbm9taWNMb2NhdGlvbiA9PSBpbnNfc3RhcnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnSW5zZXJ0aW9uJywgdmFsdWU6IHRoaXMuaW5zZXJ0aW9uc1tpXS5zZXEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnTG9jYXRpb24nLCB2YWx1ZTogaW5zX3N0YXJ0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnUmVhZCBOYW1lJywgdmFsdWU6IHRoaXMucmVhZE5hbWUgfSk7XHJcblxyXG4gICAgICAgIC8vIFNhbXBsZVxyXG4gICAgICAgIC8vIFJlYWQgZ3JvdXBcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgMSB0byBnZW5vbWljIGxvY2F0aW9uIHRvIG1hcCBmcm9tIDAtYmFzZWQgY29tcHV0ZXIgdW5pdHMgdG8gdXNlci1iYXNlZCB1bml0c1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdBbGlnbm1lbnQgU3RhcnQnLCB2YWx1ZTogaWd2Lm51bWJlckZvcm1hdHRlcigxICsgdGhpcy5zdGFydCksIGJvcmRlclRvcDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1JlYWQgU3RyYW5kJywgdmFsdWU6ICh0cnVlID09PSB0aGlzLnN0cmFuZCA/ICcoKyknIDogJygtKScpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0NpZ2FyJywgdmFsdWU6IHRoaXMuY2lnYXIgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hcHBlZCcsIHZhbHVlOiB5ZXNObyh0aGlzLmlzTWFwcGVkKCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXBwaW5nIFF1YWxpdHknLCB2YWx1ZTogdGhpcy5tcSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnU2Vjb25kYXJ5JywgdmFsdWU6IHllc05vKHRoaXMuaXNTZWNvbmRhcnkoKSkgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1N1cHBsZW1lbnRhcnknLCB2YWx1ZTogeWVzTm8odGhpcy5pc1N1cHBsZW1lbnRhcnkoKSkgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0R1cGxpY2F0ZScsIHZhbHVlOiB5ZXNObyh0aGlzLmlzRHVwbGljYXRlKCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdGYWlsZWQgUUMnLCB2YWx1ZTogeWVzTm8odGhpcy5pc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkpIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1BhaXJlZCgpKSB7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaChcIjxocj5cIik7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdGaXJzdCBpbiBQYWlyJywgdmFsdWU6ICF0aGlzLmlzU2Vjb25kT2ZQYWlyKCksIGJvcmRlclRvcDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgaXMgTWFwcGVkJywgdmFsdWU6IHllc05vKHRoaXMuaXNNYXRlTWFwcGVkKCkpIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc01hdGVNYXBwZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgQ2hyb21vc29tZScsIHZhbHVlOiB0aGlzLm1hdGUuY2hyIH0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgU3RhcnQnLCB2YWx1ZTogKHRoaXMubWF0ZS5wb3NpdGlvbiArIDEpfSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnTWF0ZSBTdHJhbmQnLCB2YWx1ZTogKHRydWUgPT09IHRoaXMubWF0ZS5zdHJhbmQgPyAnKCspJyA6ICcoLSknKX0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0luc2VydCBTaXplJywgdmFsdWU6IHRoaXMuZnJhZ21lbnRMZW5ndGggfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRlIFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRlIFN0cmFuZFxyXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IFNpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaXJzdCBpbiBQYWlyXHJcbiAgICAgICAgICAgIC8vIFBhaXIgT3JpZW50YXRpb25cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG4gICAgICAgIHRhZ0RpY3QgPSB0aGlzLnRhZ3MoKTtcclxuICAgICAgICBpc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGFnRGljdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRhZ0RpY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdGFnRGljdFtrZXldLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiBrZXksIHZhbHVlOiB0YWdEaWN0W2tleV0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHllc05vKGJvb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wgPyAnWWVzJyA6ICdObyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgXHJcblxyXG4gICBcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkRmxvYXQoYmEsIG9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYmEuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEJhbUZpbHRlcntcclxuXHJcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLnZlbmRvckZhaWxlZCA9IG9wdGlvbnMudmVuZG9yRmFpbGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy52ZW5kb3JGYWlsZWQ7XHJcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVzID0gb3B0aW9ucy5kdXBsaWNhdGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5kdXBsaWNhdGVzO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5ID0gb3B0aW9ucy5zZWNvbmRhcnkgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdXBwbGVtZW50YXJ5ID0gb3B0aW9ucy5zdXBwbGVtZW50YXJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubXFUaHJlc2hvbGQgPSBvcHRpb25zLm1xVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5tcVRocmVzaG9sZDtcclxuICAgIH1cclxuXHJcbiAgICBwYXNzKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy52ZW5kb3JGYWlsZWQgJiYgYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZXMgJiYgYWxpZ25tZW50LmlzRHVwbGljYXRlKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnkgJiYgYWxpZ25tZW50LmlzU2Vjb25kYXJ5KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zdXBwbGVtZW50YXJ5ICYmIGFsaWdubWVudC5pc1N1cHBsZW1lbnRhcnkoKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnQubXEgPCB0aGlzLm1xVGhyZXNob2xkKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbiAgICB2YXIgQkxPQ0tfSEVBREVSX0xFTkdUSCA9IDE4O1xyXG4gICAgdmFyIEJMT0NLX0xFTkdUSF9PRkZTRVQgPSAxNjsgIC8vIExvY2F0aW9uIGluIHRoZSBnemlwIGJsb2NrIG9mIHRoZSB0b3RhbCBibG9jayBzaXplIChhY3R1YWxseSB0b3RhbCBibG9jayBzaXplIC0gMSlcclxuICAgIHZhciBCTE9DS19GT09URVJfTEVOR1RIID0gODsgLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgZm9sbG93IHRoZSBkZWZsYXRlZCBkYXRhXHJcbiAgICB2YXIgTUFYX0NPTVBSRVNTRURfQkxPQ0tfU0laRSA9IDY0ICogMTAyNDsgLy8gV2UgcmVxdWlyZSB0aGF0IGEgY29tcHJlc3NlZCBibG9jayAoaW5jbHVkaW5nIGhlYWRlciBhbmQgZm9vdGVyLCBiZSA8PSB0aGlzKVxyXG4gICAgdmFyIEdaSVBfT1ZFUkhFQUQgPSBCTE9DS19IRUFERVJfTEVOR1RIICsgQkxPQ0tfRk9PVEVSX0xFTkdUSCArIDI7IC8vIEd6aXAgb3ZlcmhlYWQgaXMgdGhlIGhlYWRlciwgdGhlIGZvb3RlciwgYW5kIHRoZSBibG9jayBzaXplIChlbmNvZGVkIGFzIGEgc2hvcnQpLlxyXG4gICAgdmFyIEdaSVBfSUQxID0gMzE7ICAgLy8gTWFnaWMgbnVtYmVyXHJcbiAgICB2YXIgR1pJUF9JRDIgPSAxMzk7ICAvLyBNYWdpYyBudW1iZXJcclxuICAgIHZhciBHWklQX0ZMRyA9IDQ7IC8vIEZFWFRSQSBmbGFnIG1lYW5zIHRoZXJlIGFyZSBvcHRpb25hbCBmaWVsZHNcclxuXHJcblxyXG4gICAgLy8gVW5jb21wcmVzcyBkYXRhLCAgYXNzdW1lZCB0byBiZSBzZXJpZXMgb2YgYmd6aXBwZWQgYmxvY2tzXHJcbiAgICAvLyBDb2RlIGlzIGJhc2VkIGhlYXZpbHkgb24gYmFtLmpzLCBwYXJ0IG9mIHRoZSBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyLCAgKGMpIFRob21hcyBEb3duIDIwMDYtMjAwMS5cclxuY2xhc3MgdW5iZ3pme1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgbGltKSB7XHJcbiAgICAgICAgZm9yIChsZXQgYSBpbiBkYXRhKXtcclxuICAgICAgICAgICBjb25zb2xlLmxvZyhhKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgIHZhciBvQmxvY2tMaXN0ID0gW10sXHJcbiAgICAgICAgICAgIHB0ciA9IFswXSxcclxuICAgICAgICAgICAgdG90YWxTaXplID0gMDtcclxuXHJcbiAgICAgICAgbGltID0gbGltIHx8IGRhdGEuYnl0ZUxlbmd0aCAtIDE4O1xyXG5cclxuICAgICAgICB3aGlsZSAocHRyWzBdIDwgbGltKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhLCBwdHJbMF0sIDE4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4bGVuID0gKGJhWzExXSA8PCA4KSB8IChiYVsxMF0pO1xyXG4gICAgICAgICAgICB2YXIgc2kxID0gYmFbMTJdO1xyXG4gICAgICAgICAgICB2YXIgc2kyID0gYmFbMTNdO1xyXG4gICAgICAgICAgICB2YXIgc2xlbiA9IChiYVsxNV0gPDwgOCkgfCAoYmFbMTRdKTtcclxuICAgICAgICAgICAgdmFyIGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDEyICsgeGxlbiArIHB0clswXTsgICAgLy8gU3RhcnQgb2YgQ0RBVEFcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IChic2l6ZSArIDgpKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmMgPSBqc3psaWJfaW5mbGF0ZV9idWZmZXIoZGF0YSwgc3RhcnQsIGxlbmd0aCwgcHRyKTtcclxuXHJcbiAgICAgICAgICAgIHB0clswXSArPSA4OyAgICAvLyBTa2lwcGluZyBDUkMtMzIgYW5kIHNpemUgb2YgdW5jb21wcmVzc2VkIGRhdGFcclxuXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSB1bmMuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgb0Jsb2NrTGlzdC5wdXNoKHVuYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25jYXRlbmF0ZSBkZWNvbXByZXNzZWQgYmxvY2tzXHJcbiAgICAgICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9CbG9ja0xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkob0Jsb2NrTGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgQWxpZ25tZW50Q29udGFpbmVye1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kLCBzYW1wbGluZ1dpbmRvd1NpemUsIHNhbXBsaW5nRGVwdGgsIHBhaXJzU3VwcG9ydGVkLHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50PXBhcmVudDtcclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQuY21fY2xhc3Mpe1xyXG4gICAgICAgICAgICB0aGlzLmNvdmVyYWdlTWFwPSBuZXcgQ292ZXJhZ2VNYXAoY2hyLHN0YXJ0LGVuZCxwYXJlbnQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuY292ZXJhZ2VNYXA9IG5ldyB0aGlzLnBhcmVudC5jbV9jbGFzcyhjaHIsc3RhcnQsZW5kLHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmF3X2FsaWdubWVudHM9W107XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSA9IHNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gMTAwIDogc2FtcGxpbmdXaW5kb3dTaXplO1xyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IHNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IDUwIDogc2FtcGxpbmdEZXB0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIHRoaXMucGFpcmVkID0gZmFsc2U7ICAvLyBmYWxzZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0ge307ICAvLyB3b3JraW5nIGNhY2hlIG9mIHBhaXJlZCBhbGlnbm1lbnRzIGJ5IHJlYWQgbmFtZVxyXG5cclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFsaWdubWVudCkgeyAgICAgICAgIC8vIFRPRE8gLS0gcGFzcyB0aGlzIGluXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNNYXBwZWQoKSAmJiAhYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1c2goYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcihhbGlnbm1lbnQpID09PSBmYWxzZSkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnQudGFnQkEpe1xyXG4gICAgICAgICAgICBhbGlnbm1lbnQudGFnQkE9ZGVjb2RlVGFncyhhbGlnbm1lbnQudGFnQkEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQua2VlcF9yYXdfYWxpZ25tZW50cyl7XHJcbiAgICAgICAgICAgIHRoaXMucmF3X2FsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb3ZlcmFnZU1hcC5pbmNDb3VudHMoYWxpZ25tZW50KTtcclxuICAgICAgICBpZiAoIXRoaXMucGFyZW50LmRpc3BsYXlfYWxpZ25tZW50cyl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBDb3VudCBjb3ZlcmFnZSBiZWZvcmUgYW55IGRvd25zYW1wbGluZ1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wYWlyc1N1cHBvcnRlZCAmJiB0aGlzLmRvd25zYW1wbGVkUmVhZHMuaGFzKGFsaWdubWVudC5yZWFkTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAgIC8vIE1hdGUgYWxyZWFkeSBkb3duc2FtcGxlZCAtLSBwYWlycyBhcmUgdHJlYXRlZCBhcyBhIHNpbmdsZSBhbGlnbm1lbnQgZm9yIGRvd25zYW1wbGluZ1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFsaWdubWVudC5zdGFydCA+PSB0aGlzLmN1cnJlbnRCdWNrZXQuZW5kKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEJ1Y2tldC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQgPSBuZXcgRG93bnNhbXBsZUJ1Y2tldChhbGlnbm1lbnQuc3RhcnQsIGFsaWdubWVudC5zdGFydCArIHRoaXMuc2FtcGxpbmdXaW5kb3dTaXplLCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldC5hZGRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5pc2goKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCdWNrZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBmaW5pc2hCdWNrZXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5lZWQgdG8gcmVtb3ZlIHBhcnRpYWwgcGFpcnMgd2hvc2UgbWF0ZSB3YXMgZG93bnNhbXBsZWRcclxuICAgICAgICBpZih0aGlzLnBhaXJzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBbXSwgZHMgPSB0aGlzLmRvd25zYW1wbGVkUmVhZHM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkcy5oYXMoYS5yZWFkTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gdG1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucGFpcnNDYWNoZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnMoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hyID09IGNociAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDw9IHN0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZW5kID49IGVuZDtcclxuICAgIH1cclxuXHJcbiAgICBoYXNEb3duc2FtcGxlZEludGVydmFscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb3duc2FtcGxlZEludGVydmFscyAmJiB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5pc2hCdWNrZXQoKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gdGhpcy5hbGlnbm1lbnRzLmNvbmNhdCh0aGlzLmN1cnJlbnRCdWNrZXQuYWxpZ25tZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldC5kb3duc2FtcGxlZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzLnB1c2gobmV3IERvd25zYW1wbGVkSW50ZXJ2YWwoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQuZW5kLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmRvd25zYW1wbGVkQ291bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYWlyZWQgPSB0aGlzLnBhaXJlZCB8fCB0aGlzLmN1cnJlbnRCdWNrZXQucGFpcmVkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgIFxyXG4gICAgXHJcblxyXG5cclxuXHJcbmNsYXNzIERvd25zYW1wbGVCdWNrZXR7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBhbGlnbm1lbnRDb250YWluZXIpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gYWxpZ25tZW50Q29udGFpbmVyLnNhbXBsaW5nRGVwdGg7XHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IGFsaWdubWVudENvbnRhaW5lci5wYWlyc1N1cHBvcnRlZDtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRSZWFkcztcclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSBhbGlnbm1lbnRDb250YWluZXIucGFpcnNDYWNoZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBzYW1wbGluZ1Byb2IsIGlkeCwgcmVwbGFjZWRBbGlnbm1lbnQsIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpZ25tZW50cy5sZW5ndGggPCB0aGlzLnNhbXBsaW5nRGVwdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTm90IHN1YmplY3QgdG8gZG93bnNhbXBsaW5nLCBqdXN0IHVwZGF0ZSB0aGUgZXhpc3RpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gdW5kZWZpbmVkOyAgIC8vIERvbid0IG5lZWQgdG8gdHJhY2sgdGhpcyBhbnltb3JlLiBOT1RFOiBEb24ndCBcImRlbGV0ZVwiLCBjYXVzZXMgcnVudGltZSBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFsaWdubWVudCBpbiBhIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5wdXNoKHBhaXJlZEFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBzYW1wbGluZ1Byb2IgPSB0aGlzLnNhbXBsaW5nRGVwdGggLyAodGhpcy5zYW1wbGluZ0RlcHRoICsgdGhpcy5kb3duc2FtcGxlZENvdW50ICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHNhbXBsaW5nUHJvYikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLmFsaWdubWVudHMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRBbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudHNbaWR4XTsgICAvLyBUbyBiZSByZXBsYWNlZFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wYWlyc0NhY2hlW3JlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVtyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gYWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChhbGlnbm1lbnQucmVhZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkQ291bnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgIC8vIFRPRE8gLS0gcmVmYWN0b3IgdGhpcyB0byB1c2UgYW4gb2JqZWN0LCByYXRoZXIgdGhhbiBhbiBhcnJheSwgIGlmIGVuZC1zdGFydCBpcyA+IHNvbWUgdGhyZXNob2xkXHJcbmNsYXNzIENvdmVyYWdlTWFwe1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kLHBhcmVudCkge1xyXG5cclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLmJwU3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IChlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQ9cGFyZW50O1xyXG4gICAgICAgIHRoaXMuY292ZXJhZ2UgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB0aGlzLm1heGltdW0gPSAwO1xyXG5cclxuICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGluY0NvdW50cyhhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50LmJsb2NrcyA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICBpbmNCbG9ja0NvdW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhbGlnbm1lbnQuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICBpbmNCbG9ja0NvdW50KGJsb2NrKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbmNCbG9ja0NvdW50KGJsb2NrKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5LFxyXG4gICAgICAgICAgICAgICAgYmFzZSxcclxuICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICAgICAgcTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IGJsb2NrLnN0YXJ0IC0gc2VsZi5icFN0YXJ0LCBqID0gMDsgaiA8IGJsb2NrLmxlbjsgaSsrLCBqKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuY292ZXJhZ2VbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldID0gbmV3IENvdmVyYWdlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYmFzZSA9IGJsb2NrLnNlcS5jaGFyQXQoaik7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSAoYWxpZ25tZW50LnN0cmFuZCkgPyBcInBvc1wiICsgYmFzZSA6IFwibmVnXCIgKyBiYXNlO1xyXG4gICAgICAgICAgICAgICAgcSA9IGJsb2NrLnF1YWxbal07XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5jb3ZlcmFnZVtpXVtrZXldICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldW1wicXVhbFwiICsgYmFzZV0gKz0gcTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldLnRvdGFsICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldLnF1YWwgKz0gcTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLm1heGltdW0gPSBNYXRoLm1heChzZWxmLmNvdmVyYWdlW2ldLnRvdGFsLCBzZWxmLm1heGltdW0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuQ292ZXJhZ2VNYXAudGhyZXNob2xkID0gMC4yO1xyXG5Db3ZlcmFnZU1hcC5xdWFsaXR5V2VpZ2h0ID0gdHJ1ZTtcclxuXHJcbmNsYXNzIENvdmVyYWdle1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NBID0gMDtcclxuICAgICAgICB0aGlzLm5lZ0EgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnBvc1QgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnVCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zQyA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdDID0gMDtcclxuICAgICAgICB0aGlzLnBvc0cgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLm5lZ0cgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnBvc04gPSAwO1xyXG4gICAgICAgIHRoaXMubmVnTiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zID0gMDtcclxuICAgICAgICB0aGlzLm5lZyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucXVhbEEgPSAwO1xyXG4gICAgICAgIHRoaXMucXVhbFQgPSAwO1xyXG4gICAgICAgIHRoaXMucXVhbEMgPSAwO1xyXG4gICAgICAgIHRoaXMucXVhbEcgPSAwO1xyXG4gICAgICAgIHRoaXMucXVhbE4gPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnF1YWwgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnRvdGFsID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc01pc21hdGNoKHJlZkJhc2UpIHtcclxuXHJcbiAgICAgICAgdmFyIG15c2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIG1pc21hdGNoUXVhbGl0eVN1bSxcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gQ292ZXJhZ2VNYXAudGhyZXNob2xkICogKChDb3ZlcmFnZU1hcC5xdWFsaXR5V2VpZ2h0ICYmIHRoaXMucXVhbCkgPyB0aGlzLnF1YWwgOiB0aGlzLnRvdGFsKTtcclxuXHJcbiAgICAgICAgbWlzbWF0Y2hRdWFsaXR5U3VtID0gMDtcclxuICAgICAgICBbXCJBXCIsIFwiVFwiLCBcIkNcIiwgXCJHXCJdLmZvckVhY2goZnVuY3Rpb24gKGJhc2UpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChiYXNlICE9PSByZWZCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNtYXRjaFF1YWxpdHlTdW0gKz0gKChDb3ZlcmFnZU1hcC5xdWFsaXR5V2VpZ2h0ICYmIG15c2VsZi5xdWFsKSA/IG15c2VsZltcInF1YWxcIiArIGJhc2VdIDogKG15c2VsZltcInBvc1wiICsgYmFzZV0gKyBteXNlbGZbXCJuZWdcIiArIGJhc2VdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1pc21hdGNoUXVhbGl0eVN1bSA+PSB0aHJlc2hvbGQ7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBEb3duc2FtcGxlZEludGVydmFse1xyXG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgY291bnRzKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuY291bnRzID0gY291bnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7bmFtZTogXCJzdGFydFwiLCB2YWx1ZTogdGhpcy5zdGFydCArIDF9LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJlbmRcIiwgdmFsdWU6IHRoaXMuZW5kfSxcclxuICAgICAgICAgICAge25hbWU6IFwiIyBkb3duc2FtcGxlZDpcIiwgdmFsdWU6IHRoaXMuY291bnRzfV1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmNsYXNzIFBhaXJlZEFsaWdubWVudHtcclxuICAgIGNvbnN0cnVjdG9yKGZpcnN0QWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmlyc3RBbGlnbm1lbnQgPSBmaXJzdEFsaWdubWVudDtcclxuICAgICAgICB0aGlzLmNociA9IGZpcnN0QWxpZ25tZW50LmNocjtcclxuICAgICAgICB0aGlzLnJlYWROYW1lID0gZmlyc3RBbGlnbm1lbnQucmVhZE5hbWU7XHJcblxyXG4gICAgICAgIGlmIChmaXJzdEFsaWdubWVudC5zdGFydCA8IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IE1hdGgubWF4KGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb24sIGZpcnN0QWxpZ25tZW50LnN0YXJ0ICsgZmlyc3RBbGlnbm1lbnQubGVuZ3RoT25SZWYpOyAgLy8gQXBwcm94aW1hdGVcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nU3RhcnQgPSBmaXJzdEFsaWdubWVudC5zdGFydCArIGZpcnN0QWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdFbmQgPSBmaXJzdEFsaWdubWVudC5tYXRlLnBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQgKyBmaXJzdEFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nU3RhcnQgPSBmaXJzdEFsaWdubWVudC5tYXRlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdFbmQgPSBmaXJzdEFsaWdubWVudC5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGhPblJlZiA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc2V0U2Vjb25kQWxpZ25tZW50KGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICAvLyBUT0RPIC0tIGNoZWNrIHRoZSBjaHJzIGFyZSBlcXVhbCwgIGVycm9yIG90aGVyd2lzZVxyXG4gICAgICAgIHRoaXMuc2Vjb25kQWxpZ25tZW50ID0gYWxpZ25tZW50O1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50LnN0YXJ0ID4gdGhpcy5maXJzdEFsaWdubWVudC5zdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nRW5kID0gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGFsaWdubWVudC5zdGFydDtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nU3RhcnQgPSBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVuZ3RoT25SZWYgPSB0aGlzLmVuZCAtIHRoaXMuc3RhcnQ7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uKSB7XHJcblxyXG4gICAgICAgIHZhciBuYW1lVmFsdWVzID0gW107XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZXMgPSBuYW1lVmFsdWVzLmNvbmNhdCh0aGlzLmZpcnN0QWxpZ25tZW50LnBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaChcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMgPSBuYW1lVmFsdWVzLmNvbmNhdCh0aGlzLnNlY29uZEFsaWdubWVudC5wb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuYW1lVmFsdWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGFpcmVkICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQnkgZGVmaW5pdGlvblxyXG4gICAgfVxyXG5cclxuICAgIGZpcnN0T2ZQYWlyU3RyYW5kICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maXJzdEFsaWdubWVudC5pc0ZpcnN0T2ZQYWlyKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RBbGlnbm1lbnQuc3RyYW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlY29uZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRBbGlnbm1lbnQuc3RyYW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RBbGlnbm1lbnQuc3RyYW5kOyAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgaW53YXJkIHBvaW50aW5nIHBhaXJzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgQmFtQWxpZ25tZW50Um93IHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5zY29yZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kQ2VudGVyQWxpZ25tZW50KGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBjZW50ZXJBbGlnbm1lbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgc2luZ2xlIGFsaWdubWVudCB0aGF0IG92ZXJsYXBzIHNvcnQgbG9jYXRpb25cclxuICAgICAgICB0aGlzLmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbihhKXtcclxuXHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNlbnRlckFsaWdubWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYS5zdGFydCArIGEubGVuZ3RoT25SZWYpIDwgYnBTdGFydCB8fCBhLnN0YXJ0ID4gYnBFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckFsaWdubWVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2VudGVyQWxpZ25tZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjb3JlKGdlbm9taWNMb2NhdGlvbiwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc2NvcmUgPSB0aGlzLmNhY3VsYXRlU2NvcmUoZ2Vub21pY0xvY2F0aW9uLCAoMSArIGdlbm9taWNMb2NhdGlvbiksIGdlbm9taWNJbnRlcnZhbCwgc29ydE9wdGlvbik7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBjYWN1bGF0ZVNjb3JlKGJwU3RhcnQsIGJwRW5kLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIGJhc2VTY29yZSxcclxuICAgICAgICAgICAgYWxpZ25tZW50O1xyXG5cclxuICAgICAgICBhbGlnbm1lbnQgPSB0aGlzLmZpbmRDZW50ZXJBbGlnbm1lbnQoYnBTdGFydCwgYnBFbmQpO1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcIk5VQ0xFT1RJREVcIiA9PT0gc29ydE9wdGlvbi5zb3J0KSB7XHJcblxyXG4gICAgICAgICAgICBiYXNlU2NvcmUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBhbGlnbm1lbnQuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gZ2Vub21pY0ludGVydmFsLnNlcXVlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyYWdlTWFwID0gZ2Vub21pY0ludGVydmFsLmNvdmVyYWdlTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBiYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHBocmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChcIipcIiAhPT0gYmxvY2suc2VxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbmRleFJlZmVyZW5jZVNlcXVlbmNlID0gYmxvY2suc3RhcnQgLSBnZW5vbWljSW50ZXJ2YWwuc3RhcnQsIGJwQmxvY2tTZXF1ZW5jZSA9IGJsb2NrLnN0YXJ0LCBsZW5ndGhCbG9ja1NlcXVlbmNlID0gYmxvY2suc2VxLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGkgPCBsZW5ndGhCbG9ja1NlcXVlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaSsrLCBpbmRleFJlZmVyZW5jZVNlcXVlbmNlKyssIGJwQmxvY2tTZXF1ZW5jZSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnBTdGFydCA9PT0gYnBCbG9ja1NlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlID0gc2VxdWVuY2UuY2hhckF0KGluZGV4UmVmZXJlbmNlU2VxdWVuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJsb2NrLnNlcS5jaGFyQXQoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09IFwiPVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IHJlZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gJ04nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2UgPT09IHJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlID09PSBcIlhcIiB8fCBiYXNlICE9PSByZWZlcmVuY2Upe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmFnZSA9IGNvdmVyYWdlTWFwLmNvdmVyYWdlWyAoYnBCbG9ja1NlcXVlbmNlIC0gY292ZXJhZ2VNYXAuYnBTdGFydCkgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IGNvdmVyYWdlWyBcInBvc1wiICsgYmFzZSBdICsgY292ZXJhZ2VbIFwibmVnXCIgKyBiYXNlIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGhyZWQgPSAoY292ZXJhZ2UucXVhbCkgPyBjb3ZlcmFnZS5xdWFsIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAtKGNvdW50ICsgKHBocmVkIC8gMTAwMC4wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmFtQWxpZ25tZW50Um93LmNhY3VsYXRlU2NvcmUgLSBodWg/XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBicFN0YXJ0ID09PSBicEJsb2NrU2VxdWVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBibG9jay5zZXEubGVuZ3RoXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh1bmRlZmluZWQgPT09IGJhc2VTY29yZSkgPyBOdW1iZXIuTUFYX1ZBTFVFIDogYmFzZVNjb3JlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcIlNUUkFORFwiID09PSBzb3J0T3B0aW9uLnNvcnQpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuc3RyYW5kID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcIlNUQVJUXCIgPT09IHNvcnRPcHRpb24uc29ydCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxubGV0IGJnekJsb2NrU2l6ZSA9ZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgY29uc3QgYmEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcclxuICAgIGNvbnN0IGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuICAgIHJldHVybiBic2l6ZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGRlY29kZVRhZ3MoYmEpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBwID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbiA9IGJhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHRhZ3MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChwIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwXSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDJdKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnQScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpJyB8fCB0eXBlID09PSAnSScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRJbnQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjJyB8fCB0eXBlID09PSAnQycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhW3AgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzJyB8fCB0eXBlID09PSAnUycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRTaG9ydChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2YnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAnRklYTUUgbmVlZCBmbG9hdHMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZEZsb2F0KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA3O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2MgPSBiYVtwKytdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vJ1Vua25vd24gdHlwZSAnICsgdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdFcnJvciB1bmtub3duIHR5cGU6ICcgKyB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGFnc1t0YWddID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhZ3M7XHJcbiAgICAgICAgfVxyXG5cclxuZXhwb3J0IHtsb2FkQmFtSW5kZXgsQmFtUmVhZGVyLEJhbVNvdXJjZSxCYW1GaWx0ZXIsQmFtQWxpZ25tZW50LEFsaWdubWVudENvbnRhaW5lcixQYWlyZWRBbGlnbm1lbnQsYmd6QmxvY2tTaXplLENvdmVyYWdlTWFwLENvdmVyYWdlfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdENBO0FBd0NBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFJQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/bam.js\n");

/***/ }),

/***/ "../MLVPanel/src/bam_track.js":
/*!*******************************!*\
  !*** .Panel/src/bam_track.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AlignmentTrack = exports.CoverageTrack = exports.BAMTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nvar _bam = __webpack_require__(/*! ./bam.js */ \"../MLVPanel/src/bam.js\");\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar alignmentRowYInset = 0;\nvar alignmentStartGap = 5;\nvar downsampleRowHeight = 5;\nvar DEFAULT_COVERAGE_TRACK_HEIGHT = 50;\n\nvar BAMTrack = function (_MLVTrack) {\n    _inherits(BAMTrack, _MLVTrack);\n\n    function BAMTrack(config) {\n        _classCallCheck(this, BAMTrack);\n\n        if (!config.color) {\n            config.color = \"#D3D3D3\";\n        }\n\n        var _this = _possibleConstructorReturn(this, (BAMTrack.__proto__ || Object.getPrototypeOf(BAMTrack)).call(this, config));\n\n        _this._setFeatureSource();\n        if (_this.config.bigwig) {\n            _this.bigwig_track = new _tracks.MLVWigTrack({\n                url: _this.config.bigwig,\n                type: \"bigwig\",\n                discrete: true,\n                color: \"#D3D3D3\",\n                scale: \"dynamic\",\n                height: 100\n            });\n        }\n\n        _this.config = config;\n\n        if (config.coverageTrackHeight === undefined) {\n            config.coverageTrackHeight = DEFAULT_COVERAGE_TRACK_HEIGHT;\n        }\n\n        _this.visibilityWindow = config.visibilityWindow || 30000; // 30kb default\n\n        _this.viewAsPairs = true; //config.viewAsPairs;\n\n        _this.pairsSupported = config.pairsSupported === undefined ? true : false;\n\n        _this.color = config.color || \"rgb(185, 185, 185)\";\n\n        // sort alignment rows\n        _this.sortOption = config.sortOption || { sort: \"NUCLEOTIDE\" };\n        _this.sortDirection = true;\n\n        // filter alignments\n        _this.filterOption = config.filterOption || { name: \"mappingQuality\", params: [30, undefined] };\n        _this.display_alignments = true;\n\n        return _this;\n    }\n\n    _createClass(BAMTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _bam.BamSource(this.config, this);\n            this.feature_source.setViewAsPairs(true);\n\n            this.coverageTrack = new CoverageTrack(this.config, this);\n            this.alignmentTrack = new AlignmentTrack(this.config, this);\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n            if (bpEnd - bpStart > 500000 && this.bigwig_track) {\n                this.draw_bigwig = true;\n                return this.bigwig_track.getFeatures(chr, bpStart, bpEnd, force, data);\n            }\n            this.draw_bigwig = false;\n            return this.feature_source.getAlignments(chr, bpStart, bpEnd);\n        }\n\n        // Alt - Click to Sort alignment rows\n\n    }, {\n        key: \"altClick\",\n        value: function altClick(genomicLocation, event) {\n\n            this.alignmentTrack.sortAlignmentRows(genomicLocation, this.sortOption);\n\n            this.trackView.redrawTile(this.featureSource.alignmentContainer);\n            $(this.trackView.viewportDiv).scrollTop(0);\n\n            this.sortDirection = !this.sortDirection;\n        }\n    }, {\n        key: \"computePixelHeight\",\n\n\n        /**\r\n         * Optional method to compute pixel height to accomodate the list of features.  The implementation below\r\n         * has side effects (modifiying the samples hash).  This is unfortunate, but harmless.\r\n         *\r\n         * @param features\r\n         * @returns {number}\r\n         */\n        value: function computePixelHeight(alignmentContainer) {\n\n            return this.coverageTrack.computePixelHeight(alignmentContainer) + this.alignmentTrack.computePixelHeight(alignmentContainer);\n        }\n    }, {\n        key: \"drawFeatures\",\n        value: function drawFeatures(options) {\n            this.top = options.top;\n            if (this.draw_zoom_in) {\n                this.bottom = this.top + this.config.height;\n                return this.bottom;\n            }\n            if (this.draw_bigwig) {\n                this.bottom = this.bigwig_track.drawFeatures(options);\n                return;\n            }\n            if (this.coverageTrack.height > 0) {\n                this.coverageTrack.draw(options);\n            }\n\n            this.bottom = this.alignmentTrack.draw(options);\n            return this.bottom;\n        }\n    }, {\n        key: \"paintAxis\",\n        value: function paintAxis(ctx, pixelWidth, pixelHeight) {\n\n            this.coverageTrack.paintAxis(ctx, pixelWidth, this.coverageTrackHeight);\n        }\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(genomicLocation, chr, offset, bpPerPixel) {\n            if (!this.feature_source.alignmentContainer) {\n                return null;\n            }\n            var packedAlignmentRows = this.feature_source.alignmentContainer.packedAlignmentRows,\n                downsampledIntervals = this.feature_source.alignmentContainer.downsampledIntervals,\n                packedAlignmentsIndex,\n                alignmentRow,\n                clickedObject,\n                i,\n                len,\n                tmp;\n            if (!packedAlignmentRows) {\n                return null;\n            }\n            packedAlignmentsIndex = Math.floor((offset.y - this.top - this.coverageTrack.height - alignmentRowYInset) / this.config.featureHeight);\n\n            if (packedAlignmentsIndex < 0) {\n\n                for (i = 0, len = downsampledIntervals.length; i < len; i++) {\n\n                    if (downsampledIntervals[i].start <= genomicLocation && downsampledIntervals[i].end >= genomicLocation) {\n                        clickedObject = downsampledIntervals[i];\n                        break;\n                    }\n                }\n            } else if (packedAlignmentsIndex < packedAlignmentRows.length) {\n\n                alignmentRow = packedAlignmentRows[packedAlignmentsIndex];\n\n                clickedObject = undefined;\n\n                for (i = 0, len = alignmentRow.alignments.length, tmp; i < len; i++) {\n\n                    tmp = alignmentRow.alignments[i];\n\n                    if (tmp.start <= genomicLocation && tmp.start + tmp.lengthOnRef >= genomicLocation) {\n                        clickedObject = tmp;\n                        break;\n                    }\n                }\n            }\n\n            return clickedObject;\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            if (yOffset >= this.coverageTrack.top && yOffset < this.coverageTrack.height) {\n                return this.coverageTrack.popupData(genomicLocation, xOffset, this.coverageTrack.top);\n            } else {\n                return this.alignmentTrack.popupData(genomicLocation, xOffset, yOffset - this.alignmentTrack.top);\n            }\n        }\n    }, {\n        key: \"popupMenuItems\",\n        value: function popupMenuItems(popover) {\n\n            var self = this,\n                html,\n                menuItems = [],\n                colorByMenuItems = [],\n                tagLabel = 'tag' + (self.alignmentTrack.colorByTag ? ' (' + self.alignmentTrack.colorByTag + ')' : ''),\n                selected;\n\n            colorByMenuItems.push({ key: 'none', label: 'track color' });\n\n            if (!self.viewAsPairs) {\n                colorByMenuItems.push({ key: 'strand', label: 'read strand' });\n            }\n            if (self.pairsSupported && self.alignmentTrack.hasPairs) {\n                colorByMenuItems.push({ key: 'firstOfPairStrand', label: 'first-of-pair strand' });\n            }\n            colorByMenuItems.push({ key: 'tag', label: tagLabel });\n\n            menuItems.push(igv.colorPickerMenuItem(popover, this.trackView));\n\n            menuItems.push('<div class=\"igv-track-menu-category igv-track-menu-border-top\">Color by</div>');\n\n            colorByMenuItems.forEach(function (item) {\n                selected = self.alignmentTrack.colorBy === item.key;\n                menuItems.push(colorByMarkup(item, selected));\n            });\n\n            html = [];\n            if (self.pairsSupported && self.alignmentTrack.hasPairs) {\n                html.push('<div class=\"igv-track-menu-item igv-track-menu-border-top\">');\n                html.push(true === self.viewAsPairs ? '<i class=\"fa fa-check fa-check-shim\">' : '<i class=\"fa fa-check fa-check-shim fa-check-hidden\">');\n                html.push('</i>');\n                html.push('View as pairs');\n                html.push('</div>');\n                menuItems.push({\n                    object: $(html.join('')),\n                    click: function click() {\n                        var $fa = $(this).find('i');\n\n                        popover.hide();\n\n                        self.viewAsPairs = !self.viewAsPairs;\n\n                        if (true === self.viewAsPairs) {\n                            $fa.removeClass('fa-check-hidden');\n                        } else {\n                            $fa.addClass('fa-check-hidden');\n                        }\n\n                        self.featureSource.setViewAsPairs(self.viewAsPairs);\n                        self.trackView.update();\n                    }\n                });\n            }\n\n            return menuItems;\n\n            function colorByMarkup(menuItem, showCheck, index) {\n\n                var parts = [],\n                    item = {};\n\n                //parts.push((0 === index) ? '<div class=\\\"igv-track-menu-item igv-track-menu-border-top\\\">' : '<div class=\"igv-track-menu-item\">');\n                parts.push('<div class=\"igv-track-menu-item\">');\n\n                parts.push(showCheck ? '<i class=\"fa fa-check fa-check-shim\"></i>' : '<i class=\"fa fa-check fa-check-shim fa-check-hidden\"></i>');\n\n                //parts.push('<span>');\n                //parts.push('Color by: ');\n                //parts.push('</span>');\n\n                if (menuItem.key === 'tag') {\n                    parts.push('<span id=\"color-by-tag\">');\n                } else {\n                    parts.push('<span>');\n                }\n                parts.push(menuItem.label);\n                parts.push('</span>');\n\n                parts.push('</div>');\n\n                item.object = $(parts.join(''));\n\n                item.click = function () {\n\n                    igv.popover.hide();\n\n                    if ('tag' === menuItem.key) {\n\n                        igv.dialog.configure(function () {\n                            return \"Tag Name\";\n                        }, self.alignmentTrack.colorByTag ? self.alignmentTrack.colorByTag : '', function () {\n                            var tag = igv.dialog.$dialogInput.val().trim();\n                            self.alignmentTrack.colorBy = 'tag';\n\n                            if (tag !== self.alignmentTrack.colorByTag) {\n                                self.alignmentTrack.colorByTag = igv.dialog.$dialogInput.val().trim();\n                                self.alignmentTrack.tagColors = new igv.PaletteColorTable(\"Set1\");\n                                $('#color-by-tag').text(self.alignmentTrack.colorByTag);\n                            }\n\n                            self.trackView.update();\n                        });\n\n                        igv.dialog.show($(self.trackView.trackDiv));\n                    } else {\n                        self.alignmentTrack.colorBy = menuItem.key;\n                        self.trackView.update();\n                    }\n                };\n\n                return item;\n            }\n        }\n    }]);\n\n    return BAMTrack;\n}(_tracks.MLVTrack);\n\nfunction shadedBaseColor(qual, nucleotide, genomicLocation) {\n\n    var color,\n        alpha,\n        minQ = 5,\n        //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN),\n    maxQ = 20,\n        //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX);\n    foregroundColor = [0, 255, 255],\n        //nucleotideColorComponents[nucleotide],\n    backgroundColor = [255, 255, 255]; // White\n\n\n    //if (171167156 === genomicLocation) {\n    //    // NOTE: Add 1 when presenting genomic location\n    //    console.log(\"shadedBaseColor - locus \" + igv.numberFormatter(1 + genomicLocation) + \" qual \" + qual);\n    //}\n\n    if (!foregroundColor) return;\n\n    if (qual < minQ) {\n        alpha = 0.1;\n    } else {\n        alpha = Math.max(0.1, Math.min(1.0, 0.1 + 0.9 * (qual - minQ) / (maxQ - minQ)));\n    }\n    // Round alpha to nearest 0.1\n    alpha = Math.round(alpha * 10) / 10.0;\n\n    if (alpha >= 1) {\n        color = _tracks.Graphics.nucleotideColors[nucleotide];\n    } else {\n        color = \"rgba(\" + foregroundColor[0] + \",\" + foregroundColor[1] + \",\" + foregroundColor[2] + \",\" + alpha + \")\"; //igv.getCompositeColor(backgroundColor, foregroundColor, alpha);\n    }\n    return color;\n}\n\nvar CoverageTrack = function () {\n    function CoverageTrack(config, parent) {\n        _classCallCheck(this, CoverageTrack);\n\n        this.parent = parent;\n        this.featureSource = parent.featureSource;\n\n        this.height = 20; //config.coverageTrackHeight;\n        this.dataRange = { min: 0 }; // Leav max undefined\n    }\n\n    _createClass(CoverageTrack, [{\n        key: \"computePixelHeight\",\n        value: function computePixelHeight(alignmentContainer) {\n            return this.height;\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(options) {\n\n            var self = this,\n                alignmentContainer = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                coverageMap = alignmentContainer.coverageMap,\n                bp,\n                x,\n                y,\n                w,\n                h,\n                refBase,\n                i,\n                len,\n                item,\n                accumulatedHeight,\n                sequence;\n\n            if (coverageMap.refSeq) sequence = coverageMap.refSeq.toUpperCase();\n\n            this.dataRange.max = coverageMap.maximum;\n            var top = options.top;\n            options.top += this.height;\n            // paint backdrop color for all coverage buckets\n            w = Math.max(1, Math.ceil(1.0 / bpPerPixel));\n            for (i = 0, len = coverageMap.coverage.length; i < len; i++) {\n\n                bp = coverageMap.bpStart + i;\n                if (bp < bpStart) continue;\n                if (bp > bpEnd) break;\n\n                item = coverageMap.coverage[i];\n                if (!item) continue;\n\n                h = Math.round(item.total / this.dataRange.max * this.height);\n                y = this.height - h;\n                x = Math.floor((bp - bpStart) / bpPerPixel);\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: this.parent.config.color, strokeStyle: this.color });\n                _tracks.Graphics.fillRect(ctx, x, y + top, w, h);\n            }\n\n            // coverage mismatch coloring -- don't try to do this in above loop, color bar will be overwritten when w<1\n            if (sequence) {\n                for (i = 0, len = coverageMap.coverage.length; i < len; i++) {\n\n                    bp = coverageMap.bpStart + i;\n                    if (bp < bpStart) continue;\n                    if (bp > bpEnd) break;\n\n                    item = coverageMap.coverage[i];\n                    if (!item) continue;\n\n                    h = item.total / this.dataRange.max * this.height;\n                    y = this.height - h;\n                    x = Math.floor((bp - bpStart) / bpPerPixel);\n\n                    refBase = sequence[i];\n                    if (item.isMismatch(refBase)) {\n\n                        _tracks.Graphics.setProperties(ctx, { fillStyle: _tracks.Graphics.nucleotideColors[refBase] });\n                        _tracks.Graphics.fillRect(ctx, x, y + top, w, h);\n\n                        accumulatedHeight = 0.0;\n                        [\"A\", \"C\", \"T\", \"G\"].forEach(function (nucleotide) {\n\n                            var count, hh;\n\n                            count = item[\"pos\" + nucleotide] + item[\"neg\" + nucleotide];\n\n                            // non-logoritmic\n                            hh = count / self.dataRange.max * self.height;\n\n                            y = self.height - hh - accumulatedHeight;\n                            accumulatedHeight += hh;\n\n                            _tracks.Graphics.setProperties(ctx, { fillStyle: _tracks.Graphics.nucleotideColors[nucleotide] });\n                            _tracks.Graphics.fillRect(ctx, x, y + top, w, hh);\n                        });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            var coverageMap = this.featureSource.alignmentContainer.coverageMap,\n                coverageMapIndex,\n                coverage,\n                nameValues = [];\n\n            coverageMapIndex = genomicLocation - coverageMap.bpStart;\n            coverage = coverageMap.coverage[coverageMapIndex];\n\n            if (coverage) {\n\n                nameValues.push(igv.browser.referenceFrame.chr + \":\" + igv.numberFormatter(1 + genomicLocation));\n\n                nameValues.push({ name: 'Total Count', value: coverage.total });\n\n                // A\n                tmp = coverage.posA + coverage.negA;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor((coverage.posA + coverage.negA) / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'A', value: tmp });\n\n                // C\n                tmp = coverage.posC + coverage.negC;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'C', value: tmp });\n\n                // G\n                tmp = coverage.posG + coverage.negG;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'G', value: tmp });\n\n                // T\n                tmp = coverage.posT + coverage.negT;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'T', value: tmp });\n\n                // N\n                tmp = coverage.posN + coverage.negN;\n                if (tmp > 0) tmp = tmp.toString() + \" (\" + Math.floor(tmp / coverage.total * 100.0) + \"%)\";\n                nameValues.push({ name: 'N', value: tmp });\n            }\n\n            return nameValues;\n        }\n    }]);\n\n    return CoverageTrack;\n}();\n\nvar AlignmentTrack = function () {\n    function AlignmentTrack(config, parent) {\n        _classCallCheck(this, AlignmentTrack);\n\n        this.config = config;\n\n        this.parent = parent;\n        this.featureSource = parent.feature_source;\n\n        this.alignmentRowHeight = config.alignmentRowHeight || 6;\n\n        this.negStrandColor = config.negStrandColor || \"rgba(150, 150, 230, 0.75)\";\n        this.posStrandColor = config.posStrandColor || \"rgba(230, 150, 150, 0.75)\";\n        this.insertionColor = config.insertionColor || \"rgb(138, 94, 161)\";\n        this.deletionColor = config.deletionColor || \"black\";\n        this.skippedColor = config.skippedColor || \"rgb(150, 170, 170)\";\n\n        this.colorBy = config.colorBy || \"none\";\n        this.colorByTag = config.colorByTag;\n        this.bamColorTag = config.bamColorTag === undefined ? \"YC\" : config.bamColorTag;\n\n        // sort alignment rows\n        this.sortOption = config.sortOption || { sort: \"NUCLEOTIDE\" };\n\n        this.sortDirection = true;\n\n        this.hasPairs = false; // Until proven otherwise\n    }\n\n    _createClass(AlignmentTrack, [{\n        key: \"computePixelHeight\",\n        value: function computePixelHeight(alignmentContainer) {\n\n            if (alignmentContainer.packedAlignmentRows) {\n                var h = 0;\n                if (alignmentContainer.hasDownsampledIntervals()) {\n                    h += downsampleRowHeight + alignmentStartGap;\n                }\n                return h + this.config.featureHeight * alignmentContainer.packedAlignmentRows.length + 5;\n            } else {\n                return this.height;\n            }\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(options) {\n\n            var self = this,\n                alignmentContainer = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                packedAlignmentRows = alignmentContainer.packedAlignmentRows,\n                sequence = alignmentContainer.sequence,\n                base_text = \"normal \" + (this.config.featureHeight - 2) + \"px Arial\";\n            if (!packedAlignmentRows) {\n                return;\n            }\n            var top = options.top;\n            if (sequence) {\n                sequence = sequence.toUpperCase();\n            }\n\n            if (false /*alignmentContainer.hasDownsampledIntervals()*/) {} else {\n                alignmentRowYInset = 3;\n            }\n\n            if (packedAlignmentRows) {\n\n                packedAlignmentRows.forEach(function renderAlignmentRow(alignmentRow, i) {\n\n                    var yRect = alignmentRowYInset + self.config.featureHeight * i + top,\n                        alignmentHeight = self.config.featureHeight - 2,\n                        i,\n                        b,\n                        alignment;\n\n                    for (i = 0; i < alignmentRow.alignments.length; i++) {\n\n                        alignment = alignmentRow.alignments[i];\n\n                        self.hasPairs = self.hasPairs || alignment.isPaired();\n\n                        if (alignment.start + alignment.lengthOnRef < bpStart) continue;\n                        if (alignment.start > bpEnd) break;\n\n                        if (true === alignment.hidden) {\n                            continue;\n                        }\n\n                        if (alignment instanceof _bam.PairedAlignment) {\n\n                            drawPairConnector(alignment, yRect, alignmentHeight);\n\n                            drawSingleAlignment(alignment.firstAlignment, yRect, alignmentHeight);\n\n                            if (alignment.secondAlignment) {\n                                drawSingleAlignment(alignment.secondAlignment, yRect, alignmentHeight);\n                            }\n                        } else {\n                            drawSingleAlignment(alignment, yRect, alignmentHeight);\n                        }\n                    }\n                });\n            }\n\n            // alignment is a PairedAlignment\n            function drawPairConnector(alignment, yRect, alignmentHeight) {\n\n                var alignmentColor = self.getAlignmentColor(alignment.firstAlignment),\n                    outlineColor = alignmentColor,\n                    xBlockStart = (alignment.connectingStart - bpStart) / bpPerPixel,\n                    xBlockEnd = (alignment.connectingEnd - bpStart) / bpPerPixel,\n                    yStrokedLine = yRect + alignmentHeight / 2;\n\n                if (alignment.connectingEnd < bpStart || alignment.connectingStart > bpEnd) return;\n\n                if (alignment.mq <= 0) {\n                    alignmentColor = _utils.Utils.addAlphaToRGB(alignmentColor, \"0.15\");\n                }\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: alignmentColor, strokeStyle: outlineColor });\n\n                _tracks.Graphics.strokeLine(ctx, xBlockStart, yStrokedLine, xBlockEnd, yStrokedLine);\n            }\n\n            function drawSingleAlignment(alignment, yRect, alignmentHeight) {\n\n                var alignmentColor = self.getAlignmentColor(alignment),\n                    outlineColor = alignmentColor,\n                    lastBlockEnd,\n                    blocks = alignment.blocks,\n                    block,\n                    b;\n\n                if (alignment.start + alignment.lengthOnRef < bpStart || alignment.start > bpEnd) return;\n\n                if (alignment.mq <= 0) {\n                    alignmentColor = _utils.Utils.addAlphaToRGB(alignmentColor, \"0.15\");\n                }\n\n                _tracks.Graphics.setProperties(ctx, { fillStyle: alignmentColor, strokeStyle: outlineColor });\n\n                for (b = 0; b < blocks.length; b++) {\n                    // Can't use forEach here -- we need ability to break\n\n                    block = blocks[b];\n\n                    if (block.start + block.len < bpStart) continue;\n\n                    drawBlock(block);\n\n                    if (block.start + block.len > bpEnd) break; // Do this after drawBlock to insure gaps are drawn\n\n\n                    if (alignment.insertions) {\n                        alignment.insertions.forEach(function (block) {\n                            var refOffset = block.start - bpStart,\n                                xBlockStart = refOffset / bpPerPixel - 1,\n                                widthBlock = 3;\n                            _tracks.Graphics.fillRect(ctx, xBlockStart, yRect - 1, widthBlock, alignmentHeight + 2, { fillStyle: self.insertionColor });\n                        });\n                    }\n                }\n\n                function drawBlock(block) {\n                    var seqOffset = block.start - alignmentContainer.start,\n                        xBlockStart = (block.start - bpStart) / bpPerPixel,\n                        xBlockEnd = (block.start + block.len - bpStart) / bpPerPixel,\n                        widthBlock = Math.max(1, xBlockEnd - xBlockStart),\n                        widthArrowHead = self.config.featureHeight / 2.0,\n                        blockSeq = block.seq.toUpperCase(),\n                        skippedColor = self.skippedColor,\n                        deletionColor = self.deletionColor,\n                        refChar,\n                        readChar,\n                        readQual,\n                        xBase,\n                        widthBase,\n                        colorBase,\n                        x,\n                        y,\n                        i,\n                        yStrokedLine = yRect + alignmentHeight / 2;\n\n                    if (block.gapType !== undefined && xBlockEnd !== undefined && lastBlockEnd !== undefined) {\n                        if (\"D\" === block.gapType) {\n                            _tracks.Graphics.strokeLine(ctx, lastBlockEnd, yStrokedLine, xBlockStart, yStrokedLine, { strokeStyle: deletionColor });\n                        } else {\n                            _tracks.Graphics.strokeLine(ctx, lastBlockEnd, yStrokedLine, xBlockStart, yStrokedLine, { strokeStyle: skippedColor });\n                        }\n                    }\n                    lastBlockEnd = xBlockEnd;\n\n                    if (true === alignment.strand && b === blocks.length - 1) {\n                        // Last block on + strand\n                        x = [xBlockStart, xBlockEnd, xBlockEnd + widthArrowHead, xBlockEnd, xBlockStart, xBlockStart];\n                        y = [yRect, yRect, yRect + alignmentHeight / 2.0, yRect + alignmentHeight, yRect + alignmentHeight, yRect];\n                        _tracks.Graphics.fillPolygon(ctx, x, y, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            _tracks.Graphics.strokePolygon(ctx, x, y, { strokeStyle: outlineColor });\n                        }\n                    } else if (false === alignment.strand && b === 0) {\n                        // First block on - strand\n                        x = [xBlockEnd, xBlockStart, xBlockStart - widthArrowHead, xBlockStart, xBlockEnd, xBlockEnd];\n                        y = [yRect, yRect, yRect + alignmentHeight / 2.0, yRect + alignmentHeight, yRect + alignmentHeight, yRect];\n                        _tracks.Graphics.fillPolygon(ctx, x, y, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            _tracks.Graphics.strokePolygon(ctx, x, y, { strokeStyle: outlineColor });\n                        }\n                    } else {\n                        //      igv.graphics.fillRect(ctx, xBlockStart, yRect, widthBlock, height, {fillStyle: \"white\"});\n                        _tracks.Graphics.fillRect(ctx, xBlockStart, yRect, widthBlock, alignmentHeight, { fillStyle: alignmentColor });\n                        if (alignment.mq <= 0) {\n                            ctx.save();\n                            ctx.strokeStyle = outlineColor;\n                            ctx.strokeRect(xBlockStart, yRect, widthBlock, alignmentHeight);\n                            ctx.restore();\n                        }\n                    }\n                    // Only do mismatch coloring if a refseq exists to do the comparison\n                    if (sequence && blockSeq !== \"*\") {\n                        for (var i = 0, len = blockSeq.length; i < len; i++) {\n                            readChar = blockSeq.charAt(i);\n                            refChar = sequence.charAt(seqOffset + i);\n                            if (readChar === \"=\") {\n                                readChar = refChar;\n                            }\n                            if (readChar === \"X\" || refChar !== readChar) {\n                                if (block.qual && block.qual.length > i) {\n                                    readQual = block.qual[i];\n                                    colorBase = shadedBaseColor(readQual, readChar, i + block.start);\n                                } else {\n                                    colorBase = _tracks.Graphics.nucleotideColors[readChar];\n                                }\n                                if (colorBase) {\n                                    xBase = (block.start + i - bpStart) / bpPerPixel;\n                                    widthBase = Math.max(1, 1 / bpPerPixel);\n                                    if (bpPerPixel < 0.15) {\n                                        _tracks.Graphics.strokeText(ctx, readChar, xBase + widthBase / 2, yRect + 2, {\n                                            strokeStyle: colorBase,\n                                            font: base_text,\n                                            textAlign: 'center',\n                                            textBaseline: 'hanging'\n                                        });\n                                    } else {\n                                        _tracks.Graphics.fillRect(ctx, xBase, yRect, widthBase, alignmentHeight, { fillStyle: colorBase });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return alignmentRowYInset + self.config.featureHeight * packedAlignmentRows.length + top;\n        }\n    }, {\n        key: \"sortAlignmentRows\",\n        value: function sortAlignmentRows(genomicLocation, sortOption) {\n\n            var self = this,\n                alignmentContainer = this.featureSource.alignmentContainer,\n                alignmentRows = alignmentContainer.packedAlignmentRows;\n\n            alignmentRows.forEach(function (alignmentRow) {\n                alignmentRow.updateScore(genomicLocation, alignmentContainer, sortOption);\n            });\n\n            alignmentRows.sort(function (a, b) {\n                return self.sortDirection ? a.score - b.score : b.score - a.score;\n            });\n        }\n    }, {\n        key: \"popupData\",\n        value: function popupData(genomicLocation, xOffset, yOffset) {\n\n            var packedAlignmentRows = this.featureSource.alignmentContainer.packedAlignmentRows,\n                downsampledIntervals = this.featureSource.alignmentContainer.downsampledIntervals,\n                packedAlignmentsIndex,\n                alignmentRow,\n                clickedObject,\n                i,\n                len,\n                tmp;\n\n            packedAlignmentsIndex = Math.floor((yOffset - alignmentRowYInset) / this.config.featureHeight);\n\n            if (packedAlignmentsIndex < 0) {\n\n                for (i = 0, len = downsampledIntervals.length; i < len; i++) {\n\n                    if (downsampledIntervals[i].start <= genomicLocation && downsampledIntervals[i].end >= genomicLocation) {\n                        clickedObject = downsampledIntervals[i];\n                        break;\n                    }\n                }\n            } else if (packedAlignmentsIndex < packedAlignmentRows.length) {\n\n                alignmentRow = packedAlignmentRows[packedAlignmentsIndex];\n\n                clickedObject = undefined;\n\n                for (i = 0, len = alignmentRow.alignments.length, tmp; i < len; i++) {\n\n                    tmp = alignmentRow.alignments[i];\n\n                    if (tmp.start <= genomicLocation && tmp.start + tmp.lengthOnRef >= genomicLocation) {\n                        clickedObject = tmp;\n                        break;\n                    }\n                }\n            }\n\n            if (clickedObject) {\n                return clickedObject.popupData(genomicLocation);\n            } else {\n                return [];\n            }\n        }\n    }, {\n        key: \"getAlignmentColor\",\n        value: function getAlignmentColor(alignment) {\n\n            var alignmentTrack = this,\n                option = alignmentTrack.colorBy,\n                tagValue,\n                color,\n                strand;\n\n            color = alignmentTrack.parent.config.color; // default\n\n            switch (option) {\n\n                case \"strand\":\n                    color = alignment.strand ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                    break;\n                case \"firstOfPairStrand\":\n\n                    if (alignment instanceof _bam.PairedAlignment) {\n                        color = alignment.firstOfPairStrand() ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                    } else if (alignment.isPaired()) {\n\n                        if (alignment.isFirstOfPair()) {\n                            color = alignment.strand ? alignmentTrack.posStrandColor : alignmentTrack.negStrandColor;\n                        } else if (alignment.isSecondOfPair()) {\n                            color = alignment.strand ? alignmentTrack.negStrandColor : alignmentTrack.posStrandColor;\n                        } else {\n                            console.log(\"ERROR. Paired alignments are either first or second.\");\n                        }\n                    }\n                    break;\n\n                case \"tag\":\n\n                    tagValue = alignment.tags()[alignmentTrack.colorByTag];\n                    if (tagValue !== undefined) {\n\n                        if (alignmentTrack.bamColorTag === alignmentTrack.colorByTag) {\n                            // UCSC style color option\n                            color = \"rgb(\" + tagValue + \")\";\n                        } else {\n                            color = alignmentTrack.tagColors.getColor(tagValue);\n                        }\n                    }\n                    break;\n                default:\n                    color = alignmentTrack.parent.config.color;\n            }\n            return color;\n        }\n    }], [{\n        key: \"doSortAlignmentRows\",\n        value: function doSortAlignmentRows(genomicLocation, genomicInterval, sortOption, sortDirection) {\n\n            var alignmentRows = genomicInterval.packedAlignmentRows,\n                sequence = genomicInterval.sequence;\n\n            if (sequence) {\n                sequence = sequence.toUpperCase();\n            } else {\n                console.log(\"No sequence, no traversal. No discussion!\");\n                return;\n            }\n\n            alignmentRows.forEach(function (alignmentRow) {\n                alignmentRow.updateScore(genomicLocation, genomicInterval, sortOption);\n            });\n\n            alignmentRows.sort(function (a, b) {\n                return sortDirection ? a.score - b.score : b.score - a.score;\n            });\n        }\n    }]);\n\n    return AlignmentTrack;\n}();\n\nBAMTrack.filters = {\n\n    noop: function noop() {\n        return function (alignment) {\n            return false;\n        };\n    },\n\n    strand: function strand(_strand) {\n        return function (alignment) {\n            return alignment.strand === _strand;\n        };\n    },\n\n    mappingQuality: function mappingQuality(lower, upper) {\n        return function (alignment) {\n\n            if (lower && alignment.mq < lower) {\n                return true;\n            }\n\n            if (upper && alignment.mq > upper) {\n                return true;\n            }\n\n            return false;\n        };\n    }\n};\n\n_tracks.MLVTrack.custom_tracks[\"bam\"] = BAMTrack;\n\n_tracks.MLVTrack.track_types[\"bam\"] = {\n    \"class\": BAMTrack,\n    name: \"BAM\"\n};\n\nexports.BAMTrack = BAMTrack;\nexports.CoverageTrack = CoverageTrack;\nexports.AlignmentTrack = AlignmentTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JhbV90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmFtX3RyYWNrLmpzPzljM2EiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7TUxWVHJhY2ssR3JhcGhpY3MsTUxWV2lnVHJhY2t9IGZyb20gXCIuL3RyYWNrcy5qc1wiO1xyXG5pbXBvcnQge0JhbVNvdXJjZSxQYWlyZWRBbGlnbm1lbnR9IGZyb20gXCIuL2JhbS5qc1wiO1xyXG5pbXBvcnQge1V0aWxzfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG5cclxudmFyIGFsaWdubWVudFJvd1lJbnNldCA9IDA7XHJcbnZhciBhbGlnbm1lbnRTdGFydEdhcCA9IDU7XHJcbnZhciBkb3duc2FtcGxlUm93SGVpZ2h0ID0gNTtcclxuY29uc3QgREVGQVVMVF9DT1ZFUkFHRV9UUkFDS19IRUlHSFQgPSA1MDtcclxuXHJcbmNsYXNzIEJBTVRyYWNrIGV4dGVuZHMgTUxWVHJhY2t7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKCFjb25maWcuY29sb3Ipe1xyXG4gICAgICAgICAgICBjb25maWcuY29sb3I9XCIjRDNEM0QzXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5iaWd3aWcpe1xyXG4gICAgICAgICAgICB0aGlzLmJpZ3dpZ190cmFjayA9IG5ldyBNTFZXaWdUcmFjayh7XHJcbiAgICAgICAgICAgICAgICB1cmw6dGhpcy5jb25maWcuYmlnd2lnLFxyXG4gICAgICAgICAgICAgICAgdHlwZTpcImJpZ3dpZ1wiLFxyXG4gICAgICAgICAgICAgICAgZGlzY3JldGU6dHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOlwiI0QzRDNEM1wiLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6XCJkeW5hbWljXCIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6MTAwXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWc9Y29uZmlnO1xyXG5cclxuICAgICAgICBpZihjb25maWcuY292ZXJhZ2VUcmFja0hlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5jb3ZlcmFnZVRyYWNrSGVpZ2h0ID0gREVGQVVMVF9DT1ZFUkFHRV9UUkFDS19IRUlHSFQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5V2luZG93ID0gY29uZmlnLnZpc2liaWxpdHlXaW5kb3cgfHwgMzAwMDA7ICAgICAvLyAzMGtiIGRlZmF1bHRcclxuXHJcbiAgICAgICAgdGhpcy52aWV3QXNQYWlycyA9IHRydWU7Ly9jb25maWcudmlld0FzUGFpcnM7XHJcblxyXG4gICAgICAgIHRoaXMucGFpcnNTdXBwb3J0ZWQgPSBjb25maWcucGFpcnNTdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbmZpZy5jb2xvciB8fCBcInJnYigxODUsIDE4NSwgMTg1KVwiO1xyXG5cclxuICAgICAgICAvLyBzb3J0IGFsaWdubWVudCByb3dzXHJcbiAgICAgICAgdGhpcy5zb3J0T3B0aW9uID0gY29uZmlnLnNvcnRPcHRpb24gfHwge3NvcnQ6IFwiTlVDTEVPVElERVwifTtcclxuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb24gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBmaWx0ZXIgYWxpZ25tZW50c1xyXG4gICAgICAgIHRoaXMuZmlsdGVyT3B0aW9uID0gY29uZmlnLmZpbHRlck9wdGlvbiB8fCB7bmFtZTogXCJtYXBwaW5nUXVhbGl0eVwiLCBwYXJhbXM6IFszMCwgdW5kZWZpbmVkXX07XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5X2FsaWdubWVudHM9dHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoKXtcclxuICAgICAgICB0aGlzLmZlYXR1cmVfc291cmNlPW5ldyBCYW1Tb3VyY2UodGhpcy5jb25maWcsdGhpcyk7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlX3NvdXJjZS5zZXRWaWV3QXNQYWlycyh0cnVlKTtcclxuXHJcblx0ICAgdGhpcy5jb3ZlcmFnZVRyYWNrID0gbmV3IENvdmVyYWdlVHJhY2sodGhpcy5jb25maWcsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50VHJhY2sgPSBuZXcgQWxpZ25tZW50VHJhY2sodGhpcy5jb25maWcsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZlYXR1cmVzKGNociwgYnBTdGFydCwgYnBFbmQsZm9yY2UsZGF0YSkge1xyXG4gICAgICAgIGlmIChicEVuZC0gYnBTdGFydD41MDAwMDAgJiYgdGhpcy5iaWd3aWdfdHJhY2spe1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdfYmlnd2lnPXRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpZ3dpZ190cmFjay5nZXRGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kLGZvcmNlLGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYXdfYmlnd2lnPWZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVfc291cmNlLmdldEFsaWdubWVudHMoY2hyLCBicFN0YXJ0LCBicEVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWx0IC0gQ2xpY2sgdG8gU29ydCBhbGlnbm1lbnQgcm93c1xyXG4gICAgYWx0Q2xpY2soZ2Vub21pY0xvY2F0aW9uLCBldmVudCkge1xyXG5cclxuICAgICAgICB0aGlzLmFsaWdubWVudFRyYWNrLnNvcnRBbGlnbm1lbnRSb3dzKGdlbm9taWNMb2NhdGlvbiwgdGhpcy5zb3J0T3B0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy50cmFja1ZpZXcucmVkcmF3VGlsZSh0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAkKHRoaXMudHJhY2tWaWV3LnZpZXdwb3J0RGl2KS5zY3JvbGxUb3AoMCk7XHJcblxyXG4gICAgICAgIHRoaXMuc29ydERpcmVjdGlvbiA9ICF0aGlzLnNvcnREaXJlY3Rpb247XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsIG1ldGhvZCB0byBjb21wdXRlIHBpeGVsIGhlaWdodCB0byBhY2NvbW9kYXRlIHRoZSBsaXN0IG9mIGZlYXR1cmVzLiAgVGhlIGltcGxlbWVudGF0aW9uIGJlbG93XHJcbiAgICAgKiBoYXMgc2lkZSBlZmZlY3RzIChtb2RpZml5aW5nIHRoZSBzYW1wbGVzIGhhc2gpLiAgVGhpcyBpcyB1bmZvcnR1bmF0ZSwgYnV0IGhhcm1sZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlc1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgY29tcHV0ZVBpeGVsSGVpZ2h0KGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmFnZVRyYWNrLmNvbXB1dGVQaXhlbEhlaWdodChhbGlnbm1lbnRDb250YWluZXIpICtcclxuICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRUcmFjay5jb21wdXRlUGl4ZWxIZWlnaHQoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50b3A9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd196b29tX2luKXtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b209dGhpcy50b3ArdGhpcy5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRyYXdfYmlnd2lnKXtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b209dGhpcy5iaWd3aWdfdHJhY2suZHJhd0ZlYXR1cmVzKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuY292ZXJhZ2VUcmFjay5oZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY292ZXJhZ2VUcmFjay5kcmF3KG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuYWxpZ25tZW50VHJhY2suZHJhdyhvcHRpb25zKTtcclxuICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tO1xyXG4gICAgfTtcclxuXHJcbiAgICBwYWludEF4aXMoY3R4LCBwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlVHJhY2sucGFpbnRBeGlzKGN0eCwgcGl4ZWxXaWR0aCwgdGhpcy5jb3ZlcmFnZVRyYWNrSGVpZ2h0KTtcclxuXHJcbiAgICB9XHJcbiAgICBnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLGNocixvZmZzZXQsYnBQZXJQaXhlbCl7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVfc291cmNlLmFsaWdubWVudENvbnRhaW5lcil7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFx0dmFyIHBhY2tlZEFsaWdubWVudFJvd3MgPSB0aGlzLmZlYXR1cmVfc291cmNlLmFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzLFxyXG4gICAgICAgICAgICBkb3duc2FtcGxlZEludGVydmFscyA9IHRoaXMuZmVhdHVyZV9zb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmRvd25zYW1wbGVkSW50ZXJ2YWxzLFxyXG4gICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRzSW5kZXgsXHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdyxcclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCxcclxuICAgICAgICAgICAgaSwgbGVuLCB0bXA7XHJcbiAgICAgICAgaWYgKCFwYWNrZWRBbGlnbm1lbnRSb3dzKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhY2tlZEFsaWdubWVudHNJbmRleCA9IE1hdGguZmxvb3IoKChvZmZzZXQueSAtdGhpcy50b3AtdGhpcy5jb3ZlcmFnZVRyYWNrLmhlaWdodCkgLSAoYWxpZ25tZW50Um93WUluc2V0KSkgLyB0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKHBhY2tlZEFsaWdubWVudHNJbmRleCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb3duc2FtcGxlZEludGVydmFsc1tpXS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gJiYgKGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldLmVuZCA+PSBnZW5vbWljTG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYWNrZWRBbGlnbm1lbnRzSW5kZXggPCBwYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50Um93ID0gcGFja2VkQWxpZ25tZW50Um93c1twYWNrZWRBbGlnbm1lbnRzSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLmxlbmd0aCwgdG1wOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0bXAgPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG1wLnN0YXJ0IDw9IGdlbm9taWNMb2NhdGlvbiAmJiAodG1wLnN0YXJ0ICsgdG1wLmxlbmd0aE9uUmVmID49IGdlbm9taWNMb2NhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlja2VkT2JqZWN0ID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNsaWNrZWRPYmplY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uLCB4T2Zmc2V0LCB5T2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIGlmICh5T2Zmc2V0ID49IHRoaXMuY292ZXJhZ2VUcmFjay50b3AgJiYgeU9mZnNldCA8IHRoaXMuY292ZXJhZ2VUcmFjay5oZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJhZ2VUcmFjay5wb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uLCB4T2Zmc2V0LCB0aGlzLmNvdmVyYWdlVHJhY2sudG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudFRyYWNrLnBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24sIHhPZmZzZXQsIHlPZmZzZXQgLSB0aGlzLmFsaWdubWVudFRyYWNrLnRvcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwb3B1cE1lbnVJdGVtcyhwb3BvdmVyKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgaHRtbCxcclxuICAgICAgICAgICAgbWVudUl0ZW1zID0gW10sXHJcbiAgICAgICAgICAgIGNvbG9yQnlNZW51SXRlbXMgPSBbXSxcclxuICAgICAgICAgICAgdGFnTGFiZWwgPSAndGFnJyArIChzZWxmLmFsaWdubWVudFRyYWNrLmNvbG9yQnlUYWcgPyAnICgnICsgc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnICsgJyknIDogJycpLFxyXG4gICAgICAgICAgICBzZWxlY3RlZDtcclxuXHJcblxyXG4gICAgICAgIGNvbG9yQnlNZW51SXRlbXMucHVzaCh7a2V5OiAnbm9uZScsIGxhYmVsOiAndHJhY2sgY29sb3InfSk7XHJcblxyXG4gICAgICAgIGlmKCFzZWxmLnZpZXdBc1BhaXJzKSB7XHJcbiAgICAgICAgICAgIGNvbG9yQnlNZW51SXRlbXMucHVzaCh7a2V5OiAnc3RyYW5kJywgbGFiZWw6ICdyZWFkIHN0cmFuZCd9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGYucGFpcnNTdXBwb3J0ZWQgJiYgc2VsZi5hbGlnbm1lbnRUcmFjay5oYXNQYWlycykge1xyXG4gICAgICAgICAgICBjb2xvckJ5TWVudUl0ZW1zLnB1c2goe2tleTogJ2ZpcnN0T2ZQYWlyU3RyYW5kJywgbGFiZWw6ICdmaXJzdC1vZi1wYWlyIHN0cmFuZCd9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sb3JCeU1lbnVJdGVtcy5wdXNoKHtrZXk6ICd0YWcnLCBsYWJlbDogdGFnTGFiZWx9KTtcclxuXHJcbiAgICAgICAgbWVudUl0ZW1zLnB1c2goaWd2LmNvbG9yUGlja2VyTWVudUl0ZW0ocG9wb3ZlciwgdGhpcy50cmFja1ZpZXcpKTtcclxuXHJcbiAgICAgICAgbWVudUl0ZW1zLnB1c2goJzxkaXYgY2xhc3M9XCJpZ3YtdHJhY2stbWVudS1jYXRlZ29yeSBpZ3YtdHJhY2stbWVudS1ib3JkZXItdG9wXCI+Q29sb3IgYnk8L2Rpdj4nKTtcclxuXHJcbiAgICAgICAgY29sb3JCeU1lbnVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5ID09PSBpdGVtLmtleTtcclxuICAgICAgICAgICAgbWVudUl0ZW1zLnB1c2goY29sb3JCeU1hcmt1cChpdGVtLCBzZWxlY3RlZCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgaHRtbCA9IFtdO1xyXG4gICAgICAgIGlmIChzZWxmLnBhaXJzU3VwcG9ydGVkICYmIHNlbGYuYWxpZ25tZW50VHJhY2suaGFzUGFpcnMpIHtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKCc8ZGl2IGNsYXNzPVwiaWd2LXRyYWNrLW1lbnUtaXRlbSBpZ3YtdHJhY2stbWVudS1ib3JkZXItdG9wXCI+Jyk7XHJcbiAgICAgICAgICAgIGh0bWwucHVzaCh0cnVlID09PSBzZWxmLnZpZXdBc1BhaXJzID8gJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2sgZmEtY2hlY2stc2hpbVwiPicgOiAnPGkgY2xhc3M9XCJmYSBmYS1jaGVjayBmYS1jaGVjay1zaGltIGZhLWNoZWNrLWhpZGRlblwiPicpO1xyXG4gICAgICAgICAgICBodG1sLnB1c2goJzwvaT4nKTtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKCdWaWV3IGFzIHBhaXJzJyk7XHJcbiAgICAgICAgICAgIGh0bWwucHVzaCgnPC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIG1lbnVJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9iamVjdDogJChodG1sLmpvaW4oJycpKSxcclxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRmYSA9ICQodGhpcykuZmluZCgnaScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3BvdmVyLmhpZGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWV3QXNQYWlycyA9ICFzZWxmLnZpZXdBc1BhaXJzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gc2VsZi52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkZmEucmVtb3ZlQ2xhc3MoJ2ZhLWNoZWNrLWhpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRmYS5hZGRDbGFzcygnZmEtY2hlY2staGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVTb3VyY2Uuc2V0Vmlld0FzUGFpcnMoc2VsZi52aWV3QXNQYWlycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmFja1ZpZXcudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1lbnVJdGVtcztcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY29sb3JCeU1hcmt1cChtZW51SXRlbSwgc2hvd0NoZWNrLCBpbmRleCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gW10sXHJcbiAgICAgICAgICAgICAgICBpdGVtID0ge307XHJcblxyXG5cclxuICAgICAgICAgICAgLy9wYXJ0cy5wdXNoKCgwID09PSBpbmRleCkgPyAnPGRpdiBjbGFzcz1cXFwiaWd2LXRyYWNrLW1lbnUtaXRlbSBpZ3YtdHJhY2stbWVudS1ib3JkZXItdG9wXFxcIj4nIDogJzxkaXYgY2xhc3M9XCJpZ3YtdHJhY2stbWVudS1pdGVtXCI+Jyk7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJzxkaXYgY2xhc3M9XCJpZ3YtdHJhY2stbWVudS1pdGVtXCI+Jyk7XHJcblxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNob3dDaGVjayA/ICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrIGZhLWNoZWNrLXNoaW1cIj48L2k+JyA6ICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrIGZhLWNoZWNrLXNoaW0gZmEtY2hlY2staGlkZGVuXCI+PC9pPicpO1xyXG5cclxuICAgICAgICAgICAgLy9wYXJ0cy5wdXNoKCc8c3Bhbj4nKTtcclxuICAgICAgICAgICAgLy9wYXJ0cy5wdXNoKCdDb2xvciBieTogJyk7XHJcbiAgICAgICAgICAgIC8vcGFydHMucHVzaCgnPC9zcGFuPicpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1lbnVJdGVtLmtleSA9PT0gJ3RhZycpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJzxzcGFuIGlkPVwiY29sb3ItYnktdGFnXCI+Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3Bhbj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG1lbnVJdGVtLmxhYmVsKTtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnPC9zcGFuPicpO1xyXG5cclxuICAgICAgICAgICAgcGFydHMucHVzaCgnPC9kaXY+Jyk7XHJcblxyXG4gICAgICAgICAgICBpdGVtLm9iamVjdCA9ICQocGFydHMuam9pbignJykpO1xyXG5cclxuICAgICAgICAgICAgaXRlbS5jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZ3YucG9wb3Zlci5oaWRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCd0YWcnID09PSBtZW51SXRlbS5rZXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWd2LmRpYWxvZy5jb25maWd1cmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVGFnIE5hbWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnID8gc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnIDogJycsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gaWd2LmRpYWxvZy4kZGlhbG9nSW5wdXQudmFsKCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbGlnbm1lbnRUcmFjay5jb2xvckJ5ID0gJ3RhZyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGFnICE9PSBzZWxmLmFsaWdubWVudFRyYWNrLmNvbG9yQnlUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFsaWdubWVudFRyYWNrLmNvbG9yQnlUYWcgPSBpZ3YuZGlhbG9nLiRkaWFsb2dJbnB1dC52YWwoKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbGlnbm1lbnRUcmFjay50YWdDb2xvcnMgPSBuZXcgaWd2LlBhbGV0dGVDb2xvclRhYmxlKFwiU2V0MVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjY29sb3ItYnktdGFnJykudGV4dChzZWxmLmFsaWdubWVudFRyYWNrLmNvbG9yQnlUYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHJhY2tWaWV3LnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWd2LmRpYWxvZy5zaG93KCQoc2VsZi50cmFja1ZpZXcudHJhY2tEaXYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50VHJhY2suY29sb3JCeSA9IG1lbnVJdGVtLmtleTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRyYWNrVmlldy51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICBcclxufVxyXG5cclxuIGZ1bmN0aW9uIHNoYWRlZEJhc2VDb2xvcihxdWFsLCBudWNsZW90aWRlLCBnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIGNvbG9yLFxyXG4gICAgICAgICAgICBhbHBoYSxcclxuICAgICAgICAgICAgbWluUSA9IDUsICAgLy9wcmVmcy5nZXRBc0ludChQcmVmZXJlbmNlTWFuYWdlci5TQU1fQkFTRV9RVUFMSVRZX01JTiksXHJcbiAgICAgICAgICAgIG1heFEgPSAyMCwgIC8vcHJlZnMuZ2V0QXNJbnQoUHJlZmVyZW5jZU1hbmFnZXIuU0FNX0JBU0VfUVVBTElUWV9NQVgpO1xyXG4gICAgICAgICAgICBmb3JlZ3JvdW5kQ29sb3IgPVswLDI1NSwyNTVdLCAvL251Y2xlb3RpZGVDb2xvckNvbXBvbmVudHNbbnVjbGVvdGlkZV0sXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IFsyNTUsIDI1NSwgMjU1XTsgICAvLyBXaGl0ZVxyXG5cclxuXHJcbiAgICAgICAgLy9pZiAoMTcxMTY3MTU2ID09PSBnZW5vbWljTG9jYXRpb24pIHtcclxuICAgICAgICAvLyAgICAvLyBOT1RFOiBBZGQgMSB3aGVuIHByZXNlbnRpbmcgZ2Vub21pYyBsb2NhdGlvblxyXG4gICAgICAgIC8vICAgIGNvbnNvbGUubG9nKFwic2hhZGVkQmFzZUNvbG9yIC0gbG9jdXMgXCIgKyBpZ3YubnVtYmVyRm9ybWF0dGVyKDEgKyBnZW5vbWljTG9jYXRpb24pICsgXCIgcXVhbCBcIiArIHF1YWwpO1xyXG4gICAgICAgIC8vfVxyXG5cclxuICAgICAgICBpZiAoIWZvcmVncm91bmRDb2xvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAocXVhbCA8IG1pblEpIHtcclxuICAgICAgICAgICAgYWxwaGEgPSAwLjE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWxwaGEgPSBNYXRoLm1heCgwLjEsIE1hdGgubWluKDEuMCwgMC4xICsgMC45ICogKHF1YWwgLSBtaW5RKSAvIChtYXhRIC0gbWluUSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUm91bmQgYWxwaGEgdG8gbmVhcmVzdCAwLjFcclxuICAgICAgICBhbHBoYSA9IE1hdGgucm91bmQoYWxwaGEgKiAxMCkgLyAxMC4wO1xyXG5cclxuICAgICAgICBpZiAoYWxwaGEgPj0gMSkge1xyXG4gICAgICAgICAgICBjb2xvciA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbbnVjbGVvdGlkZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvciA9IFwicmdiYShcIiArIGZvcmVncm91bmRDb2xvclswXSArIFwiLFwiICsgZm9yZWdyb3VuZENvbG9yWzFdICsgXCIsXCIgKyBmb3JlZ3JvdW5kQ29sb3JbMl0gKyBcIixcIiArIGFscGhhICsgXCIpXCI7ICAgIC8vaWd2LmdldENvbXBvc2l0ZUNvbG9yKGJhY2tncm91bmRDb2xvciwgZm9yZWdyb3VuZENvbG9yLCBhbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuXHJcblxyXG5jbGFzcyBDb3ZlcmFnZVRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZywgcGFyZW50KSB7XHJcblxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZSA9IHBhcmVudC5mZWF0dXJlU291cmNlO1xyXG4gICAgICAgXHJcblxyXG5cclxuICAgICAgICB0aGlzLmhlaWdodCA9IDIwOy8vY29uZmlnLmNvdmVyYWdlVHJhY2tIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5kYXRhUmFuZ2UgPSB7bWluOiAwfTsgICAvLyBMZWF2IG1heCB1bmRlZmluZWRcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlUGl4ZWxIZWlnaHQoYWxpZ25tZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXcob3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lciA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxLFxyXG4gICAgICAgICAgICBjb3ZlcmFnZU1hcCA9IGFsaWdubWVudENvbnRhaW5lci5jb3ZlcmFnZU1hcCxcclxuICAgICAgICAgICAgYnAsXHJcbiAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgIHcsXHJcbiAgICAgICAgICAgIGgsXHJcbiAgICAgICAgICAgIHJlZkJhc2UsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGxlbixcclxuICAgICAgICAgICAgaXRlbSxcclxuICAgICAgICAgICAgYWNjdW11bGF0ZWRIZWlnaHQsXHJcbiAgICAgICAgICAgIHNlcXVlbmNlO1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgaWYgKGNvdmVyYWdlTWFwLnJlZlNlcSkgc2VxdWVuY2UgPSBjb3ZlcmFnZU1hcC5yZWZTZXEudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhUmFuZ2UubWF4ID0gY292ZXJhZ2VNYXAubWF4aW11bTtcclxuICAgICAgICB2YXIgdG9wID1vcHRpb25zLnRvcDtcclxuICAgICAgICBvcHRpb25zLnRvcCs9dGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgLy8gcGFpbnQgYmFja2Ryb3AgY29sb3IgZm9yIGFsbCBjb3ZlcmFnZSBidWNrZXRzXHJcbiAgICAgICAgdyA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCgxLjAgLyBicFBlclBpeGVsKSk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY292ZXJhZ2VNYXAuY292ZXJhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGJwID0gKGNvdmVyYWdlTWFwLmJwU3RhcnQgKyBpKTtcclxuICAgICAgICAgICAgaWYgKGJwIDwgYnBTdGFydCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChicCA+IGJwRW5kKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGl0ZW0gPSBjb3ZlcmFnZU1hcC5jb3ZlcmFnZVtpXTtcclxuICAgICAgICAgICAgaWYgKCFpdGVtKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGggPSBNYXRoLnJvdW5kKChpdGVtLnRvdGFsIC8gdGhpcy5kYXRhUmFuZ2UubWF4KSAqIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgeSA9IHRoaXMuaGVpZ2h0IC0gaDtcclxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoKGJwIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiB0aGlzLnBhcmVudC5jb25maWcuY29sb3IsIHN0cm9rZVN0eWxlOiB0aGlzLmNvbG9yfSk7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxSZWN0KGN0eCwgeCwgeSt0b3AsIHcsIGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY292ZXJhZ2UgbWlzbWF0Y2ggY29sb3JpbmcgLS0gZG9uJ3QgdHJ5IHRvIGRvIHRoaXMgaW4gYWJvdmUgbG9vcCwgY29sb3IgYmFyIHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2hlbiB3PDFcclxuICAgICAgICBpZiAoc2VxdWVuY2UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY292ZXJhZ2VNYXAuY292ZXJhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBicCA9IChjb3ZlcmFnZU1hcC5icFN0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnAgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChicCA+IGJwRW5kKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBpdGVtID0gY292ZXJhZ2VNYXAuY292ZXJhZ2VbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGggPSAoaXRlbS50b3RhbCAvIHRoaXMuZGF0YVJhbmdlLm1heCkgKiB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmhlaWdodCAtIGg7XHJcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoYnAgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZkJhc2UgPSBzZXF1ZW5jZVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzTWlzbWF0Y2gocmVmQmFzZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHtmaWxsU3R5bGU6IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbcmVmQmFzZV19KTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHkrdG9wLCB3LCBoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRIZWlnaHQgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgW1wiQVwiLCBcIkNcIiwgXCJUXCIsIFwiR1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChudWNsZW90aWRlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gaXRlbVtcInBvc1wiICsgbnVjbGVvdGlkZV0gKyBpdGVtW1wibmVnXCIgKyBudWNsZW90aWRlXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub24tbG9nb3JpdG1pY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaCA9IChjb3VudCAvIHNlbGYuZGF0YVJhbmdlLm1heCkgKiBzZWxmLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAoc2VsZi5oZWlnaHQgLSBoaCkgLSBhY2N1bXVsYXRlZEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRIZWlnaHQgKz0gaGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwge2ZpbGxTdHlsZTogR3JhcGhpY3MubnVjbGVvdGlkZUNvbG9yc1tudWNsZW90aWRlXX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHkrdG9wLCB3LCBoaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uLCB4T2Zmc2V0LCB5T2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBjb3ZlcmFnZU1hcCA9IHRoaXMuZmVhdHVyZVNvdXJjZS5hbGlnbm1lbnRDb250YWluZXIuY292ZXJhZ2VNYXAsXHJcbiAgICAgICAgICAgIGNvdmVyYWdlTWFwSW5kZXgsXHJcbiAgICAgICAgICAgIGNvdmVyYWdlLFxyXG4gICAgICAgICAgICBuYW1lVmFsdWVzID0gW107XHJcblxyXG5cclxuICAgICAgICBjb3ZlcmFnZU1hcEluZGV4ID0gZ2Vub21pY0xvY2F0aW9uIC0gY292ZXJhZ2VNYXAuYnBTdGFydDtcclxuICAgICAgICBjb3ZlcmFnZSA9IGNvdmVyYWdlTWFwLmNvdmVyYWdlW2NvdmVyYWdlTWFwSW5kZXhdO1xyXG5cclxuICAgICAgICBpZiAoY292ZXJhZ2UpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goaWd2LmJyb3dzZXIucmVmZXJlbmNlRnJhbWUuY2hyICsgXCI6XCIgKyBpZ3YubnVtYmVyRm9ybWF0dGVyKDEgKyBnZW5vbWljTG9jYXRpb24pKTtcclxuXHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ1RvdGFsIENvdW50JywgdmFsdWU6IGNvdmVyYWdlLnRvdGFsfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBXHJcbiAgICAgICAgICAgIHRtcCA9IGNvdmVyYWdlLnBvc0EgKyBjb3ZlcmFnZS5uZWdBO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMCkgIHRtcCA9IHRtcC50b1N0cmluZygpICsgXCIgKFwiICsgTWF0aC5mbG9vcigoKGNvdmVyYWdlLnBvc0EgKyBjb3ZlcmFnZS5uZWdBKSAvIGNvdmVyYWdlLnRvdGFsKSAqIDEwMC4wKSArIFwiJSlcIjtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnQScsIHZhbHVlOiB0bXB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBDXHJcbiAgICAgICAgICAgIHRtcCA9IGNvdmVyYWdlLnBvc0MgKyBjb3ZlcmFnZS5uZWdDO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMCkgIHRtcCA9IHRtcC50b1N0cmluZygpICsgXCIgKFwiICsgTWF0aC5mbG9vcigodG1wIC8gY292ZXJhZ2UudG90YWwpICogMTAwLjApICsgXCIlKVwiO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goe25hbWU6ICdDJywgdmFsdWU6IHRtcH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gR1xyXG4gICAgICAgICAgICB0bXAgPSBjb3ZlcmFnZS5wb3NHICsgY292ZXJhZ2UubmVnRztcclxuICAgICAgICAgICAgaWYgKHRtcCA+IDApICB0bXAgPSB0bXAudG9TdHJpbmcoKSArIFwiIChcIiArIE1hdGguZmxvb3IoKHRtcCAvIGNvdmVyYWdlLnRvdGFsKSAqIDEwMC4wKSArIFwiJSlcIjtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnRycsIHZhbHVlOiB0bXB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRcclxuICAgICAgICAgICAgdG1wID0gY292ZXJhZ2UucG9zVCArIGNvdmVyYWdlLm5lZ1Q7XHJcbiAgICAgICAgICAgIGlmICh0bXAgPiAwKSAgdG1wID0gdG1wLnRvU3RyaW5nKCkgKyBcIiAoXCIgKyBNYXRoLmZsb29yKCh0bXAgLyBjb3ZlcmFnZS50b3RhbCkgKiAxMDAuMCkgKyBcIiUpXCI7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ1QnLCB2YWx1ZTogdG1wfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBOXHJcbiAgICAgICAgICAgIHRtcCA9IGNvdmVyYWdlLnBvc04gKyBjb3ZlcmFnZS5uZWdOO1xyXG4gICAgICAgICAgICBpZiAodG1wID4gMCkgIHRtcCA9IHRtcC50b1N0cmluZygpICsgXCIgKFwiICsgTWF0aC5mbG9vcigodG1wIC8gY292ZXJhZ2UudG90YWwpICogMTAwLjApICsgXCIlKVwiO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goe25hbWU6ICdOJywgdmFsdWU6IHRtcH0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEFsaWdubWVudFRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZywgcGFyZW50KSB7XHJcblx0ICAgIHRoaXMuY29uZmlnPWNvbmZpZztcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlID0gcGFyZW50LmZlYXR1cmVfc291cmNlO1xyXG4gICAgIFxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50Um93SGVpZ2h0ID0gY29uZmlnLmFsaWdubWVudFJvd0hlaWdodCB8fCA2O1xyXG5cclxuICAgICAgICB0aGlzLm5lZ1N0cmFuZENvbG9yID0gY29uZmlnLm5lZ1N0cmFuZENvbG9yIHx8IFwicmdiYSgxNTAsIDE1MCwgMjMwLCAwLjc1KVwiO1xyXG4gICAgICAgIHRoaXMucG9zU3RyYW5kQ29sb3IgPSBjb25maWcucG9zU3RyYW5kQ29sb3IgfHwgXCJyZ2JhKDIzMCwgMTUwLCAxNTAsIDAuNzUpXCI7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRpb25Db2xvciA9IGNvbmZpZy5pbnNlcnRpb25Db2xvciB8fCBcInJnYigxMzgsIDk0LCAxNjEpXCI7XHJcbiAgICAgICAgdGhpcy5kZWxldGlvbkNvbG9yID0gY29uZmlnLmRlbGV0aW9uQ29sb3IgfHwgXCJibGFja1wiO1xyXG4gICAgICAgIHRoaXMuc2tpcHBlZENvbG9yID0gY29uZmlnLnNraXBwZWRDb2xvciB8fCBcInJnYigxNTAsIDE3MCwgMTcwKVwiO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yQnkgPSBjb25maWcuY29sb3JCeSB8fCBcIm5vbmVcIjtcclxuICAgICAgICB0aGlzLmNvbG9yQnlUYWcgPSBjb25maWcuY29sb3JCeVRhZztcclxuICAgICAgICB0aGlzLmJhbUNvbG9yVGFnID0gY29uZmlnLmJhbUNvbG9yVGFnID09PSB1bmRlZmluZWQgPyBcIllDXCIgOiBjb25maWcuYmFtQ29sb3JUYWc7XHJcblxyXG4gICAgICAgIC8vIHNvcnQgYWxpZ25tZW50IHJvd3NcclxuICAgICAgICB0aGlzLnNvcnRPcHRpb24gPSBjb25maWcuc29ydE9wdGlvbiB8fCB7c29ydDogXCJOVUNMRU9USURFXCJ9O1xyXG5cclxuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb24gPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmhhc1BhaXJzID0gZmFsc2U7ICAgLy8gVW50aWwgcHJvdmVuIG90aGVyd2lzZVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlUGl4ZWxIZWlnaHQoYWxpZ25tZW50Q29udGFpbmVyKSB7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cykge1xyXG4gICAgICAgICAgICB2YXIgaCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRDb250YWluZXIuaGFzRG93bnNhbXBsZWRJbnRlcnZhbHMoKSkge1xyXG4gICAgICAgICAgICAgICAgaCArPSBkb3duc2FtcGxlUm93SGVpZ2h0ICsgYWxpZ25tZW50U3RhcnRHYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGggKyAodGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCAqIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkgKyA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdyhvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MgPSBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyxcclxuICAgICAgICAgICAgc2VxdWVuY2UgPSBhbGlnbm1lbnRDb250YWluZXIuc2VxdWVuY2UsXHJcbiAgICAgICAgICAgIGJhc2VfdGV4dD1cIm5vcm1hbCBcIisodGhpcy5jb25maWcuZmVhdHVyZUhlaWdodC0yKStcInB4IEFyaWFsXCI7XHJcbiAgICAgICAgaWYgKCFwYWNrZWRBbGlnbm1lbnRSb3dzKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdG9wID0gb3B0aW9ucy50b3A7XHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIHNlcXVlbmNlID0gc2VxdWVuY2UudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmYWxzZS8qYWxpZ25tZW50Q29udGFpbmVyLmhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkqLykge1xyXG4gICAgICAgICAgICBhbGlnbm1lbnRSb3dZSW5zZXQgPSBkb3duc2FtcGxlUm93SGVpZ2h0ICsgYWxpZ25tZW50U3RhcnRHYXA7XHJcblxyXG4gICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRJbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4QmxvY2tTdGFydCA9IChpbnRlcnZhbC5zdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQgPSAoaW50ZXJ2YWwuZW5kIC0gYnBTdGFydCkgLyBicFBlclBpeGVsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4QmxvY2tFbmQgLSB4QmxvY2tTdGFydCA+IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHhCbG9ja0VuZCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4QmxvY2tTdGFydCwgMiwgKHhCbG9ja0VuZCAtIHhCbG9ja1N0YXJ0KSwgZG93bnNhbXBsZVJvd0hlaWdodCAtIDIsIHtmaWxsU3R5bGU6IFwiYmxhY2tcIn0pO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvd1lJbnNldCA9IDM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFja2VkQWxpZ25tZW50Um93cykge1xyXG5cclxuICAgICAgICAgICAgcGFja2VkQWxpZ25tZW50Um93cy5mb3JFYWNoKGZ1bmN0aW9uIHJlbmRlckFsaWdubWVudFJvdyhhbGlnbm1lbnRSb3csIGkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeVJlY3QgPSBhbGlnbm1lbnRSb3dZSW5zZXQgKyAoc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodCAqIGkpK3RvcCxcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRIZWlnaHQgPSBzZWxmLmNvbmZpZy5mZWF0dXJlSGVpZ2h0IC0gMixcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGlnbm1lbnRSb3cuYWxpZ25tZW50cy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oYXNQYWlycyA9IHNlbGYuaGFzUGFpcnMgfHwgYWxpZ25tZW50LmlzUGFpcmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmKSA8IGJwU3RhcnQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPiBicEVuZCkgYnJlYWs7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gYWxpZ25tZW50LmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgaW5zdGFuY2VvZiBQYWlyZWRBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdQYWlyQ29ubmVjdG9yKGFsaWdubWVudCwgeVJlY3QsIGFsaWdubWVudEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3U2luZ2xlQWxpZ25tZW50KGFsaWdubWVudC5maXJzdEFsaWdubWVudCwgeVJlY3QsIGFsaWdubWVudEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1NpbmdsZUFsaWdubWVudChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50LCB5UmVjdCwgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTaW5nbGVBbGlnbm1lbnQoYWxpZ25tZW50LCB5UmVjdCwgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBhbGlnbm1lbnQgaXMgYSBQYWlyZWRBbGlnbm1lbnRcclxuICAgICAgICBmdW5jdGlvbiBkcmF3UGFpckNvbm5lY3RvcihhbGlnbm1lbnQsIHlSZWN0LCBhbGlnbm1lbnRIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb2xvciA9IHNlbGYuZ2V0QWxpZ25tZW50Q29sb3IoYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KSxcclxuICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvciA9IGFsaWdubWVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgeEJsb2NrU3RhcnQgPSAoYWxpZ25tZW50LmNvbm5lY3RpbmdTdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgIHhCbG9ja0VuZCA9IChhbGlnbm1lbnQuY29ubmVjdGluZ0VuZCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgIHlTdHJva2VkTGluZSA9IHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LmNvbm5lY3RpbmdFbmQpIDwgYnBTdGFydCB8fCBhbGlnbm1lbnQuY29ubmVjdGluZ1N0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Q29sb3IgPSBVdGlscy5hZGRBbHBoYVRvUkdCKGFsaWdubWVudENvbG9yLCBcIjAuMTVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvciwgc3Ryb2tlU3R5bGU6IG91dGxpbmVDb2xvcn0pO1xyXG5cclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHhCbG9ja1N0YXJ0LCB5U3Ryb2tlZExpbmUsIHhCbG9ja0VuZCwgeVN0cm9rZWRMaW5lKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZHJhd1NpbmdsZUFsaWdubWVudChhbGlnbm1lbnQsIHlSZWN0LCBhbGlnbm1lbnRIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb2xvciA9IHNlbGYuZ2V0QWxpZ25tZW50Q29sb3IoYWxpZ25tZW50KSxcclxuICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvciA9IGFsaWdubWVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgbGFzdEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tzID0gYWxpZ25tZW50LmJsb2NrcyxcclxuICAgICAgICAgICAgICAgIGJsb2NrLFxyXG4gICAgICAgICAgICAgICAgYjtcclxuXHJcbiAgICAgICAgICAgIGlmICgoYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmKSA8IGJwU3RhcnQgfHwgYWxpZ25tZW50LnN0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Q29sb3IgPSBVdGlscy5hZGRBbHBoYVRvUkdCKGFsaWdubWVudENvbG9yLCBcIjAuMTVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvciwgc3Ryb2tlU3R5bGU6IG91dGxpbmVDb2xvcn0pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChiID0gMDsgYiA8IGJsb2Nrcy5sZW5ndGg7IGIrKykgeyAgIC8vIENhbid0IHVzZSBmb3JFYWNoIGhlcmUgLS0gd2UgbmVlZCBhYmlsaXR5IHRvIGJyZWFrXHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2sgPSBibG9ja3NbYl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChibG9jay5zdGFydCArIGJsb2NrLmxlbikgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBkcmF3QmxvY2soYmxvY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYmxvY2suc3RhcnQgKyBibG9jay5sZW4pID4gYnBFbmQpIGJyZWFrOyAgLy8gRG8gdGhpcyBhZnRlciBkcmF3QmxvY2sgdG8gaW5zdXJlIGdhcHMgYXJlIGRyYXduXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5pbnNlcnRpb25zLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZPZmZzZXQgPSBibG9jay5zdGFydCAtIGJwU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCA9IHJlZk9mZnNldCAvIGJwUGVyUGl4ZWwgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhCbG9jayA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxSZWN0KGN0eCwgeEJsb2NrU3RhcnQsIHlSZWN0IC0gMSwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0ICsgMiwge2ZpbGxTdHlsZTogc2VsZi5pbnNlcnRpb25Db2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0Jsb2NrKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxT2Zmc2V0ID0gYmxvY2suc3RhcnQgLSBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJsb2NrU3RhcnQgPSAoYmxvY2suc3RhcnQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kID0gKChibG9jay5zdGFydCArIGJsb2NrLmxlbikgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhCbG9jayA9IE1hdGgubWF4KDEsIHhCbG9ja0VuZCAtIHhCbG9ja1N0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aEFycm93SGVhZCA9IHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQgLyAyLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSBibG9jay5zZXEudG9VcHBlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkQ29sb3IgPSBzZWxmLnNraXBwZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGlvbkNvbG9yID0gc2VsZi5kZWxldGlvbkNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZkNoYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZENoYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFF1YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeEJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhCYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQmFzZSxcclxuICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICB5U3Ryb2tlZExpbmUgPSB5UmVjdCArIGFsaWdubWVudEhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrLmdhcFR5cGUgIT09IHVuZGVmaW5lZCAmJiB4QmxvY2tFbmQgIT09IHVuZGVmaW5lZCAmJiBsYXN0QmxvY2tFbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIkRcIiA9PT0gYmxvY2suZ2FwVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgbGFzdEJsb2NrRW5kLCB5U3Ryb2tlZExpbmUsIHhCbG9ja1N0YXJ0LCB5U3Ryb2tlZExpbmUsIHtzdHJva2VTdHlsZTogZGVsZXRpb25Db2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIGxhc3RCbG9ja0VuZCwgeVN0cm9rZWRMaW5lLCB4QmxvY2tTdGFydCwgeVN0cm9rZWRMaW5lLCB7c3Ryb2tlU3R5bGU6IHNraXBwZWRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RCbG9ja0VuZCA9IHhCbG9ja0VuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSA9PT0gYWxpZ25tZW50LnN0cmFuZCAmJiBiID09PSBibG9ja3MubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgYmxvY2sgb24gKyBzdHJhbmRcclxuICAgICAgICAgICAgICAgICAgICB4ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQgKyB3aWR0aEFycm93SGVhZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrU3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyAoYWxpZ25tZW50SGVpZ2h0IC8gMi4wKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyBhbGlnbm1lbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdF07XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFBvbHlnb24oY3R4LCB4LCB5LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwge3N0cm9rZVN0eWxlOiBvdXRsaW5lQ29sb3J9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSA9PT0gYWxpZ25tZW50LnN0cmFuZCAmJiBiID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgYmxvY2sgb24gLSBzdHJhbmRcclxuICAgICAgICAgICAgICAgICAgICB4ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhCbG9ja1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCAtIHdpZHRoQXJyb3dIZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmxvY2tFbmRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyAoYWxpZ25tZW50SGVpZ2h0IC8gMi4wKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVJlY3QgKyBhbGlnbm1lbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlSZWN0ICsgYWxpZ25tZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5UmVjdF07XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFBvbHlnb24oY3R4LCB4LCB5LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwge3N0cm9rZVN0eWxlOiBvdXRsaW5lQ29sb3J9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGlndi5ncmFwaGljcy5maWxsUmVjdChjdHgsIHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBcIndoaXRlXCJ9KTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0LCB7ZmlsbFN0eWxlOiBhbGlnbm1lbnRDb2xvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQubXEgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvdXRsaW5lQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHhCbG9ja1N0YXJ0LCB5UmVjdCwgd2lkdGhCbG9jaywgYWxpZ25tZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIG1pc21hdGNoIGNvbG9yaW5nIGlmIGEgcmVmc2VxIGV4aXN0cyB0byBkbyB0aGUgY29tcGFyaXNvblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlICYmIGJsb2NrU2VxICE9PSBcIipcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBibG9ja1NlcS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQ2hhciA9IGJsb2NrU2VxLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQ2hhciA9IHNlcXVlbmNlLmNoYXJBdChzZXFPZmZzZXQgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRDaGFyID09PSBcIj1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZENoYXIgPSByZWZDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQ2hhciA9PT0gXCJYXCIgfHwgcmVmQ2hhciAhPT0gcmVhZENoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5xdWFsICYmIGJsb2NrLnF1YWwubGVuZ3RoID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRRdWFsID0gYmxvY2sucXVhbFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckJhc2UgPSBzaGFkZWRCYXNlQ29sb3IocmVhZFF1YWwsIHJlYWRDaGFyLCBpICsgYmxvY2suc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JCYXNlID0gR3JhcGhpY3MubnVjbGVvdGlkZUNvbG9yc1tyZWFkQ2hhcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEJhc2UgPSAoKGJsb2NrLnN0YXJ0ICsgaSkgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhCYXNlID0gTWF0aC5tYXgoMSwgMSAvIGJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsPDAuMTUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIHJlYWRDaGFyLCB4QmFzZSt3aWR0aEJhc2UvMiwgeVJlY3QrMiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogY29sb3JCYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBiYXNlX3RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTonaGFuZ2luZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHhCYXNlLCB5UmVjdCwgd2lkdGhCYXNlLCBhbGlnbm1lbnRIZWlnaHQsIHtmaWxsU3R5bGU6IGNvbG9yQmFzZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50Um93WUluc2V0ICsgKHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQgKiBwYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkrdG9wO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzb3J0QWxpZ25tZW50Um93cyhnZW5vbWljTG9jYXRpb24sIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIgPSB0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnRSb3dzID0gYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3M7XHJcblxyXG4gICAgICAgIGFsaWdubWVudFJvd3MuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50Um93KSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdy51cGRhdGVTY29yZShnZW5vbWljTG9jYXRpb24sIGFsaWdubWVudENvbnRhaW5lciwgc29ydE9wdGlvbik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFsaWdubWVudFJvd3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zb3J0RGlyZWN0aW9uID8gYS5zY29yZSAtIGIuc2NvcmUgOiBiLnNjb3JlIC0gYS5zY29yZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRvU29ydEFsaWdubWVudFJvd3MoZ2Vub21pY0xvY2F0aW9uLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24sIHNvcnREaXJlY3Rpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIGFsaWdubWVudFJvd3MgPSBnZW5vbWljSW50ZXJ2YWwucGFja2VkQWxpZ25tZW50Um93cyxcclxuICAgICAgICAgICAgc2VxdWVuY2UgPSBnZW5vbWljSW50ZXJ2YWwuc2VxdWVuY2U7XHJcblxyXG4gICAgICAgIGlmIChzZXF1ZW5jZSkge1xyXG4gICAgICAgICAgICBzZXF1ZW5jZSA9IHNlcXVlbmNlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBzZXF1ZW5jZSwgbm8gdHJhdmVyc2FsLiBObyBkaXNjdXNzaW9uIVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxpZ25tZW50Um93cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnRSb3cpIHtcclxuICAgICAgICAgICAgYWxpZ25tZW50Um93LnVwZGF0ZVNjb3JlKGdlbm9taWNMb2NhdGlvbiwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYWxpZ25tZW50Um93cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0RGlyZWN0aW9uID8gYS5zY29yZSAtIGIuc2NvcmUgOiBiLnNjb3JlIC0gYS5zY29yZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbiwgeE9mZnNldCwgeU9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgcGFja2VkQWxpZ25tZW50Um93cyA9IHRoaXMuZmVhdHVyZVNvdXJjZS5hbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyxcclxuICAgICAgICAgICAgZG93bnNhbXBsZWRJbnRlcnZhbHMgPSB0aGlzLmZlYXR1cmVTb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmRvd25zYW1wbGVkSW50ZXJ2YWxzLFxyXG4gICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRzSW5kZXgsXHJcbiAgICAgICAgICAgIGFsaWdubWVudFJvdyxcclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCxcclxuICAgICAgICAgICAgaSwgbGVuLCB0bXA7XHJcblxyXG4gICAgICAgIHBhY2tlZEFsaWdubWVudHNJbmRleCA9IE1hdGguZmxvb3IoKHlPZmZzZXQgLSAoYWxpZ25tZW50Um93WUluc2V0KSkgLyB0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKHBhY2tlZEFsaWdubWVudHNJbmRleCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb3duc2FtcGxlZEludGVydmFsc1tpXS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gJiYgKGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldLmVuZCA+PSBnZW5vbWljTG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IGRvd25zYW1wbGVkSW50ZXJ2YWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYWNrZWRBbGlnbm1lbnRzSW5kZXggPCBwYWNrZWRBbGlnbm1lbnRSb3dzLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50Um93ID0gcGFja2VkQWxpZ25tZW50Um93c1twYWNrZWRBbGlnbm1lbnRzSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgY2xpY2tlZE9iamVjdCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLmxlbmd0aCwgdG1wOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0bXAgPSBhbGlnbm1lbnRSb3cuYWxpZ25tZW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG1wLnN0YXJ0IDw9IGdlbm9taWNMb2NhdGlvbiAmJiAodG1wLnN0YXJ0ICsgdG1wLmxlbmd0aE9uUmVmID49IGdlbm9taWNMb2NhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlja2VkT2JqZWN0ID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNsaWNrZWRPYmplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWNrZWRPYmplY3QucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIGdldEFsaWdubWVudENvbG9yKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB2YXIgYWxpZ25tZW50VHJhY2sgPSB0aGlzLFxyXG4gICAgICAgICAgICBvcHRpb24gPSBhbGlnbm1lbnRUcmFjay5jb2xvckJ5LFxyXG4gICAgICAgICAgICB0YWdWYWx1ZSwgY29sb3IsXHJcbiAgICAgICAgICAgIHN0cmFuZDtcclxuXHJcbiAgICAgICAgY29sb3IgPSBhbGlnbm1lbnRUcmFjay5wYXJlbnQuY29uZmlnLmNvbG9yOyAvLyBkZWZhdWx0XHJcblxyXG4gICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwic3RyYW5kXCI6XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGFsaWdubWVudC5zdHJhbmQgPyBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvciA6IGFsaWdubWVudFRyYWNrLm5lZ1N0cmFuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmaXJzdE9mUGFpclN0cmFuZFwiOlxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGFsaWdubWVudCBpbnN0YW5jZW9mIFBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50LmZpcnN0T2ZQYWlyU3RyYW5kKCkgPyBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvciA6IGFsaWdubWVudFRyYWNrLm5lZ1N0cmFuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ25tZW50LmlzUGFpcmVkKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5pc0ZpcnN0T2ZQYWlyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhbGlnbm1lbnQuc3RyYW5kID8gYWxpZ25tZW50VHJhY2sucG9zU3RyYW5kQ29sb3IgOiBhbGlnbm1lbnRUcmFjay5uZWdTdHJhbmRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxpZ25tZW50LmlzU2Vjb25kT2ZQYWlyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhbGlnbm1lbnQuc3RyYW5kID8gYWxpZ25tZW50VHJhY2submVnU3RyYW5kQ29sb3IgOiBhbGlnbm1lbnRUcmFjay5wb3NTdHJhbmRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IuIFBhaXJlZCBhbGlnbm1lbnRzIGFyZSBlaXRoZXIgZmlyc3Qgb3Igc2Vjb25kLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcInRhZ1wiOlxyXG5cclxuICAgICAgICAgICAgICAgIHRhZ1ZhbHVlID0gYWxpZ25tZW50LnRhZ3MoKVthbGlnbm1lbnRUcmFjay5jb2xvckJ5VGFnXTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnRUcmFjay5iYW1Db2xvclRhZyA9PT0gYWxpZ25tZW50VHJhY2suY29sb3JCeVRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVQ1NDIHN0eWxlIGNvbG9yIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IFwicmdiKFwiICsgdGFnVmFsdWUgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50VHJhY2sudGFnQ29sb3JzLmdldENvbG9yKHRhZ1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gYWxpZ25tZW50VHJhY2sucGFyZW50LmNvbmZpZy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuQkFNVHJhY2suZmlsdGVycyA9IHtcclxuXHJcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0cmFuZDogZnVuY3Rpb24gKHN0cmFuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdHJhbmQgPT09IHN0cmFuZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtYXBwaW5nUXVhbGl0eTogZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb3dlciAmJiBhbGlnbm1lbnQubXEgPCBsb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh1cHBlciAmJiBhbGlnbm1lbnQubXEgPiB1cHBlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5NTFZUcmFjay5jdXN0b21fdHJhY2tzW1wiYmFtXCJdPUJBTVRyYWNrO1xyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJiYW1cIl09e1xyXG5cdFwiY2xhc3NcIjpCQU1UcmFjayxcclxuXHRuYW1lOlwiQkFNXCJcclxufVxyXG5cclxuZXhwb3J0IHtCQU1UcmFjayxDb3ZlcmFnZVRyYWNrLEFsaWdubWVudFRyYWNrfTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQTVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBO0FBMkNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBR0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQXpTQTtBQUNBO0FBOFNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBSEE7QUFJQTtBQUpBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBY0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUF3QkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTtBQXlDQTtBQUVBOzs7QUE3SEE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBK0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/bam_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/bigwig.js":
/*!****************************!*\
  !*** .Panel/src/bigwig.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BinaryParser = exports.BWSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n//import {pako} from \"./vendor/pako_inflate.js\";\n\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nvar _zlib_and_gzip = __webpack_require__(/*! ./vendor/zlib_and_gzip.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//***********js/bigwig/bufferedReader.js*****************\nvar BufferedReader = function () {\n    function BufferedReader(config, contentLength, bufferSize) {\n        _classCallCheck(this, BufferedReader);\n\n        this.path = config.url;\n        this.contentLength = contentLength;\n        this.bufferSize = bufferSize ? bufferSize : 512000;\n        this.range = { start: -1, size: -1 };\n        this.config = config;\n    }\n\n    /**\r\n     *\r\n     * @param requestedRange - byte rangeas {start, size}\r\n     * @param fulfill - function to receive result\r\n     * @param asUint8 - optional flag to return result as an UInt8Array\r\n     */\n\n\n    _createClass(BufferedReader, [{\n        key: \"dataViewForRange\",\n        value: function dataViewForRange(requestedRange, asUint8) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var hasData = self.data && self.range.start <= requestedRange.start && self.range.start + self.range.size >= requestedRange.start + requestedRange.size,\n                    bufferSize,\n                    loadRange;\n\n                if (hasData) {\n                    subbuffer(self, requestedRange, asUint8);\n                } else {\n                    // Expand buffer size if needed, but not beyond content length\n                    bufferSize = Math.max(self.bufferSize, requestedRange.size);\n\n                    if (self.contentLength > 0 && requestedRange.start + bufferSize > self.contentLength) {\n                        loadRange = { start: requestedRange.start };\n                    } else {\n                        loadRange = { start: requestedRange.start, size: bufferSize };\n                    }\n\n                    _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: loadRange })).then(function (arrayBuffer) {\n                        self.data = arrayBuffer;\n                        self.range = loadRange;\n                        subbuffer(self, requestedRange, asUint8);\n                    }).catch(reject);\n                }\n\n                function subbuffer(bufferedReader, requestedRange, asUint8) {\n\n                    var len = bufferedReader.data.byteLength,\n                        bufferStart = requestedRange.start - bufferedReader.range.start,\n                        result = asUint8 ? new Uint8Array(bufferedReader.data, bufferStart, len - bufferStart) : new DataView(bufferedReader.data, bufferStart, len - bufferStart);\n                    fulfill(result);\n                }\n            });\n        }\n    }]);\n\n    return BufferedReader;\n}();\n\n//**********js/bigwig/bwSource.js***************\n\n\nvar BWSource = function () {\n    function BWSource(config, create_feature_function) {\n        _classCallCheck(this, BWSource);\n\n        this.reader = new BWReader(config);\n        this.bufferedReader = new BufferedReader(config);\n        if (!create_feature_function) {\n            this.create_feature = BWSource.createFeature;\n        } else {\n            this.create_feature = create_feature_function;\n        }\n    }\n\n    /**\r\n    * Creates a panel\r\n    * @param {string} chr - The chromosome\r\n    * @param {int} bpStart The starting postition \r\n    * @param {int} bpEnd - The end of the region to show\r\n    * @param {boolean} use_existing - If true then the cached feature will be used- only used\r\n    * if the co-oridinates have not changed. Although, the BWreader has a cache, it is sometimes\r\n    * ignored and features are re-fetched for the same region\r\n    * @param {object} data - Should contain pixelWidth- the width of the entire canvas and \r\n    * bpPerPixel.\r\n    */\n\n\n    _createClass(BWSource, [{\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, use_existing, data) {\n            this.st = new Date().getTime();\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                if (self.features && use_existing) {\n                    fulfill(self.features);\n                    return;\n                }\n                self.reader.getZoomHeaders().then(function (zoomLevelHeaders) {\n\n                    // Select a biwig \"zoom level\" appropriate for the current resolution\n                    var bwReader = self.reader,\n                        bufferedReader = self.bufferedReader,\n                        bpp = data.bpPerPixel,\n                        zoomLevelHeader = BWSource.zoomLevelForScale(bpp, zoomLevelHeaders),\n                        treeOffset;\n\n                    if (zoomLevelHeader && bwReader.type === \"BigWig\") {\n                        treeOffset = zoomLevelHeader.indexOffset;\n                        self.decodeFunction = BWSource.decodeZoomData;\n                    } else {\n                        treeOffset = bwReader.header.fullIndexOffset;\n                        if (bwReader.type === \"BigWig\") {\n                            self.decodeFunction = BWSource.decodeWigData;\n                        } else {\n                            self.decodeFunction = self.decodeBedData;\n                        }\n                    }\n\n                    bwReader.loadRPTree(treeOffset).then(function (rpTree) {\n\n                        var chrIdx = self.reader.chromTree.dictionary[chr];\n                        if (chrIdx === undefined) {\n                            fulfill(null);\n                        } else {\n\n                            rpTree.findLeafItemsOverlapping(chrIdx, bpStart, bpEnd).then(function (leafItems) {\n\n                                var promises = [];\n\n                                if (!leafItems || leafItems.length == 0) fulfill([]);\n\n                                leafItems.forEach(function (item) {\n\n                                    promises.push(new Promise(function (fulfill, reject) {\n                                        var features = [];\n\n                                        bufferedReader.dataViewForRange({\n                                            start: item.dataOffset,\n                                            size: item.dataSize\n                                        }, true).then(function (uint8Array) {\n\n                                            var inflate = new _zlib_and_gzip.Zlib.Inflate(uint8Array);\n                                            var plain = inflate.decompress();\n\n                                            //var plain = pako.inflate(uint8Array);\n                                            self.decodeFunction(new DataView(plain.buffer), chr, chrIdx, bpStart, bpEnd, features);\n\n                                            fulfill(features);\n                                        }).catch(reject);\n                                    }));\n                                });\n\n                                Promise.all(promises).then(function (featureArrays) {\n                                    var en = new Date().getTime();\n                                    var e = en - self.st;\n                                    var a = bpp;\n                                    //console.log(e);\n                                    var i,\n                                        allFeatures = featureArrays[0];\n                                    if (featureArrays.length > 1) {\n                                        for (i = 1; i < featureArrays.length; i++) {\n                                            allFeatures = allFeatures.concat(featureArrays[i]);\n                                        }\n                                    }\n                                    allFeatures.sort(function (a, b) {\n                                        return a.start - b.start;\n                                    });\n                                    self.features = allFeatures;\n                                    fulfill(allFeatures);\n                                }).catch(reject);\n                            }).catch(function (error) {\n                                reject(error);\n                            });\n                        }\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"getDefaultRange\",\n        value: function getDefaultRange() {\n\n            if (this.reader.totalSummary != undefined) {\n                return this.reader.totalSummary.defaultRange;\n            } else {\n                return undefined;\n            }\n        }\n    }, {\n        key: \"decodeBedData\",\n        value: function decodeBedData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 3 * 4 + 1,\n                // Minimum # of bytes required for a bed record\n            chromId,\n                chromStart,\n                chromEnd,\n                rest,\n                tokens,\n                feature,\n                exonCount,\n                exonSizes,\n                exonStarts,\n                exons,\n                eStart,\n                eEnd;\n\n            while (binaryParser.remLength() >= minSize) {\n\n                chromId = binaryParser.getInt();\n                if (chromId != chrIdx) continue;\n\n                chromStart = binaryParser.getInt();\n                chromEnd = binaryParser.getInt();\n                rest = binaryParser.getString();\n\n                feature = { chr: chr, start: chromStart, end: chromEnd };\n\n                if (chromStart < bpEnd && chromEnd >= bpStart) {\n                    featureArray.push(feature);\n\n                    tokens = rest.split(\"\\t\");\n                    this.create_feature(tokens, feature);\n                }\n            }\n        }\n    }], [{\n        key: \"zoomLevelForScale\",\n        value: function zoomLevelForScale(bpPerPixel, zoomLevelHeaders) {\n\n            var level = null,\n                i,\n                zl;\n\n            for (i = 0; i < zoomLevelHeaders.length; i++) {\n\n                zl = zoomLevelHeaders[i];\n\n                if (zl.reductionLevel > bpPerPixel) {\n                    level = zl;\n                    break;\n                }\n            }\n\n            if (null == level) {\n                level = zoomLevelHeaders[zoomLevelHeaders.length - 1];\n            }\n\n            return level && level.reductionLevel < 4 * bpPerPixel ? level : null;\n        }\n    }, {\n        key: \"decodeWigData\",\n        value: function decodeWigData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                chromId = binaryParser.getInt(),\n                chromStart = binaryParser.getInt(),\n                chromEnd = binaryParser.getInt(),\n                itemStep = binaryParser.getInt(),\n                itemSpan = binaryParser.getInt(),\n                type = binaryParser.getByte(),\n                reserved = binaryParser.getByte(),\n                itemCount = binaryParser.getUShort(),\n                value;\n\n            if (chromId === chrIdx) {\n\n                while (itemCount-- > 0) {\n\n                    switch (type) {\n                        case 1:\n                            chromStart = binaryParser.getInt();\n                            chromEnd = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            break;\n                        case 2:\n                            chromStart = binaryParser.getInt();\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            break;\n                        case 3:\n                            // Fixed step\n                            value = binaryParser.getFloat();\n                            chromEnd = chromStart + itemSpan;\n                            chromStart += itemStep;\n                            break;\n\n                    }\n\n                    if (chromStart >= bpEnd) {\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"decodeZoomData\",\n        value: function decodeZoomData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\n\n            var binaryParser = new BinaryParser(data),\n                minSize = 8 * 4,\n                // Minimum # of bytes required for a zoom record\n            chromId,\n                chromStart,\n                chromEnd,\n                validCount,\n                minVal,\n                maxVal,\n                sumData,\n                sumSquares,\n                value;\n\n            while (binaryParser.remLength() >= minSize) {\n                chromId = binaryParser.getInt();\n                if (chromId === chrIdx) {\n\n                    chromStart = binaryParser.getInt();\n                    chromEnd = binaryParser.getInt();\n                    validCount = binaryParser.getInt();\n                    minVal = binaryParser.getFloat();\n                    maxVal = binaryParser.getFloat();\n                    sumData = binaryParser.getFloat();\n                    sumSquares = binaryParser.getFloat();\n                    value = validCount == 0 ? 0 : sumData / validCount;\n\n                    if (chromStart >= bpEnd && chromStart < 1000000000) {\n                        console.log(\"should have broken\");\n\n                        break; // Out of interval\n                    } else if (chromEnd > bpStart && Number.isFinite(value)) {\n                        featureArray.push({ chr: chr, start: chromStart, end: chromEnd, value: value });\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"createFeature\",\n        value: function createFeature(tokens, feature) {\n            if (tokens.length > 0) {\n                feature.name = tokens[0];\n            }\n\n            if (tokens.length > 1) {\n                feature.score = parseFloat(tokens[1]);\n            }\n            if (tokens.length > 2) {\n                feature.strand = tokens[2];\n            }\n            if (tokens.length > 3) {\n                feature.cdStart = parseInt(tokens[3]);\n            }\n            if (tokens.length > 4) {\n                feature.cdEnd = parseInt(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                //if (tokens[5] !== \".\" && tokens[5] !== \"0\")\n                //feature.color = igv.createColorString(tokens[5]);\n            }\n            if (tokens.length > 8) {\n                exonCount = parseInt(tokens[6]);\n                exonSizes = tokens[7].split(',');\n                exonStarts = tokens[8].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    exons.push({ start: eStart, end: eEnd });\n                }\n\n                feature.exons = exons;\n            }\n        }\n    }]);\n\n    return BWSource;\n}();\n\n//************js/bigwig/bwReader.js*****************\n\n\nvar BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High\nvar BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low\nvar BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High\nvar BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low\nvar BBFILE_HEADER_SIZE = 64;\n\nvar BWReader = function () {\n    function BWReader(config) {\n        _classCallCheck(this, BWReader);\n\n        this.path = config.url;\n        this.headPath = config.headURL || this.path;\n        this.rpTreeCache = {};\n        this.config = $.extend({}, config, true);\n    }\n\n    _createClass(BWReader, [{\n        key: \"getZoomHeaders\",\n        value: function getZoomHeaders() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                if (self.zoomLevelHeaders) {\n                    fulfill(self.zoomLevelHeaders);\n                } else {\n                    self.loadHeader().then(function () {\n                        fulfill(self.zoomLevelHeaders);\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }\n            });\n        }\n    }, {\n        key: \"loadHeader\",\n        value: function loadHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: { start: 0, size: BBFILE_HEADER_SIZE } })).then(function (data) {\n\n                    if (!data) return;\n\n                    // Assume low-to-high unless proven otherwise\n                    self.littleEndian = true;\n\n                    var binaryParser = new BinaryParser(new DataView(data));\n\n                    var magic = binaryParser.getUInt();\n\n                    if (magic === BIGWIG_MAGIC_LTH) {\n                        self.type = \"BigWig\";\n                    } else if (magic == BIGBED_MAGIC_LTH) {\n                        self.type = \"BigBed\";\n                    } else {\n                        //Try big endian order\n                        self.littleEndian = false;\n\n                        binaryParser.littleEndian = false;\n                        binaryParser.position = 0;\n                        var magic = binaryParser.getUInt();\n\n                        if (magic === BIGWIG_MAGIC_HTL) {\n                            self.type = \"BigWig\";\n                        } else if (magic == BIGBED_MAGIC_HTL) {\n                            self.type = \"BigBed\";\n                        } else {\n                            // TODO -- error, unknown file type  or BE\n                        }\n                    }\n                    // Table 5  \"Common header for BigWig and BigBed files\"\n                    self.header = {};\n                    self.header.bwVersion = binaryParser.getUShort();\n                    self.header.nZoomLevels = binaryParser.getUShort();\n                    self.header.chromTreeOffset = binaryParser.getLong();\n                    self.header.fullDataOffset = binaryParser.getLong();\n                    self.header.fullIndexOffset = binaryParser.getLong();\n                    self.header.fieldCount = binaryParser.getUShort();\n                    self.header.definedFieldCount = binaryParser.getUShort();\n                    self.header.autoSqlOffset = binaryParser.getLong();\n                    self.header.totalSummaryOffset = binaryParser.getLong();\n                    self.header.uncompressBuffSize = binaryParser.getInt();\n                    self.header.reserved = binaryParser.getLong();\n\n                    self.loadZoomHeadersAndChrTree().then(fulfill).catch(reject);\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"loadZoomHeadersAndChrTree\",\n        value: function loadZoomHeadersAndChrTree() {\n\n            var startOffset = BBFILE_HEADER_SIZE,\n                self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var range = { start: startOffset, size: self.header.fullDataOffset - startOffset + 5 };\n\n                _igvxhr.igvxhr.loadArrayBuffer(self.path, Object.assign(self.config, { range: range })).then(function (data) {\n\n                    var nZooms = self.header.nZoomLevels,\n                        binaryParser = new BinaryParser(new DataView(data)),\n                        i,\n                        len,\n                        zoomNumber,\n                        zlh;\n\n                    self.zoomLevelHeaders = [];\n\n                    self.firstZoomDataOffset = Number.MAX_VALUE;\n                    for (i = 0; i < nZooms; i++) {\n                        zoomNumber = nZooms - i;\n                        zlh = new ZoomLevelHeader(zoomNumber, binaryParser);\n                        self.firstZoomDataOffset = Math.min(zlh.dataOffset, self.firstZoomDataOffset);\n                        self.zoomLevelHeaders.push(zlh);\n                    }\n\n                    // Autosql\n                    if (self.header.autoSqlOffset > 0) {\n                        binaryParser.position = self.header.autoSqlOffset - startOffset;\n                        self.autoSql = binaryParser.getString();\n                    }\n\n                    // Total summary\n                    if (self.header.totalSummaryOffset > 0) {\n                        binaryParser.position = self.header.totalSummaryOffset - startOffset;\n                        self.totalSummary = new BWTotalSummary(binaryParser);\n                    }\n\n                    // Chrom data index\n                    if (self.header.chromTreeOffset > 0) {\n                        binaryParser.position = self.header.chromTreeOffset - startOffset;\n                        self.chromTree = new BPTree(binaryParser, startOffset);\n                    } else {}\n                    // TODO -- this is an error, not expected\n\n\n                    //Finally total data count\n                    binaryParser.position = self.header.fullDataOffset - startOffset;\n                    self.dataCount = binaryParser.getInt();\n\n                    fulfill();\n                }).catch(function (error) {\n                    reject(error);\n                });\n            });\n        }\n    }, {\n        key: \"loadRPTree\",\n        value: function loadRPTree(offset) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rpTree = self.rpTreeCache[offset];\n                if (rpTree) {\n                    fulfill(rpTree);\n                } else {\n                    rpTree = new RPTree(offset, self.contentLength, self.config, self.littleEndian);\n                    self.rpTreeCache[offset] = rpTree;\n                    rpTree.load().then(function () {\n                        fulfill(rpTree);\n                    }).catch(reject);\n                }\n            });\n        }\n    }]);\n\n    return BWReader;\n}();\n\nvar ZoomLevelHeader = function ZoomLevelHeader(index, byteBuffer) {\n    _classCallCheck(this, ZoomLevelHeader);\n\n    this.index = index;\n    this.reductionLevel = byteBuffer.getInt();\n    this.reserved = byteBuffer.getInt();\n    this.dataOffset = byteBuffer.getLong();\n    this.indexOffset = byteBuffer.getLong();\n};\n\nvar RPTREE_MAGIC_LTH = 0x2468ACE0;\nvar RPTREE_MAGIC_HTL = 0xE0AC6824;\nvar RPTREE_HEADER_SIZE = 48;\nvar RPTREE_NODE_LEAF_ITEM_SIZE = 32; // leaf item size\nvar RPTREE_NODE_CHILD_ITEM_SIZE = 24; // child item size\nvar BUFFER_SIZE = 512000;\n\n//***********js/bigwig/RPTree*******************\n\n\n//  buffer\n\nvar RPTree = function () {\n    function RPTree(fileOffset, contentLength, config, littleEndian) {\n        _classCallCheck(this, RPTree);\n\n        this.config = config;\n        this.filesize = contentLength;\n        this.fileOffset = fileOffset; // File offset to beginning of tree\n        this.path = config.url;\n        this.littleEndian = littleEndian;\n    }\n\n    _createClass(RPTree, [{\n        key: \"load\",\n        value: function load() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var rootNodeOffset = self.fileOffset + RPTREE_HEADER_SIZE,\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                self.readNode(rootNodeOffset, bufferedReader).then(function (node) {\n                    self.rootNode = node;\n                    fulfill(self);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"readNode\",\n        value: function readNode(filePosition, bufferedReader) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                bufferedReader.dataViewForRange({ start: filePosition, size: 4 }, false).then(function (dataView) {\n                    var binaryParser = new BinaryParser(dataView, self.littleEndian);\n\n                    var type = binaryParser.getByte();\n                    var isLeaf = type === 1 ? true : false;\n                    var reserved = binaryParser.getByte();\n                    var count = binaryParser.getUShort();\n\n                    filePosition += 4;\n\n                    var bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);\n                    var range2 = { start: filePosition, size: bytesRequired };\n\n                    bufferedReader.dataViewForRange(range2, false).then(function (dataView) {\n\n                        var i,\n                            items = new Array(count),\n                            binaryParser = new BinaryParser(dataView);\n\n                        if (isLeaf) {\n                            for (i = 0; i < count; i++) {\n                                var item = {\n                                    isLeaf: true,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    dataOffset: binaryParser.getLong(),\n                                    dataSize: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n                            fulfill(new RPTreeNode(items));\n                        } else {\n                            // non-leaf\n                            for (i = 0; i < count; i++) {\n\n                                var item = {\n                                    isLeaf: false,\n                                    startChrom: binaryParser.getInt(),\n                                    startBase: binaryParser.getInt(),\n                                    endChrom: binaryParser.getInt(),\n                                    endBase: binaryParser.getInt(),\n                                    childOffset: binaryParser.getLong()\n                                };\n                                items[i] = item;\n                            }\n\n                            fulfill(new RPTreeNode(items));\n                        }\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n    }, {\n        key: \"findLeafItemsOverlapping\",\n        value: function findLeafItemsOverlapping(chrIdx, startBase, endBase) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var leafItems = [],\n                    processing = new Set(),\n                    bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\n\n                processing.add(0); // Zero represents the root node\n                findLeafItems(self.rootNode, 0);\n\n                function findLeafItems(node, nodeId) {\n\n                    if (RPTree.overlaps(node, chrIdx, startBase, endBase)) {\n\n                        var items = node.items;\n\n                        items.forEach(function (item) {\n\n                            if (RPTree.overlaps(item, chrIdx, startBase, endBase)) {\n\n                                if (item.isLeaf) {\n                                    leafItems.push(item);\n                                } else {\n                                    if (item.childNode) {\n                                        findLeafItems(item.childNode);\n                                    } else {\n                                        processing.add(item.childOffset); // Represent node to-be-loaded by its file position\n                                        self.readNode(item.childOffset, bufferedReader).then(function (node) {\n                                            item.childNode = node;\n                                            findLeafItems(node, item.childOffset);\n                                        }).catch(reject);\n                                    }\n                                }\n                            }\n                        });\n                    }\n\n                    if (nodeId != undefined) processing.delete(nodeId);\n\n                    // Wait until all nodes are processed\n                    if (processing.size === 0) {\n                        fulfill(leafItems);\n                    }\n                }\n            });\n        }\n\n        /**\r\n         * Return true if {chrIdx:startBase-endBase} overlaps item's interval\r\n         * @returns {boolean}\r\n         */\n\n    }], [{\n        key: \"overlaps\",\n        value: function overlaps(item, chrIdx, startBase, endBase) {\n\n            //  if (chrIdx > item.endChrom || chrIdx < item.startChrom) return false;\n\n            if (!item) {\n                console.log(\"null item\");\n                return false;\n            }\n\n            return (chrIdx > item.startChrom || chrIdx == item.startChrom && endBase >= item.startBase) && (chrIdx < item.endChrom || chrIdx == item.endChrom && startBase < item.endBase);\n        }\n    }]);\n\n    return RPTree;\n}();\n\nvar RPTreeNode = function RPTreeNode(items) {\n    _classCallCheck(this, RPTreeNode);\n\n    this.items = items;\n\n    var minChromId = Number.MAX_VALUE,\n        maxChromId = 0,\n        minStartBase = Number.MAX_VALUE,\n        maxEndBase = 0,\n        i,\n        item;\n\n    for (i = 0; i < items.length; i++) {\n        item = items[i];\n        minChromId = Math.min(minChromId, item.startChrom);\n        maxChromId = Math.max(maxChromId, item.endChrom);\n        minStartBase = Math.min(minStartBase, item.startBase);\n        maxEndBase = Math.max(maxEndBase, item.endBase);\n    }\n\n    this.startChrom = minChromId;\n    this.endChrom = maxChromId;\n    this.startBase = minStartBase;\n    this.endBase = maxEndBase;\n};\n\n//*******************js/binary.js******************\n\n\nvar BinaryParser = function () {\n    function BinaryParser(dataView, littleEndian) {\n        _classCallCheck(this, BinaryParser);\n\n        this.littleEndian = littleEndian ? littleEndian : true;\n        this.position = 0;\n        this.view = dataView;\n        this.length = dataView.byteLength;\n    }\n\n    _createClass(BinaryParser, [{\n        key: \"available\",\n        value: function available() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"remLength\",\n        value: function remLength() {\n            return this.length - this.position;\n        }\n    }, {\n        key: \"hasNext\",\n        value: function hasNext() {\n            return this.position < this.length - 1;\n        }\n    }, {\n        key: \"getByte\",\n        value: function getByte() {\n            var retValue = this.view.getUint8(this.position, this.littleEndian);\n            this.position++;\n            return retValue;\n        }\n    }, {\n        key: \"getShort\",\n        value: function getShort() {\n\n            var retValue = this.view.getInt16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getUShort\",\n        value: function getUShort() {\n\n            // var byte1 = this.getByte(),\n            //     byte2 = this.getByte(),\n            //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\n            //     return retValue;\n\n            //\n            var retValue = this.view.getUint16(this.position, this.littleEndian);\n            this.position += 2;\n            return retValue;\n        }\n    }, {\n        key: \"getInt\",\n        value: function getInt() {\n\n            var retValue = this.view.getInt32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getUInt\",\n        value: function getUInt() {\n            var retValue = this.view.getUint32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getLong\",\n        value: function getLong() {\n\n            // DataView doesn't support long. So we'll try manually\n\n            var b = [];\n            b[0] = this.view.getUint8(this.position);\n            b[1] = this.view.getUint8(this.position + 1);\n            b[2] = this.view.getUint8(this.position + 2);\n            b[3] = this.view.getUint8(this.position + 3);\n            b[4] = this.view.getUint8(this.position + 4);\n            b[5] = this.view.getUint8(this.position + 5);\n            b[6] = this.view.getUint8(this.position + 6);\n            b[7] = this.view.getUint8(this.position + 7);\n\n            var value = 0;\n            if (this.littleEndian) {\n                for (var i = b.length - 1; i >= 0; i--) {\n                    value = value * 256 + b[i];\n                }\n            } else {\n                for (var i = 0; i < b.length; i++) {\n                    value = value * 256 + b[i];\n                }\n            }\n\n            this.position += 8;\n            return value;\n        }\n    }, {\n        key: \"getString\",\n        value: function getString(len) {\n\n            var s = \"\";\n            var c;\n            while ((c = this.view.getUint8(this.position++)) != 0) {\n                s += String.fromCharCode(c);\n                if (len && s.length == len) break;\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthString\",\n        value: function getFixedLengthString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 0) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFixedLengthTrimmedString\",\n        value: function getFixedLengthTrimmedString(len) {\n\n            var s = \"\";\n            var i;\n            var c;\n            for (i = 0; i < len; i++) {\n                c = this.view.getUint8(this.position++);\n                if (c > 32) {\n                    s += String.fromCharCode(c);\n                }\n            }\n            return s;\n        }\n    }, {\n        key: \"getFloat\",\n        value: function getFloat() {\n\n            var retValue = this.view.getFloat32(this.position, this.littleEndian);\n            this.position += 4;\n            return retValue;\n        }\n    }, {\n        key: \"getDouble\",\n        value: function getDouble() {\n\n            var retValue = this.view.getFloat64(this.position, this.littleEndian);\n            this.position += 8;\n            return retValue;\n        }\n    }, {\n        key: \"skip\",\n        value: function skip(n) {\n\n            this.position += n;\n            return this.position;\n        }\n\n        /**\r\n         * Return a bgzip (bam and tabix) virtual pointer\r\n         * TODO -- why isn't 8th byte used ?\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"getVPointer\",\n        value: function getVPointer() {\n\n            var position = this.position,\n                offset = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position),\n                byte6 = (this.view.getUint8(position + 6) & 0xff) * 0x100000000,\n                byte5 = (this.view.getUint8(position + 5) & 0xff) * 0x1000000,\n                byte4 = (this.view.getUint8(position + 4) & 0xff) * 0x10000,\n                byte3 = (this.view.getUint8(position + 3) & 0xff) * 0x100,\n                byte2 = this.view.getUint8(position + 2) & 0xff,\n                block = byte6 + byte5 + byte4 + byte3 + byte2;\n            this.position += 8;\n\n            //       if (block == 0 && offset == 0) {\n            //           return null;\n            //       } else {\n            return new VPointer(block, offset);\n            //       }\n        }\n    }]);\n\n    return BinaryParser;\n}();\n\nvar VPointer = function () {\n    function VPointer(block, offset) {\n        _classCallCheck(this, VPointer);\n\n        this.block = block;\n        this.offset = offset;\n    }\n\n    _createClass(VPointer, [{\n        key: \"isLessThan\",\n        value: function isLessThan(vp) {\n            return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;\n        }\n    }, {\n        key: \"isGreaterThan\",\n        value: function isGreaterThan(vp) {\n            return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;\n        }\n    }, {\n        key: \"print\",\n        value: function print() {\n            return \"\" + this.block + \":\" + this.offset;\n        }\n    }]);\n\n    return VPointer;\n}();\n\n//*******js/bigwig/bwTotalSummary.js*************\n\n\nvar BWTotalSummary = function () {\n    function BWTotalSummary(byteBuffer) {\n        _classCallCheck(this, BWTotalSummary);\n\n        if (byteBuffer) {\n\n            this.basesCovered = byteBuffer.getLong();\n            this.minVal = byteBuffer.getDouble();\n            this.maxVal = byteBuffer.getDouble();\n            this.sumData = byteBuffer.getDouble();\n            this.sumSquares = byteBuffer.getDouble();\n\n            this.computeStats();\n        } else {\n            this.basesCovered = 0;\n            this.minVal = 0;\n            this.maxVal = 0;\n            this.sumData = 0;\n            this.sumSquares = 0;\n            this.mean = 0;\n            this.stddev = 0;\n        }\n    }\n\n    _createClass(BWTotalSummary, [{\n        key: \"computeStats\",\n        value: function computeStats() {\n            var n = this.basesCovered;\n            if (n > 0) {\n                this.mean = this.sumData / n;\n                this.stddev = Math.sqrt(this.sumSquares / (n - 1));\n\n                var min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,\n                    max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;\n\n                this.defaultRange = {\n                    min: 0,\n                    max: this.mean + 3 * this.stddev\n                };\n            }\n        }\n    }, {\n        key: \"updateStats\",\n        value: function updateStats(stats) {\n\n            this.basesCovered += stats.count;\n            this.sumData += status.sumData;\n            this.sumSquares += sumSquares;\n            this.minVal = MIN(_minVal, min);\n            this.maxVal = MAX(_maxVal, max);\n\n            computeStats.call(this);\n        }\n    }]);\n\n    return BWTotalSummary;\n}();\n\n//***************js/bigwig/bwBPTree.js**************\n\n\nvar BPTREE_MAGIC_LTH = 0x78CA8C91;\nvar BPTREE_MAGIC_HTL = 0x918CCA78;\nvar BPTREE_HEADER_SIZE = 32;\n\nvar BPTree = function BPTree(binaryParser, startOffset) {\n    _classCallCheck(this, BPTree);\n\n    var self = this,\n        genome = null;\n\n    this.header = {};\n    this.header.magic = binaryParser.getInt();\n    this.header.blockSize = binaryParser.getInt();\n    this.header.keySize = binaryParser.getInt();\n    this.header.valSize = binaryParser.getInt();\n    this.header.itemCount = binaryParser.getLong();\n    this.header.reserved = binaryParser.getLong();\n\n    this.dictionary = {};\n\n    // Recursively walk tree to populate dictionary\n    readTreeNode(binaryParser, -1, this.header.keySize, this.dictionary);\n\n    var itemSize = 8 + this.header.keySize;\n    var minSize = 4 + itemSize; // Bytes for a node with 1 item\n\n    function readTreeNode(byteBuffer, offset, keySize, dictionary) {\n\n        if (offset >= 0) byteBuffer.position = offset;\n\n        var type = byteBuffer.getByte(),\n            reserved = byteBuffer.getByte(),\n            count = byteBuffer.getUShort(),\n            i,\n            key,\n            chromId,\n            chromSize,\n            childOffset,\n            bufferOffset,\n            currOffset;\n\n        if (type == 1) {\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                chromId = byteBuffer.getInt();\n                chromSize = byteBuffer.getInt();\n\n                if (genome) key = genome.getChromosomeName(key); // Translate to canonical chr name\n                dictionary[key] = chromId;\n            }\n        } else {\n            // non-leaf\n\n            for (i = 0; i < count; i++) {\n\n                key = byteBuffer.getFixedLengthTrimmedString(keySize);\n                childOffset = byteBuffer.getLong();\n                bufferOffset = childOffset - startOffset;\n                currOffset = byteBuffer.position;\n                readTreeNode(byteBuffer, bufferOffset, keySize, dictionary);\n                byteBuffer.position = currOffset;\n            }\n        }\n    }\n};\n\nexports.BWSource = BWSource;\nexports.BinaryParser = BinaryParser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2JpZ3dpZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvYmlnd2lnLmpzPzExZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7aWd2eGhyfSBmcm9tIFwiLi9pZ3Z4aHIuanNcIjtcclxuLy9pbXBvcnQge3Bha299IGZyb20gXCIuL3ZlbmRvci9wYWtvX2luZmxhdGUuanNcIjtcclxuaW1wb3J0IHtabGlifSBmcm9tIFwiLi92ZW5kb3IvemxpYl9hbmRfZ3ppcC5qc1wiO1xyXG5cclxuXHJcbi8vKioqKioqKioqKipqcy9iaWd3aWcvYnVmZmVyZWRSZWFkZXIuanMqKioqKioqKioqKioqKioqKlxyXG5jbGFzcyBCdWZmZXJlZFJlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgY29udGVudExlbmd0aCwgYnVmZmVyU2l6ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aDtcclxuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplID8gYnVmZmVyU2l6ZSA6IDUxMjAwMDtcclxuICAgICAgICB0aGlzLnJhbmdlID0ge3N0YXJ0OiAtMSwgc2l6ZTogLTF9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRSYW5nZSAtIGJ5dGUgcmFuZ2VhcyB7c3RhcnQsIHNpemV9XHJcbiAgICAgKiBAcGFyYW0gZnVsZmlsbCAtIGZ1bmN0aW9uIHRvIHJlY2VpdmUgcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gYXNVaW50OCAtIG9wdGlvbmFsIGZsYWcgdG8gcmV0dXJuIHJlc3VsdCBhcyBhbiBVSW50OEFycmF5XHJcbiAgICAgKi9cclxuICAgIGRhdGFWaWV3Rm9yUmFuZ2UocmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzRGF0YSA9IChzZWxmLmRhdGEgJiYgKHNlbGYucmFuZ2Uuc3RhcnQgPD0gcmVxdWVzdGVkUmFuZ2Uuc3RhcnQpICYmXHJcbiAgICAgICAgICAgICAgICAoKHNlbGYucmFuZ2Uuc3RhcnQgKyBzZWxmLnJhbmdlLnNpemUpID49IChyZXF1ZXN0ZWRSYW5nZS5zdGFydCArIHJlcXVlc3RlZFJhbmdlLnNpemUpKSksXHJcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplLFxyXG4gICAgICAgICAgICAgICAgbG9hZFJhbmdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIHN1YmJ1ZmZlcihzZWxmLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgYnVmZmVyIHNpemUgaWYgbmVlZGVkLCBidXQgbm90IGJleW9uZCBjb250ZW50IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSA9IE1hdGgubWF4KHNlbGYuYnVmZmVyU2l6ZSwgcmVxdWVzdGVkUmFuZ2Uuc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdGVkUmFuZ2Uuc3RhcnQgKyBidWZmZXJTaXplID4gc2VsZi5jb250ZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZFJhbmdlID0ge3N0YXJ0OiByZXF1ZXN0ZWRSYW5nZS5zdGFydH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSB7c3RhcnQ6IHJlcXVlc3RlZFJhbmdlLnN0YXJ0LCBzaXplOiBidWZmZXJTaXplfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywge3JhbmdlOiBsb2FkUmFuZ2V9KSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGEgPSBhcnJheUJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJhbmdlID0gbG9hZFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmJ1ZmZlcihzZWxmLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YmJ1ZmZlcihidWZmZXJlZFJlYWRlciwgcmVxdWVzdGVkUmFuZ2UsIGFzVWludDgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyZWRSZWFkZXIuZGF0YS5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gcmVxdWVzdGVkUmFuZ2Uuc3RhcnQgLSBidWZmZXJlZFJlYWRlci5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc1VpbnQ4ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyZWRSZWFkZXIuZGF0YSwgYnVmZmVyU3RhcnQsIGxlbiAtIGJ1ZmZlclN0YXJ0KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXJlZFJlYWRlci5kYXRhLCBidWZmZXJTdGFydCwgbGVuIC0gYnVmZmVyU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqKioqKioqKmpzL2JpZ3dpZy9id1NvdXJjZS5qcyoqKioqKioqKioqKioqKlxyXG5jbGFzcyBCV1NvdXJjZXtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsY3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBCV1JlYWRlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyZWRSZWFkZXIgPSBuZXcgQnVmZmVyZWRSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICBpZiAoIWNyZWF0ZV9mZWF0dXJlX2Z1bmN0aW9uKXtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVfZmVhdHVyZT1CV1NvdXJjZS5jcmVhdGVGZWF0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlPWNyZWF0ZV9mZWF0dXJlX2Z1bmN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcblx0KiBDcmVhdGVzIGEgcGFuZWxcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBjaHIgLSBUaGUgY2hyb21vc29tZVxyXG5cdCogQHBhcmFtIHtpbnR9IGJwU3RhcnQgVGhlIHN0YXJ0aW5nIHBvc3RpdGlvbiBcclxuXHQqIEBwYXJhbSB7aW50fSBicEVuZCAtIFRoZSBlbmQgb2YgdGhlIHJlZ2lvbiB0byBzaG93XHJcblx0KiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9leGlzdGluZyAtIElmIHRydWUgdGhlbiB0aGUgY2FjaGVkIGZlYXR1cmUgd2lsbCBiZSB1c2VkLSBvbmx5IHVzZWRcclxuXHQqIGlmIHRoZSBjby1vcmlkaW5hdGVzIGhhdmUgbm90IGNoYW5nZWQuIEFsdGhvdWdoLCB0aGUgQldyZWFkZXIgaGFzIGEgY2FjaGUsIGl0IGlzIHNvbWV0aW1lc1xyXG5cdCogaWdub3JlZCBhbmQgZmVhdHVyZXMgYXJlIHJlLWZldGNoZWQgZm9yIHRoZSBzYW1lIHJlZ2lvblxyXG5cdCogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBTaG91bGQgY29udGFpbiBwaXhlbFdpZHRoLSB0aGUgd2lkdGggb2YgdGhlIGVudGlyZSBjYW52YXMgYW5kIFxyXG5cdCogYnBQZXJQaXhlbC5cclxuXHQqL1xyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCx1c2VfZXhpc3RpbmcsZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc3QgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZXMgJiYgdXNlX2V4aXN0aW5nKXtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5yZWFkZXIuZ2V0Wm9vbUhlYWRlcnMoKS50aGVuKGZ1bmN0aW9uICh6b29tTGV2ZWxIZWFkZXJzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IGEgYml3aWcgXCJ6b29tIGxldmVsXCIgYXBwcm9wcmlhdGUgZm9yIHRoZSBjdXJyZW50IHJlc29sdXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBid1JlYWRlciA9IHNlbGYucmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyID0gc2VsZi5idWZmZXJlZFJlYWRlcixcclxuICAgICAgICAgICAgICAgICAgICBicHAgPWRhdGEuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWxIZWFkZXI9QldTb3VyY2Uuem9vbUxldmVsRm9yU2NhbGUoYnBwLCB6b29tTGV2ZWxIZWFkZXJzKSxcclxuICAgICAgICAgICAgICAgICAgICB0cmVlT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoem9vbUxldmVsSGVhZGVyICYmIGJ3UmVhZGVyLnR5cGU9PT1cIkJpZ1dpZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZU9mZnNldCA9IHpvb21MZXZlbEhlYWRlci5pbmRleE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uID0gQldTb3VyY2UuZGVjb2RlWm9vbURhdGE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVPZmZzZXQgPSBid1JlYWRlci5oZWFkZXIuZnVsbEluZGV4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChid1JlYWRlci50eXBlID09PSBcIkJpZ1dpZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPUJXU291cmNlLmRlY29kZVdpZ0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uID1zZWxmLmRlY29kZUJlZERhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJ3UmVhZGVyLmxvYWRSUFRyZWUodHJlZU9mZnNldCkudGhlbihmdW5jdGlvbiAocnBUcmVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJJZHggPSBzZWxmLnJlYWRlci5jaHJvbVRyZWUuZGljdGlvbmFyeVtjaHJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHJJZHggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwVHJlZS5maW5kTGVhZkl0ZW1zT3ZlcmxhcHBpbmcoY2hySWR4LCBicFN0YXJ0LCBicEVuZCkudGhlbihmdW5jdGlvbiAobGVhZkl0ZW1zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFmSXRlbXMgfHwgbGVhZkl0ZW1zLmxlbmd0aCA9PSAwKSBmdWxmaWxsKFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFmSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpdGVtLmRhdGFPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBpdGVtLmRhdGFTaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpLnRoZW4oZnVuY3Rpb24gKHVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZSA9IG5ldyBabGliLkluZmxhdGUodWludDhBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFpbj0gaW5mbGF0ZS5kZWNvbXByZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcGxhaW4gPSBwYWtvLmluZmxhdGUodWludDhBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uKG5ldyBEYXRhVmlldyhwbGFpbi5idWZmZXIpLCBjaHIsIGNocklkeCwgYnBTdGFydCwgYnBFbmQsIGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChmZWF0dXJlQXJyYXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBlbi1zZWxmLnN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYnBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmZWF0dXJlQXJyYXlzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT0xOyBpPGZlYXR1cmVBcnJheXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBhbGxGZWF0dXJlcy5jb25jYXQoZmVhdHVyZUFycmF5c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlcz1hbGxGZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsbEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgZ2V0RGVmYXVsdFJhbmdlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeS5kZWZhdWx0UmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHpvb21MZXZlbEZvclNjYWxlKGJwUGVyUGl4ZWwsIHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbnVsbCwgaSwgemw7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICB6bCA9IHpvb21MZXZlbEhlYWRlcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoemwucmVkdWN0aW9uTGV2ZWwgPiBicFBlclBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHpsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChudWxsID09IGxldmVsKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gem9vbUxldmVsSGVhZGVyc1t6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsZXZlbCAmJiBsZXZlbC5yZWR1Y3Rpb25MZXZlbCA8IDQgKiBicFBlclBpeGVsKSA/IGxldmVsIDogbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZ0RhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICBpdGVtU3RlcCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgaXRlbVNwYW4gPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIHR5cGUgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICByZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKSxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChjaHJvbUlkID09PSBjaHJJZHgpIHtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVtQ291bnQtLSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6ICAvLyBGaXhlZCBzdGVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHJvbVN0YXJ0ICs9IGl0ZW1TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNocm9tU3RhcnQgPj0gYnBFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gT3V0IG9mIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVpvb21EYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gOCAqIDQsICAgLy8gTWluaW11bSAjIG9mIGJ5dGVzIHJlcXVpcmVkIGZvciBhIHpvb20gcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICB2YWxpZENvdW50LFxyXG4gICAgICAgICAgICBtaW5WYWwsXHJcbiAgICAgICAgICAgIG1heFZhbCxcclxuICAgICAgICAgICAgc3VtRGF0YSxcclxuICAgICAgICAgICAgc3VtU3F1YXJlcyxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIHdoaWxlIChiaW5hcnlQYXJzZXIucmVtTGVuZ3RoKCkgPj0gbWluU2l6ZSkge1xyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCA9PT0gY2hySWR4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIG1pblZhbCA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1EYXRhID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1TcXVhcmVzID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkQ291bnQgPT0gMCA/IDAgOiBzdW1EYXRhIC8gdmFsaWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyb21TdGFydCA+PSBicEVuZCAmJiBjaHJvbVN0YXJ0PDEwMDAwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaG91bGQgaGF2ZSBicm9rZW5cIilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIE91dCBvZiBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBkZWNvZGVCZWREYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gMyAqIDQgKyAxLCAgIC8vIE1pbmltdW0gIyBvZiBieXRlcyByZXF1aXJlZCBmb3IgYSBiZWQgcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICByZXN0LFxyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGV4b25Db3VudCwgZXhvblNpemVzLCBleG9uU3RhcnRzLCBleG9ucywgZVN0YXJ0LCBlRW5kO1xyXG5cclxuXHJcbiAgICAgICAgd2hpbGUgKGJpbmFyeVBhcnNlci5yZW1MZW5ndGgoKSA+PSBtaW5TaXplKSB7XHJcblxyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCAhPSBjaHJJZHgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIHJlc3QgPSBiaW5hcnlQYXJzZXIuZ2V0U3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZH07XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hyb21TdGFydCA8IGJwRW5kICYmIGNocm9tRW5kID49IGJwU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVBcnJheS5wdXNoKGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VucyA9IHJlc3Quc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlKHRva2VucyxmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBjcmVhdGVGZWF0dXJlKHRva2VucyxmZWF0dXJlKXtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm5hbWUgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gdG9rZW5zWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jZFN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuY2RFbmQgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAodG9rZW5zWzVdICE9PSBcIi5cIiAmJiB0b2tlbnNbNV0gIT09IFwiMFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZlYXR1cmUuY29sb3IgPSBpZ3YuY3JlYXRlQ29sb3JTdHJpbmcodG9rZW5zWzVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25Db3VudCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzddLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblN0YXJ0cyA9IHRva2Vuc1s4XS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25zID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZUVuZCA9IGVTdGFydCArIHBhcnNlSW50KGV4b25TaXplc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBlU3RhcnQsIGVuZDogZUVuZH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vLyoqKioqKioqKioqKmpzL2JpZ3dpZy9id1JlYWRlci5qcyoqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQklHV0lHX01BR0lDX0xUSCA9IDB4ODg4RkZDMjY7IC8vIEJpZ1dpZyBNYWdpYyBMb3cgdG8gSGlnaFxyXG5jb25zdCBCSUdXSUdfTUFHSUNfSFRMID0gMHgyNkZDOEY2NjsgLy8gQmlnV2lnIE1hZ2ljIEhpZ2ggdG8gTG93XHJcbmNvbnN0IEJJR0JFRF9NQUdJQ19MVEggPSAweDg3ODlGMkVCOyAvLyBCaWdCZWQgTWFnaWMgTG93IHRvIEhpZ2hcclxuY29uc3QgQklHQkVEX01BR0lDX0hUTCA9IDB4RUJGMjg5ODc7IC8vIEJpZ0JlZCBNYWdpYyBIaWdoIHRvIExvd1xyXG5jb25zdCBCQkZJTEVfSEVBREVSX1NJWkUgPSA2NDtcclxuXHJcblxyXG5jbGFzcyBCV1JlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5oZWFkUGF0aCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMucGF0aDtcclxuICAgICAgICB0aGlzLnJwVHJlZUNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSAkLmV4dGVuZCh7fSxjb25maWcsdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdldFpvb21IZWFkZXJzKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnpvb21MZXZlbEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEhlYWRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZToge3N0YXJ0OiAwLCBzaXplOiBCQkZJTEVfSEVBREVSX1NJWkV9fSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBsb3ctdG8taGlnaCB1bmxlc3MgcHJvdmVuIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKG5ldyBEYXRhVmlldyhkYXRhKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWFnaWMgPT09IEJJR1dJR19NQUdJQ19MVEgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGUgPSBcIkJpZ1dpZ1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnaWMgPT0gQklHQkVEX01BR0lDX0xUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnQmVkXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyeSBiaWcgZW5kaWFuIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCSUdXSUdfTUFHSUNfSFRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnV2lnXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2ljID09IEJJR0JFRF9NQUdJQ19IVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdCZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gZXJyb3IsIHVua25vd24gZmlsZSB0eXBlICBvciBCRVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSA1ICBcIkNvbW1vbiBoZWFkZXIgZm9yIEJpZ1dpZyBhbmQgQmlnQmVkIGZpbGVzXCJcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyID0ge307XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5id1ZlcnNpb24gPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5uWm9vbUxldmVscyA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsSW5kZXhPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuZmllbGRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmRlZmluZWRGaWVsZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIudW5jb21wcmVzc0J1ZmZTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIucmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZFpvb21IZWFkZXJzQW5kQ2hyVHJlZSgpLnRoZW4oZnVsZmlsbCkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICBsb2FkWm9vbUhlYWRlcnNBbmRDaHJUcmVlKCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gQkJGSUxFX0hFQURFUl9TSVpFLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHtzdGFydDogc3RhcnRPZmZzZXQsIHNpemU6IChzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0ICsgNSl9O1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZTogcmFuZ2V9KSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5ab29tcyA9IHNlbGYuaGVhZGVyLm5ab29tTGV2ZWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGRhdGEpKSxcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbixcclxuICAgICAgICAgICAgICAgICAgICB6b29tTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHpsaDtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnpvb21MZXZlbEhlYWRlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ab29tczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgem9vbU51bWJlciA9IG5ab29tcyAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgemxoID0gbmV3IFpvb21MZXZlbEhlYWRlcih6b29tTnVtYmVyLCBiaW5hcnlQYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCA9IE1hdGgubWluKHpsaC5kYXRhT2Zmc2V0LCBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuem9vbUxldmVsSGVhZGVycy5wdXNoKHpsaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXV0b3NxbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmF1dG9TcWxPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXV0b1NxbCA9IGJpbmFyeVBhcnNlci5nZXRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUb3RhbCBzdW1tYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudG90YWxTdW1tYXJ5ID0gbmV3IEJXVG90YWxTdW1tYXJ5KGJpbmFyeVBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hyb20gZGF0YSBpbmRleFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5jaHJvbVRyZWVPZmZzZXQgLSBzdGFydE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tVHJlZSA9IG5ldyBCUFRyZWUoYmluYXJ5UGFyc2VyLCBzdGFydE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIHRoaXMgaXMgYW4gZXJyb3IsIG5vdCBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vRmluYWxseSB0b3RhbCBkYXRhIGNvdW50XHJcbiAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFJQVHJlZShvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcnBUcmVlID0gc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICBpZiAocnBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBycFRyZWUgPSBuZXcgUlBUcmVlKG9mZnNldCwgc2VsZi5jb250ZW50TGVuZ3RoLCBzZWxmLmNvbmZpZywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdID0gcnBUcmVlO1xyXG4gICAgICAgICAgICAgICAgcnBUcmVlLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiBjbGFzcyBab29tTGV2ZWxIZWFkZXJ7XHJcbiAgICAgY29uc3RydWN0b3IoaW5kZXgsIGJ5dGVCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZWR1Y3Rpb25MZXZlbCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5yZXNlcnZlZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5kYXRhT2Zmc2V0ID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgfVxyXG4gfVxyXG5cclxuXHJcbmNvbnN0IFJQVFJFRV9NQUdJQ19MVEggPSAweDI0NjhBQ0UwO1xyXG5jb25zdCBSUFRSRUVfTUFHSUNfSFRMID0gMHhFMEFDNjgyNDtcclxuY29uc3QgUlBUUkVFX0hFQURFUl9TSVpFID0gNDg7XHJcbmNvbnN0IFJQVFJFRV9OT0RFX0xFQUZfSVRFTV9TSVpFID0gMzI7ICAgLy8gbGVhZiBpdGVtIHNpemVcclxuY29uc3QgUlBUUkVFX05PREVfQ0hJTERfSVRFTV9TSVpFID0gMjQ7ICAvLyBjaGlsZCBpdGVtIHNpemVcclxuY29uc3QgQlVGRkVSX1NJWkUgPSA1MTIwMDA7IFxyXG5cclxuLy8qKioqKioqKioqKmpzL2JpZ3dpZy9SUFRyZWUqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuICAgICAvLyAgYnVmZmVyXHJcblxyXG5jbGFzcyBSUFRyZWV7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKGZpbGVPZmZzZXQsIGNvbnRlbnRMZW5ndGgsIGNvbmZpZywgbGl0dGxlRW5kaWFuKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuZmlsZXNpemUgPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZmlsZU9mZnNldCA9IGZpbGVPZmZzZXQ7IC8vIEZpbGUgb2Zmc2V0IHRvIGJlZ2lubmluZyBvZiB0cmVlXHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgbG9hZCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdE5vZGVPZmZzZXQgPSBzZWxmLmZpbGVPZmZzZXQgKyBSUFRSRUVfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5yZWFkTm9kZShyb290Tm9kZU9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucm9vdE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVhZE5vZGUoZmlsZVBvc2l0aW9uLCBidWZmZXJlZFJlYWRlcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiA0fSwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihkYXRhVmlldywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYmluYXJ5UGFyc2VyLmdldEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xlYWYgPSAodHlwZSA9PT0gMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVQb3NpdGlvbiArPSA0O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBieXRlc1JlcXVpcmVkID0gY291bnQgKiAoaXNMZWFmID8gUlBUUkVFX05PREVfTEVBRl9JVEVNX1NJWkUgOiBSUFRSRUVfTk9ERV9DSElMRF9JVEVNX1NJWkUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlMiA9IHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiBieXRlc1JlcXVpcmVkfTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHJhbmdlMiwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IG5ldyBBcnJheShjb3VudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YVZpZXcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWFmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWY6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNpemU6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IFJQVHJlZU5vZGUoaXRlbXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIG5vbi1sZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFmOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG5ldyBSUFRyZWVOb2RlKGl0ZW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmluZExlYWZJdGVtc092ZXJsYXBwaW5nKGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsZWFmSXRlbXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgcHJvY2Vzc2luZy5hZGQoMCk7ICAvLyBaZXJvIHJlcHJlc2VudHMgdGhlIHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKHNlbGYucm9vdE5vZGUsIDApO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZExlYWZJdGVtcyhub2RlLCBub2RlSWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKG5vZGUsIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBub2RlLml0ZW1zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKGl0ZW0sIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzTGVhZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKGl0ZW0uY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcuYWRkKGl0ZW0uY2hpbGRPZmZzZXQpOyAgLy8gUmVwcmVzZW50IG5vZGUgdG8tYmUtbG9hZGVkIGJ5IGl0cyBmaWxlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZE5vZGUoaXRlbS5jaGlsZE9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRMZWFmSXRlbXMobm9kZSwgaXRlbS5jaGlsZE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgIT0gdW5kZWZpbmVkKSBwcm9jZXNzaW5nLmRlbGV0ZShub2RlSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG5vZGVzIGFyZSBwcm9jZXNzZWRcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nLnNpemU9PT0wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChsZWFmSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB7Y2hySWR4OnN0YXJ0QmFzZS1lbmRCYXNlfSBvdmVybGFwcyBpdGVtJ3MgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb3ZlcmxhcHMoaXRlbSwgY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpIHtcclxuXHJcbiAgICAgICAgLy8gIGlmIChjaHJJZHggPiBpdGVtLmVuZENocm9tIHx8IGNocklkeCA8IGl0ZW0uc3RhcnRDaHJvbSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJudWxsIGl0ZW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKGNocklkeCA+IGl0ZW0uc3RhcnRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLnN0YXJ0Q2hyb20gJiYgZW5kQmFzZSA+PSBpdGVtLnN0YXJ0QmFzZSkpICYmXHJcbiAgICAgICAgICAgICgoY2hySWR4IDwgaXRlbS5lbmRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLmVuZENocm9tICYmIHN0YXJ0QmFzZSA8IGl0ZW0uZW5kQmFzZSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUlBUcmVlTm9kZXtcclxuICAgIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xyXG5cclxuICAgICAgICB2YXIgbWluQ2hyb21JZCA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSAwLFxyXG4gICAgICAgICAgICBtaW5TdGFydEJhc2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBtYXhFbmRCYXNlID0gMCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaXRlbTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgICAgbWluQ2hyb21JZCA9IE1hdGgubWluKG1pbkNocm9tSWQsIGl0ZW0uc3RhcnRDaHJvbSk7XHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSBNYXRoLm1heChtYXhDaHJvbUlkLCBpdGVtLmVuZENocm9tKTtcclxuICAgICAgICAgICAgbWluU3RhcnRCYXNlID0gTWF0aC5taW4obWluU3RhcnRCYXNlLCBpdGVtLnN0YXJ0QmFzZSk7XHJcbiAgICAgICAgICAgIG1heEVuZEJhc2UgPSBNYXRoLm1heChtYXhFbmRCYXNlLCBpdGVtLmVuZEJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydENocm9tID0gbWluQ2hyb21JZDtcclxuICAgICAgICB0aGlzLmVuZENocm9tID0gbWF4Q2hyb21JZDtcclxuICAgICAgICB0aGlzLnN0YXJ0QmFzZSA9IG1pblN0YXJ0QmFzZTtcclxuICAgICAgICB0aGlzLmVuZEJhc2UgPSBtYXhFbmRCYXNlO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuLy8qKioqKioqKioqKioqKioqKioqanMvYmluYXJ5LmpzKioqKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJpbmFyeVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSAobGl0dGxlRW5kaWFuID8gbGl0dGxlRW5kaWFuIDogdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gZGF0YVZpZXc7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGF2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPCB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qnl0ZSgpIHtcclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2hvcnQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyXHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFVTaG9ydCgpe1xyXG5cclxuICAgICAgICAvLyB2YXIgYnl0ZTEgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgYnl0ZTIgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgcmV0VmFsdWUgPSAoKGJ5dGUyIDw8IDI0ID4+PiAxNikgKyAoYnl0ZTEgPDwgMjQgPj4+IDI0KSk7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiByZXRWYWx1ZTtcclxuXHJcbiAgICAgICAvL1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYgKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDJcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEludCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRVSW50KCkge1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TG9uZygpIHtcclxuXHJcbiAgICAgICAgLy8gRGF0YVZpZXcgZG9lc24ndCBzdXBwb3J0IGxvbmcuIFNvIHdlJ2xsIHRyeSBtYW51YWxseVxyXG5cclxuICAgICAgICB2YXIgYiA9IFtdO1xyXG4gICAgICAgIGJbMF0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgYlsxXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMSk7XHJcbiAgICAgICAgYlsyXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMik7XHJcbiAgICAgICAgYlszXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMyk7XHJcbiAgICAgICAgYls0XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgYls1XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNSk7XHJcbiAgICAgICAgYls2XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNik7XHJcbiAgICAgICAgYls3XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNyk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisrKSkgIT0gMCkge1xyXG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIGlmIChsZW4gJiYgcy5sZW5ndGggPT0gbGVuKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Rml4ZWRMZW5ndGhTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDMyKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmxvYXQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RG91YmxlKCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBza2lwKG4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGJnemlwIChiYW0gYW5kIHRhYml4KSB2aXJ0dWFsIHBvaW50ZXJcclxuICAgICAqIFRPRE8gLS0gd2h5IGlzbid0IDh0aCBieXRlIHVzZWQgP1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldFZQb2ludGVyKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMSkgPDwgOCkgfCAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uKSksXHJcbiAgICAgICAgICAgIGJ5dGU2ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA2KSAmIDB4ZmYpICogMHgxMDAwMDAwMDApLFxyXG4gICAgICAgICAgICBieXRlNSA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgNSkgJiAweGZmKSAqIDB4MTAwMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGU0ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA0KSAmIDB4ZmYpICogMHgxMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGUzID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAzKSAmIDB4ZmYpICogMHgxMDApLFxyXG4gICAgICAgICAgICBieXRlMiA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMikgJiAweGZmKSksXHJcbiAgICAgICAgICAgIGJsb2NrID0gYnl0ZTYgKyBieXRlNSArIGJ5dGU0ICsgYnl0ZTMgKyBieXRlMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDg7XHJcblxyXG4gICAgICAgIC8vICAgICAgIGlmIChibG9jayA9PSAwICYmIG9mZnNldCA9PSAwKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWUG9pbnRlcihibG9jaywgb2Zmc2V0KTtcclxuICAgICAgICAvLyAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFZQb2ludGVye1xyXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIG9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpc0xlc3NUaGFuKHZwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPCB2cC5ibG9jayB8fFxyXG4gICAgICAgICAgICAodGhpcy5ibG9jayA9PT0gdnAuYmxvY2sgJiYgdGhpcy5vZmZzZXQgPCB2cC5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzR3JlYXRlclRoYW4odnApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA+IHZwLmJsb2NrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmJsb2NrID09PSB2cC5ibG9jayAmJiB0aGlzLm9mZnNldCA+IHZwLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLmJsb2NrICsgXCI6XCIgKyB0aGlzLm9mZnNldDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vKioqKioqKmpzL2JpZ3dpZy9id1RvdGFsU3VtbWFyeS5qcyoqKioqKioqKioqKipcclxuXHJcblxyXG5cclxuY2xhc3MgQldUb3RhbFN1bW1hcnl7XHJcbiAgICBjb25zdHJ1Y3RvcihieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgIGlmIChieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pblZhbCA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4VmFsID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1EYXRhID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1TcXVhcmVzID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVN0YXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWluVmFsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tYXhWYWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bURhdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bVNxdWFyZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1lYW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZGRldiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAgY29tcHV0ZVN0YXRzKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5iYXNlc0NvdmVyZWQ7XHJcbiAgICAgICAgaWYgKG4gPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVhbiA9IHRoaXMuc3VtRGF0YSAvIG47XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZGV2ID0gTWF0aC5zcXJ0KHRoaXMuc3VtU3F1YXJlcyAvIChuIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMubWluVmFsIDwgMCA/IHRoaXMubWVhbiAtIDIgKiB0aGlzLnN0ZGRldiA6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLm1heFZhbCA+IDAgPyB0aGlzLm1lYW4gKyAyICogdGhpcy5zdGRkZXYgOiAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0UmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWVhbiArIDMgKiB0aGlzLnN0ZGRldlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVN0YXRzKHN0YXRzKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmFzZXNDb3ZlcmVkICs9IHN0YXRzLmNvdW50O1xyXG4gICAgICAgIHRoaXMuc3VtRGF0YSArPSBzdGF0dXMuc3VtRGF0YTtcclxuICAgICAgICB0aGlzLnN1bVNxdWFyZXMgKz0gc3VtU3F1YXJlcztcclxuICAgICAgICB0aGlzLm1pblZhbCA9IE1JTihfbWluVmFsLCBtaW4pO1xyXG4gICAgICAgIHRoaXMubWF4VmFsID0gTUFYKF9tYXhWYWwsIG1heCk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVTdGF0cy5jYWxsKHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqKioqKipqcy9iaWd3aWcvYndCUFRyZWUuanMqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJQVFJFRV9NQUdJQ19MVEggPSAweDc4Q0E4QzkxO1xyXG5jb25zdCBCUFRSRUVfTUFHSUNfSFRMID0gMHg5MThDQ0E3ODtcclxuY29uc3QgQlBUUkVFX0hFQURFUl9TSVpFID0gMzI7XHJcblxyXG5cclxuIGNsYXNzIEJQVHJlZXtcclxuICAgICBjb25zdHJ1Y3RvcihiaW5hcnlQYXJzZXIsIHN0YXJ0T2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZ2Vub21lID0gIG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhZGVyID0ge307XHJcbiAgICAgICAgdGhpcy5oZWFkZXIubWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIuYmxvY2tTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLmtleVNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIudmFsU2l6ZSA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5pdGVtQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLnJlc2VydmVkID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHdhbGsgdHJlZSB0byBwb3B1bGF0ZSBkaWN0aW9uYXJ5XHJcbiAgICAgICAgcmVhZFRyZWVOb2RlKGJpbmFyeVBhcnNlciwgLTEsIHRoaXMuaGVhZGVyLmtleVNpemUsIHRoaXMuZGljdGlvbmFyeSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IDggKyB0aGlzLmhlYWRlci5rZXlTaXplO1xyXG4gICAgICAgIHZhciBtaW5TaXplID0gNCArIGl0ZW1TaXplOyAgIC8vIEJ5dGVzIGZvciBhIG5vZGUgd2l0aCAxIGl0ZW1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIG9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSAwKSBieXRlQnVmZmVyLnBvc2l0aW9uID0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBieXRlQnVmZmVyLmdldEJ5dGUoKSxcclxuICAgICAgICAgICAgICAgIHJlc2VydmVkID0gYnl0ZUJ1ZmZlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IGJ5dGVCdWZmZXIuZ2V0VVNob3J0KCksXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgY2hyb21JZCxcclxuICAgICAgICAgICAgICAgIGNocm9tU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgY3Vyck9mZnNldDtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gYnl0ZUJ1ZmZlci5nZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcoa2V5U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21JZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21TaXplID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZ2Vub21lKSBrZXkgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoa2V5KTsgIC8vIFRyYW5zbGF0ZSB0byBjYW5vbmljYWwgY2hyIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0gPSBjaHJvbUlkO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gbm9uLWxlYWZcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBieXRlQnVmZmVyLmdldEZpeGVkTGVuZ3RoVHJpbW1lZFN0cmluZyhrZXlTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlck9mZnNldCA9IGNoaWxkT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCA9IGJ5dGVCdWZmZXIucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIGJ1ZmZlck9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUJ1ZmZlci5wb3NpdGlvbiA9IGN1cnJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQge0JXU291cmNlLEJpbmFyeVBhcnNlcn07XHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBcUhBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBOzs7QUFwSkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/bigwig.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/sca_bam_track.js":
/*!*****************************************!*\
  !*** .Panel/src/extra/sca_bam_track.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SCABAMTrack = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _bam_track = __webpack_require__(/*! ../bam_track.js */ \"../MLVPanel/src/bam_track.js\");\n\nvar _bam = __webpack_require__(/*! ../bam.js */ \"../MLVPanel/src/bam.js\");\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SCACoverageMap = function () {\n    function SCACoverageMap(chr, start, end, parent) {\n        _classCallCheck(this, SCACoverageMap);\n\n        this.chr = chr;\n        this.bpStart = start;\n        this.length = end - start;\n        this.parent = parent;\n        this.reset();\n    }\n\n    _createClass(SCACoverageMap, [{\n        key: \"reset\",\n        value: function reset() {\n            this.coverages = { \"selected\": null };\n\n            for (var c in this.parent.categories) {\n                var a = new Array(this.length);\n                a.maximum = 0;\n                a.count = this.parent.category_counts[c];\n                this.coverages[c] = a;\n            }\n            this.resetSelected();\n        }\n    }, {\n        key: \"resetSelected\",\n        value: function resetSelected() {\n            var a = new Array(this.length);\n            a.maximum = 0;\n            a.count = this.parent.selected_count;\n            this.coverages[\"selected\"] = a;\n        }\n    }, {\n        key: \"incCounts\",\n        value: function incCounts(alignment, sel_only) {\n            var self = this;\n            if (!sel_only) {\n\n                var _cat = this.parent.category_function(alignment.tagBA.CB);\n\n                if (alignment.blocks === undefined) {\n\n                    incBlockCount(alignment, _cat);\n                } else {\n                    alignment.blocks.forEach(function (block) {\n                        incBlockCount(block, _cat);\n                    });\n                }\n            }\n\n            var cat = \"selected\";\n\n            if (this.parent.selected) {\n                if (!this.parent.selected[alignment.tagBA.CB]) {\n                    return;\n                }\n            }\n\n            if (alignment.blocks === undefined) {\n\n                incBlockCount(alignment, cat);\n            } else {\n                alignment.blocks.forEach(function (block) {\n                    incBlockCount(block, cat);\n                });\n            }\n\n            function incBlockCount(block, cat) {\n                var coverage = self.coverages[cat];\n                if (!coverage) {\n                    return;\n                }\n\n                var //key,\n                //base,\n                i, j, q;\n\n                for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\n\n                    if (!coverage[i]) {\n                        coverage[i] = { total: 0, maximum: 0 }; //new Coverage();\n                    }\n\n                    //base = block.seq.charAt(j);\n                    //key = (alignment.strand) ? \"pos\" + base : \"neg\" + base;\n                    //q = block.qual[j];\n\n                    //coverage[i][key] += 1;\n                    //coverage[i][\"qual\" + base] += q;\n\n                    coverage[i].total += 1;\n                    //coverage[i].qual += q;\n\n                    coverage.maximum = Math.max(coverage[i].total, coverage.maximum);\n                }\n            }\n        }\n    }]);\n\n    return SCACoverageMap;\n}();\n\nvar SCACoverageTrack = function (_CoverageTrack) {\n    _inherits(SCACoverageTrack, _CoverageTrack);\n\n    function SCACoverageTrack(coverage, height) {\n        _classCallCheck(this, SCACoverageTrack);\n\n        return _possibleConstructorReturn(this, (SCACoverageTrack.__proto__ || Object.getPrototypeOf(SCACoverageTrack)).call(this, coverage, height));\n    }\n\n    _createClass(SCACoverageTrack, [{\n        key: \"drawScale\",\n        value: function drawScale(ctx) {\n            var top = this.parent.top;\n            var cms = this.parent.feature_source.alignmentContainer.coverageMap;\n            var ind_track_height = this.parent.config.ind_track_height ? this.parent.config.ind_track_height : 50;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.parent.cat_order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var name = _step.value;\n\n                    var c = cms.coverages[name];\n                    var bot = top + ind_track_height;\n                    ctx.beginPath();\n                    ctx.moveTo(0, top);\n                    ctx.lineTo(0, bot);\n                    ctx.moveTo(0, top);\n                    ctx.lineTo(20, top);\n                    ctx.moveTo(0, bot);\n                    ctx.lineTo(20, bot);\n                    ctx.font = \"12px Arial\";\n                    ctx.stroke();\n                    ctx.textBaseline = \"top\";\n                    ctx.fillStyle = \"black\";\n                    var num = c.maximum / c.count;\n                    if (isNaN(num)) {\n                        num = 0;\n                    }\n                    ctx.fillText(num.toFixed(2), 20, top);\n                    ctx.font = \"14px Arial\";\n                    ctx.textBaseline = \"middle\";\n                    ctx.fillText(name, 2, top + ind_track_height / 2);\n                    ctx.font = \"12px Arial\";\n                    top += ind_track_height;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(options) {\n            var self = this,\n                alignmentContainer = options.features,\n                ctx = options.context,\n                bpPerPixel = options.bpPerPixel,\n                bpStart = options.bpStart,\n                pixelWidth = options.pixelWidth,\n                bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n                coverageMap = alignmentContainer.coverageMap,\n                bp,\n                x,\n                y,\n                h,\n                refBase,\n                i,\n                len,\n                item,\n                accumulatedHeight,\n                sequence;\n\n            var ind_track_height = this.parent.config.ind_track_height ? this.parent.config.ind_track_height : 50;\n\n            if (coverageMap.refSeq) sequence = coverageMap.refSeq.toUpperCase();\n            var top = options.top;\n            var w = Math.max(1, Math.ceil(1.0 / bpPerPixel));\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.parent.cat_order[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var cb = _step2.value;\n\n\n                    var coverage = coverageMap.coverages[cb];\n                    console.log(cb + \":\" + coverage.count);\n                    var max = coverage.maximum / coverage.count;\n                    ctx.fillStyle = this.parent.categories[cb];\n                    if (cb === \"selected\") {\n                        ctx.fillStyle = \"red\";\n                    }\n                    for (i = 0, len = coverage.length; i < len; i++) {\n\n                        bp = coverageMap.bpStart + i;\n                        if (bp < bpStart) continue;\n                        if (bp > bpEnd) break;\n\n                        item = coverage[i];\n                        if (!item) continue;\n\n                        h = Math.round(item.total / coverage.count / max * ind_track_height);\n                        y = ind_track_height - h;\n                        x = Math.floor((bp - bpStart) / bpPerPixel);\n\n                        ctx.fillRect(x, y + top, w, h);\n                    }\n                    top += ind_track_height;\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.dataRange.max = coverageMap.maximum;\n            options.top += top;\n        }\n    }]);\n\n    return SCACoverageTrack;\n}(_bam_track.CoverageTrack);\n\nvar SCABAMTrack = function (_BAMTrack) {\n    _inherits(SCABAMTrack, _BAMTrack);\n\n    function SCABAMTrack(config) {\n        _classCallCheck(this, SCABAMTrack);\n\n        if (!config.featureHeight) {\n            config.featureHeight = 12;\n        }\n\n        var _this2 = _possibleConstructorReturn(this, (SCABAMTrack.__proto__ || Object.getPrototypeOf(SCABAMTrack)).call(this, config));\n\n        _this2.display_alignments = false;\n        _this2.cm_class = SCACoverageMap;\n        _this2.keep_raw_alignments = true;\n        return _this2;\n    }\n\n    _createClass(SCABAMTrack, [{\n        key: \"_setFeatureSource\",\n        value: function _setFeatureSource() {\n            this.feature_source = new _bam.BamSource(this.config, this);\n\n            this.feature_source.setViewAsPairs(true);\n\n            this.coverageTrack = new SCACoverageTrack(this.config, this);\n            this.alignmentTrack = new _bam_track.AlignmentTrack(this.config, this);\n        }\n    }, {\n        key: \"setSelected\",\n        value: function setSelected(selected, count) {\n            this.selected = selected;\n            var cm = this.feature_source.alignmentContainer.coverageMap;\n            this.selected_count = count;\n            cm.resetSelected();\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.feature_source.alignmentContainer.raw_alignments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var alignment = _step3.value;\n\n                    cm.incCounts(alignment, true);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n            if (bpEnd - bpStart > 200000) {\n                this.draw_zoom_in = true;\n                return new Promise(function (fulfill, reject) {\n                    fulfill([]);\n                });\n            }\n            this.draw_zoom_in = false;\n            return _get(SCABAMTrack.prototype.__proto__ || Object.getPrototypeOf(SCABAMTrack.prototype), \"getFeatures\", this).call(this, chr, bpStart, bpEnd, force, data);\n        }\n    }, {\n        key: \"setCoverageCategory\",\n        value: function setCoverageCategory(cat_to_color, cat_counts, cat_func, update) {\n            this.categories = cat_to_color;\n            var ind_track_height = this.config.ind_track_height ? this.config.ind_track_height : 50;\n            var li = [];\n            for (var val in cat_counts) {\n                li.push({ val: val, num: cat_counts[val] });\n            }\n            li.sort(function (a, b) {\n                if (a.val === \"other\") {\n                    return 1;\n                }\n                return b.num - a.num;\n            });\n            this.cat_order = [\"selected\"];\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = li[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var l = _step4.value;\n\n                    this.cat_order.push(l.val);\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            ;\n\n            this.config.height = (Object.keys(cat_to_color).length + 1) * ind_track_height;\n            this.category_counts = cat_counts;\n            this.category_function = cat_func;\n            if (update) {\n                var cm = this.feature_source.alignmentContainer.coverageMap;\n                cm.reset();\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                    for (var _iterator5 = this.feature_source.alignmentContainer.raw_alignments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                        var alignment = _step5.value;\n\n                        cm.incCounts(alignment);\n                    }\n                } catch (err) {\n                    _didIteratorError5 = true;\n                    _iteratorError5 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                            _iterator5.return();\n                        }\n                    } finally {\n                        if (_didIteratorError5) {\n                            throw _iteratorError5;\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"drawScale\",\n        value: function drawScale(pixel_height, ctx) {\n            if (this.draw_zoom_in) {\n                return;\n            }\n            this.coverageTrack.drawScale(ctx);\n        }\n    }, {\n        key: \"addExtraControls\",\n        value: function addExtraControls(dialog) {\n            var self = this;\n            dialog.div.empty();\n\n            dialog.scale_slider = $(\"<div>\").slider({\n                max: 100,\n                min: 10,\n                value: this.config.ind_track_height ? this.config.ind_track_height : 50,\n                slide: function slide(e, ui) {\n                    dialog.config.y_max = ui.value;\n                    if (dialog.panel) {\n                        dialog.panel.setTrackAttribute(dialog.config.track_id, \"ind_track_height\", ui.value);\n                        var h = Object.keys(self.category_counts).length + 1;\n                        dialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", h * ui.value);\n                        dialog.panel.update();\n                    }\n                }\n            }).appendTo(dialog.div);\n        }\n    }]);\n\n    return SCABAMTrack;\n}(_bam_track.BAMTrack);\n\n_tracks.MLVTrack.track_types[\"sca_bam_track\"] = {\n    \"class\": SCABAMTrack\n};\n\nexports.SCABAMTrack = SCABAMTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3NjYV9iYW1fdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3NjYV9iYW1fdHJhY2suanM/ZWFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0JBTVRyYWNrLENvdmVyYWdlVHJhY2ssQWxpZ25tZW50VHJhY2t9IGZyb20gXCIuLi9iYW1fdHJhY2suanNcIjtcclxuaW1wb3J0IHtCYW1Tb3VyY2UsQ292ZXJhZ2VNYXAsQ292ZXJhZ2V9IGZyb20gXCIuLi9iYW0uanNcIjtcclxuaW1wb3J0IHtNTFZUcmFja30gZnJvbSAnLi4vdHJhY2tzLmpzJztcclxuXHJcbmNsYXNzIFNDQUNvdmVyYWdlTWFwe1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihjaHIsIHN0YXJ0LCBlbmQscGFyZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICAgICAgdGhpcy5icFN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gKGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPXBhcmVudDtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldCgpe1xyXG4gICAgICAgIFx0dGhpcy5jb3ZlcmFnZXM9IHtcInNlbGVjdGVkXCI6bnVsbH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAobGV0IGMgaW4gdGhpcy5wYXJlbnQuY2F0ZWdvcmllcyl7XHJcbiAgICAgICAgICAgIFx0ICAgbGV0IGEgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBcdCAgIGEubWF4aW11bT0wO1xyXG4gICAgICAgICAgICBcdCAgIGEuY291bnQgPSB0aGlzLnBhcmVudC5jYXRlZ29yeV9jb3VudHNbY11cdCBcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuY292ZXJhZ2VzW2NdPWE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGVkKCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzZXRTZWxlY3RlZCgpe1xyXG4gICAgICAgIFx0ICBsZXQgYSA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBhLm1heGltdW09MDtcclxuICAgICAgICAgICAgICAgIGEuY291bnQ9dGhpcy5wYXJlbnQuc2VsZWN0ZWRfY291bnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdmVyYWdlc1tcInNlbGVjdGVkXCJdPWE7XHJcbiAgICAgICAgfVxyXG5cclxuICBcclxuXHJcbiAgICAgICAgaW5jQ291bnRzKGFsaWdubWVudCxzZWxfb25seSkge1xyXG4gICAgICAgIFx0bGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXNlbF9vbmx5KXtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRsZXQgY2F0ID0gdGhpcy5wYXJlbnQuY2F0ZWdvcnlfZnVuY3Rpb24oYWxpZ25tZW50LnRhZ0JBLkNCKTtcclxuXHRcdFx0XHJcblxyXG5cdFx0XHRcdGlmIChhbGlnbm1lbnQuYmxvY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdFx0XHRpbmNCbG9ja0NvdW50KGFsaWdubWVudCxjYXQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHRcdFx0XHRcdFx0aW5jQmxvY2tDb3VudChibG9jayxjYXQpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgY2F0ID0gXCJzZWxlY3RlZFwiXHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuc2VsZWN0ZWQpe1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5zZWxlY3RlZFthbGlnbm1lbnQudGFnQkEuQ0JdKXtcclxuICAgICAgICAgICAgICAgIFx0cmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50LmJsb2NrcyA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5jQmxvY2tDb3VudChhbGlnbm1lbnQsY2F0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNCbG9ja0NvdW50KGJsb2NrLGNhdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgXHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaW5jQmxvY2tDb3VudChibG9jayxjYXQpIHtcclxuICAgICAgICAgICAgXHRsZXQgY292ZXJhZ2UgPSBzZWxmLmNvdmVyYWdlc1tjYXRdO1xyXG4gICAgICAgICAgICBcdGlmICghY292ZXJhZ2Upe1xyXG4gICAgICAgICAgICBcdFx0cmV0dXJuO1xyXG4gICAgICAgICAgICBcdH1cclxuXHJcblx0XHRcdFx0dmFyIC8va2V5LFxyXG5cdFx0XHRcdFx0Ly9iYXNlLFxyXG5cdFx0XHRcdFx0aSxcclxuXHRcdFx0XHRcdGosXHJcblx0XHRcdFx0XHRxO1xyXG5cdFx0XHRcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gYmxvY2suc3RhcnQgLSBzZWxmLmJwU3RhcnQsIGogPSAwOyBqIDwgYmxvY2subGVuOyBpKyssIGorKykge1xyXG5cclxuXHRcdFx0XHRcdGlmICghY292ZXJhZ2VbaV0pIHtcclxuXHRcdFx0XHRcdFx0Y292ZXJhZ2VbaV0gPSB7dG90YWw6MCxtYXhpbXVtOjB9Oy8vbmV3IENvdmVyYWdlKCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9iYXNlID0gYmxvY2suc2VxLmNoYXJBdChqKTtcclxuXHRcdFx0XHRcdC8va2V5ID0gKGFsaWdubWVudC5zdHJhbmQpID8gXCJwb3NcIiArIGJhc2UgOiBcIm5lZ1wiICsgYmFzZTtcclxuXHRcdFx0XHRcdC8vcSA9IGJsb2NrLnF1YWxbal07XHJcblxyXG5cdFx0XHRcdFx0Ly9jb3ZlcmFnZVtpXVtrZXldICs9IDE7XHJcblx0XHRcdFx0XHQvL2NvdmVyYWdlW2ldW1wicXVhbFwiICsgYmFzZV0gKz0gcTtcclxuXHJcblx0XHRcdFx0XHRjb3ZlcmFnZVtpXS50b3RhbCArPSAxO1xyXG5cdFx0XHRcdFx0Ly9jb3ZlcmFnZVtpXS5xdWFsICs9IHE7XHJcblxyXG5cdFx0XHRcdFx0Y292ZXJhZ2UubWF4aW11bSA9IE1hdGgubWF4KGNvdmVyYWdlW2ldLnRvdGFsLCBjb3ZlcmFnZS5tYXhpbXVtKTtcclxuXHJcblx0XHRcdFx0fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuY2xhc3MgU0NBQ292ZXJhZ2VUcmFjayBleHRlbmRzIENvdmVyYWdlVHJhY2t7XHJcblxyXG4gICAgIFx0XHRjb25zdHJ1Y3Rvcihjb3ZlcmFnZSxoZWlnaHQpe1xyXG4gICAgIFx0XHRcdHN1cGVyKGNvdmVyYWdlLGhlaWdodCk7XHRcclxuICAgICBcdFx0fVxyXG5cclxuICAgICBcdFx0ZHJhd1NjYWxlKGN0eCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wPXRoaXMucGFyZW50LnRvcDtcclxuXHQgICAgICAgICAgICBsZXQgY21zID0gdGhpcy5wYXJlbnQuZmVhdHVyZV9zb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwO1xyXG5cdCAgICAgICAgICAgIGxldCBpbmRfdHJhY2tfaGVpZ2h0PSB0aGlzLnBhcmVudC5jb25maWcuaW5kX3RyYWNrX2hlaWdodD90aGlzLnBhcmVudC5jb25maWcuaW5kX3RyYWNrX2hlaWdodDo1MDtcclxuXHQgICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHRoaXMucGFyZW50LmNhdF9vcmRlcil7XHJcblx0ICAgICAgICAgICAgXHRsZXQgYz0gY21zLmNvdmVyYWdlc1tuYW1lXTtcclxuXHQgICAgICAgICAgICBcdGxldCBib3QgPSB0b3AraW5kX3RyYWNrX2hlaWdodDtcclxuXHQgICAgICAgICAgICBcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdCAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LmxpbmVUbygwLGJvdCk7XHJcblx0XHQgICAgICAgICAgICBjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdCAgICAgICAgICAgIGN0eC5saW5lVG8oMjAsdG9wKTtcclxuXHRcdCAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCxib3QpO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LmxpbmVUbygyMCxib3QpO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LmZvbnQ9XCIxMnB4IEFyaWFsXCI7XHJcblx0XHQgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcblx0XHQgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lPVwidG9wXCI7XHJcblx0XHQgICAgICAgICAgICBjdHguZmlsbFN0eWxlPVwiYmxhY2tcIjtcclxuXHRcdCAgICAgICAgICAgIGxldCBudW0gPSBjLm1heGltdW0vYy5jb3VudDtcclxuXHRcdCAgICAgICAgICAgIGlmIChpc05hTihudW0pKXtcclxuXHRcdCAgICAgICAgICAgIFx0bnVtPTA7XHJcblx0XHQgICAgICAgICAgICB9XHJcblx0XHQgICAgICAgICAgICBjdHguZmlsbFRleHQobnVtLnRvRml4ZWQoMiksMjAsdG9wKTtcclxuXHRcdCAgICAgICAgICAgIGN0eC5mb250PVwiMTRweCBBcmlhbFwiO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZT1cIm1pZGRsZVwiO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5hbWUsMix0b3ArKGluZF90cmFja19oZWlnaHQvMikpO1xyXG5cdFx0ICAgICAgICAgICAgY3R4LmZvbnQ9XCIxMnB4IEFyaWFsXCI7XHJcblx0XHQgICAgICAgICAgICB0b3ArPWluZF90cmFja19oZWlnaHQ7XHJcblx0ICAgICAgICAgICAgfVxyXG4gICAgIFx0XHR9XHJcblxyXG5cclxuICAgICBcdFx0ZHJhdyhvcHRpb25zKXtcclxuICAgICBcdFx0ICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lciA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgICAgICBjdHggPSBvcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgICAgIHBpeGVsV2lkdGggPSBvcHRpb25zLnBpeGVsV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgICAgICBjb3ZlcmFnZU1hcCA9IGFsaWdubWVudENvbnRhaW5lci5jb3ZlcmFnZU1hcCxcclxuICAgICAgICAgICAgICAgIGJwLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgICAgICBoLFxyXG4gICAgICAgICAgICAgICAgcmVmQmFzZSxcclxuICAgICAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgICAgICBsZW4sXHJcbiAgICAgICAgICAgICAgICBpdGVtLFxyXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kX3RyYWNrX2hlaWdodD0gdGhpcy5wYXJlbnQuY29uZmlnLmluZF90cmFja19oZWlnaHQ/dGhpcy5wYXJlbnQuY29uZmlnLmluZF90cmFja19oZWlnaHQ6NTA7XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmFnZU1hcC5yZWZTZXEpIHNlcXVlbmNlID0gY292ZXJhZ2VNYXAucmVmU2VxLnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdFx0bGV0IHRvcCA9IG9wdGlvbnMudG9wO1xyXG5cdFx0XHRcdGxldCB3ID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKDEuMCAvIGJwUGVyUGl4ZWwpKTtcclxuXHRcdFx0XHRmb3IgKGxldCBjYiBvZiB0aGlzLnBhcmVudC5jYXRfb3JkZXIpe1xyXG5cclxuXHRcdFx0XHRcdGxldCBjb3ZlcmFnZT0gY292ZXJhZ2VNYXAuY292ZXJhZ2VzW2NiXTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGNiK1wiOlwiK2NvdmVyYWdlLmNvdW50KTtcclxuXHRcdFx0XHRcdGxldCBtYXggPSBjb3ZlcmFnZS5tYXhpbXVtL2NvdmVyYWdlLmNvdW50XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPXRoaXMucGFyZW50LmNhdGVnb3JpZXNbY2JdO1xyXG5cdFx0XHRcdFx0aWYgKGNiPT09XCJzZWxlY3RlZFwiKXtcclxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1cInJlZFwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY292ZXJhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcblx0XHRcdFx0XHRcdGJwID0gKGNvdmVyYWdlTWFwLmJwU3RhcnQgKyBpKTtcclxuXHRcdFx0XHRcdFx0aWYgKGJwIDwgYnBTdGFydCkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdGlmIChicCA+IGJwRW5kKSBicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGl0ZW0gPSBjb3ZlcmFnZVtpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFpdGVtKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGggPSBNYXRoLnJvdW5kKCgoaXRlbS50b3RhbC9jb3ZlcmFnZS5jb3VudCkgLyBtYXgpICogaW5kX3RyYWNrX2hlaWdodCk7XHJcblx0XHRcdFx0XHRcdHkgPSBpbmRfdHJhY2tfaGVpZ2h0IC0gaDtcclxuXHRcdFx0XHRcdFx0eCA9IE1hdGguZmxvb3IoKGJwIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHJcblx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoIHgsIHkrdG9wLCB3LCBoKTtcclxuXHRcdFx0XHQgICAgfVxyXG5cdFx0XHRcdCAgICB0b3ArPWluZF90cmFja19oZWlnaHQ7XHJcblxyXG4gICAgIFx0XHQgICAgfVxyXG4gICAgIFx0XHQgICAgdGhpcy5kYXRhUmFuZ2UubWF4ID0gY292ZXJhZ2VNYXAubWF4aW11bTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudG9wKz10b3A7XHJcbiAgICAgXHRcdH1cclxuICAgICBcdH1cclxuXHJcblxyXG4gIFxyXG5cclxuICAgIGNsYXNzIFNDQUJBTVRyYWNrIGV4dGVuZHMgQkFNVHJhY2t7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKXtcclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZmVhdHVyZUhlaWdodCl7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuZmVhdHVyZUhlaWdodD0xMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXBlcihjb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlfYWxpZ25tZW50cz1mYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jbV9jbGFzcz0gU0NBQ292ZXJhZ2VNYXA7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcF9yYXdfYWxpZ25tZW50cz10cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3NldEZlYXR1cmVTb3VyY2UoKXtcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQmFtU291cmNlKHRoaXMuY29uZmlnLHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlX3NvdXJjZS5zZXRWaWV3QXNQYWlycyh0cnVlKTtcclxuXHJcblx0ICAgICAgICB0aGlzLmNvdmVyYWdlVHJhY2sgPSBuZXcgU0NBQ292ZXJhZ2VUcmFjayh0aGlzLmNvbmZpZywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50VHJhY2sgPSBuZXcgQWxpZ25tZW50VHJhY2sodGhpcy5jb25maWcsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsY291bnQpe1xyXG4gICAgICAgIFx0dGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgICAgIFx0bGV0IGNtID10aGlzLmZlYXR1cmVfc291cmNlLmFsaWdubWVudENvbnRhaW5lci5jb3ZlcmFnZU1hcDtcclxuICAgICAgICBcdHRoaXMuc2VsZWN0ZWRfY291bnQ9Y291bnQ7XHJcbiAgICAgICAgXHRjbS5yZXNldFNlbGVjdGVkKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGFsaWdubWVudCBvZiB0aGlzLmZlYXR1cmVfc291cmNlLmFsaWdubWVudENvbnRhaW5lci5yYXdfYWxpZ25tZW50cyl7XHJcbiAgICAgICAgICAgIFx0ICAgIGNtLmluY0NvdW50cyhhbGlnbm1lbnQsdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRcdGlmIChicEVuZC0gYnBTdGFydD4yMDAwMDApe1xyXG5cdFx0XHRcdHRoaXMuZHJhd196b29tX2luPXRydWU7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHRcdFx0XHRcdGZ1bGZpbGwoW10pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZHJhd196b29tX2luPWZhbHNlO1xyXG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgICAgIHNldENvdmVyYWdlQ2F0ZWdvcnkoY2F0X3RvX2NvbG9yLGNhdF9jb3VudHMsY2F0X2Z1bmMsdXBkYXRlKXtcclxuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzPWNhdF90b19jb2xvcjtcclxuICAgICAgICBcdGxldCBpbmRfdHJhY2tfaGVpZ2h0PSB0aGlzLmNvbmZpZy5pbmRfdHJhY2tfaGVpZ2h0P3RoaXMuY29uZmlnLmluZF90cmFja19oZWlnaHQ6NTA7XHJcbiAgICAgICAgXHRsZXQgbGk9W107XHJcbiAgICAgICAgXHRmb3IgKGxldCB2YWwgaW4gY2F0X2NvdW50cyl7XHJcbiAgICAgICAgXHRcdGxpLnB1c2goe3ZhbDp2YWwsbnVtOmNhdF9jb3VudHNbdmFsXX0pO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0bGkuc29ydChmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgIFx0XHRpZiAoYS52YWw9PT1cIm90aGVyXCIpe1xyXG4gICAgICAgIFx0XHRcdHJldHVybiAxO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHJldHVybiBiLm51bS1hLm51bTtcclxuICAgICAgICBcdH0pO1xyXG4gICAgICAgIFx0dGhpcy5jYXRfb3JkZXI9W1wic2VsZWN0ZWRcIl07XHJcbiAgICAgICAgXHRmb3IgKGxldCBsIG9mIGxpKXtcclxuICAgICAgICBcdFx0dGhpcy5jYXRfb3JkZXIucHVzaChsLnZhbCk7XHJcbiAgICAgICAgXHR9O1xyXG4gICAgICAgIFx0XHJcblxyXG4gICAgICAgIFx0dGhpcy5jb25maWcuaGVpZ2h0PShPYmplY3Qua2V5cyhjYXRfdG9fY29sb3IpLmxlbmd0aCsxKSppbmRfdHJhY2tfaGVpZ2h0O1xyXG4gICAgICAgIFx0dGhpcy5jYXRlZ29yeV9jb3VudHMgPSBjYXRfY291bnRzOyBcclxuICAgICAgICBcdHRoaXMuY2F0ZWdvcnlfZnVuY3Rpb249Y2F0X2Z1bmM7XHJcbiAgICAgICAgXHRpZiAodXBkYXRlKXtcclxuICAgICAgICAgICAgICAgIGxldCBjbSA9IHRoaXMuZmVhdHVyZV9zb3VyY2UuYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwO1xyXG4gICAgICAgICAgICAgICAgY20ucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGFsaWdubWVudCBvZiB0aGlzLmZlYXR1cmVfc291cmNlLmFsaWdubWVudENvbnRhaW5lci5yYXdfYWxpZ25tZW50cyl7XHJcbiAgICAgICAgICAgIFx0ICAgIGNtLmluY0NvdW50cyhhbGlnbm1lbnQpO1xyXG5cdFx0XHRcdH1cclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgXHR9XHJcbiAgICAgZHJhd1NjYWxlKHBpeGVsX2hlaWdodCxjdHgpe1xyXG4gICAgIFx0aWYgKHRoaXMuZHJhd196b29tX2luKXtcclxuICAgICBcdFx0cmV0dXJuO1xyXG4gICAgIFx0fVxyXG4gICAgIFx0dGhpcy5jb3ZlcmFnZVRyYWNrLmRyYXdTY2FsZShjdHgpO1xyXG4gICAgIFxyXG5cdFxyXG5cdFx0fVxyXG5cclxuXHRhZGRFeHRyYUNvbnRyb2xzKGRpYWxvZyl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHRkaWFsb2cuZGl2LmVtcHR5KCk7XHJcblx0XHJcblx0XHJcblxyXG5cdFxyXG4gICAgXHRkaWFsb2cuc2NhbGVfc2xpZGVyPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG4gICAgICAgXHRcdG1heDoxMDAsXHJcbiAgICAgICBcdFx0bWluOjEwLFxyXG4gICAgICAgXHRcdHZhbHVlOnRoaXMuY29uZmlnLmluZF90cmFja19oZWlnaHQ/dGhpcy5jb25maWcuaW5kX3RyYWNrX2hlaWdodDo1MCxcclxuICAgICAgIFx0XHRzbGlkZTpmdW5jdGlvbihlLHVpKXtcclxuICAgICAgICAgICBcdFx0ZGlhbG9nLmNvbmZpZy55X21heD11aS52YWx1ZVxyXG4gICAgICAgICAgIFx0XHRpZiAoZGlhbG9nLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJpbmRfdHJhY2tfaGVpZ2h0XCIsdWkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgXHRsZXQgaCA9IE9iamVjdC5rZXlzKHNlbGYuY2F0ZWdvcnlfY291bnRzKS5sZW5ndGgrMTtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJoZWlnaHRcIixoKnVpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgIFx0XHR9XHJcbiAgICAgICAgICAgXHRcdFxyXG4gICAgICAgXHRcdH0gXHJcbiAgICBcdH0pLmFwcGVuZFRvKGRpYWxvZy5kaXYpO1xyXG4gICAgXHJcblx0XHRcdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgICBcdE1MVlRyYWNrLnRyYWNrX3R5cGVzW1wic2NhX2JhbV90cmFja1wiXT17XHJcbiAgICAgICAgICAgIFwiY2xhc3NcIjpTQ0FCQU1UcmFja1x0XHJcbiAgICAgXHR9XHJcblxyXG5leHBvcnQge1NDQUJBTVRyYWNrfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBNkJBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0JBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUExQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQTJCQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQXREQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFzREE7QUFDQTtBQUNBOzs7O0FBL0ZBO0FBQ0E7QUFvR0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQVBBO0FBUUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFjQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFiQTtBQWlCQTs7OztBQTNHQTtBQUNBO0FBb0hBO0FBQ0E7QUFEQTtBQUNBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/sca_bam_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/simple_browser.js":
/*!******************************************!*\
  !*** .Panel/src/extra/simple_browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.SinglePanelBrowser = exports.BrowserControls = exports.SimpleBrowser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _panel = __webpack_require__(/*! ../panel.js */ \"../MLVPanel/src/panel.js\");\n\nvar _track_dialog = __webpack_require__(/*! ../track_dialog.js */ \"../MLVPanel/src/track_dialog.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BaseBrowser = function () {\n\tfunction BaseBrowser(parent_div, config) {\n\t\t_classCallCheck(this, BaseBrowser);\n\n\t\tthis.div = $(\"#\" + parent_div).css({ \"padding\": \"2px\", \"overflow\": \"hidden\" });\n\t\tthis.listeners = {};\n\t\tthis.width = this.div.width();\n\t\tif (config.tracks_proxy) {\n\t\t\tthis.tracks_proxy = config.tracks_proxy;\n\t\t}\n\t}\n\n\t_createClass(BaseBrowser, [{\n\t\tkey: \"addControls\",\n\t\tvalue: function addControls(control_config) {\n\t\t\tvar div = $(\"<div>\").attr(\"id\", \"mlv-iv-control-panel\").appendTo(this.div);\n\t\t\tthis.control_panel = new BrowserControls(\"mlv-iv-control-panel\", this, control_config);\n\t\t\tvar new_div = $(\"<div>\").css({ \"height\": \"calc(100% - 30px)\", \"width\": \"calc(100% - 5px)\", \"position\": \"absolute\", \"top\": \"30px\" }).appendTo(this.div);\n\t\t\tthis.div = new_div;\n\t\t}\n\t}, {\n\t\tkey: \"addToMenu\",\n\t\tvalue: function addToMenu(element) {\n\t\t\tthis.control_panel.container.append(element);\n\t\t}\n\t}, {\n\t\tkey: \"replaceWithProxy\",\n\t\tvalue: function replaceWithProxy(url) {\n\t\t\tvar tp = this.tracks_proxy;\n\t\t\tif (!tp) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\tfor (var name in tp) {\n\t\t\t\tif (url.includes(name)) {\n\t\t\t\t\treturn url.replace(name, tp[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\t}]);\n\n\treturn BaseBrowser;\n}();\n\nvar SinglePanelBrowser = function (_BaseBrowser) {\n\t_inherits(SinglePanelBrowser, _BaseBrowser);\n\n\tfunction SinglePanelBrowser(parent_div, track_config, config) {\n\t\t_classCallCheck(this, SinglePanelBrowser);\n\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\n\t\tvar _this = _possibleConstructorReturn(this, (SinglePanelBrowser.__proto__ || Object.getPrototypeOf(SinglePanelBrowser)).call(this, parent_div, config));\n\n\t\t_this.panel = new _panel.MLVPanel(track_config, {\n\t\t\tallow_user_zoom: true,\n\t\t\tallow_user_drag: true,\n\t\t\tfixed_height_mode: true,\n\t\t\tallow_user_range_selection: true\n\t\t});\n\t\tif (config.add_controls) {\n\t\t\t_this.addControls({ allowed_track_types: config.allowed_track_types });\n\t\t}\n\n\t\t_this.div.append(_this.panel.getDiv());\n\t\tvar self = _this;\n\t\t$(window).on(\"resize\", function (e) {\n\t\t\tif (!e.target.open) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.setSize();\n\t\t});\n\t\tif (config.add_ruler) {\n\t\t\t_this.panel.addRulerTrack();\n\t\t}\n\t\t_this.panel.addLegend();\n\t\t_this.setSize();\n\n\t\t_this.panel.addListener(\"range_selected\", function (chr, start, end) {\n\t\t\tself.panel.update(chr, start, end);\n\t\t});\n\n\t\treturn _this;\n\t}\n\n\t_createClass(SinglePanelBrowser, [{\n\t\tkey: \"setSize\",\n\t\tvalue: function setSize() {\n\t\t\tthis.panel.setWidth(this.div.width());\n\t\t\tthis.panel.setHeight(this.div.height());\n\t\t\tif (this.panel.chr) {\n\t\t\t\tthis.panel.update();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"zoom\",\n\t\tvalue: function zoom(amount) {\n\t\t\tvar range = this.panel.end - this.panel.start;\n\t\t\tvar middle = this.panel.start + range / 2;\n\t\t\tvar new_range = range / amount;\n\t\t\tvar st = Math.round(middle - new_range / 2);\n\t\t\tvar en = Math.round(middle + new_range / 2);\n\t\t\tthis.panel.update(this.panel.chr, st, en);\n\t\t}\n\t}, {\n\t\tkey: \"addTrackFromBrowser\",\n\t\tvalue: function addTrackFromBrowser(config, update, pos) {\n\t\t\tconfig.url = this.replaceWithProxy(config.url);\n\t\t\tconfig.allow_user_remove = true;\n\t\t\tthis.panel.addTrack(config);\n\t\t\tif (update) {\n\t\t\t\tthis.panel.repaint(true, true);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"goToPosition\",\n\t\tvalue: function goToPosition(chr, start, end) {\n\t\t\tthis.panel.update(chr, start, end);\n\t\t}\n\t}, {\n\t\tkey: \"getPosition\",\n\t\tvalue: function getPosition() {\n\t\t\treturn {\n\t\t\t\tchr: this.panel.chr,\n\t\t\t\tstart: Math.round(this.panel.start),\n\t\t\t\tend: Math.round(this.panel.end)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"addListener\",\n\t\tvalue: function addListener(type, func) {\n\n\t\t\tthis.panel.addListener(type, func);\n\t\t}\n\t}, {\n\t\tkey: \"setState\",\n\t\tvalue: function setState(state) {\n\t\t\tthis.panel.removeAllTracks();\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = state.state[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar conf = _step.value;\n\n\t\t\t\t\tthis.panel.addTrack(conf);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state.position) {\n\t\t\t\tthis.panel.update(state.position.chr, state.position.start, state.position.end);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setHighlightedRegion\",\n\t\tvalue: function setHighlightedRegion(chr, start, end) {\n\t\t\tthis.panel.removeHighlightedRegion(\"region_1\");\n\t\t\tif (!chr) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.panel.setHighlightedRegion({ chr: chr, start: start, end: end }, \"region_1\", \"blue\");\n\t\t}\n\t}]);\n\n\treturn SinglePanelBrowser;\n}(BaseBrowser);\n\nvar SimpleBrowser = function (_BaseBrowser2) {\n\t_inherits(SimpleBrowser, _BaseBrowser2);\n\n\t/**\r\n    * Creates a filter panel\r\n    * @param {string } parent_div- The id of the div element to house the browser\r\n    * @param {Object} [config] - config of how the browser is constructed\r\n    * <ul>\r\n    * <li>add_controls - if true then a control bar is added (default false)</li>\r\n    * <li>add_ruler - if true a ruler track will be added (default false)\r\n    * </ul>\r\n    */\n\tfunction SimpleBrowser(parent_div, config) {\n\t\t_classCallCheck(this, SimpleBrowser);\n\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\n\t\tvar _this2 = _possibleConstructorReturn(this, (SimpleBrowser.__proto__ || Object.getPrototypeOf(SimpleBrowser)).call(this, parent_div, config));\n\n\t\tif (config.add_controls) {\n\t\t\t_this2.addControls({ limit_chromosome: config.limit_chromosome, allowed_track_types: config.allowed_track_types });\n\t\t}\n\n\t\t_this2.panels = {};\n\t\t_this2.chr = \"\";\n\t\t_this2.start = 1;\n\t\t_this2.end = 10000;\n\t\tif (config.add_ruler) {\n\t\t\t_this2.addPanel(\"ruler\");\n\t\t}\n\n\t\tvar self = _this2;\n\t\t$(window).on(\"resize\", function (e) {\n\t\t\tif (!e.target.open) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.setWidth();\n\t\t});\n\n\t\t_this2._addHandlers();\n\t\treturn _this2;\n\t}\n\n\t_createClass(SimpleBrowser, [{\n\t\tkey: \"_addHandlers\",\n\t\tvalue: function _addHandlers() {\n\t\t\tvar self = this;\n\t\t\tthis.div.on('mousewheel.zoom  mouse.zoom DOMMouseScroll', function (event) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvar deltaY = event.originalEvent.deltaY;\n\t\t\t\tif (deltaY === undefined) {\n\t\t\t\t\tdeltaY = event.originalEvent.detail;\n\t\t\t\t}\n\t\t\t\tif (self._isLoading() || self.bp_per_pixel < 0.05 && deltaY > 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar canvasCoords = self._translateCoOrds(event.originalEvent);\n\t\t\t\tvar factor = deltaY < 0 ? 2 : 0.5;\n\t\t\t\tvar mbp = self.start + canvasCoords.x * self.bp_per_pixel;\n\t\t\t\tvar new_length = Math.round((self.end - self.start) * factor);\n\t\t\t\tvar new_start = Math.round(mbp - canvasCoords.x / self.width * new_length);\n\t\t\t\tself.goToPosition(self.chr, new_start, new_start + new_length);\n\t\t\t});\n\n\t\t\tthis.div.on(\"mousedown.draghandler\", function (e) {\n\t\t\t\tif (e.shiftKey) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar canvasCoords = self._translateCoOrds(e);\n\t\t\t\tself.isMouseDown = true;\n\t\t\t\tself.start_dragging = true;\n\t\t\t\tself.lastMouseX = canvasCoords.x;\n\t\t\t\tself.mouseDownX = self.lastMouseX;\n\t\t\t}).on(\"mousemove.draghandler\", function (e) {\n\t\t\t\tvar canvasCoords = self._translateCoOrds(e);\n\t\t\t\tif ($._no_drag) {\n\t\t\t\t\tself.is_dragging = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (self.is_dragging || self.start_dragging) {\n\t\t\t\t\tvar diff = canvasCoords.x - self.lastMouseX;\n\t\t\t\t\tif (self._isLoading()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar bp_diff = self.bp_per_pixel * diff;\n\t\t\t\t\tvar start = self.start -= bp_diff;\n\t\t\t\t\tvar end = self.end -= bp_diff;\n\t\t\t\t\tself.goToPosition(self.chr, start, end);\n\n\t\t\t\t\tself.lastMouseX = canvasCoords.x;\n\t\t\t\t\tif (self.start_dragging && diff > 30) {\n\t\t\t\t\t\tself.is_dragging = true;\n\t\t\t\t\t\tself.start_dragging = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).on(\"mouseup.draghandler\", function (e) {\n\t\t\t\tself.is_dragging = false;\n\t\t\t\tself.start_dragging = false;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"_translateCoOrds\",\n\t\tvalue: function _translateCoOrds(e) {\n\t\t\tvar x = e.pageX - this.div.offset().left;\n\t\t\tvar y = e.pageY - this.div.offset().top;\n\t\t\treturn { x: x, y: y };\n\t\t}\n\t}, {\n\t\tkey: \"_isLoading\",\n\t\tvalue: function _isLoading() {\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tif (this.panels[p_id].loading) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: \"setHighlightedRegion\",\n\t\tvalue: function setHighlightedRegion(location, name, color) {\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tif (id === \"ruler\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis.panels[id].setHighlightedRegion(location, name, color);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"removeHighlightedRegion\",\n\t\tvalue: function removeHighlightedRegion(name) {\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tthis.panels[id].removeHighlightedRegion(name);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getState\",\n\t\tvalue: function getState() {\n\t\t\tvar state = [];\n\t\t\tfor (var id in this.panels) {\n\t\t\t\tvar p = this.panels[id];\n\t\t\t\tdelete p.pan_config.update;\n\t\t\t\tstate.push({\n\t\t\t\t\tconfig: p.getAllTrackConfigs(),\n\t\t\t\t\tpan_config: p.pan_config,\n\t\t\t\t\ttop: p.getDiv().css(\"top\").replace(\"px\", \"\"),\n\t\t\t\t\theight: p.getDiv().css(\"height\").replace(\"px\", \"\"),\n\t\t\t\t\tid: id\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t}, {\n\t\tkey: \"removePanel\",\n\t\tvalue: function removePanel(id) {\n\t\t\tvar pan = this.panels[id];\n\t\t\tpan.getDiv().remove();\n\t\t\tdelete this.panels[id];\n\t\t}\n\t}, {\n\t\tkey: \"setState\",\n\t\tvalue: function setState(state) {\n\t\t\tvar ids = Object.keys(this.panels);\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar id = _step2.value;\n\n\t\t\t\t\tthis.removePanel(id);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = state[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar item = _step3.value;\n\n\t\t\t\t\tthis.addPanel(item.id, item.config, item.top, item.height, item.pan_config);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n     * Adds a panel to the browser Creates a filter panel\r\n     * @param {string } id - The id of track \r\n     * @param {Object[]} track_config - The config describing the tracks in the panel\r\n     * @param {number} top - The position of the top of the panel(in pixels)\r\n     * @param {number} height- The height of the panel (in pixels)\r\n     */\n\n\t}, {\n\t\tkey: \"addPanel\",\n\t\tvalue: function addPanel(id, track_config, top, height, pan_config) {\n\t\t\tvar ruler = false;\n\t\t\tif (id === \"ruler\") {\n\t\t\t\ttrack_config = [];\n\t\t\t\truler = true;\n\t\t\t\ttop = 5;\n\t\t\t\theight = 40;\n\t\t\t}\n\t\t\tvar self = this;\n\t\t\tif (!pan_config) {\n\t\t\t\tpan_config = {};\n\t\t\t}\n\t\t\tvar panel_config = {\n\t\t\t\theight: height,\n\t\t\t\twidth: this.div.width(),\n\t\t\t\tallow_user_move: \"vertical\",\n\t\t\t\tallow_user_resize: \"vertical\"\n\n\t\t\t};\n\t\t\tif (pan_config.allow_user_close) {\n\t\t\t\tpanel_config.allow_user_close = true;\n\t\t\t}\n\n\t\t\tvar p = new _panel.MLVPanel(track_config, panel_config);\n\n\t\t\tif (pan_config.allow_user_close) {\n\t\t\t\tp.addListener(\"panel_closed\", function () {\n\t\t\t\t\tdelete self.panels[id];\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (ruler) {\n\t\t\t\tp.addRulerTrack();\n\t\t\t\tp.allowUserRangeSelection();\n\t\t\t\tp.addListener(\"range_selected\", function (chr, start, end) {\n\t\t\t\t\tself.goToPosition(chr, start, end);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tp.addLegend();\n\t\t\t}\n\t\t\tthis.panels[id] = p;\n\t\t\tp.pan_config = pan_config;\n\t\t\t//set panel position and add it to DOM\n\t\t\tvar div = p.getDiv();\n\t\t\tdiv.css({ top: top + \"px\", left: \"0px\" }).width(this.width);\n\t\t\tif (pan_config.move_to_back) {\n\t\t\t\tthis.div.prepend(div);\n\t\t\t} else {\n\t\t\t\tthis.div.append(div);\n\t\t\t}\n\t\t\tdiv.draggable(\"option\", \"containment\", \"parent\");\n\t\t\t$(\".track-handle\").removeClass(\"fa-arrows-alt-v\").addClass(\"fa-arrows-alt\");\n\t\t\tif (!ruler) {\n\t\t\t\tdiv.append($(\"<i class='fas fa-arrows-alt-v'></i>\").css({ \"position\": \"absolute\", \"bottom\": \"-5px\", \"right\": \"7px\", \"font-size\": \"12px\", \"opacity\": \"0.8\" }));\n\t\t\t}\n\t\t\tif (pan_config.update) {\n\t\t\t\tp.update(this.chr, this.start, this.end);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"_positionChanged\",\n\t\tvalue: function _positionChanged(chr, start, end) {\n\t\t\tthis.chr = chr;\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.bp_per_pixel = (this.end - this.start) / this.width;\n\t\t\tvar callback = this.listeners['view_changed'];\n\t\t\tif (callback) {\n\t\t\t\tcallback(chr + \":\" + Math.round(start) + \"-\" + Math.round(end));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getPosition\",\n\t\tvalue: function getPosition() {\n\t\t\treturn {\n\t\t\t\tchr: this.chr,\n\t\t\t\tstart: Math.round(this.start),\n\t\t\t\tend: Math.round(this.end)\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"setWidth\",\n\t\tvalue: function setWidth() {\n\t\t\tthis.width = this.div.width();\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tthis.panels[p_id].setWidth(this.width);\n\t\t\t\tthis.panels[p_id].update();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"zoom\",\n\t\tvalue: function zoom(amount) {\n\t\t\tvar range = this.end - this.start;\n\t\t\tvar middle = this.start + range / 2;\n\t\t\tvar new_range = range / amount;\n\t\t\tvar st = Math.round(middle - new_range / 2);\n\t\t\tvar en = Math.round(middle + new_range / 2);\n\t\t\tthis.goToPosition(this.chr, st, en);\n\t\t}\n\n\t\t/**\r\n     * Displays the specified genomic location\r\n     * @param {string } chr - chromosome \r\n     * @param {number} start - The start of the genomic location\r\n     * @param {number} end - The end of the genomic location\r\n     */\n\n\t}, {\n\t\tkey: \"goToPosition\",\n\t\tvalue: function goToPosition(chr, start, end) {\n\t\t\tfor (var p_id in this.panels) {\n\t\t\t\tthis.panels[p_id].update(chr, start, end);\n\t\t\t}\n\t\t\tthis._positionChanged(chr, start, end);\n\t\t}\n\t}, {\n\t\tkey: \"addListener\",\n\t\tvalue: function addListener(type, func) {\n\t\t\tthis.listeners[type] = func;\n\t\t}\n\t}, {\n\t\tkey: \"addTrackFromBrowser\",\n\t\tvalue: function addTrackFromBrowser(config, update) {\n\t\t\tconfig.url = this.replaceWithProxy(config.url);\n\t\t\tvar id = \"pan_\" + this.pan_id++;\n\t\t\tthis.addPanel(id, [config], 0, 200, { allow_user_close: true, move_to_back: true, update: update });\n\t\t}\n\t}]);\n\n\treturn SimpleBrowser;\n}(BaseBrowser);\n\nvar BrowserControls = function () {\n\tfunction BrowserControls(element_id, browser, config) {\n\t\tvar _this3 = this;\n\n\t\t_classCallCheck(this, BrowserControls);\n\n\t\tthis.browser = browser;\n\t\tif (!config) {\n\t\t\tconfig = {};\n\t\t}\n\t\tthis.limit_chromosome = false;\n\t\tif (config.limit_chromosome) {\n\t\t\tthis.limit_chromosome = limit_chromosome;\n\t\t}\n\t\tthis.pan_id = 1;\n\t\tthis.container = $(\"#\" + element_id).css({ \"padding-left\": \"20px\" }).addClass(\"browser-menu-panel\");\n\t\tthis.container.append(\"<label>zoom</label>\");\n\t\tthis.zoom_level_input = $(\"<input>\").val(\"2\").width(15).appendTo(this.container);\n\t\tthis.zoom_level_input.spinner({ step: 1 });\n\t\tvar self = this;\n\t\tthis.zoom_in = $(\"<i>\").attr(\"class\", \"fa fa-search-plus mlv-click-icon \").appendTo(this.container).click(function () {\n\t\t\t_this3.browser.zoom(_this3.zoom_level_input.val());\n\t\t});\n\t\tthis.zoom_out = $(\"<i>\").attr(\"class\", \"fa fa-search-minus mlv-click-icon \").appendTo(this.container).click(function () {\n\t\t\t_this3.browser.zoom(1 / _this3.zoom_level_input.val());\n\t\t});\n\t\tvar l_l = this.limit_chromosome ? this.limit_chromosome : \"Location\";\n\n\t\tthis.container.append($(\"<label>\").text(l_l).css({ \"margin-left\": \"10px\" }));\n\t\tthis.location_input = $(\"<input>\").css(\"width\", \"200px\").appendTo(this.container).keypress(function (e) {\n\t\t\tif (e.keyCode === 13) {\n\t\t\t\tvar loc = self.calculatePosition($(this).val());\n\t\t\t\tself.browser.goToPosition(loc.chr, loc.start, loc.end);\n\t\t\t}\n\t\t});\n\n\t\tvar add_track = $(\"<button>\").html(\"<i class = 'fa fa-plus'></i>Add Track\").attr(\"class\", \"btn btn-sm btn-secondary\").css(\"margin-left\", \"3px\").click(function (e) {\n\t\t\tnew _track_dialog.AddTrackDialog(function (config) {\n\t\t\t\tself.browser.addTrackFromBrowser(config, true);\n\t\t\t}, { allowed_track_types: config.allowed_track_types });\n\t\t}).appendTo(this.container);\n\t\tthis.browser.addListener(\"view_changed\", function (location, start, end) {\n\t\t\tif (self.limit_chromosome) {\n\t\t\t\tlocation = location.split(\":\")[1];\n\t\t\t}\n\t\t\tif (start) {\n\t\t\t\tlocation = location + \":\" + start + \"-\" + end;\n\t\t\t}\n\t\t\tself.location_input.val(location);\n\t\t});\n\t}\n\n\t_createClass(BrowserControls, [{\n\t\tkey: \"calculatePosition\",\n\t\tvalue: function calculatePosition(text) {\n\t\t\ttext = text.replace(/,/g, \"\");\n\n\t\t\tvar arr = text.split(\":\");\n\t\t\tvar chr = null;\n\t\t\tvar pos = null;\n\t\t\tif (arr.length === 1) {\n\t\t\t\tchr = this.browser.getPosition().chr;\n\t\t\t\tpos = arr[0];\n\t\t\t} else {\n\t\t\t\tchr = arr[0];\n\t\t\t\tpos = arr[1];\n\t\t\t}\n\t\t\tvar arr2 = pos.split(\"-\");\n\t\t\treturn { chr: chr, start: parseInt(arr2[0]), end: parseInt(arr2[1]) };\n\t\t}\n\t}]);\n\n\treturn BrowserControls;\n}();\n\nexports.SimpleBrowser = SimpleBrowser;\nexports.BrowserControls = BrowserControls;\nexports.SinglePanelBrowser = SinglePanelBrowser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3NpbXBsZV9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9leHRyYS9zaW1wbGVfYnJvd3Nlci5qcz8wNzY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWUGFuZWx9IGZyb20gXCIuLi9wYW5lbC5qc1wiO1xyXG5pbXBvcnQge0FkZFRyYWNrRGlhbG9nfSBmcm9tIFwiLi4vdHJhY2tfZGlhbG9nLmpzXCI7XHJcblxyXG5jbGFzcyBCYXNlQnJvd3NlcntcclxuXHJcblx0Y29uc3RydWN0b3IocGFyZW50X2Rpdixjb25maWcpe1xyXG5cdFx0dGhpcy5kaXYgPSAkKFwiI1wiK3BhcmVudF9kaXYpLmNzcyh7XCJwYWRkaW5nXCI6XCIycHhcIixcIm92ZXJmbG93XCI6XCJoaWRkZW5cIn0pO1xyXG5cdFx0dGhpcy5saXN0ZW5lcnM9IHt9O1xyXG5cdFx0dGhpcy53aWR0aD10aGlzLmRpdi53aWR0aCgpO1xyXG5cdFx0aWYgKGNvbmZpZy50cmFja3NfcHJveHkpe1xyXG5cdFx0XHR0aGlzLnRyYWNrc19wcm94eT1jb25maWcudHJhY2tzX3Byb3h5O1xyXG5cdFx0fVxyXG5cdFxyXG5cdH1cclxuXHJcblx0YWRkQ29udHJvbHMoY29udHJvbF9jb25maWcpe1xyXG5cdFx0bGV0IGRpdiA9JChcIjxkaXY+XCIpLmF0dHIoXCJpZFwiLFwibWx2LWl2LWNvbnRyb2wtcGFuZWxcIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5jb250cm9sX3BhbmVsID0gbmV3IEJyb3dzZXJDb250cm9scyhcIm1sdi1pdi1jb250cm9sLXBhbmVsXCIsdGhpcyxjb250cm9sX2NvbmZpZyk7XHJcblx0XHRsZXQgbmV3X2Rpdj0kKFwiPGRpdj5cIikuY3NzKHtcImhlaWdodFwiOlwiY2FsYygxMDAlIC0gMzBweClcIixcIndpZHRoXCI6XCJjYWxjKDEwMCUgLSA1cHgpXCIsXCJwb3NpdGlvblwiOlwiYWJzb2x1dGVcIixcInRvcFwiOlwiMzBweFwifSkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5kaXY9bmV3X2RpdjtcclxuXHR9XHJcblxyXG5cdGFkZFRvTWVudShlbGVtZW50KXtcclxuXHRcdHRoaXMuY29udHJvbF9wYW5lbC5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xyXG5cdH1cclxuXHJcblx0cmVwbGFjZVdpdGhQcm94eSh1cmwpe1xyXG5cdFx0bGV0IHRwID0gdGhpcy50cmFja3NfcHJveHk7XHJcblx0XHRpZiAoIXRwKXtcclxuXHRcdFx0cmV0dXJuIHVybDtcclxuXHRcdH1cclxuXHRcclxuXHRcdGZvciAobGV0IG5hbWUgaW4gdHApe1xyXG5cdFx0XHRpZiAodXJsLmluY2x1ZGVzKG5hbWUpKXtcclxuXHRcdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UobmFtZSx0cFtuYW1lXSlcclxuXHRcdFx0fVx0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdXJsO1x0XHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxufVxyXG5cclxuY2xhc3MgU2luZ2xlUGFuZWxCcm93c2VyIGV4dGVuZHMgQmFzZUJyb3dzZXJ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBhcmVudF9kaXYsdHJhY2tfY29uZmlnLGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHJcblx0XHRzdXBlcihwYXJlbnRfZGl2LGNvbmZpZyk7XHJcblxyXG5cdFx0dGhpcy5wYW5lbCA9IG5ldyBNTFZQYW5lbChcclxuXHRcdFx0dHJhY2tfY29uZmlnLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0YWxsb3dfdXNlcl96b29tOnRydWUsXHJcblx0XHRcdFx0YWxsb3dfdXNlcl9kcmFnOnRydWUsXHJcblx0XHRcdFx0Zml4ZWRfaGVpZ2h0X21vZGU6dHJ1ZSxcclxuXHRcdFx0XHRhbGxvd191c2VyX3JhbmdlX3NlbGVjdGlvbjp0cnVlXHJcblx0XHRcdH1cclxuXHJcblx0XHQpXHJcblx0XHRpZiAoY29uZmlnLmFkZF9jb250cm9scyl7XHJcblx0XHRcdHRoaXMuYWRkQ29udHJvbHMoe2FsbG93ZWRfdHJhY2tfdHlwZXM6Y29uZmlnLmFsbG93ZWRfdHJhY2tfdHlwZXN9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRpdi5hcHBlbmQodGhpcy5wYW5lbC5nZXREaXYoKSk7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHQkKHdpbmRvdykub24oXCJyZXNpemVcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKCFlLnRhcmdldC5vcGVuKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5zZXRTaXplKCk7XHJcblx0XHR9KTtcclxuXHRcdGlmIChjb25maWcuYWRkX3J1bGVyKXtcclxuXHRcdFx0dGhpcy5wYW5lbC5hZGRSdWxlclRyYWNrKClcclxuXHRcdH1cclxuXHRcdHRoaXMucGFuZWwuYWRkTGVnZW5kKCk7XHJcblx0XHR0aGlzLnNldFNpemUoKTtcclxuXHJcblx0XHR0aGlzLnBhbmVsLmFkZExpc3RlbmVyKFwicmFuZ2Vfc2VsZWN0ZWRcIixmdW5jdGlvbihjaHIsc3RhcnQsZW5kKXtcclxuXHRcdFx0c2VsZi5wYW5lbC51cGRhdGUoY2hyLHN0YXJ0LGVuZCk7XHJcblx0XHR9KVxyXG5cdFxyXG5cclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cclxuXHRzZXRTaXplKCl7XHJcblx0XHR0aGlzLnBhbmVsLnNldFdpZHRoKHRoaXMuZGl2LndpZHRoKCkpO1xyXG5cdFx0dGhpcy5wYW5lbC5zZXRIZWlnaHQodGhpcy5kaXYuaGVpZ2h0KCkpO1xyXG5cdFx0aWYgKHRoaXMucGFuZWwuY2hyKXtcclxuXHRcdFx0dGhpcy5wYW5lbC51cGRhdGUoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHpvb20oYW1vdW50KXtcclxuXHRcdGxldCByYW5nZSA9IHRoaXMucGFuZWwuZW5kLXRoaXMucGFuZWwuc3RhcnQ7XHJcblx0XHRsZXQgbWlkZGxlID10aGlzLnBhbmVsLnN0YXJ0K3JhbmdlLzI7XHJcblx0XHRsZXQgbmV3X3JhbmdlID0ocmFuZ2UvYW1vdW50KTtcclxuXHRcdGxldCBzdCA9IE1hdGgucm91bmQobWlkZGxlLW5ld19yYW5nZS8yKTtcclxuXHRcdGxldCBlbiA9IE1hdGgucm91bmQobWlkZGxlK25ld19yYW5nZS8yKTtcclxuXHRcdHRoaXMucGFuZWwudXBkYXRlKHRoaXMucGFuZWwuY2hyLHN0LGVuKTtcclxuXHR9XHJcblxyXG5cdGFkZFRyYWNrRnJvbUJyb3dzZXIoY29uZmlnLHVwZGF0ZSxwb3Mpe1xyXG5cdFx0Y29uZmlnLnVybCA9IHRoaXMucmVwbGFjZVdpdGhQcm94eShjb25maWcudXJsKTtcclxuXHRcdGNvbmZpZy5hbGxvd191c2VyX3JlbW92ZT10cnVlO1xyXG5cdFx0dGhpcy5wYW5lbC5hZGRUcmFjayhjb25maWcpO1xyXG5cdFx0aWYgKHVwZGF0ZSl7XHJcblx0XHRcdHRoaXMucGFuZWwucmVwYWludCh0cnVlLHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z29Ub1Bvc2l0aW9uKGNocixzdGFydCxlbmQpe1xyXG5cdFx0dGhpcy5wYW5lbC51cGRhdGUoY2hyLHN0YXJ0LGVuZCk7XHJcblx0fVxyXG5cclxuXHRnZXRQb3NpdGlvbigpe1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjaHI6dGhpcy5wYW5lbC5jaHIsXHJcblx0XHRcdFx0c3RhcnQ6TWF0aC5yb3VuZCh0aGlzLnBhbmVsLnN0YXJ0KSxcclxuXHRcdFx0XHRlbmQ6TWF0aC5yb3VuZCh0aGlzLnBhbmVsLmVuZClcclxuXHRcdFx0fTtcclxuXHR9XHJcblxyXG5cdGFkZExpc3RlbmVyKHR5cGUsZnVuYyl7XHJcblxyXG5cdFx0dGhpcy5wYW5lbC5hZGRMaXN0ZW5lcih0eXBlLGZ1bmMpO1xyXG5cdH1cclxuXHJcblx0c2V0U3RhdGUoc3RhdGUpe1xyXG5cdFx0dGhpcy5wYW5lbC5yZW1vdmVBbGxUcmFja3MoKTtcclxuXHRcdGZvciAobGV0IGNvbmYgb2Ygc3RhdGUuc3RhdGUpe1xyXG5cdFx0XHR0aGlzLnBhbmVsLmFkZFRyYWNrKGNvbmYpO1xyXG5cdFx0fVxyXG4gICAgICAgICAgIGlmIChzdGF0ZS5wb3NpdGlvbil7XHJcblx0XHQgICAgIHRoaXMucGFuZWwudXBkYXRlKHN0YXRlLnBvc2l0aW9uLmNocixzdGF0ZS5wb3NpdGlvbi5zdGFydCxzdGF0ZS5wb3NpdGlvbi5lbmQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2V0SGlnaGxpZ2h0ZWRSZWdpb24oY2hyLHN0YXJ0LGVuZCl7XHJcblx0XHR0aGlzLnBhbmVsLnJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKFwicmVnaW9uXzFcIik7XHJcblx0XHRpZiAoIWNocil7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMucGFuZWwuc2V0SGlnaGxpZ2h0ZWRSZWdpb24oXHJcblx0XHRcdHtjaHI6Y2hyLHN0YXJ0OnN0YXJ0LGVuZDplbmR9LFxyXG5cdFx0XHRcInJlZ2lvbl8xXCIsXHJcblx0XHRcdFwiYmx1ZVwiXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5jbGFzcyBTaW1wbGVCcm93c2VyIGV4dGVuZHMgQmFzZUJyb3dzZXJ7XHJcblx0IC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBwYW5lbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfSBwYXJlbnRfZGl2LSBUaGUgaWQgb2YgdGhlIGRpdiBlbGVtZW50IHRvIGhvdXNlIHRoZSBicm93c2VyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gLSBjb25maWcgb2YgaG93IHRoZSBicm93c2VyIGlzIGNvbnN0cnVjdGVkXHJcbiAgICAgKiA8dWw+XHJcbiAgICAgKiA8bGk+YWRkX2NvbnRyb2xzIC0gaWYgdHJ1ZSB0aGVuIGEgY29udHJvbCBiYXIgaXMgYWRkZWQgKGRlZmF1bHQgZmFsc2UpPC9saT5cclxuICAgICAqIDxsaT5hZGRfcnVsZXIgLSBpZiB0cnVlIGEgcnVsZXIgdHJhY2sgd2lsbCBiZSBhZGRlZCAoZGVmYXVsdCBmYWxzZSlcclxuICAgICAqIDwvdWw+XHJcbiAgICAgKi9cclxuXHRjb25zdHJ1Y3RvcihwYXJlbnRfZGl2LGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHJcblx0XHRzdXBlcihwYXJlbnRfZGl2LGNvbmZpZyk7XHJcblx0XHJcblx0XHRpZiAoY29uZmlnLmFkZF9jb250cm9scyl7XHJcblx0XHRcdHRoaXMuYWRkQ29udHJvbHMoe2xpbWl0X2Nocm9tb3NvbWU6Y29uZmlnLmxpbWl0X2Nocm9tb3NvbWUsYWxsb3dlZF90cmFja190eXBlczpjb25maWcuYWxsb3dlZF90cmFja190eXBlc30pO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRcclxuXHRcdHRoaXMucGFuZWxzPXt9O1xyXG5cdFx0dGhpcy5jaHI9XCJcIjtcclxuXHRcdHRoaXMuc3RhcnQ9MTtcclxuXHRcdHRoaXMuZW5kPTEwMDAwO1xyXG5cdFx0aWYgKGNvbmZpZy5hZGRfcnVsZXIpe1xyXG5cdFx0XHR0aGlzLmFkZFBhbmVsKFwicnVsZXJcIik7XHJcblx0XHR9XHJcblx0XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHQkKHdpbmRvdykub24oXCJyZXNpemVcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKCFlLnRhcmdldC5vcGVuKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5zZXRXaWR0aCgpO1xyXG5cdFx0fSk7XHJcblx0XHRcclxuXHRcdHRoaXMuX2FkZEhhbmRsZXJzKCk7XHRcclxuXHR9XHJcblx0XHJcblx0X2FkZEhhbmRsZXJzKCl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLmRpdi5vbignbW91c2V3aGVlbC56b29tICBtb3VzZS56b29tIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdGxldCBkZWx0YVk9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGVsdGFZO1xyXG5cdFx0XHRpZiAoZGVsdGFZID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRcdGRlbHRhWT1ldmVudC5vcmlnaW5hbEV2ZW50LmRldGFpbFxyXG5cdFx0XHR9XHJcbiAgICBcdCBcdGlmIChzZWxmLl9pc0xvYWRpbmcoKSB8fCAoc2VsZi5icF9wZXJfcGl4ZWw8MC4wNSAmJiBkZWx0YVk+MCkpe1xyXG4gICAgXHQgXHRcdHJldHVybjtcclxuICAgIFx0IFx0fVxyXG4gICAgXHQgXHRsZXQgY2FudmFzQ29vcmRzID0gc2VsZi5fdHJhbnNsYXRlQ29PcmRzKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZmFjdG9yID0gZGVsdGFZPDA/MjowLjU7XHJcbiAgICAgICAgICAgIGxldCBtYnA9IChzZWxmLnN0YXJ0KyBjYW52YXNDb29yZHMueCAqIHNlbGYuYnBfcGVyX3BpeGVsKVxyXG4gICAgICAgICAgICBsZXQgbmV3X2xlbmd0aCA9IE1hdGgucm91bmQoKHNlbGYuZW5kLXNlbGYuc3RhcnQpKmZhY3Rvcik7XHJcbiAgICAgICAgICAgIGxldCBuZXdfc3RhcnQgPSBNYXRoLnJvdW5kKG1icC0oKGNhbnZhc0Nvb3Jkcy54L3NlbGYud2lkdGgpKm5ld19sZW5ndGgpKTtcclxuICAgICAgICAgICAgc2VsZi5nb1RvUG9zaXRpb24oc2VsZi5jaHIsbmV3X3N0YXJ0LG5ld19zdGFydCtuZXdfbGVuZ3RoKVxyXG4gICAgICAgICB9KTtcclxuXHRcdFxyXG5cdFx0IHRoaXMuZGl2Lm9uKFwibW91c2Vkb3duLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgXHQgXHRpZiAoZS5zaGlmdEtleSl7XHJcblx0ICAgIFx0IFx0XHRyZXR1cm47XHJcblx0ICAgIFx0IFx0fVxyXG5cdCAgICAgICAgICAgIHZhciBjYW52YXNDb29yZHMgPXNlbGYuX3RyYW5zbGF0ZUNvT3JkcyhlKTtcclxuXHQgICAgICAgICAgICBzZWxmLmlzTW91c2VEb3duID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBzZWxmLnN0YXJ0X2RyYWdnaW5nPXRydWU7XHJcblx0ICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYID0gY2FudmFzQ29vcmRzLng7XHJcblx0ICAgICAgICAgICAgc2VsZi5tb3VzZURvd25YID0gc2VsZi5sYXN0TW91c2VYO1xyXG5cclxuXHQgICAgICAgIH0pXHJcblx0ICAgICAgIFx0Lm9uKFwibW91c2Vtb3ZlLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgY2FudmFzQ29vcmRzID1zZWxmLl90cmFuc2xhdGVDb09yZHMoZSk7XHJcblx0ICAgICAgICAgICAgaWYgKCQuX25vX2RyYWcpe1xyXG5cdCAgICAgICAgICAgIFx0c2VsZi5pc19kcmFnZ2luZz1mYWxzZTtcclxuXHQgICAgICAgICAgICBcdHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfZHJhZ2dpbmcgfHwgc2VsZi5zdGFydF9kcmFnZ2luZyl7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2FudmFzQ29vcmRzLngtc2VsZi5sYXN0TW91c2VYO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc2VsZi5faXNMb2FkaW5nKCkpe1xyXG5cdCAgICAgICAgICAgICAgICBcdHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgYnBfZGlmZj1zZWxmLmJwX3Blcl9waXhlbCpkaWZmO1xyXG5cdCAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPXNlbGYuc3RhcnQtPWJwX2RpZmY7XHJcblx0ICAgICAgICAgICAgICAgIGxldCBlbmQgPXNlbGYuZW5kLT1icF9kaWZmO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLmdvVG9Qb3NpdGlvbihzZWxmLmNocixzdGFydCxlbmQpO1xyXG5cdCAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYPWNhbnZhc0Nvb3Jkcy54O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc2VsZi5zdGFydF9kcmFnZ2luZyAmJiBkaWZmPjMwKXtcclxuXHQgICAgICAgICAgICAgICAgXHRzZWxmLmlzX2RyYWdnaW5nPXRydWU7XHJcblx0ICAgICAgICAgICAgICAgIFx0c2VsZi5zdGFydF9kcmFnZ2luZz1mYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0pXHJcblx0ICAgICAgICAub24oXCJtb3VzZXVwLmRyYWdoYW5kbGVyXCIsZnVuY3Rpb24gKGUpIHsgICBcclxuXHQgICAgICAgICAgICAgIHNlbGYuaXNfZHJhZ2dpbmc9ZmFsc2U7XHJcblx0ICAgICAgICAgICAgICBzZWxmLnN0YXJ0X2RyYWdnaW5nPWZhbHNlO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgIFxyXG5cdH1cclxuXHRcclxuXHRfdHJhbnNsYXRlQ29PcmRzKGUpe1xyXG5cdFx0ICBsZXQgeCA9IGUucGFnZVggLSB0aGlzLmRpdi5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgbGV0IHkgPSBlLnBhZ2VZIC0gdGhpcy5kaXYub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgcmV0dXJuIHt4LHl9O1xyXG5cdH1cclxuXHRcclxuXHRfaXNMb2FkaW5nKCl7XHJcblx0XHRmb3IgKGxldCBwX2lkIGluIHRoaXMucGFuZWxzKXtcdFx0XHJcblx0XHRcdGlmICh0aGlzLnBhbmVsc1twX2lkXS5sb2FkaW5nKXtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0c2V0SGlnaGxpZ2h0ZWRSZWdpb24obG9jYXRpb24sbmFtZSxjb2xvcil7XHJcblx0XHRmb3IgKGxldCBpZCBpbiB0aGlzLnBhbmVscyl7XHJcblx0XHRcdGlmIChpZCA9PT0gXCJydWxlclwiKXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBhbmVsc1tpZF0uc2V0SGlnaGxpZ2h0ZWRSZWdpb24obG9jYXRpb24sbmFtZSxjb2xvcik7XHJcblx0XHRcdFxyXG5cclxuXHJcblx0XHR9XHJcblx0fVxyXG5cdHJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKG5hbWUpe1xyXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHR0aGlzLnBhbmVsc1tpZF0ucmVtb3ZlSGlnaGxpZ2h0ZWRSZWdpb24obmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGdldFN0YXRlKCl7XHJcblx0XHRsZXQgc3RhdGUgPVtdO1xyXG5cdFx0Zm9yIChsZXQgaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHRsZXQgcCA9IHRoaXMucGFuZWxzW2lkXTtcclxuXHRcdFx0ZGVsZXRlIHAucGFuX2NvbmZpZy51cGRhdGU7XHJcblx0XHRcdHN0YXRlLnB1c2goe1xyXG5cdFx0XHRcdGNvbmZpZzpwLmdldEFsbFRyYWNrQ29uZmlncygpLFxyXG5cdFx0XHRcdHBhbl9jb25maWc6cC5wYW5fY29uZmlnLFxyXG5cdFx0XHRcdHRvcDpwLmdldERpdigpLmNzcyhcInRvcFwiKS5yZXBsYWNlKFwicHhcIixcIlwiKSxcclxuXHRcdFx0XHRoZWlnaHQ6cC5nZXREaXYoKS5jc3MoXCJoZWlnaHRcIikucmVwbGFjZShcInB4XCIsXCJcIiksXHJcblx0XHRcdFx0aWQ6aWRcclxuXHRcdFx0fSlcclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RhdGU7XHJcblx0fVxyXG5cclxuXHRyZW1vdmVQYW5lbChpZCl7XHJcblx0XHRsZXQgcGFuID0gdGhpcy5wYW5lbHNbaWRdO1xyXG5cdFx0cGFuLmdldERpdigpLnJlbW92ZSgpO1xyXG5cdFx0ZGVsZXRlIHRoaXMucGFuZWxzW2lkXTtcclxuXHR9XHJcblxyXG5cdHNldFN0YXRlKHN0YXRlKXtcclxuXHRcdGxldCBpZHMgPSBPYmplY3Qua2V5cyh0aGlzLnBhbmVscyk7XHJcblx0XHRmb3IgKGxldCBpZCBvZiBpZHMpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBhbmVsKGlkKTtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGl0ZW0gb2Ygc3RhdGUpe1xyXG5cdFx0XHR0aGlzLmFkZFBhbmVsKGl0ZW0uaWQsaXRlbS5jb25maWcsaXRlbS50b3AsaXRlbS5oZWlnaHQsaXRlbS5wYW5fY29uZmlnKVxyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHJcblx0IC8qKlxyXG4gICAgICogQWRkcyBhIHBhbmVsIHRvIHRoZSBicm93c2VyIENyZWF0ZXMgYSBmaWx0ZXIgcGFuZWxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIH0gaWQgLSBUaGUgaWQgb2YgdHJhY2sgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB0cmFja19jb25maWcgLSBUaGUgY29uZmlnIGRlc2NyaWJpbmcgdGhlIHRyYWNrcyBpbiB0aGUgcGFuZWxcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgcGFuZWwoaW4gcGl4ZWxzKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodC0gVGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgKGluIHBpeGVscylcclxuICAgICAqL1xyXG5cdGFkZFBhbmVsKGlkLHRyYWNrX2NvbmZpZyx0b3AsaGVpZ2h0LHBhbl9jb25maWcpe1xyXG5cdFx0bGV0IHJ1bGVyPWZhbHNlO1xyXG5cdFx0aWYgKGlkPT09XCJydWxlclwiKXtcclxuICAgIFx0XHR0cmFja19jb25maWc9W107XHJcbiAgICBcdFx0cnVsZXI9dHJ1ZTtcclxuICAgIFx0XHR0b3A9NTtcclxuICAgIFx0XHRoZWlnaHQ9NDA7XHJcbiAgICBcdH1cclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGlmICghcGFuX2NvbmZpZyl7XHJcblx0XHRcdHBhbl9jb25maWc9e307XHJcblx0XHR9XHJcbiAgICBcdGxldCBwYW5lbF9jb25maWc9e1xyXG5cdFx0XHRoZWlnaHQ6aGVpZ2h0LFxyXG5cdFx0XHR3aWR0aDp0aGlzLmRpdi53aWR0aCgpLFxyXG5cdFx0XHRhbGxvd191c2VyX21vdmU6XCJ2ZXJ0aWNhbFwiLFxyXG5cdFx0XHRhbGxvd191c2VyX3Jlc2l6ZTpcInZlcnRpY2FsXCIsXHJcblxyXG4gICAgXHR9XHJcbiAgICBcdGlmIChwYW5fY29uZmlnLmFsbG93X3VzZXJfY2xvc2Upe1xyXG4gICAgXHRcdHBhbmVsX2NvbmZpZy5hbGxvd191c2VyX2Nsb3NlPXRydWU7XHJcbiAgICBcdH1cclxuXHJcbiAgICBcdFxyXG4gICAgXHRcclxuICAgIFx0bGV0IHAgPSBuZXcgTUxWUGFuZWwodHJhY2tfY29uZmlnLHBhbmVsX2NvbmZpZyk7XHJcblxyXG4gICAgXHRpZiAocGFuX2NvbmZpZy5hbGxvd191c2VyX2Nsb3NlKXtcclxuICAgIFx0XHRwLmFkZExpc3RlbmVyKFwicGFuZWxfY2xvc2VkXCIsZnVuY3Rpb24oKXtcclxuICAgIFx0XHRcdGRlbGV0ZSBzZWxmLnBhbmVsc1tpZF1cclxuICAgIFx0XHR9KVxyXG4gICAgXHR9XHJcbiAgICBcdGlmIChydWxlcil7XHJcbiAgICBcdFx0cC5hZGRSdWxlclRyYWNrKCk7XHJcbiAgICBcdFx0cC5hbGxvd1VzZXJSYW5nZVNlbGVjdGlvbigpO1xyXG4gICAgXHRcdHAuYWRkTGlzdGVuZXIoXCJyYW5nZV9zZWxlY3RlZFwiLGZ1bmN0aW9uKGNocixzdGFydCxlbmQpe1xyXG4gICAgXHRcdFx0c2VsZi5nb1RvUG9zaXRpb24oY2hyLHN0YXJ0LGVuZCk7XHJcbiAgICAgICAgXHR9KTtcclxuICAgIFx0XHRcclxuICAgIFx0fVxyXG4gICAgXHRlbHNle1xyXG4gICAgXHRcdHAuYWRkTGVnZW5kKCk7XHJcbiAgICBcdH1cclxuICAgIFx0dGhpcy5wYW5lbHNbaWRdPXA7XHJcbiAgICBcdHAucGFuX2NvbmZpZz1wYW5fY29uZmlnO1xyXG4gICAgXHQvL3NldCBwYW5lbCBwb3NpdGlvbiBhbmQgYWRkIGl0IHRvIERPTVxyXG4gICAgXHRsZXQgZGl2ID0gcC5nZXREaXYoKTtcclxuICAgIFx0ZGl2LmNzcyh7dG9wOnRvcCtcInB4XCIsbGVmdDpcIjBweFwifSkud2lkdGgodGhpcy53aWR0aCk7XHJcbiAgICBcdGlmIChwYW5fY29uZmlnLm1vdmVfdG9fYmFjayl7XHJcbiAgICBcdFx0dGhpcy5kaXYucHJlcGVuZChkaXYpXHJcbiAgICBcdH1cclxuICAgIFx0ZWxzZXtcclxuICAgIFx0XHR0aGlzLmRpdi5hcHBlbmQoZGl2KTtcclxuICAgIFx0fVxyXG4gICAgXHRkaXYuZHJhZ2dhYmxlKCBcIm9wdGlvblwiLCBcImNvbnRhaW5tZW50XCIsIFwicGFyZW50XCIgKTtcclxuICAgIFx0JChcIi50cmFjay1oYW5kbGVcIikucmVtb3ZlQ2xhc3MoXCJmYS1hcnJvd3MtYWx0LXZcIikuYWRkQ2xhc3MoXCJmYS1hcnJvd3MtYWx0XCIpO1xyXG4gICAgXHRpZiAoIXJ1bGVyKXtcclxuICAgIFx0XHRkaXYuYXBwZW5kKCQoXCI8aSBjbGFzcz0nZmFzIGZhLWFycm93cy1hbHQtdic+PC9pPlwiKS5jc3Moe1wicG9zaXRpb25cIjpcImFic29sdXRlXCIsXCJib3R0b21cIjpcIi01cHhcIixcInJpZ2h0XCI6XCI3cHhcIixcImZvbnQtc2l6ZVwiOlwiMTJweFwiLFwib3BhY2l0eVwiOlwiMC44XCJ9KSk7XHJcbiAgICBcdH1cclxuICAgIFx0aWYgKHBhbl9jb25maWcudXBkYXRlKXtcclxuICAgIFx0XHRwLnVwZGF0ZSh0aGlzLmNocix0aGlzLnN0YXJ0LHRoaXMuZW5kKVxyXG4gICAgXHR9XHJcbiAgICBcdFxyXG4gICAgXHRcclxuXHR9XHJcblxyXG5cclxuXHRcclxuXHRfcG9zaXRpb25DaGFuZ2VkKGNocixzdGFydCxlbmQpe1xyXG5cdFx0dGhpcy5jaHI9Y2hyO1xyXG5cdFx0dGhpcy5zdGFydD1zdGFydDtcclxuXHRcdHRoaXMuZW5kPWVuZDtcclxuXHRcdHRoaXMuYnBfcGVyX3BpeGVsPSh0aGlzLmVuZC10aGlzLnN0YXJ0KS90aGlzLndpZHRoO1xyXG5cdFx0bGV0IGNhbGxiYWNrID0gdGhpcy5saXN0ZW5lcnNbJ3ZpZXdfY2hhbmdlZCddO1xyXG5cdFx0aWYgKGNhbGxiYWNrKXtcclxuXHRcdFx0Y2FsbGJhY2soY2hyK1wiOlwiK01hdGgucm91bmQoc3RhcnQpK1wiLVwiK01hdGgucm91bmQoZW5kKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGdldFBvc2l0aW9uKCl7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNocjp0aGlzLmNocixcclxuXHRcdFx0XHRzdGFydDpNYXRoLnJvdW5kKHRoaXMuc3RhcnQpLFxyXG5cdFx0XHRcdGVuZDpNYXRoLnJvdW5kKHRoaXMuZW5kKVxyXG5cdFx0XHR9O1xyXG5cdH1cclxuXHJcblxyXG5cdHNldFdpZHRoKCl7XHJcblx0XHR0aGlzLndpZHRoID0gdGhpcy5kaXYud2lkdGgoKTtcclxuXHRcdGZvciAobGV0IHBfaWQgaW4gdGhpcy5wYW5lbHMpe1xyXG5cdFx0XHR0aGlzLnBhbmVsc1twX2lkXS5zZXRXaWR0aCh0aGlzLndpZHRoKTtcclxuXHRcdFx0dGhpcy5wYW5lbHNbcF9pZF0udXBkYXRlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdHpvb20oYW1vdW50KXtcclxuXHRcdGxldCByYW5nZSA9IHRoaXMuZW5kLXRoaXMuc3RhcnQ7XHJcblx0XHRsZXQgbWlkZGxlID10aGlzLnN0YXJ0K3JhbmdlLzI7XHJcblx0XHRsZXQgbmV3X3JhbmdlID0ocmFuZ2UvYW1vdW50KTtcclxuXHRcdGxldCBzdCA9IE1hdGgucm91bmQobWlkZGxlLW5ld19yYW5nZS8yKTtcclxuXHRcdGxldCBlbiA9IE1hdGgucm91bmQobWlkZGxlK25ld19yYW5nZS8yKTtcclxuXHRcdHRoaXMuZ29Ub1Bvc2l0aW9uKHRoaXMuY2hyLHN0LGVuKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgKiBEaXNwbGF5cyB0aGUgc3BlY2lmaWVkIGdlbm9taWMgbG9jYXRpb25cclxuICAgICogQHBhcmFtIHtzdHJpbmcgfSBjaHIgLSBjaHJvbW9zb21lIFxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIGdlbm9taWMgbG9jYXRpb25cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCAtIFRoZSBlbmQgb2YgdGhlIGdlbm9taWMgbG9jYXRpb25cclxuICAgICovXHJcblx0Z29Ub1Bvc2l0aW9uKGNocixzdGFydCxlbmQpe1xyXG5cdFx0Zm9yIChsZXQgcF9pZCBpbiB0aGlzLnBhbmVscyl7XHJcblx0XHRcdHRoaXMucGFuZWxzW3BfaWRdLnVwZGF0ZShjaHIsc3RhcnQsZW5kKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChjaHIsc3RhcnQsZW5kKTtcclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHRhZGRMaXN0ZW5lcih0eXBlLGZ1bmMpe1xyXG5cdFx0dGhpcy5saXN0ZW5lcnNbdHlwZV09ZnVuYztcclxuXHR9XHJcblxyXG5cdGFkZFRyYWNrRnJvbUJyb3dzZXIoY29uZmlnLHVwZGF0ZSl7XHJcblx0XHRjb25maWcudXJsID0gdGhpcy5yZXBsYWNlV2l0aFByb3h5KGNvbmZpZy51cmwpO1xyXG5cdFx0bGV0IGlkID1cInBhbl9cIit0aGlzLnBhbl9pZCsrO1xyXG5cdFx0dGhpcy5hZGRQYW5lbChpZCxbY29uZmlnXSwwLDIwMCxcclxuXHRcdFx0e2FsbG93X3VzZXJfY2xvc2U6dHJ1ZSxtb3ZlX3RvX2JhY2s6dHJ1ZSx1cGRhdGU6dXBkYXRlfVxyXG5cdFx0KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQnJvd3NlckNvbnRyb2xze1xyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnRfaWQsYnJvd3Nlcixjb25maWcpe1xyXG5cdFx0dGhpcy5icm93c2VyPWJyb3dzZXI7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17fTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGltaXRfY2hyb21vc29tZT1mYWxzZTtcclxuXHRcdGlmIChjb25maWcubGltaXRfY2hyb21vc29tZSl7XHJcblx0XHRcdHRoaXMubGltaXRfY2hyb21vc29tZT1saW1pdF9jaHJvbW9zb21lO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5wYW5faWQ9MTtcclxuXHRcdHRoaXMuY29udGFpbmVyPSQoXCIjXCIrZWxlbWVudF9pZCkuY3NzKHtcInBhZGRpbmctbGVmdFwiOlwiMjBweFwifSkuYWRkQ2xhc3MoXCJicm93c2VyLW1lbnUtcGFuZWxcIik7XHJcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmQoXCI8bGFiZWw+em9vbTwvbGFiZWw+XCIpXHJcblx0XHR0aGlzLnpvb21fbGV2ZWxfaW5wdXQ9JChcIjxpbnB1dD5cIikudmFsKFwiMlwiKS53aWR0aCgxNSkuYXBwZW5kVG8odGhpcy5jb250YWluZXIpO1xyXG5cdFx0dGhpcy56b29tX2xldmVsX2lucHV0LnNwaW5uZXIoe3N0ZXA6MX0pO1xyXG5cdFx0bGV0IHNlbGY9IHRoaXM7XHJcblx0XHR0aGlzLnpvb21faW4gPSAkKFwiPGk+XCIpLmF0dHIoXCJjbGFzc1wiLFwiZmEgZmEtc2VhcmNoLXBsdXMgbWx2LWNsaWNrLWljb24gXCIpXHJcblx0XHQuYXBwZW5kVG8odGhpcy5jb250YWluZXIpXHJcblx0XHQuY2xpY2soKCk9PntcclxuXHRcdFx0dGhpcy5icm93c2VyLnpvb20odGhpcy56b29tX2xldmVsX2lucHV0LnZhbCgpKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy56b29tX291dCA9ICAkKFwiPGk+XCIpLmF0dHIoXCJjbGFzc1wiLFwiZmEgZmEtc2VhcmNoLW1pbnVzIG1sdi1jbGljay1pY29uIFwiKVxyXG5cdFx0LmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKVxyXG5cdFx0LmNsaWNrKCgpPT57XHJcblx0XHRcdHRoaXMuYnJvd3Nlci56b29tKDEvdGhpcy56b29tX2xldmVsX2lucHV0LnZhbCgpKTtcclxuXHRcdH0pO1xyXG5cdFx0bGV0IGxfbD10aGlzLmxpbWl0X2Nocm9tb3NvbWU/dGhpcy5saW1pdF9jaHJvbW9zb21lOlwiTG9jYXRpb25cIjtcclxuXHRcclxuXHJcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmQoJChcIjxsYWJlbD5cIikudGV4dChsX2wpLmNzcyh7XCJtYXJnaW4tbGVmdFwiOlwiMTBweFwifSkpXHJcblx0XHR0aGlzLmxvY2F0aW9uX2lucHV0PSQoXCI8aW5wdXQ+XCIpLmNzcyhcIndpZHRoXCIsXCIyMDBweFwiKVxyXG5cdFx0LmFwcGVuZFRvKHRoaXMuY29udGFpbmVyKVxyXG5cdFx0LmtleXByZXNzKGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRpZiAoZS5rZXlDb2RlPT09MTMpe1xyXG5cdFx0XHRcdGxldCBsb2MgPXNlbGYuY2FsY3VsYXRlUG9zaXRpb24oJCh0aGlzKS52YWwoKSk7XHJcblx0XHRcdFx0c2VsZi5icm93c2VyLmdvVG9Qb3NpdGlvbihsb2MuY2hyLGxvYy5zdGFydCxsb2MuZW5kKVxyXG5cdFx0XHR9XHRcclxuXHRcdH0pO1xyXG5cclxuXHRcdGxldCBhZGRfdHJhY2sgPSQoXCI8YnV0dG9uPlwiKS5odG1sKFwiPGkgY2xhc3MgPSAnZmEgZmEtcGx1cyc+PC9pPkFkZCBUcmFja1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLXNtIGJ0bi1zZWNvbmRhcnlcIilcclxuXHRcdFx0LmNzcyhcIm1hcmdpbi1sZWZ0XCIsXCIzcHhcIilcclxuXHRcdFx0LmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0bmV3IEFkZFRyYWNrRGlhbG9nKGZ1bmN0aW9uKGNvbmZpZyl7XHJcblx0XHRcdFx0XHRcdHNlbGYuYnJvd3Nlci5hZGRUcmFja0Zyb21Ccm93c2VyKGNvbmZpZyx0cnVlKTtcclxuXHRcdFx0XHRcdH0se2FsbG93ZWRfdHJhY2tfdHlwZXM6Y29uZmlnLmFsbG93ZWRfdHJhY2tfdHlwZXN9KVxyXG5cdFx0XHR9KVx0XHQgXHJcblx0XHRcdC5hcHBlbmRUbyh0aGlzLmNvbnRhaW5lcik7XHJcblx0XHR0aGlzLmJyb3dzZXIuYWRkTGlzdGVuZXIoXCJ2aWV3X2NoYW5nZWRcIixmdW5jdGlvbihsb2NhdGlvbixzdGFydCxlbmQpe1xyXG5cdFx0XHRpZiAoc2VsZi5saW1pdF9jaHJvbW9zb21lKXtcclxuXHRcdFx0XHRsb2NhdGlvbiA9ICBsb2NhdGlvbi5zcGxpdChcIjpcIilbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHN0YXJ0KXtcclxuXHRcdFx0XHRsb2NhdGlvbj1sb2NhdGlvbitcIjpcIitzdGFydCtcIi1cIitlbmQ7XHJcblx0XHRcdH1cdFxyXG5cdFx0XHRzZWxmLmxvY2F0aW9uX2lucHV0LnZhbChsb2NhdGlvbik7XHJcblx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRjYWxjdWxhdGVQb3NpdGlvbih0ZXh0KXtcclxuXHRcdHRleHQ9dGV4dC5yZXBsYWNlKC8sL2csXCJcIik7XHJcblx0XHJcblx0XHRsZXQgYXJyID0gdGV4dC5zcGxpdChcIjpcIik7XHJcblx0XHRsZXQgY2hyID0gbnVsbDtcclxuXHRcdGxldCBwb3MgPSBudWxsO1xyXG5cdFx0aWYgKGFyci5sZW5ndGg9PT0xKXtcclxuXHRcdFx0Y2hyID0gdGhpcy5icm93c2VyLmdldFBvc2l0aW9uKCkuY2hyO1xyXG5cdFx0XHRwb3M9YXJyWzBdXHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHRjaHIgPWFyclswXTtcclxuXHRcdFx0cG9zPWFyclsxXTtcclxuXHRcdH1cclxuXHRcdGxldCBhcnIyPSBwb3Muc3BsaXQoXCItXCIpO1xyXG5cdFx0cmV0dXJuICh7Y2hyOmNocixzdGFydDpwYXJzZUludChhcnIyWzBdKSxlbmQ6cGFyc2VJbnQoYXJyMlsxXSl9KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7U2ltcGxlQnJvd3NlcixCcm93c2VyQ29udHJvbHMsU2luZ2xlUGFuZWxCcm93c2VyfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQXlDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7OztBQS9HQTtBQUNBO0FBc0hBOzs7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUJBO0FBNkJBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OztBQWhUQTtBQUNBO0FBdVRBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/simple_browser.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/tiled_image_track.js":
/*!*********************************************!*\
  !*** .Panel/src/extra/tiled_image_track.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.TiledImageTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TiledImageTrack = function (_MLVTrack) {\n\t_inherits(TiledImageTrack, _MLVTrack);\n\n\tfunction TiledImageTrack(config) {\n\t\t_classCallCheck(this, TiledImageTrack);\n\n\t\treturn _possibleConstructorReturn(this, (TiledImageTrack.__proto__ || Object.getPrototypeOf(TiledImageTrack)).call(this, config));\n\t}\n\n\t_createClass(TiledImageTrack, [{\n\t\tkey: 'getFeatures',\n\t\tvalue: function getFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar locations = this.config.images[chr];\n\t\t\tif (!locations) {\n\t\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\t\tfulfill([]);\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar promises = [];\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar loc = _step.value;\n\n\t\t\t\t\tif (loc[0] > bpEnd) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (loc[1] < bpStart) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpromises.push(getImagePromise(loc));\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.all(promises);\n\t\t}\n\t}, {\n\t\tkey: 'drawScale',\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\n\t\t\t//ctx.drawImage(this.image,0,0,this.legend_width,pixelHeight,0,0,this.legend_width,pixelHeight)\n\t\t}\n\t}, {\n\t\tkey: 'drawFeatures',\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar bpEnd = options.bpStart + options.pixelWidth * options.bpPerPixel + 1;\n\t\t\tvar height = 0;\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar image = _step2.value;\n\n\t\t\t\t\tvar x1 = (image.start - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\tx1 = x1 < 0 ? 0 : x1;\n\t\t\t\t\tvar x_clip = 0;\n\t\t\t\t\tif (options.bpStart > image.start) {\n\t\t\t\t\t\tx_clip = (options.bpStart - image.start) / (image.end - image.start) * image.width;\n\t\t\t\t\t}\n\t\t\t\t\tvar x_clip2 = image.width;\n\t\t\t\t\tif (image.end > bpEnd) {\n\t\t\t\t\t\tx_clip2 = image.width - (image.end - bpEnd) / (image.end - image.start) * image.width;\n\t\t\t\t\t}\n\t\t\t\t\tvar x2 = options.pixelWidth;\n\t\t\t\t\tif (image.end < bpEnd) {\n\t\t\t\t\t\tx2 = options.pixelWidth - (bpEnd - image.end) / options.bpPerPixel;\n\t\t\t\t\t}\n\t\t\t\t\tvar factor = this.config.y_scale_factor ? options.bpPerPixel / this.config.y_scale_factor : 1;\n\t\t\t\t\toptions.context.drawImage(image, x_clip, 0, x_clip2 - x_clip, image.height, x1, options.top, x2 - x1, image.height / factor);\n\t\t\t\t\theight = image.height;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.bottom = options.top + height;\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn TiledImageTrack;\n}(_tracks.MLVTrack);\n\nfunction getImagePromise(loc) {\n\treturn new Promise(function (fulfill, reject) {\n\t\tvar image = new Image();\n\t\timage.start = loc[0];\n\t\timage.end = loc[1];\n\t\timage.onload = function () {\n\t\t\tfulfill(image);\n\t\t};\n\t\timage.src = loc[2];\n\t});\n}\n\n_tracks.MLVTrack.track_types['tiled_image_track'] = {\n\t\"class\": TiledImageTrack,\n\tname: \"Tiled Image Track\"\n\n};\n\nexports.TiledImageTrack = TiledImageTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3RpbGVkX2ltYWdlX3RyYWNrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9leHRyYS90aWxlZF9pbWFnZV90cmFjay5qcz84YzBjIl0sInNvdXJjZXNDb250ZW50IjpbIiAgICBcdGltcG9ydCB7TUxWVHJhY2t9IGZyb20gJy4uL3RyYWNrcy5qcydcclxuXHJcbiAgICBcdGNsYXNzIFRpbGVkSW1hZ2VUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdFx0XHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0XHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRnZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmb3JjZSxkYXRhKXtcclxuXHRcdFx0XHRsZXQgbG9jYXRpb25zID0gdGhpcy5jb25maWcuaW1hZ2VzW2Nocl07XHJcblx0XHRcdFx0aWYgKCFsb2NhdGlvbnMpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGZ1bGZpbGwscmVqZWN0KXtcclxuXHRcdFx0XHRcdFx0ZnVsZmlsbChbXSk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgcHJvbWlzZXM9IFtdO1xyXG5cdFx0XHRcdGZvciAobGV0IGxvYyBvZiBsb2NhdGlvbnMpe1xyXG5cdFx0XHRcdFx0aWYgKGxvY1swXT5icEVuZCl7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGxvY1sxXTxicFN0YXJ0KXtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRwcm9taXNlcy5wdXNoKGdldEltYWdlUHJvbWlzZShsb2MpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZHJhd1NjYWxlKHBpeGVsSGVpZ2h0LGN0eCl7XHJcbiBcclxuXHRcdFx0XHQvL2N0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwwLDAsdGhpcy5sZWdlbmRfd2lkdGgscGl4ZWxIZWlnaHQsMCwwLHRoaXMubGVnZW5kX3dpZHRoLHBpeGVsSGVpZ2h0KVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkcmF3RmVhdHVyZXMob3B0aW9ucykge1xyXG5cdFx0XHRcdGxldCBicEVuZCA9IG9wdGlvbnMuYnBTdGFydCArIG9wdGlvbnMucGl4ZWxXaWR0aCAqIG9wdGlvbnMuYnBQZXJQaXhlbCArIDE7XHJcblx0XHRcdFx0bGV0IGhlaWdodD0wO1xyXG5cdFx0XHRcdGZvciAobGV0IGltYWdlIG9mIG9wdGlvbnMuZmVhdHVyZXMpe1xyXG5cdFx0XHRcdFx0bGV0IHgxPSAoaW1hZ2Uuc3RhcnQtb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFx0XHR4MT14MTwwPzA6eDE7XHJcblx0XHRcdFx0XHRsZXQgeF9jbGlwPTA7XHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5icFN0YXJ0PmltYWdlLnN0YXJ0KXtcclxuXHRcdFx0XHRcdFx0eF9jbGlwPSgob3B0aW9ucy5icFN0YXJ0LWltYWdlLnN0YXJ0KS8oaW1hZ2UuZW5kLWltYWdlLnN0YXJ0KSkqaW1hZ2Uud2lkdGg7XHJcbiBcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IHhfY2xpcDI9aW1hZ2Uud2lkdGhcclxuXHRcdFx0XHRcdGlmIChpbWFnZS5lbmQ+YnBFbmQpe1xyXG5cdFx0XHRcdFx0XHR4X2NsaXAyID0gaW1hZ2Uud2lkdGgtKCgoaW1hZ2UuZW5kLWJwRW5kKS8oaW1hZ2UuZW5kLWltYWdlLnN0YXJ0KSkqaW1hZ2Uud2lkdGgpO1xyXG5cdFx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeDIgPSBvcHRpb25zLnBpeGVsV2lkdGg7XHJcblx0XHRcdFx0XHRpZiAoaW1hZ2UuZW5kPGJwRW5kKXtcclxuXHRcdFx0XHRcdFx0eDIgID0gb3B0aW9ucy5waXhlbFdpZHRoLSgoYnBFbmQtaW1hZ2UuZW5kKS9vcHRpb25zLmJwUGVyUGl4ZWwpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGZhY3Rvcj10aGlzLmNvbmZpZy55X3NjYWxlX2ZhY3Rvcj9vcHRpb25zLmJwUGVyUGl4ZWwvdGhpcy5jb25maWcueV9zY2FsZV9mYWN0b3I6MTtcclxuXHRcdFx0XHRcdG9wdGlvbnMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseF9jbGlwLDAseF9jbGlwMi14X2NsaXAsaW1hZ2UuaGVpZ2h0LHgxLG9wdGlvbnMudG9wLHgyLXgxLGltYWdlLmhlaWdodC9mYWN0b3IpO1xyXG5cdFx0XHRcdFx0aGVpZ2h0PWltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBvcHRpb25zLnRvcCtoZWlnaHQ7XHJcbiAgICAgICAgICAgXHRcdHJldHVybiB0aGlzLmJvdHRvbTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0XHJcblxyXG5cdFx0fVxyXG5cdFx0ZnVuY3Rpb24gZ2V0SW1hZ2VQcm9taXNlKGxvYyl7XHJcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdFx0XHRsZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHRcdFx0XHRcdGltYWdlLnN0YXJ0PWxvY1swXTtcclxuXHRcdFx0XHRcdGltYWdlLmVuZD1sb2NbMV07XHJcblx0XHRcdFx0XHRpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0XHRcdFx0XHRmdWxmaWxsKGltYWdlKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRpbWFnZS5zcmMgPWxvY1syXTsgXHJcblx0XHRcdH0pOyAgICAgICBcclxuXHRcdH1cclxuXHRcdFxyXG5cclxuXHRcdE1MVlRyYWNrLnRyYWNrX3R5cGVzWyd0aWxlZF9pbWFnZV90cmFjayddPXtcclxuXHRcdFx0XCJjbGFzc1wiOlRpbGVkSW1hZ2VUcmFjayxcclxuXHRcdFx0bmFtZTpcIlRpbGVkIEltYWdlIFRyYWNrXCJcclxuXHJcblx0XHR9XHJcblxyXG5leHBvcnQge1RpbGVkSW1hZ2VUcmFja307XHJcblxyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7Ozs7QUEzREE7QUFDQTtBQStEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/tiled_image_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/extra/ucsc_track.js":
/*!**************************************!*\
  !*** .Panel/src/extra/ucsc_track.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.UCSCMLVTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ../tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UCSCMLVTrack = function (_MLVTrack) {\n\t_inherits(UCSCMLVTrack, _MLVTrack);\n\n\tfunction UCSCMLVTrack(config) {\n\t\t_classCallCheck(this, UCSCMLVTrack);\n\n\t\tconfig.url = config.url.replace(\"hgTracks\", \"hgRenderTracks\");\n\t\tif (config.url.includes(\"/s/\")) {\n\t\t\tconfig.url = UCSCMLVTrack._convertSessionURL(config.url);\n\t\t}\n\n\t\tvar _this = _possibleConstructorReturn(this, (UCSCMLVTrack.__proto__ || Object.getPrototypeOf(UCSCMLVTrack)).call(this, config));\n\n\t\t_this.image = null;\n\t\t_this.legend_width = 74;\n\t\treturn _this;\n\t}\n\n\t_createClass(UCSCMLVTrack, [{\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tdialog.div.append($(\"<label>\").text(\"Session Url\"));\n\t\t\tvar inp = $(\"<textarea>\").val(dialog.config.url).css({ width: \"100%\", height: \"70px\" });\n\t\t\tvar but = $(\"<i class='fas fa-download'></i>\").click(function (e) {\n\t\t\t\tvar url = self._convertURL(inp.val());\n\t\t\t\tdialog.config.url = url;\n\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"url\", url);\n\t\t\t\tdialog.panel.update();\n\t\t\t});\n\t\t\tdialog.div.append(but).append(inp);\n\t\t}\n\t}, {\n\t\tkey: \"_convertURL\",\n\t\tvalue: function _convertURL(url) {\n\t\t\turl = url.replace(\"hgTracks\", \"hgRenderTracks\");\n\t\t\treturn url;\n\t\t}\n\t}, {\n\t\tkey: \"getFeatures\",\n\t\tvalue: function getFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar self = this;\n\t\t\tvar width = data.pixelWidth + this.legend_width;\n\t\t\twidth = (bpEnd - bpStart) / data.bpPerPixel + this.legend_width;\n\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\tself.image = new Image();\n\t\t\t\tself.image.onload = function () {\n\t\t\t\t\tself.config.height = self.image.height;\n\t\t\t\t\tfulfill([]);\n\t\t\t\t};\n\t\t\t\tvar url = self.config.url;\n\t\t\t\tvar args = \"&position=\" + chr + \":\" + bpStart + \"-\" + bpEnd + \"&pix=\" + width + \"&hgt.labelWidth=10\";\n\t\t\t\tself.image.src = url + args;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\t\t\tctx.globalAlpha = this.config.opacity;\n\t\t\tctx.drawImage(this.image, -this.legend_width, options.top);\n\t\t\tctx.globalAlpha = 1.0;\n\t\t\tthis.bottom = options.top + this.image.height;\n\t\t\treturn this.bottom;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\t\t\tctx.globalAlpha = 0.7;\n\t\t\tctx.drawImage(this.image, 0, 0, this.legend_width, pixelHeight, 0, this.top, this.legend_width, pixelHeight);\n\t\t\tctx.globalAlpha = 1.0;\n\t\t}\n\t}], [{\n\t\tkey: \"_convertSessionURL\",\n\t\tvalue: function _convertSessionURL(url) {\n\t\t\tvar arr = url.split(\"/\");\n\t\t\tvar new_url = arr[0] + \"//\" + arr[2] + \"/cgi-bin/hgRenderTracks?hgS_doOtherUser=submit&hgS_otherUserName=\" + arr[4] + \"&hgS_otherUserSessionName=\" + arr[5];\n\t\t\treturn new_url;\n\t\t}\n\t}]);\n\n\treturn UCSCMLVTrack;\n}(_tracks.MLVTrack);\n\n_tracks.MLVTrack.track_types['ucsc_track'] = {\n\t\"class\": UCSCMLVTrack,\n\tname: \"UCSC Session\"\n};\n\nexports.UCSCMLVTrack = UCSCMLVTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanM/MzVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIgICAgXHRpbXBvcnQge01MVlRyYWNrfSBmcm9tICcuLi90cmFja3MuanMnXHJcblxyXG4gICAgXHRjbGFzcyBVQ1NDTUxWVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRcdFx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdFx0XHRjb25maWcudXJsPSBjb25maWcudXJsLnJlcGxhY2UoXCJoZ1RyYWNrc1wiLFwiaGdSZW5kZXJUcmFja3NcIik7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy51cmwuaW5jbHVkZXMoXCIvcy9cIikpe1xyXG5cdFx0XHRcdFx0Y29uZmlnLnVybD1VQ1NDTUxWVHJhY2suX2NvbnZlcnRTZXNzaW9uVVJMKGNvbmZpZy51cmwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0XHRcdHRoaXMuaW1hZ2U9bnVsbDtcclxuXHRcdFx0XHR0aGlzLmxlZ2VuZF93aWR0aD03NDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGljIF9jb252ZXJ0U2Vzc2lvblVSTCh1cmwpe1xyXG5cdFx0XHRcdGxldCBhcnI9dXJsLnNwbGl0KFwiL1wiKTtcclxuXHRcdFx0XHRsZXQgbmV3X3VybCA9IGFyclswXStcIi8vXCIrYXJyWzJdK1wiL2NnaS1iaW4vaGdSZW5kZXJUcmFja3M/aGdTX2RvT3RoZXJVc2VyPXN1Ym1pdCZoZ1Nfb3RoZXJVc2VyTmFtZT1cIithcnJbNF1cclxuXHRcdFx0XHRcdCtcIiZoZ1Nfb3RoZXJVc2VyU2Vzc2lvbk5hbWU9XCIrYXJyWzVdO1xyXG5cdFx0XHRcdHJldHVybiBuZXdfdXJsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWRkRXh0cmFDb250cm9scyhkaWFsb2cpe1xyXG5cdFx0XHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdFx0XHRkaWFsb2cuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcblx0XHRcdFx0ZGlhbG9nLmRpdi5hcHBlbmQoJChcIjxsYWJlbD5cIikudGV4dChcIlNlc3Npb24gVXJsXCIpKTtcclxuXHRcdFx0XHRsZXQgaW5wPSQoXCI8dGV4dGFyZWE+XCIpLnZhbChkaWFsb2cuY29uZmlnLnVybCkuY3NzKHt3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCI3MHB4XCJ9KTtcclxuXHRcdFx0XHRsZXQgYnV0ID0gJChcIjxpIGNsYXNzPSdmYXMgZmEtZG93bmxvYWQnPjwvaT5cIikuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRsZXQgdXJsID0gc2VsZi5fY29udmVydFVSTChpbnAudmFsKCkpO1xyXG5cdFx0XHRcdFx0ZGlhbG9nLmNvbmZpZy51cmw9dXJsO1xyXG5cdFx0XHRcdFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwidXJsXCIsdXJsKTtcclxuXHRcdFx0XHRcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRkaWFsb2cuZGl2LmFwcGVuZChidXQpLmFwcGVuZChpbnApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY29udmVydFVSTCh1cmwpe1xyXG5cdFx0XHRcdHVybD11cmwucmVwbGFjZShcImhnVHJhY2tzXCIsXCJoZ1JlbmRlclRyYWNrc1wiKTtcclxuXHRcdFx0XHRyZXR1cm4gdXJsXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpe1xyXG5cdFx0XHRcdGxldCBzZWxmPXRoaXM7XHJcblx0XHRcdFx0bGV0IHdpZHRoID0gZGF0YS5waXhlbFdpZHRoK3RoaXMubGVnZW5kX3dpZHRoO1xyXG5cdFx0XHRcdHdpZHRoID0gKChicEVuZC1icFN0YXJ0KS9kYXRhLmJwUGVyUGl4ZWwpK3RoaXMubGVnZW5kX3dpZHRoO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdFx0XHRzZWxmLmltYWdlID0gbmV3IEltYWdlKCk7XHJcblx0XHRcdFx0XHRzZWxmLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5jb25maWcuaGVpZ2h0ID0gc2VsZi5pbWFnZS5oZWlnaHQ7XHJcbiAgICBcdFx0XHRcdFx0ZnVsZmlsbChbXSk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0bGV0IHVybCA9IHNlbGYuY29uZmlnLnVybDtcclxuXHRcdFx0XHRcdGxldCBhcmdzID1cIiZwb3NpdGlvbj1cIitjaHIrXCI6XCIrYnBTdGFydCtcIi1cIiticEVuZCtcIiZwaXg9XCIrKHdpZHRoKStcIiZoZ3QubGFiZWxXaWR0aD0xMFwiO1xyXG5cdFx0XHRcdFx0c2VsZi5pbWFnZS5zcmMgPXVybCthcmdzOyAgICAgICAgXHJcbiAgICAgICAgXHRcdH0pO1x0XHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuICAgICAgICAgIFx0XHRsZXQgY3R4ID0gb3B0aW9ucy5jb250ZXh0O1xyXG4gICAgICAgICAgXHRcdHRoaXMudG9wPW9wdGlvbnMudG9wO1xyXG4gICAgICAgICAgXHRcdGN0eC5nbG9iYWxBbHBoYT10aGlzLmNvbmZpZy5vcGFjaXR5O1xyXG4gICAgICAgICAgIFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuaW1hZ2UsLXRoaXMubGVnZW5kX3dpZHRoLG9wdGlvbnMudG9wKTtcclxuICAgICAgICAgICBcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuICAgICAgICAgICBcdFx0dGhpcy5ib3R0b20gPSBvcHRpb25zLnRvcCt0aGlzLmltYWdlLmhlaWdodDtcclxuICAgICAgICAgICBcdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkcmF3U2NhbGUocGl4ZWxIZWlnaHQsY3R4KXtcclxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC43O1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwwLDAsdGhpcy5sZWdlbmRfd2lkdGgscGl4ZWxIZWlnaHQsMCx0aGlzLnRvcCx0aGlzLmxlZ2VuZF93aWR0aCxwaXhlbEhlaWdodCk7XHJcblx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRNTFZUcmFjay50cmFja190eXBlc1sndWNzY190cmFjayddPXtcclxuXHRcdFx0XCJjbGFzc1wiOlVDU0NNTFZUcmFjayxcclxuXHRcdFx0bmFtZTpcIlVDU0MgU2Vzc2lvblwiXHJcblx0XHR9XHJcblxyXG5leHBvcnQge1VDU0NNTFZUcmFja307XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQXpEQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7O0FBakJBO0FBQ0E7QUF1RUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/extra/ucsc_track.js\n");

/***/ }),

/***/ "../MLVPanel/src/feature.js":
/*!*****************************!*\
  !*** .Panel/src/feature.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TabixBedFeatureSource = exports.BigBedFeatureSource = exports.FastaSequence = exports.FeatureSource = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nvar _igvxhr = __webpack_require__(/*! ./igvxhr.js */ \"../MLVPanel/src/igvxhr.js\");\n\nvar _bam = __webpack_require__(/*! ./bam.js */ \"../MLVPanel/src/bam.js\");\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * feature source for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureSource = function () {\n    function FeatureSource(config) {\n        _classCallCheck(this, FeatureSource);\n\n        this.config = config || {};\n    }\n\n    _createClass(FeatureSource, [{\n        key: \"getFileHeader\",\n        value: function getFileHeader() {\n            this.is_indexed = true;\n            return new Promise(function (fulfill, reject) {\n                fulfill();\n            });\n        }\n    }, {\n        key: \"getFeatures\",\n        value: function getFeatures(chr, start, end, force, data) {\n\n            //no need to get header\n            if (this.is_indexed) {\n                return this._getFeatures(chr, start, end, force, data);\n            }\n            //get headers/index then get features\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                self.getFileHeader().then(function () {\n                    self._getFeatures(chr, start, end, force, data).then(function (features) {\n                        fulfill(features);\n                    }).catch(reject);\n                }).catch(reject);\n            });\n        }\n\n        /**\r\n         * Required function fo all data source objects.  Fetches features for the\r\n         * range requested and passes them on to the success function.  Usually this is\r\n         * a function that renders the features on the canvas\r\n         *\r\n         * @param chr\r\n         * @param bpStart\r\n         * @param bpEnd\r\n         */\n\n    }, {\n        key: \"_getFeatures\",\n        value: function _getFeatures(chr, bpStart, bpEnd, force, data) {\n            if (bpStart === 0) {\n                bpStart = 1;\n            }\n            var self = this;\n            self.time = Date.now();\n            return new Promise(function (fulfill, reject) {\n                if (self.featureCache && chr !== self.featureCache.range.chr) {\n                    self.featureCache = null;\n                }\n                var genomicInterval = new GenomicInterval(chr, bpStart, bpEnd),\n                    featureCache = self.featureCache,\n                    maxRows = self.config.maxRows || 500;\n                var ranges_to_get = false;\n                if (!featureCache) {\n                    ranges_to_get = { all: [bpStart, bpEnd] };\n                } else {\n                    if (featureCache.range !== undefined) {\n                        ranges_to_get = featureCache.range.rangesToGet(genomicInterval);\n                    }\n                }\n                if (!ranges_to_get) {\n                    fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                } else {\n                    var promises = [];\n                    var p_types = [];\n                    for (var type in ranges_to_get) {\n                        var range = ranges_to_get[type];\n                        promises.push(self.retrieveFeatures(chr, range[0], range[1], force, data));\n                        p_types.push([type, ranges_to_get[type]]);\n                    }\n                    Promise.all(promises).then(function (all_features) {\n                        var existing_features = [];\n                        if (self.featureCache) {\n                            existing_features = self.featureCache.allFeatures(); //featureCache.allFeatures(chr,self.featureCache.range.start,self.featureCache.range.end);\n                        }\n                        var index = 0;\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = all_features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var featureList = _step.value;\n\n                                if (featureList === null) {\n                                    featureList = [];\n                                }\n                                if (p_types[index][0] === \"left\") {\n                                    var end = p_types[index][1][1];\n                                    //remove any already retieved  \n                                    var splice = 0;\n                                    for (var n = featureList.length - 1; n >= 0; n--) {\n                                        if (featureList[n].end < end) {\n                                            break;\n                                        }\n                                        splice++;\n                                    }\n                                    if (splice !== 0) {\n                                        featureList.splice(-splice);\n                                    }\n                                }\n                                if (p_types[index][0] === \"right\") {\n                                    var start = p_types[index][1][0];\n                                    //remove any already retieved\n                                    var i = 0;\n                                    for (i = 0; i < featureList.length; i++) {\n                                        if (featureList[i].start > start) {\n                                            break;\n                                        }\n                                    }\n                                    if (i !== 0) {\n                                        featureList.splice(0, i);\n                                    }\n                                }\n                                index++;\n                                existing_features = existing_features.concat(featureList);\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        var gi = self.featureCache ? self.featureCache.range : genomicInterval;\n                        self.featureCache = new FeatureCache(existing_features, gi);\n                        FeatureSource.packFeatures(existing_features, maxRows);\n                        fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\n                    }).catch(function (error) {\n                        reject(error);\n                    });\n                }\n            });\n        }\n    }], [{\n        key: \"packFeatures\",\n        value: function packFeatures(features, maxRows) {\n\n            if (features == null || features.length === 0) {\n                return;\n            }\n\n            // Segregate by chromosome\n\n            var chrFeatureMap = {},\n                chrs = [];\n            features.forEach(function (feature) {\n\n                var chr = feature.chr,\n                    flist = chrFeatureMap[chr];\n\n                if (!flist) {\n                    flist = [];\n                    chrFeatureMap[chr] = flist;\n                    chrs.push(chr);\n                }\n\n                flist.push(feature);\n            });\n\n            // Loop through chrosomosomes and pack features;\n\n            chrs.forEach(function (chr) {\n\n                pack(chrFeatureMap[chr], maxRows);\n            });\n\n            // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no\n            // row number is assigned.\n            function pack(featureList, maxRows) {\n\n                var rows = [];\n\n                featureList.sort(function (a, b) {\n                    return a.start - b.start;\n                });\n\n                rows.push(-1000);\n                featureList.forEach(function (feature) {\n\n                    var i,\n                        r,\n                        len = Math.min(rows.length, maxRows),\n                        start = feature.start;\n\n                    for (r = 0; r < len; r++) {\n                        if (start >= rows[r]) {\n                            feature.row = r;\n                            rows[r] = feature.end;\n                            return;\n                        }\n                    }\n                    feature.row = r;\n                    rows[r] = feature.end;\n                });\n            }\n        }\n    }]);\n\n    return FeatureSource;\n}();\n\nvar TabixBedFeatureSource = function (_FeatureSource) {\n    _inherits(TabixBedFeatureSource, _FeatureSource);\n\n    function TabixBedFeatureSource(config, decode_function) {\n        _classCallCheck(this, TabixBedFeatureSource);\n\n        var _this = _possibleConstructorReturn(this, (TabixBedFeatureSource.__proto__ || Object.getPrototypeOf(TabixBedFeatureSource)).call(this, config));\n\n        _this.reader = new FeatureFileReader(config, decode_function);\n        return _this;\n    }\n\n    _createClass(TabixBedFeatureSource, [{\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, start, end) {\n            return this.reader.readFeatures(chr, start, end);\n        }\n    }, {\n        key: \"getFileHeader\",\n        value: function getFileHeader() {\n            var self = this;\n            return new Promise(function (fulfill, reject) {\n                self.reader.readHeader().then(function () {\n                    self.is_indexed = true;\n                    fulfill();\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return TabixBedFeatureSource;\n}(FeatureSource);\n\nvar BigBedFeatureSource = function (_FeatureSource2) {\n    _inherits(BigBedFeatureSource, _FeatureSource2);\n\n    function BigBedFeatureSource(config, decode_function) {\n        _classCallCheck(this, BigBedFeatureSource);\n\n        config.sourceType = \"gtex\";\n\n        var _this2 = _possibleConstructorReturn(this, (BigBedFeatureSource.__proto__ || Object.getPrototypeOf(BigBedFeatureSource)).call(this, config));\n\n        _this2.header = true;\n        _this2.feature_source = new _bigwig.BWSource(config, decode_function);\n        return _this2;\n    }\n\n    _createClass(BigBedFeatureSource, [{\n        key: \"retrieveFeatures\",\n        value: function retrieveFeatures(chr, bpStart, bpEnd, force, data) {\n            return this.feature_source.getFeatures(chr, bpStart, bpEnd, false, data);\n        }\n    }]);\n\n    return BigBedFeatureSource;\n}(FeatureSource);\n\n//********js/FeatureFileReader.js*****\n\n\nvar F_MAX_GZIP_BLOCK_SIZE = 1 << 16;\n\n/**\r\n * Reader for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n *\r\n * @param config\r\n * @constructor\r\n */\n\nvar FeatureFileReader = function () {\n    function FeatureFileReader(config, dec_function) {\n        _classCallCheck(this, FeatureFileReader);\n\n        this.config = config || {};\n\n        if (config.localFile) {\n            this.localFile = config.localFile;\n            this.filename = config.localFile.name;\n        } else {\n            this.url = config.url;\n            this.indexURL = config.indexURL;\n            this.headURL = config.headURL || this.filename;\n\n            var uriParts = _utils.Utils.parseUri(config.url);\n            this.filename = uriParts.file;\n            this.path = uriParts.path;\n        }\n\n        this.format = config.format;\n\n        this.parser = this.getParser(this.format, dec_function);\n    }\n\n    _createClass(FeatureFileReader, [{\n        key: \"getParser\",\n        value: function getParser(format, decode) {\n            switch (format) {\n                case \"vcf\":\n                    return new VcfParser();\n                case \"seg\":\n                    return new SegParser();\n                default:\n                    return new FeatureParser(format, decode, this.config);\n            }\n        }\n\n        // seg files don't have an index\n\n    }, {\n        key: \"isIndexable\",\n        value: function isIndexable() {\n            var configIndexURL = this.config.indexURL,\n                type = this.type,\n                configIndexed = this.config.indexed;\n\n            return configIndexURL || type != \"wig\" && configIndexed != false;\n        }\n\n        /**\r\n         * Return a Promise for the async loaded index\r\n         */\n\n    }, {\n        key: \"loadIndex\",\n        value: function loadIndex() {\n            var idxFile = this.indexURL;\n            if (this.filename.endsWith(\".gz\")) {\n                if (!idxFile) idxFile = this.url + \".tbi\";\n                return (0, _bam.loadBamIndex)(idxFile, this.config, true);\n            } else {\n                if (!idxFile) idxFile = this.url + \".idx\";\n                return loadTribbleIndex(idxFile, this.config);\n            }\n        }\n    }, {\n        key: \"loadFeaturesNoIndex\",\n        value: function loadFeaturesNoIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var parser = self.parser,\n                    options = {\n                    headers: self.config.headers, // http headers, not file header\n                    withCredentials: self.config.withCredentials\n                };\n\n                if (self.localFile) {\n                    _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(parseData).catch(reject);\n                } else {\n                    _igvxhr.igvxhr.loadString(self.url, options).then(parseData).catch(reject);\n                }\n\n                function parseData(data) {\n                    self.header = parser.parseHeader(data);\n                    if (self.header instanceof String && self.header.startsWith(\"##gff-version 3\")) {\n                        self.format = 'gff3';\n                    }\n                    fulfill(parser.parseFeatures(data)); // <= PARSING DONE HERE\n                };\n            });\n        }\n    }, {\n        key: \"loadFeaturesWithIndex\",\n        value: function loadFeaturesWithIndex(chr, start, end) {\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                var blocks,\n                    index = self.index,\n                    tabix = index && index.tabix,\n                    refId = tabix ? index.sequenceIndexMap[chr] : chr,\n                    promises = [];\n\n                blocks = index.blocksForRange(refId, start, end);\n\n                if (!blocks || blocks.length === 0) {\n                    fulfill(null); // TODO -- is this correct?  Should it return an empty array?\n                } else {\n\n                    blocks.forEach(function (block) {\n\n                        promises.push(new Promise(function (fulfill, reject) {\n\n                            var startPos = block.minv.block,\n                                startOffset = block.minv.offset,\n                                endPos = block.maxv.block + (index.tabix ? F_MAX_GZIP_BLOCK_SIZE : 0),\n                                options = {\n                                headers: self.config.headers, // http headers, not file header\n                                range: { start: startPos, size: endPos - startPos + 1 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success;\n\n                            success = function success(data) {\n\n                                var inflated, slicedData;\n\n                                if (index.tabix) {\n\n                                    inflated = _igvxhr.igvxhr.arrayBufferToString((0, _igvxhr.unbgzf)(data));\n                                    // need to decompress data\n                                } else {\n                                    inflated = data;\n                                }\n\n                                slicedData = startOffset ? inflated.slice(startOffset) : inflated;\n                                var f = self.parser.parseFeatures(slicedData, chr, start, end);\n                                fulfill(f);\n                            };\n\n                            // Async load\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success).catch(reject);\n                            } else {\n                                if (index.tabix) {\n                                    _igvxhr.igvxhr.loadArrayBuffer(self.url, options).then(success).catch(reject);\n                                } else {\n                                    _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                                }\n                            }\n                        }));\n                    });\n\n                    Promise.all(promises).then(function (featureArrays) {\n\n                        var i, allFeatures;\n\n                        if (featureArrays.length === 1) {\n                            allFeatures = featureArrays[0];\n                        } else {\n                            allFeatures = featureArrays[0];\n\n                            for (i = 1; i < featureArrays.length; i++) {\n                                allFeatures = allFeatures.concat(featureArrays[i]);\n                            }\n\n                            allFeatures.sort(function (a, b) {\n                                return a.start - b.start;\n                            });\n                        }\n\n                        fulfill(allFeatures);\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this,\n                isIndeedIndexible = this.isIndexable();\n            return new Promise(function (fulfill, reject) {\n\n                if (self.indexed === undefined && isIndeedIndexible) {\n                    self.loadIndex().then(function (index) {\n                        if (index) {\n                            self.index = index;\n                            self.indexed = true;\n                        } else {\n                            self.indexed = false;\n                        }\n                        fulfill(self.index);\n                    }).catch(reject);\n                } else {\n                    fulfill(self.index); // Is either already loaded, or there isn't one\n                }\n            });\n        }\n    }, {\n        key: \"readHeader\",\n        value: function readHeader() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.header) {\n                    fulfill(self.header);\n                } else {\n\n                    // We force a load of the index first\n\n                    self.getIndex().then(function (index) {\n\n                        if (index) {\n                            // Load the file header (not HTTP header) for an indexed file.\n                            // TODO -- note this will fail if the file header is > 65kb in size\n                            var options = {\n                                headers: self.config.headers, // http headers, not file header\n                                bgz: index.tabix,\n                                range: { start: 0, size: 65000 },\n                                withCredentials: self.config.withCredentials\n                            },\n                                success = function success(data) {\n                                self.header = self.parser.parseHeader(data);\n                                fulfill(self.header);\n                            };\n\n                            if (self.localFile) {\n                                _igvxhr.igvxhr.loadStringFromFile(self.localFile, options).then(success);\n                            } else {\n                                _igvxhr.igvxhr.loadString(self.url, options).then(success).catch(reject);\n                            }\n                        } else {\n                            self.loadFeaturesNoIndex(undefined).then(function (features) {\n                                var header = self.header || {};\n                                header.features = features;\n                                fulfill(header);\n                            }).catch(error);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n\n        /**\r\n         *\r\n         * @param fulfill\r\n         * @param range -- genomic range to load.  For use with indexed source (optional)\r\n         */\n\n    }, {\n        key: \"readFeatures\",\n        value: function readFeatures(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    self.loadFeaturesWithIndex(chr, start, end).then(packFeatures).catch(reject);\n                } else {\n                    self.loadFeaturesNoIndex().then(packFeatures);\n                }\n\n                function packFeatures(features) {\n                    // TODO pack\n                    fulfill(features);\n                }\n            });\n        }\n    }]);\n\n    return FeatureFileReader;\n}();\n\n//***js/feature/FeatureParsers.js**************\n\n\nvar maxFeatureCount = Number.MAX_VALUE; // For future use,  controls downsampling\n\nvar gffNameFields = [\"Name\", \"gene_name\", \"gene\", \"gene_id\", \"alias\", \"locus\"];\n\n/**\r\n * A factory function.  Return a parser for the given file format.\r\n */\n\nvar FeatureParser = function () {\n    function FeatureParser(format, decode_func, config) {\n        _classCallCheck(this, FeatureParser);\n\n        var customFormat;\n\n        this.format = format;\n        this.nameField = config ? config.nameField : undefined;\n        this.skipRows = 0; // The number of fixed header rows to skip.  Override for specific types as neede\n\n        if (decode_func) {\n            this.delimiter = /\\s+/;\n\n            this.decode = function (tokens, ignore) {\n                var feature = { chr: tokens[0], start: parseInt(tokens[1]), end: parseInt(tokens[2]) };\n                decode_func(tokens.slice(3), feature);\n                return feature;\n            };\n        } else if (config.decode_function === \"generic\") {\n            this.decode = function (tokens, ignore) {\n                var feature = { chr: tokens[0], start: parseInt(tokens[1]), end: parseInt(tokens[2]) };\n                feature.data = tokens.slice(3);\n                return feature;\n            };\n        } else {\n            this.decode = FeatureParser.decodeBed;\n            this.delimiter = /\\s+/;\n        }\n\n        /* switch (format) {\r\n             case \"narrowpeak\":\r\n             case \"broadpeak\":\r\n             case \"peaks\":\r\n                 this.decode = this.decodePeak;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"bedgraph\":\r\n                 this.decode = this.decodeBedGraph;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"wig\":\r\n                 this.decode = this.decodeWig;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"gff3\" :\r\n             case \"gff\" :\r\n             case \"gtf\" :\r\n                 this.decode = this.decodeGFF;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"aneu\":\r\n                 this.decode = this.decodeAneu;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"fusionjuncspan\":\r\n                 // bhaas, needed for FusionInspector view\r\n                 this.decode = this.decodeFusionJuncSpan;\r\n                 this.delimiter = /\\s+/;\r\n                 break;\r\n             case \"gtexgwas\":\r\n                 this.skipRows = 1;\r\n                 this.decode = this.decodeGtexGWAS;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             case \"refflat\":\r\n                 this.decode = this.decodeRefflat;\r\n                 this.delimiter = \"\\t\";\r\n                 break;\r\n             default:\r\n                  customFormat = igv.browser.getFormat(format);\r\n                 if (customFormat !== undefined) {\r\n                     this.decode = decodeCustom;\r\n                     this.format = customFormat;\r\n                     this.delimiter = customFormat.delimiter || \"\\t\";\r\n                 }\r\n                   else {\r\n                 \r\n                // }\r\n           }*/\n    }\n\n    _createClass(FeatureParser, [{\n        key: \"parseHeader\",\n        value: function parseHeader(data) {\n\n            var lines = data.split(\"\\n\"),\n                len = lines.length,\n                line,\n                i,\n                header;\n\n            for (i = 0; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    if (line.startsWith(\"track\")) {\n                        header = this.parseTrackLine(line);\n                    } else if (line.startsWith(\"##gff-version 3\")) {\n                        this.format = \"gff3\";\n                        if (!header) header = {};\n                        header[\"format\"] = \"gff3\";\n                    }\n                } else {\n                    header = {};\n                    break;\n                }\n            }\n            return header;\n        }\n    }, {\n        key: \"parseFeatures\",\n        value: function parseFeatures(data, chr, start, end) {\n\n            if (!data) return null;\n\n            var wig,\n                feature,\n                lines = data.split(\"\\n\"),\n                len = lines.length,\n                tokens,\n                allFeatures = [],\n                line,\n                i,\n                cnt = 0,\n                j,\n                decode = this.decode,\n                format = this.format,\n                delimiter = this.delimiter || \"\\t\";\n\n            for (i = this.skipRows; i < len; i++) {\n                line = lines[i];\n                if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"fixedStep\")) {\n                    wig = this.parseFixedStep(line);\n                    continue;\n                } else if (format === \"wig\" && line.startsWith(\"variableStep\")) {\n                    wig = this.parseVariableStep(line);\n                    continue;\n                }\n\n                tokens = lines[i].split(delimiter);\n                if (tokens.length < 1 || format !== \"wig\" && tokens.length < 3) continue;\n\n                feature = this.decode(tokens, wig);\n\n                if (feature) {\n                    if (feature.chr !== chr || feature.end < start || feature.start > end) {\n                        continue;\n                    }\n                    if (allFeatures.length < maxFeatureCount) {\n                        allFeatures.push(feature);\n                    } else {\n                        // Reservoir sampling,  conditionally replace existing feature with new one.\n                        j = Math.floor(Math.random() * cnt);\n                        if (j < maxFeatureCount) {\n                            allFeatures[j] = feature;\n                        }\n                    }\n                    cnt++;\n                } else {\n                    console.log(null);\n                }\n            }\n\n            return allFeatures;\n        }\n    }, {\n        key: \"decodeCustom\",\n\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n        value: function decodeCustom(tokens, ignore) {\n\n            var feature,\n                chr,\n                start,\n                end,\n                format = this.format,\n                // \"this\" refers to FeatureParser instance\n            coords = format.coords || 0;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[format.chr];\n            start = parseInt(tokens[format.start]) - coords;\n            end = format.end !== undefined ? parseInt(tokens[format.end]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (format.fields) {\n                format.fields.forEach(function (field, index) {\n                    if (index != format.chr && index != format.start && index != format.end) {\n                        feature[field] = tokens[index];\n                    }\n                });\n            }\n\n            return feature;\n        }\n    }], [{\n        key: \"parseFixedStep\",\n        value: function parseFixedStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                ss = parseInt(tokens[2].split(\"=\")[1], 10),\n                step = parseInt(tokens[3].split(\"=\")[1], 10),\n                span = tokens.length > 4 ? parseInt(tokens[4].split(\"=\")[1], 10) : 1;\n\n            return { format: \"fixedStep\", chrom: cc, start: ss, step: step, span: span, index: 0 };\n        }\n    }, {\n        key: \"parseVariableStep\",\n        value: function parseVariableStep(line) {\n\n            var tokens = line.split(/\\s+/),\n                cc = tokens[1].split(\"=\")[1],\n                span = tokens.length > 2 ? parseInt(tokens[2].split(\"=\")[1], 10) : 1;\n            return { format: \"variableStep\", chrom: cc, span: span };\n        }\n    }, {\n        key: \"parseTrackLine\",\n        value: function parseTrackLine(line) {\n            var properties = {},\n                tokens = line.split(/(?:\")([^\"]+)(?:\")|([^\\s\"]+)(?=\\s+|$)/g),\n                tmp = [],\n                i,\n                tk,\n                curr;\n\n            // Clean up tokens array\n            for (i = 1; i < tokens.length; i++) {\n                if (!tokens[i] || tokens[i].trim().length === 0) continue;\n\n                tk = tokens[i].trim();\n\n                if (tk.endsWith(\"=\") > 0) {\n                    curr = tk;\n                } else if (curr) {\n                    tmp.push(curr + tk);\n                    curr = undefined;\n                } else {\n                    tmp.push(tk);\n                }\n            }\n\n            tmp.forEach(function (str) {\n                if (!str) return;\n                var kv = str.split('=', 2);\n                if (kv.length == 2) {\n                    properties[kv[0]] = kv[1];\n                }\n            });\n\n            return properties;\n        }\n\n        /**\r\n         * Decode the \"standard\" UCSC bed format\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns decoded feature, or null if this is not a valid record\r\n         */\n\n    }, {\n        key: \"decodeBed\",\n        value: function decodeBed(tokens, ignore) {\n\n            var chr, start, end, id, name, tmp, idName, exonCount, exonSizes, exonStarts, exons, exon, feature, eStart, eEnd;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end, score: 1000 };\n\n            if (tokens.length > 3) {\n                // Note: these are very special rules for the gencode gene files.\n                tmp = tokens[3].replace(/\"/g, '');\n                idName = tmp.split(';');\n                for (var i = 0; i < idName.length; i++) {\n                    var kv = idName[i].split('=');\n                    if (kv[0] == \"gene_id\") {\n                        id = kv[1];\n                    }\n                    if (kv[0] == \"gene_name\") {\n                        name = kv[1];\n                    }\n                }\n                feature.id = id ? id : tmp;\n                feature.name = name ? name : tmp;\n            }\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n            }\n            if (tokens.length > 5) {\n                feature.strand = tokens[5];\n            }\n            if (tokens.length > 6) {\n                feature.cdStart = parseInt(tokens[6]);\n            }\n            if (tokens.length > 7) {\n                feature.cdEnd = parseInt(tokens[7]);\n            }\n            if (tokens.length > 8) {\n                if (tokens[8] !== \".\" && tokens[8] !== \"0\") feature.color = igv.createColorString(tokens[8]);\n            }\n            if (tokens.length > 11) {\n                exonCount = parseInt(tokens[9]);\n                exonSizes = tokens[10].split(',');\n                exonStarts = tokens[11].split(',');\n                exons = [];\n\n                for (var i = 0; i < exonCount; i++) {\n                    eStart = start + parseInt(exonStarts[i]);\n                    eEnd = eStart + parseInt(exonSizes[i]);\n                    var exon = { start: eStart, end: eEnd };\n\n                    if (feature.cdStart > eEnd || feature.cdEnd < feature.cdStart) exon.utr = true; // Entire exon is UTR\n                    if (feature.cdStart >= eStart && feature.cdStart <= eEnd) exon.cdStart = feature.cdStart;\n                    if (feature.cdEnd >= eStart && feature.cdEnd <= eEnd) exon.cdEnd = feature.cdEnd;\n\n                    exons.push(exon);\n                }\n\n                feature.exons = exons;\n            }\n\n            feature.popupData = function () {\n                var data = [];\n                if (feature.name) data.push({ name: \"Name\", value: feature.name });\n                if (\"+\" === feature.strand || \"-\" === feature.strand) data.push({ name: \"Strand\", value: feature.strand });\n                return data;\n            };\n\n            return feature;\n        }\n\n        /**\r\n         * Decode a UCSC \"refflat\" record\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeRefflat\",\n        value: function decodeRefflat(tokens, ignore) {\n\n            if (tokens.length < 10) return null;\n\n            var feature = {\n                chr: tokens[2],\n                start: parseInt(tokens[4]),\n                end: parseInt(tokens[5]),\n                id: tokens[1],\n                name: tokens[0],\n                strand: tokens[3],\n                cdStart: parseInt(tokens[6]),\n                cdEnd: parseInt(tokens[7])\n            },\n                exonCount = parseInt(tokens[8]),\n                exonStarts = tokens[9].split(','),\n                exonEnds = tokens[10].split(','),\n                exons = [];\n\n            for (var i = 0; i < exonCount; i++) {\n                exons.push({ start: parseInt(exonStarts[i]), end: parseInt(exonEnds[i]) });\n            }\n\n            feature.exons = exons;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodePeak\",\n        value: function decodePeak(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n            name = tokens[3];\n            score = parseFloat(tokens[4]);\n            strand = tokens[5].trim();\n            signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[7]);\n            qValue = parseFloat(tokens[8]);\n\n            if (score === 0) score = signal;\n\n            return {\n                chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n                pValue: pValue, qValue: qValue\n            };\n        }\n    }, {\n        key: \"decodeBedGraph\",\n        value: function decodeBedGraph(tokens, ignore) {\n\n            var chr, start, end, value;\n\n            if (tokens.length < 3) return null;\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]);\n            end = parseInt(tokens[2]);\n\n            value = parseFloat(tokens[3]);\n\n            return { chr: chr, start: start, end: end, value: value };\n        }\n    }, {\n        key: \"decodeWig\",\n        value: function decodeWig(tokens, wig) {\n\n            var ss, ee, value;\n\n            if (wig.format === \"fixedStep\") {\n\n                ss = wig.index * wig.step + wig.start;\n                ee = ss + wig.span;\n                value = parseFloat(tokens[0]);\n                ++wig.index;\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else if (wig.format === \"variableStep\") {\n\n                if (tokens.length < 2) return null;\n\n                ss = parseInt(tokens[0], 10);\n                ee = ss + wig.span;\n                value = parseFloat(tokens[1]);\n                return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value: value };\n            } else {\n                return decodeBedGraph(tokens);\n            }\n        }\n    }, {\n        key: \"decodeAneu\",\n        value: function decodeAneu(tokens, ignore) {\n\n            var chr, start, end, feature;\n\n            if (tokens.length < 4) return null;\n\n            chr = tokens[1];\n            start = parseInt(tokens[2]);\n            end = tokens.length > 3 ? parseInt(tokens[3]) : start + 1;\n\n            feature = { chr: chr, start: start, end: end };\n\n            if (tokens.length > 4) {\n                feature.score = parseFloat(tokens[4]);\n                feature.value = feature.score;\n            }\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeFusionJuncSpan\",\n        value: function decodeFusionJuncSpan(tokens, ignore) {\n\n            /*\r\n             Format:\r\n               0       #scaffold\r\n             1       fusion_break_name\r\n             2       break_left\r\n             3       break_right\r\n             4       num_junction_reads\r\n             5       num_spanning_frags\r\n             6       spanning_frag_coords\r\n               0       B3GNT1--NPSR1\r\n             1       B3GNT1--NPSR1|2203-10182\r\n             2       2203\r\n             3       10182\r\n             4       189\r\n             5       1138\r\n             6       1860-13757,1798-13819,1391-18127,1443-17174,...\r\n               */\n\n            var chr = tokens[0];\n            var fusion_name = tokens[1];\n            var junction_left = parseInt(tokens[2]);\n            var junction_right = parseInt(tokens[3]);\n            var num_junction_reads = parseInt(tokens[4]);\n            var num_spanning_frags = parseInt(tokens[5]);\n\n            var spanning_frag_coords_text = tokens[6];\n\n            var feature = {\n                chr: chr,\n                name: fusion_name,\n                junction_left: junction_left,\n                junction_right: junction_right,\n                num_junction_reads: num_junction_reads,\n                num_spanning_frags: num_spanning_frags,\n                spanning_frag_coords: [],\n\n                start: -1,\n                end: -1\n            }; // set start and end later based on min/max of span coords\n\n            var min_coord = junction_left;\n            var max_coord = junction_right;\n\n            if (num_spanning_frags > 0) {\n\n                var coord_pairs = spanning_frag_coords_text.split(',');\n\n                for (var i = 0; i < coord_pairs.length; i++) {\n                    var split_coords = coord_pairs[i].split('-');\n\n                    var span_left = split_coords[0];\n                    var span_right = split_coords[1];\n\n                    if (span_left < min_coord) {\n                        min_coord = span_left;\n                    }\n                    if (span_right > max_coord) {\n                        max_coord = span_right;\n                    }\n                    feature.spanning_frag_coords.push({ left: span_left, right: span_right });\n                }\n            }\n\n            feature.start = min_coord;\n            feature.end = max_coord;\n\n            feature.popupData = function () {\n                return [{ name: \"Name\", value: feature.name }];\n            };\n\n            return feature;\n        }\n    }, {\n        key: \"decodeGtexGWAS\",\n        value: function decodeGtexGWAS(tokens, ignore) {\n\n            var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 8) {\n                return null;\n            }\n\n            chr = tokens[0];\n            start = parseInt(tokens[1]) - 1;\n            end = parseInt(tokens[3].split(':')[1]);\n            //name = tokens[3];\n            //score = parseFloat(tokens[4]);\n            //strand = tokens[5].trim();\n            //signal = parseFloat(tokens[6]);\n            pValue = parseFloat(tokens[5]);\n            //qValue = parseFloat(tokens[8]);\n\n            //return {chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\n            //    pValue: pValue, qValue: qValue};\n            return { chr: chr, start: start, end: end, pvalue: pValue };\n        }\n\n        /**\r\n         * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.\r\n         *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001\r\n         * @param tokens\r\n         * @param ignore\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"decodeGFF\",\n        value: function decodeGFF(tokens, ignore) {\n\n            var tokenCount,\n                chr,\n                start,\n                end,\n                strand,\n                type,\n                score,\n                phase,\n                attributeString,\n                id,\n                parent,\n                color,\n                name,\n                transcript_id,\n                i,\n                format = this.format;\n\n            tokenCount = tokens.length;\n            if (tokenCount < 9) {\n                return null; // Not a valid gff record\n            }\n\n            chr = tokens[0];\n            type = tokens[2];\n            start = parseInt(tokens[3]) - 1;\n            end = parseInt(tokens[4]);\n            score = \".\" === tokens[5] ? 0 : parseFloat(tokens[5]);\n            strand = tokens[6];\n            phase = \".\" === tokens[7] ? 0 : parseInt(tokens[7]);\n            attributeString = tokens[8];\n\n            // Find ID and Parent, or transcript_id\n            var delim = 'gff3' === format ? '=' : /\\s+/;\n            var attributes = {};\n            attributeString.split(';').forEach(function (kv) {\n                var t = kv.trim().split(delim, 2),\n                    key,\n                    value;\n                if (t.length == 2) {\n                    key = t[0].trim();\n                    value = t[1].trim();\n                    //Strip off quotes, if any\n                    if (value.startsWith('\"') && value.endsWith('\"')) {\n                        value = value.substr(1, value.length - 2);\n                    }\n                    if (\"ID\" === t[0]) id = t[1];else if (\"Parent\" === t[0]) parent = t[1];else if (\"color\" === t[0].toLowerCase()) color = igv.createColorString(t[1]);else if (\"transcript_id\" === t[0]) id = t[1]; // gtf format\n                    attributes[key] = value;\n                }\n            });\n\n            // Find name (label) property\n            if (this.nameField) {\n                name = attributes[this.nameField];\n            } else {\n                for (i = 0; i < gffNameFields.length; i++) {\n                    if (attributes.hasOwnProperty(gffNameFields[i])) {\n                        this.nameField = gffNameFields[i];\n                        name = attributes[this.nameField];\n\n                        break;\n                    }\n                }\n            }\n\n            return {\n                id: id,\n                parent: parent,\n                name: name,\n                type: type,\n                chr: chr,\n                start: start,\n                end: end,\n                score: score,\n                strand: strand,\n                color: color,\n                attributeString: attributeString,\n                popupData: function popupData() {\n                    var kvs = this.attributeString.split(';'),\n                        pd = [],\n                        key,\n                        value;\n                    kvs.forEach(function (kv) {\n                        var t = kv.trim().split(delim, 2);\n                        if (t.length === 2 && t[1] !== undefined) {\n                            key = t[0].trim();\n                            value = t[1].trim();\n                            //Strip off quotes, if any\n                            if (value.startsWith('\"') && value.endsWith('\"')) {\n                                value = value.substr(1, value.length - 2);\n                            }\n                            pd.push({ name: key, value: value });\n                        }\n                    });\n                    return pd;\n                }\n\n            };\n        }\n    }]);\n\n    return FeatureParser;\n}();\n\n//*******js/feature/featureCache.js**********************\n\n\n/**\r\n * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)\r\n *\r\n * @param featureList\r\n * @param The genomic range spanned by featureList (optional)\r\n * @constructor\r\n */\n\nvar FeatureCache = function () {\n    function FeatureCache(featureList, range) {\n        _classCallCheck(this, FeatureCache);\n\n        this.treeMap = FeatureCache.buildTreeMap(featureList);\n        this.range = range;\n    }\n\n    _createClass(FeatureCache, [{\n        key: \"queryFeatures\",\n        value: function queryFeatures(chr, start, end) {\n\n            var featureList, intervalFeatures, feature, len, i, tree, intervals;\n\n            tree = this.treeMap[chr];\n\n            if (!tree) return [];\n\n            intervals = tree.findOverlapping(start, end);\n\n            if (intervals.length == 0) {\n                return [];\n            } else {\n                // Trim the list of features in the intervals to those\n                // overlapping the requested range.\n                // Assumption: features are sorted by start position\n\n                featureList = [];\n\n                intervals.forEach(function (interval) {\n                    intervalFeatures = interval.value;\n                    len = intervalFeatures.length;\n                    for (i = 0; i < len; i++) {\n                        feature = intervalFeatures[i];\n                        if (feature.start > end) break;else if (feature.end >= start) {\n                            featureList.push(feature);\n                        }\n                    }\n                });\n                return featureList;\n            }\n        }\n    }, {\n        key: \"allFeatures\",\n        value: function allFeatures() {\n\n            var allFeatures = [];\n            var treeMap = this.treeMap;\n            if (treeMap) {\n                for (var key in treeMap) {\n                    if (treeMap.hasOwnProperty(key)) {\n\n                        var tree = treeMap[key];\n                        tree.mapIntervals(function (interval) {\n                            allFeatures = allFeatures.concat(interval.value);\n                        });\n                    }\n                }\n            }\n            return allFeatures;\n        }\n    }], [{\n        key: \"buildTreeMap\",\n        value: function buildTreeMap(featureList) {\n\n            var featureCache = {},\n                chromosomes = [],\n                treeMap = {},\n                genome = null;\n\n            if (featureList) {\n\n                featureList.forEach(function (feature) {\n\n                    var chr = feature.chr,\n                        geneList;\n\n                    // Translate to \"official\" name\n                    if (genome) chr = genome.getChromosomeName(chr);\n\n                    geneList = featureCache[chr];\n\n                    if (!geneList) {\n                        chromosomes.push(chr);\n                        geneList = [];\n                        featureCache[chr] = geneList;\n                    }\n\n                    geneList.push(feature);\n                });\n\n                // Now build interval tree for each chromosome\n\n                for (var i = 0; i < chromosomes.length; i++) {\n                    var chr = chromosomes[i];\n                    treeMap[chr] = FeatureCache.buildIntervalTree(featureCache[chr]);\n                }\n            }\n\n            return treeMap;\n        }\n    }, {\n        key: \"buildIntervalTree\",\n\n\n        /**\r\n         * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups\r\n         * of 10, or total size / 100,   to reduce size of the tree.\r\n         *\r\n         * @param featureList\r\n         */\n        value: function buildIntervalTree(featureList) {\n\n            var i, e, iStart, iEnd, tree, chunkSize, len, subArray;\n\n            tree = new IntervalTree();\n            len = featureList.length;\n\n            chunkSize = Math.max(10, Math.round(len / 100));\n\n            featureList.sort(function (f1, f2) {\n                return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;\n            });\n\n            for (i = 0; i < len; i += chunkSize) {\n                e = Math.min(len, i + chunkSize);\n                subArray = featureList.slice(i, e);\n                iStart = subArray[0].start;\n                //\n                iEnd = iStart;\n                subArray.forEach(function (feature) {\n                    iEnd = Math.max(iEnd, feature.end);\n                });\n                tree.insert(iStart, iEnd, subArray);\n            }\n\n            return tree;\n        }\n    }]);\n\n    return FeatureCache;\n}();\n\n//*****js/intervalTree.js************\n\n\nvar BLACK = 1;\nvar RED = 2;\n\nvar NIL = {};\nNIL.color = BLACK;\nNIL.parent = NIL;\nNIL.left = NIL;\nNIL.right = NIL;\n\nvar IntervalTree = function () {\n    function IntervalTree() {\n        _classCallCheck(this, IntervalTree);\n\n        this.root = NIL;\n    }\n\n    _createClass(IntervalTree, [{\n        key: \"insert\",\n        value: function insert(start, end, value) {\n\n            var interval = new Interval(start, end, value);\n            var x = new Node(interval);\n            this.treeInsert(x);\n            x.color = RED;\n            while (x != this.root && x.parent.color == RED) {\n                if (x.parent == x.parent.parent.left) {\n                    var y = x.parent.parent.right;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.right) {\n                            x = x.parent;\n                            this.leftRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.rightRotate(x.parent.parent);\n                    }\n                } else {\n                    var y = x.parent.parent.left;\n                    if (y.color == RED) {\n                        x.parent.color = BLACK;\n                        y.color = BLACK;\n                        x.parent.parent.color = RED;\n                        x = x.parent.parent;\n                    } else {\n                        if (x == x.parent.left) {\n                            x = x.parent;\n                            this.rightRotate(x);\n                        }\n                        x.parent.color = BLACK;\n                        x.parent.parent.color = RED;\n                        this.leftRotate(x.parent.parent);\n                    }\n                }\n            }\n            this.root.color = BLACK;\n        }\n\n        /**\r\n         *\r\n         * @param start - query interval\r\n         * @param end - query interval\r\n         * @returns Array of all intervals overlapping the query region\r\n         */\n\n    }, {\n        key: \"findOverlapping\",\n        value: function findOverlapping(start, end) {\n\n            var searchInterval = new Interval(start, end, 0);\n\n            if (this.root === NIL) return [];\n\n            var intervals = this.searchAll(searchInterval, this.root, []);\n\n            if (intervals.length > 1) {\n                intervals.sort(function (i1, i2) {\n                    return i1.low - i2.low;\n                });\n            }\n\n            return intervals;\n        }\n\n        /**\r\n         * Dump info on intervals to console.  For debugging.\r\n         */\n\n    }, {\n        key: \"logIntervals\",\n        value: function logIntervals() {\n\n            logNode(this.root, 0);\n\n            function logNode(node, indent) {\n\n                var space = \"\";\n                for (var i = 0; i < indent; i++) {\n                    space += \" \";\n                }console.log(space + node.interval.low + \" \" + node.interval.high); // + \" \" + (node.interval.value ? node.interval.value : \" null\"));\n\n                indent += 5;\n\n                if (node.left != NIL) logNode(node.left, indent);\n                if (node.right != NIL) logNode(node.right, indent);\n            }\n        }\n    }, {\n        key: \"mapIntervals\",\n        value: function mapIntervals(func) {\n\n            applyInterval(this.root);\n\n            function applyInterval(node) {\n\n                func(node.interval);\n\n                if (node.left != NIL) applyInterval(node.left);\n                if (node.right != NIL) applyInterval(node.right);\n            }\n        }\n    }, {\n        key: \"searchAll\",\n        value: function searchAll(interval, node, results) {\n\n            if (node.interval.overlaps(interval)) {\n                results.push(node.interval);\n            }\n\n            if (node.left != NIL && node.left.max >= interval.low) {\n                this.searchAll(interval, node.left, results);\n            }\n\n            if (node.right != NIL && node.right.min <= interval.high) {\n                this.searchAll(interval, node.right, results);\n            }\n\n            return results;\n        }\n    }, {\n        key: \"leftRotate\",\n        value: function leftRotate(x) {\n            var y = x.right;\n            x.right = y.left;\n            if (y.left != NIL) {\n                y.left.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.left == x) {\n                    x.parent.left = y;\n                } else {\n                    x.parent.right = y;\n                }\n            }\n            y.left = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n    }, {\n        key: \"rightRotate\",\n        value: function rightRotate(x) {\n            var y = x.left;\n            x.left = y.right;\n            if (y.right != NIL) {\n                y.right.parent = x;\n            }\n            y.parent = x.parent;\n            if (x.parent == NIL) {\n                this.root = y;\n            } else {\n                if (x.parent.right == x) {\n                    x.parent.right = y;\n                } else {\n                    x.parent.left = y;\n                }\n            }\n            y.right = x;\n            x.parent = y;\n\n            this.applyUpdate(x);\n            // no need to apply update on y, since it'll y is an ancestor\n            // of x, and will be touched by applyUpdate().\n        }\n\n        /**\r\n         * Note:  Does not maintain RB constraints,  this is done post insert\r\n         *\r\n         * @param x  a Node\r\n         */\n\n    }, {\n        key: \"treeInsert\",\n        value: function treeInsert(x) {\n            var node = this.root;\n            var y = NIL;\n            while (node != NIL) {\n                y = node;\n                if (x.interval.low <= node.interval.low) {\n                    node = node.left;\n                } else {\n                    node = node.right;\n                }\n            }\n            x.parent = y;\n\n            if (y == NIL) {\n                this.root = x;\n                x.left = x.right = NIL;\n            } else {\n                if (x.interval.low <= y.interval.low) {\n                    y.left = x;\n                } else {\n                    y.right = x;\n                }\n            }\n\n            this.applyUpdate(x);\n        }\n\n        // Applies the statistic update on the node and its ancestors.\n\n    }, {\n        key: \"applyUpdate\",\n        value: function applyUpdate(node) {\n            while (node != NIL) {\n                var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;\n                var intervalHigh = node.interval.high;\n                node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;\n\n                var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;\n                var intervalLow = node.interval.low;\n                node.min = nodeMin < intervalLow ? nodeMin : intervalLow;\n\n                node = node.parent;\n            }\n        }\n    }]);\n\n    return IntervalTree;\n}();\n\nvar Interval = function () {\n    function Interval(low, high, value) {\n        _classCallCheck(this, Interval);\n\n        this.low = low;\n        this.high = high;\n        this.value = value;\n    }\n\n    _createClass(Interval, [{\n        key: \"equals\",\n        value: function equals(other) {\n            if (!other) {\n                return false;\n            }\n            if (this == other) {\n                return true;\n            }\n            return this.low == otherInterval.low && this.high == otherInterval.high;\n        }\n    }, {\n        key: \"compareTo\",\n        value: function compareTo(other) {\n            if (this.low < other.low) return -1;\n            if (this.low > other.low) return 1;\n\n            if (this.high < other.high) return -1;\n            if (this.high > other.high) return 1;\n\n            return 0;\n        }\n\n        /**\r\n         * Returns true if this interval overlaps the other.\r\n         */\n\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(other) {\n            try {\n                return this.low <= other.high && other.low <= this.high;\n            } catch (e) {\n                //alert(e);\n                igv.presentAlert(e);\n            }\n        }\n    }]);\n\n    return Interval;\n}();\n\nvar Node = function Node(interval) {\n    _classCallCheck(this, Node);\n\n    this.parent = NIL;\n    this.left = NIL;\n    this.right = NIL;\n    this.interval = interval;\n    this.color = RED;\n};\n\nvar GenomicInterval = function () {\n    function GenomicInterval(chr, start, end, features) {\n        _classCallCheck(this, GenomicInterval);\n\n        this.chr = chr;\n        this.start = start;\n        this.end = end;\n        this.features = features;\n    }\n\n    _createClass(GenomicInterval, [{\n        key: \"contains\",\n        value: function contains(chr, start, end) {\n            return this.chr == chr && this.start <= start && this.end >= end;\n        }\n    }, {\n        key: \"containsRange\",\n        value: function containsRange(range) {\n            return this.chr === range.chr && this.start <= range.start && this.end >= range.end;\n        }\n    }, {\n        key: \"rangesToGet\",\n        value: function rangesToGet(range) {\n            var needs_range = false;\n            var ranges = {};\n            if (this.chr !== range.chr) {\n                ranges.all = [range.start, range.end];\n                needs_range = true;\n                this.start = range.start;\n                this.end = range.end;\n            } else {\n                if (range.start < this.start) {\n                    ranges.left = [range.start, this.start];\n                    needs_range = true;\n                    this.start = range.start;\n                }\n                if (range.end > this.end) {\n                    ranges.right = [this.end, range.end];\n                    needs_range = true;\n                    this.end = range.end;\n                }\n            }\n            if (!needs_range) {\n                return false;\n            }\n            return ranges;\n        }\n    }]);\n\n    return GenomicInterval;\n}();\n\nvar FastaSequence = function () {\n    function FastaSequence(url) {\n        _classCallCheck(this, FastaSequence);\n\n        this.file = url;\n        this.indexed = true;\n        if (this.indexed) {\n            this.indexFile = this.file + \".fai\";\n        }\n    }\n\n    _createClass(FastaSequence, [{\n        key: \"init\",\n        value: function init() {\n\n            var self = this;\n\n            if (self.indexed) {\n\n                return new Promise(function (fulfill, reject) {\n\n                    self.getIndex().then(function (index) {\n                        var order = 0;\n                        self.chromosomes = {};\n                        self.chromosomeNames.forEach(function (chrName) {\n                            var bpLength = self.index[chrName].size;\n                            self.chromosomes[chrName] = new igv.Chromosome(chrName, order++, bpLength);\n                        });\n\n                        // Ignore index, getting chr names as a side effect.  Really bad practice\n                        fulfill();\n                    }).catch(reject);\n                });\n            } else {\n                return self.loadAll();\n            }\n        }\n    }, {\n        key: \"getSequence\",\n        value: function getSequence(chr, start, end) {\n\n            if (this.indexed) {\n                return this.getSequenceIndexed(chr, start, end);\n            } else {\n                return getSequenceNonIndexed.this(chr, start, end);\n            }\n        }\n    }, {\n        key: \"getSequenceIndexed\",\n        value: function getSequenceIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var interval = self.interval;\n\n                if (interval && interval.contains(chr, start, end)) {\n\n                    fulfill(getSequenceFromInterval(interval, start, end));\n                } else {\n\n                    //console.log(\"Cache miss: \" + (interval === undefined ? \"nil\" : interval.chr + \":\" + interval.start + \"-\" + interval.end));\n\n                    // Expand query, to minimum of 100kb\n                    var qstart = start;\n                    var qend = end;\n                    if (end - start < 100000) {\n                        var w = end - start;\n                        var center = Math.round(start + w / 2);\n                        qstart = Math.max(0, center - 50000);\n                        qend = center + 50000;\n                    }\n\n                    self.readSequence(chr, qstart, qend).then(function (seqBytes) {\n                        self.interval = new GenomicInterval(chr, qstart, qend, seqBytes);\n                        fulfill(getSequenceFromInterval(self.interval, start, end));\n                    }).catch(reject);\n                }\n\n                function getSequenceFromInterval(interval, start, end) {\n                    var offset = start - interval.start;\n                    var n = end - start;\n                    var seq = interval.features ? interval.features.substr(offset, n) : null;\n                    return seq;\n                }\n            });\n        }\n    }, {\n        key: \"getSequenceNonIndexed\",\n        value: function getSequenceNonIndexed(chr, start, end) {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                var seq = self.sequences[chr];\n                if (seq && seq.length > end) {\n                    fulfill(seq.substring(start, end));\n                }\n            });\n        }\n    }, {\n        key: \"getIndex\",\n        value: function getIndex() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n\n                if (self.index) {\n                    fulfill(self.index);\n                } else {\n                    _igvxhr.igvxhr.load(self.indexFile, {}).then(function (data) {\n                        var lines = data.split(\"\\n\");\n                        var len = lines.length;\n                        var lineNo = 0;\n\n                        self.chromosomeNames = []; // TODO -- eliminate this side effect !!!!\n                        self.index = {}; // TODO -- ditto\n                        while (lineNo < len) {\n\n                            var tokens = lines[lineNo++].split(\"\\t\");\n                            var nTokens = tokens.length;\n                            if (nTokens == 5) {\n                                // Parse the index line.\n                                var chr = tokens[0];\n                                var size = parseInt(tokens[1]);\n                                var position = parseInt(tokens[2]);\n                                var basesPerLine = parseInt(tokens[3]);\n                                var bytesPerLine = parseInt(tokens[4]);\n\n                                var indexEntry = {\n                                    size: size, position: position, basesPerLine: basesPerLine, bytesPerLine: bytesPerLine\n                                };\n\n                                self.chromosomeNames.push(chr);\n                                self.index[chr] = indexEntry;\n                            }\n                        }\n\n                        if (fulfill) {\n                            fulfill(self.index);\n                        }\n                    }).catch(reject);\n                }\n            });\n        }\n    }, {\n        key: \"loadAll\",\n        value: function loadAll() {\n\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.chromosomeNames = [];\n                self.chromosomes = {};\n                self.sequences = {};\n\n                _igvxhr.igvxhr.load(self.file, {\n                    withCredentials: self.withCredentials\n\n                }).then(function (data) {\n\n                    var lines = data.splitLines(),\n                        len = lines.length,\n                        lineNo = 0,\n                        nextLine,\n                        currentSeq = \"\",\n                        currentChr,\n                        order = 0;\n\n                    while (lineNo < len) {\n                        nextLine = lines[lineNo++].trim();\n                        if (nextLine.startsWith(\"#\") || nextLine.length === 0) {\n                            continue;\n                        } else if (nextLine.startsWith(\">\")) {\n                            if (currentSeq) {\n                                self.chromosomeNames.push(currentChr);\n                                self.sequences[currentChr] = currentSeq;\n                                self.chromosomes[currentChr] = new igv.Chromosome(currentChr, order++, currentSeq.length);\n                            }\n                            currentChr = nextLine.substr(1).split(\"\\\\s+\")[0];\n                            currentSeq = \"\";\n                        } else {\n                            currentSeq += nextLine;\n                        }\n                    }\n\n                    fulfill();\n                });\n            });\n        }\n    }, {\n        key: \"readSequence\",\n        value: function readSequence(chr, qstart, qend) {\n\n            //console.log(\"Read sequence \" + chr + \":\" + qstart + \"-\" + qend);\n            var self = this;\n\n            return new Promise(function (fulfill, reject) {\n                self.getIndex().then(function () {\n\n                    var idxEntry = self.index[chr];\n                    if (!idxEntry) {\n                        console.log(\"No index entry for chr: \" + chr);\n\n                        // Tag interval with null so we don't try again\n                        self.interval = new GenomicInterval(chr, qstart, qend, null);\n                        fulfill(null);\n                    } else {\n\n                        var start = Math.max(0, qstart); // qstart should never be < 0\n                        var end = Math.min(idxEntry.size, qend);\n                        var bytesPerLine = idxEntry.bytesPerLine;\n                        var basesPerLine = idxEntry.basesPerLine;\n                        var position = idxEntry.position;\n                        var nEndBytes = bytesPerLine - basesPerLine;\n\n                        var startLine = Math.floor(start / basesPerLine);\n                        var endLine = Math.floor(end / basesPerLine);\n\n                        var base0 = startLine * basesPerLine; // Base at beginning of start line\n\n                        var offset = start - base0;\n\n                        var startByte = position + startLine * bytesPerLine + offset;\n\n                        var base1 = endLine * basesPerLine;\n                        var offset1 = end - base1;\n                        var endByte = position + endLine * bytesPerLine + offset1 - 1;\n                        var byteCount = endByte - startByte + 1;\n                        if (byteCount <= 0) {\n                            fulfill(null);\n                        }\n\n                        _igvxhr.igvxhr.load(self.file, {\n                            range: { start: startByte, size: byteCount }\n                        }).then(function (allBytes) {\n\n                            var nBases,\n                                seqBytes = \"\",\n                                srcPos = 0,\n                                desPos = 0,\n                                allBytesLength = allBytes.length;\n\n                            if (offset > 0) {\n                                nBases = Math.min(end - start, basesPerLine - offset);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            while (srcPos < allBytesLength) {\n                                nBases = Math.min(basesPerLine, allBytesLength - srcPos);\n                                seqBytes += allBytes.substr(srcPos, nBases);\n                                srcPos += nBases + nEndBytes;\n                                desPos += nBases;\n                            }\n\n                            fulfill(seqBytes);\n                        }).catch(reject);\n                    }\n                }).catch(reject);\n            });\n        }\n    }]);\n\n    return FastaSequence;\n}();\n\nexports.FeatureSource = FeatureSource;\nexports.FastaSequence = FastaSequence;\nexports.BigBedFeatureSource = BigBedFeatureSource;\nexports.TabixBedFeatureSource = TabixBedFeatureSource;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanM/MzFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuXHJcbmltcG9ydCB7VXRpbHN9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7aWd2eGhyLHVuYmd6Zn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcbmltcG9ydCB7bG9hZEJhbUluZGV4fSBmcm9tIFwiLi9iYW0uanNcIjtcclxuaW1wb3J0IHtCV1NvdXJjZX0gZnJvbSBcIi4vYmlnd2lnLmpzXCI7XHJcblxyXG5jb25zdCBNQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmVhdHVyZSBzb3VyY2UgZm9yIFwiYmVkIGxpa2VcIiBmaWxlcyAodGFiIGRlbGltaXRlZCBmaWxlcyB3aXRoIDEgZmVhdHVyZSBwZXIgbGluZTogYmVkLCBnZmYsIHZjZiwgZXRjKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbmNsYXNzIEZlYXR1cmVTb3VyY2V7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0RmlsZUhlYWRlcigpIHtcclxuICAgICAgICB0aGlzLmlzX2luZGV4ZWQ9dHJ1ZTsgIFxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bGZpbGwoKTsgICAgICAgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSAgIFxyXG5cclxuXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpe1xyXG4gICAgICBcclxuICAgICAgICAvL25vIG5lZWQgdG8gZ2V0IGhlYWRlclxyXG4gICAgICAgIGlmICh0aGlzLmlzX2luZGV4ZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9nZXQgaGVhZGVycy9pbmRleCB0aGVuIGdldCBmZWF0dXJlc1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZnVsZmlsbCxyZWplY3Qpe1xyXG4gICAgICAgICAgICBzZWxmLmdldEZpbGVIZWFkZXIoKS50aGVuKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9nZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpLnRoZW4oZnVuY3Rpb24oZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgZnVuY3Rpb24gZm8gYWxsIGRhdGEgc291cmNlIG9iamVjdHMuICBGZXRjaGVzIGZlYXR1cmVzIGZvciB0aGVcclxuICAgICAqIHJhbmdlIHJlcXVlc3RlZCBhbmQgcGFzc2VzIHRoZW0gb24gdG8gdGhlIHN1Y2Nlc3MgZnVuY3Rpb24uICBVc3VhbGx5IHRoaXMgaXNcclxuICAgICAqIGEgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBmZWF0dXJlcyBvbiB0aGUgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHBhcmFtIGJwU3RhcnRcclxuICAgICAqIEBwYXJhbSBicEVuZFxyXG4gICAgICovXHJcbiAgICBfZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgaWYgKGJwU3RhcnQ9PT0wKXtcclxuICAgICAgICAgICAgYnBTdGFydD0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi50aW1lPURhdGUubm93KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZUNhY2hlICYmIGNociAhPT0gc2VsZi5mZWF0dXJlQ2FjaGUucmFuZ2UuY2hyKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlPW51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdlbm9taWNJbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBicFN0YXJ0LCBicEVuZCksXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlQ2FjaGUgPSBzZWxmLmZlYXR1cmVDYWNoZSxcclxuICAgICAgICAgICAgICAgIG1heFJvd3MgPSBzZWxmLmNvbmZpZy5tYXhSb3dzIHx8IDUwMDtcclxuICAgICAgICAgICAgbGV0IHJhbmdlc190b19nZXQ9ZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghZmVhdHVyZUNhY2hlKXtcclxuICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9e2FsbDpbYnBTdGFydCxicEVuZF19O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUNhY2hlLnJhbmdlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9ZmVhdHVyZUNhY2hlLnJhbmdlLnJhbmdlc1RvR2V0KGdlbm9taWNJbnRlcnZhbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJhbmdlc190b19nZXQpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGxldCBwcm9taXNlcz1bXTtcclxuICAgICAgICAgICAgICAgIGxldCBwX3R5cGVzPVtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiByYW5nZXNfdG9fZ2V0KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2U9IHJhbmdlc190b19nZXRbdHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnJldHJpZXZlRmVhdHVyZXMoY2hyLCByYW5nZVswXSwgcmFuZ2VbMV0sZm9yY2UsZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBfdHlwZXMucHVzaChbdHlwZSxyYW5nZXNfdG9fZ2V0W3R5cGVdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ19mZWF0dXJlcz1bXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZUNhY2hlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX2ZlYXR1cmVzPXNlbGYuZmVhdHVyZUNhY2hlLmFsbEZlYXR1cmVzKCk7Ly9mZWF0dXJlQ2FjaGUuYWxsRmVhdHVyZXMoY2hyLHNlbGYuZmVhdHVyZUNhY2hlLnJhbmdlLnN0YXJ0LHNlbGYuZmVhdHVyZUNhY2hlLnJhbmdlLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4PTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmVMaXN0IG9mIGFsbF9mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3QgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0PVtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwX3R5cGVzW2luZGV4XVswXT09PVwibGVmdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcF90eXBlc1tpbmRleF1bMV1bMV07IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBhbHJlYWR5IHJldGlldmVkICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaWNlPTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbj1mZWF0dXJlTGlzdC5sZW5ndGgtMTtuPj0wO24tLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdFtuXS5lbmQ8IGVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGljZSE9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdC5zcGxpY2UoLXNwbGljZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBfdHlwZXNbaW5kZXhdWzBdPT09XCJyaWdodFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ9cF90eXBlc1tpbmRleF1bMV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYW55IGFscmVhZHkgcmV0aWV2ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaT0wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7aTxmZWF0dXJlTGlzdC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0W2ldLnN0YXJ0PiBzdGFydCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSE9PTApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdC5zcGxpY2UoMCxpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19mZWF0dXJlcz1leGlzdGluZ19mZWF0dXJlcy5jb25jYXQoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnaSA9IHNlbGYuZmVhdHVyZUNhY2hlP3NlbGYuZmVhdHVyZUNhY2hlLnJhbmdlOmdlbm9taWNJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlQ2FjaGUgPSBuZXcgRmVhdHVyZUNhY2hlKGV4aXN0aW5nX2ZlYXR1cmVzLCBnaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZlYXR1cmVTb3VyY2UucGFja0ZlYXR1cmVzKGV4aXN0aW5nX2ZlYXR1cmVzLCBtYXhSb3dzKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgc3RhdGljIHBhY2tGZWF0dXJlcyhmZWF0dXJlcywgbWF4Um93cykge1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZXMgPT0gbnVsbCB8fCBmZWF0dXJlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VncmVnYXRlIGJ5IGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgdmFyIGNockZlYXR1cmVNYXAgPSB7fSxcclxuICAgICAgICAgICAgY2hycyA9IFtdO1xyXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaHIgPSBmZWF0dXJlLmNocixcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gY2hyRmVhdHVyZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgZmxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNockZlYXR1cmVNYXBbY2hyXSA9IGZsaXN0O1xyXG4gICAgICAgICAgICAgICAgY2hycy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsaXN0LnB1c2goZmVhdHVyZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBjaHJvc29tb3NvbWVzIGFuZCBwYWNrIGZlYXR1cmVzO1xyXG5cclxuICAgICAgICBjaHJzLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xyXG5cclxuICAgICAgICAgICAgcGFjayhjaHJGZWF0dXJlTWFwW2Nocl0sIG1heFJvd3MpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gQXNzaWducyBhIHJvdyAjIHRvIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBmZWF0dXJlIGRvZXMgbm90IGZpdCBpbiBhbnkgcm93IGFuZCAjcm93cyA9PSBtYXhSb3dzIG5vXHJcbiAgICAgICAgLy8gcm93IG51bWJlciBpcyBhc3NpZ25lZC5cclxuICAgICAgICBmdW5jdGlvbiBwYWNrKGZlYXR1cmVMaXN0LCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJvd3MucHVzaCgtMTAwMCk7XHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICByLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWluKHJvd3MubGVuZ3RoLCBtYXhSb3dzKSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZlYXR1cmUuc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IGxlbjsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IHJvd3Nbcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5yb3cgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnJvdyA9IHI7XHJcbiAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcblxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgVGFiaXhCZWRGZWF0dXJlU291cmNlIGV4dGVuZHMgRmVhdHVyZVNvdXJjZXtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pe1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgRmVhdHVyZUZpbGVSZWFkZXIoY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0cmlldmVGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIucmVhZEZlYXR1cmVzKGNocixzdGFydCxlbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpbGVIZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVhZGVyLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuaXNfaW5kZXhlZD10cnVlOyAgXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcbiAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICB9ICAgXHJcbn1cclxuXHJcbmNsYXNzIEJpZ0JlZEZlYXR1cmVTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLGRlY29kZV9mdW5jdGlvbil7XHJcblx0XHRjb25maWcuc291cmNlVHlwZT1cImd0ZXhcIjtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHR0aGlzLmhlYWRlcj10cnVlO1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQldTb3VyY2UoY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXRyaWV2ZUZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZvcmNlLGRhdGEpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0RmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZmFsc2UsZGF0YSk7ICAgICBcdFxyXG5cdH1cclxufVxyXG5cclxuLy8qKioqKioqKmpzL0ZlYXR1cmVGaWxlUmVhZGVyLmpzKioqKipcclxuXHJcblxyXG5cclxuY29uc3QgRl9NQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZGVyIGZvciBcImJlZCBsaWtlXCIgZmlsZXMgKHRhYiBkZWxpbWl0ZWQgZmlsZXMgd2l0aCAxIGZlYXR1cmUgcGVyIGxpbmU6IGJlZCwgZ2ZmLCB2Y2YsIGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5jbGFzcyBGZWF0dXJlRmlsZVJlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxkZWNfZnVuY3Rpb24pIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgICAgIGlmIChjb25maWcubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxGaWxlID0gY29uZmlnLmxvY2FsRmlsZTtcclxuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IGNvbmZpZy5sb2NhbEZpbGUubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXJsID0gY29uZmlnLnVybDtcclxuICAgICAgICAgICAgdGhpcy5pbmRleFVSTCA9IGNvbmZpZy5pbmRleFVSTDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkVVJMID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5maWxlbmFtZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1cmlQYXJ0cyA9IFV0aWxzLnBhcnNlVXJpKGNvbmZpZy51cmwpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gdXJpUGFydHMuZmlsZTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gdXJpUGFydHMucGF0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gY29uZmlnLmZvcm1hdDtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB0aGlzLmdldFBhcnNlcih0aGlzLmZvcm1hdCwgZGVjX2Z1bmN0aW9uKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGdldFBhcnNlcihmb3JtYXQsIGRlY29kZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2Y2ZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmNmUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZWdcIiA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlZ1BhcnNlcigpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlUGFyc2VyKGZvcm1hdCwgZGVjb2RlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZWcgZmlsZXMgZG9uJ3QgaGF2ZSBhbiBpbmRleFxyXG4gICAgaXNJbmRleGFibGUoKSB7XHJcbiAgICAgICAgdmFyIGNvbmZpZ0luZGV4VVJMID0gdGhpcy5jb25maWcuaW5kZXhVUkwsXHJcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbmZpZ0luZGV4ZWQgPSB0aGlzLmNvbmZpZy5pbmRleGVkO1xyXG5cclxuICAgICAgICByZXR1cm4gY29uZmlnSW5kZXhVUkwgfHwgKHR5cGUgIT0gXCJ3aWdcIiAmJiBjb25maWdJbmRleGVkICE9IGZhbHNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgYXN5bmMgbG9hZGVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGxvYWRJbmRleCgpIHtcclxuICAgICAgICB2YXIgaWR4RmlsZSA9IHRoaXMuaW5kZXhVUkw7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsZW5hbWUuZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgaWYgKCFpZHhGaWxlKSBpZHhGaWxlID0gdGhpcy51cmwgKyBcIi50YmlcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRCYW1JbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlkeEZpbGUpIGlkeEZpbGUgPSB0aGlzLnVybCArIFwiLmlkeFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9hZFRyaWJibGVJbmRleChpZHhGaWxlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRGZWF0dXJlc05vSW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IHNlbGYucGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLCAgICAgICAgICAgLy8gaHR0cCBoZWFkZXJzLCBub3QgZmlsZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihwYXJzZURhdGEpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZURhdGEoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIgPSBwYXJzZXIucGFyc2VIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIgaW5zdGFuY2VvZiBTdHJpbmcgJiYgc2VsZi5oZWFkZXIuc3RhcnRzV2l0aChcIiMjZ2ZmLXZlcnNpb24gM1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZm9ybWF0ID0gJ2dmZjMnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChwYXJzZXIucGFyc2VGZWF0dXJlcyhkYXRhKSk7ICAgLy8gPD0gUEFSU0lORyBET05FIEhFUkVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiBcclxuXHJcbiAgICBsb2FkRmVhdHVyZXNXaXRoSW5kZXgoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleCxcclxuICAgICAgICAgICAgICAgIHRhYml4ID0gaW5kZXggJiYgaW5kZXgudGFiaXgsXHJcbiAgICAgICAgICAgICAgICByZWZJZCA9IHRhYml4ID8gaW5kZXguc2VxdWVuY2VJbmRleE1hcFtjaHJdIDogY2hyLFxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGJsb2NrcyA9IGluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZklkLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYmxvY2tzIHx8IGJsb2Nrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7ICAgICAgIC8vIFRPRE8gLS0gaXMgdGhpcyBjb3JyZWN0PyAgU2hvdWxkIGl0IHJldHVybiBhbiBlbXB0eSBhcnJheT9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBibG9jay5taW52LmJsb2NrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBibG9jay5taW52Lm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IGJsb2NrLm1heHYuYmxvY2sgKyAoaW5kZXgudGFiaXggPyBGX01BWF9HWklQX0JMT0NLX1NJWkUgOiAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc3RhcnRQb3MsIHNpemU6IGVuZFBvcyAtIHN0YXJ0UG9zICsgMX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGVkLCBzbGljZWREYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleC50YWJpeCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsYXRlZCA9IGlndnhoci5hcnJheUJ1ZmZlclRvU3RyaW5nKHVuYmd6ZihkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBkZWNvbXByZXNzIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxhdGVkID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWREYXRhID0gc3RhcnRPZmZzZXQgPyBpbmZsYXRlZC5zbGljZShzdGFydE9mZnNldCkgOiBpbmZsYXRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc2VsZi5wYXJzZXIucGFyc2VGZWF0dXJlcyhzbGljZWREYXRhLGNocixzdGFydCxlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3luYyBsb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4LnRhYml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmcoc2VsZi51cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcykuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVBcnJheXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGFsbEZlYXR1cmVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUFycmF5cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBmZWF0dXJlQXJyYXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChmZWF0dXJlQXJyYXlzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxsRmVhdHVyZXMpXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG4gICAgXHJcblxyXG5cclxuICAgIGdldEluZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaXNJbmRlZWRJbmRleGlibGUgPSB0aGlzLmlzSW5kZXhhYmxlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4ZWQgPT09IHVuZGVmaW5lZCAmJiBpc0luZGVlZEluZGV4aWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpOyAgIC8vIElzIGVpdGhlciBhbHJlYWR5IGxvYWRlZCwgb3IgdGhlcmUgaXNuJ3Qgb25lXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmhlYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGZvcmNlIGEgbG9hZCBvZiB0aGUgaW5kZXggZmlyc3RcclxuXHJcbiAgICAgICAgICAgICAgIHNlbGYuIGdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIGZpbGUgaGVhZGVyIChub3QgSFRUUCBoZWFkZXIpIGZvciBhbiBpbmRleGVkIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gbm90ZSB0aGlzIHdpbGwgZmFpbCBpZiB0aGUgZmlsZSBoZWFkZXIgaXMgPiA2NWtiIGluIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmd6OiBpbmRleC50YWJpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiA2NTAwMH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhlYWRlciA9IHNlbGYucGFyc2VyLnBhcnNlSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5oZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzTm9JbmRleCh1bmRlZmluZWQpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gc2VsZi5oZWFkZXIgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuZmVhdHVyZXMgPSBmZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bGZpbGxcclxuICAgICAqIEBwYXJhbSByYW5nZSAtLSBnZW5vbWljIHJhbmdlIHRvIGxvYWQuICBGb3IgdXNlIHdpdGggaW5kZXhlZCBzb3VyY2UgKG9wdGlvbmFsKVxyXG4gICAgICovXHJcbiAgICByZWFkRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRGZWF0dXJlc1dpdGhJbmRleChjaHIsIHN0YXJ0LCBlbmQpLnRoZW4ocGFja0ZlYXR1cmVzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkRmVhdHVyZXNOb0luZGV4KCkudGhlbihwYWNrRmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYWNrRmVhdHVyZXMoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcGFja1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChmZWF0dXJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqanMvZmVhdHVyZS9GZWF0dXJlUGFyc2Vycy5qcyoqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgbWF4RmVhdHVyZUNvdW50ID0gTnVtYmVyLk1BWF9WQUxVRTsgICAgLy8gRm9yIGZ1dHVyZSB1c2UsICBjb250cm9scyBkb3duc2FtcGxpbmdcclxuXHJcbmNvbnN0IGdmZk5hbWVGaWVsZHMgPSBbXCJOYW1lXCIsIFwiZ2VuZV9uYW1lXCIsIFwiZ2VuZVwiLCBcImdlbmVfaWRcIiwgXCJhbGlhc1wiLCBcImxvY3VzXCJdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmYWN0b3J5IGZ1bmN0aW9uLiAgUmV0dXJuIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gZmlsZSBmb3JtYXQuXHJcbiAgICAgKi9cclxuY2xhc3MgRmVhdHVyZVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCwgZGVjb2RlX2Z1bmMsIGNvbmZpZykge1xyXG5cclxuICAgICAgICB2YXIgY3VzdG9tRm9ybWF0O1xyXG5cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLm5hbWVGaWVsZCA9IGNvbmZpZyA/IGNvbmZpZy5uYW1lRmllbGQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5za2lwUm93cyA9IDA7ICAgLy8gVGhlIG51bWJlciBvZiBmaXhlZCBoZWFkZXIgcm93cyB0byBza2lwLiAgT3ZlcnJpZGUgZm9yIHNwZWNpZmljIHR5cGVzIGFzIG5lZWRlXHJcblxyXG4gICAgICAgIGlmIChkZWNvZGVfZnVuYykge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlID1mdW5jdGlvbih0b2tlbnMsaWdub3JlKXtcclxuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlPXtjaHI6dG9rZW5zWzBdLHN0YXJ0OnBhcnNlSW50KHRva2Vuc1sxXSksZW5kOnBhcnNlSW50KHRva2Vuc1syXSl9XHJcbiAgICAgICAgICAgICAgICBkZWNvZGVfZnVuYyh0b2tlbnMuc2xpY2UoMyksZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICAgICAgfSA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWNvZGVfZnVuY3Rpb249PT1cImdlbmVyaWNcIil7XHJcbiAgICAgICAgICAgICB0aGlzLmRlY29kZSA9ZnVuY3Rpb24odG9rZW5zLGlnbm9yZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZT17Y2hyOnRva2Vuc1swXSxzdGFydDpwYXJzZUludCh0b2tlbnNbMV0pLGVuZDpwYXJzZUludCh0b2tlbnNbMl0pfVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5kYXRhPXRva2Vucy5zbGljZSgzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG4gICAgICAgICAgICB9IDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSBGZWF0dXJlUGFyc2VyLmRlY29kZUJlZDtcclxuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cclxuXHJcbiAgICAgICAvKiBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFycm93cGVha1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRwZWFrXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZWFrc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlY29kZVBlYWs7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmVkZ3JhcGhcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVCZWRHcmFwaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3aWdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVXaWc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2ZmM1wiIDpcclxuICAgICAgICAgICAgY2FzZSBcImdmZlwiIDpcclxuICAgICAgICAgICAgY2FzZSBcImd0ZlwiIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVHRkY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImFuZXVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVBbmV1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmdXNpb25qdW5jc3BhblwiOlxyXG4gICAgICAgICAgICAgICAgLy8gYmhhYXMsIG5lZWRlZCBmb3IgRnVzaW9uSW5zcGVjdG9yIHZpZXdcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVGdXNpb25KdW5jU3BhbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJndGV4Z3dhc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwUm93cyA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlR3RleEdXQVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJlZmZsYXRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVSZWZmbGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICBjdXN0b21Gb3JtYXQgPSBpZ3YuYnJvd3Nlci5nZXRGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Gb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gZGVjb2RlQ3VzdG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gY3VzdG9tRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gY3VzdG9tRm9ybWF0LmRlbGltaXRlciB8fCBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgfSovXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZUhlYWRlcihkYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIiksXHJcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaGVhZGVyO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJicm93c2VyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSB0aGlzLnBhcnNlVHJhY2tMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiIyNnZmYtdmVyc2lvbiAzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBcImdmZjNcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcikgaGVhZGVyID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyW1wiZm9ybWF0XCJdID0gXCJnZmYzXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXI9e307XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZUZlYXR1cmVzKGRhdGEsY2hyLHN0YXJ0LGVuZCkge1xyXG5cclxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgd2lnLFxyXG4gICAgICAgICAgICBmZWF0dXJlLFxyXG4gICAgICAgICAgICBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIiksXHJcbiAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgdG9rZW5zLFxyXG4gICAgICAgICAgICBhbGxGZWF0dXJlcyA9IFtdLFxyXG4gICAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBjbnQgPSAwLFxyXG4gICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICBkZWNvZGUgPSB0aGlzLmRlY29kZSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQsXHJcbiAgICAgICAgICAgIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyIHx8IFwiXFx0XCI7XHJcblxyXG5cclxuICAgICAgICBmb3IgKGkgPSB0aGlzLnNraXBSb3dzOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwidHJhY2tcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJicm93c2VyXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwid2lnXCIgJiYgbGluZS5zdGFydHNXaXRoKFwiZml4ZWRTdGVwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB3aWcgPSB0aGlzLnBhcnNlRml4ZWRTdGVwKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIndpZ1wiICYmIGxpbmUuc3RhcnRzV2l0aChcInZhcmlhYmxlU3RlcFwiKSkge1xyXG4gICAgICAgICAgICAgICAgd2lnID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RlcChsaW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b2tlbnMgPSBsaW5lc1tpXS5zcGxpdChkZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDEgfHwgKGZvcm1hdCE9PVwid2lnXCIgJiYgdG9rZW5zLmxlbmd0aDwzKSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0gdGhpcy5kZWNvZGUodG9rZW5zLCB3aWcpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jaHIgIT09Y2hyIHx8IGZlYXR1cmUuZW5kPHN0YXJ0IHx8IGZlYXR1cmUuc3RhcnQ+ZW5kKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlcy5sZW5ndGggPCBtYXhGZWF0dXJlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXJ2b2lyIHNhbXBsaW5nLCAgY29uZGl0aW9uYWxseSByZXBsYWNlIGV4aXN0aW5nIGZlYXR1cmUgd2l0aCBuZXcgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbWF4RmVhdHVyZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzW2pdID0gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhbGxGZWF0dXJlcztcclxuICAgIH07XHJcblxyXG5cclxuICAgIHN0YXRpYyBwYXJzZUZpeGVkU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3MgPSBwYXJzZUludCh0b2tlbnNbMl0uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHN0ZXAgPSBwYXJzZUludCh0b2tlbnNbM10uc3BsaXQoXCI9XCIpWzFdLCAxMCksXHJcbiAgICAgICAgICAgIHNwYW4gPSAodG9rZW5zLmxlbmd0aCA+IDQpID8gcGFyc2VJbnQodG9rZW5zWzRdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtmb3JtYXQ6IFwiZml4ZWRTdGVwXCIsIGNocm9tOiBjYywgc3RhcnQ6IHNzLCBzdGVwOiBzdGVwLCBzcGFuOiBzcGFuLCBpbmRleDogMH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVZhcmlhYmxlU3RlcChsaW5lKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgIGNjID0gdG9rZW5zWzFdLnNwbGl0KFwiPVwiKVsxXSxcclxuICAgICAgICAgICAgc3BhbiA9IHRva2Vucy5sZW5ndGggPiAyID8gcGFyc2VJbnQodG9rZW5zWzJdLnNwbGl0KFwiPVwiKVsxXSwgMTApIDogMTtcclxuICAgICAgICByZXR1cm4ge2Zvcm1hdDogXCJ2YXJpYWJsZVN0ZXBcIiwgY2hyb206IGNjLCBzcGFuOiBzcGFufVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VUcmFja0xpbmUobGluZSkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge30sXHJcbiAgICAgICAgICAgIHRva2VucyA9IGxpbmUuc3BsaXQoLyg/OlwiKShbXlwiXSspKD86XCIpfChbXlxcc1wiXSspKD89XFxzK3wkKS9nKSxcclxuICAgICAgICAgICAgdG1wID0gW10sXHJcbiAgICAgICAgICAgIGksIHRrLCBjdXJyO1xyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCB0b2tlbnMgYXJyYXlcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdG9rZW5zW2ldIHx8IHRva2Vuc1tpXS50cmltKCkubGVuZ3RoID09PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIHRrID0gdG9rZW5zW2ldLnRyaW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ay5lbmRzV2l0aChcIj1cIikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gdGs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3Vycikge1xyXG4gICAgICAgICAgICAgICAgdG1wLnB1c2goY3VyciArIHRrKTtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0bXAucHVzaCh0ayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdG1wLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICBpZiAoIXN0cikgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIga3YgPSBzdHIuc3BsaXQoJz0nLCAyKTtcclxuICAgICAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2t2WzBdXSA9IGt2WzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSB0aGUgXCJzdGFuZGFyZFwiIFVDU0MgYmVkIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgZGVjb2RlZCBmZWF0dXJlLCBvciBudWxsIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgcmVjb3JkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVCZWQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgaWQsIG5hbWUsIHRtcCwgaWROYW1lLCBleG9uQ291bnQsIGV4b25TaXplcywgZXhvblN0YXJ0cywgZXhvbnMsIGV4b24sIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGVTdGFydCwgZUVuZDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICBlbmQgPSB0b2tlbnMubGVuZ3RoID4gMiA/IHBhcnNlSW50KHRva2Vuc1syXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHNjb3JlOiAxMDAwfTtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXNlIGFyZSB2ZXJ5IHNwZWNpYWwgcnVsZXMgZm9yIHRoZSBnZW5jb2RlIGdlbmUgZmlsZXMuXHJcbiAgICAgICAgICAgIHRtcCA9IHRva2Vuc1szXS5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgICAgIGlkTmFtZSA9IHRtcC5zcGxpdCgnOycpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkTmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGt2ID0gaWROYW1lW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa3ZbMF0gPT0gXCJnZW5lX2lkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IGt2WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGt2WzBdID09IFwiZ2VuZV9uYW1lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga3ZbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmVhdHVyZS5pZCA9IGlkID8gaWQgOiB0bXA7XHJcbiAgICAgICAgICAgIGZlYXR1cmUubmFtZSA9IG5hbWUgPyBuYW1lIDogdG1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNSkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnN0cmFuZCA9IHRva2Vuc1s1XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA2KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuY2RTdGFydCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNykge1xyXG4gICAgICAgICAgICBmZWF0dXJlLmNkRW5kID0gcGFyc2VJbnQodG9rZW5zWzddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbnNbOF0gIT09IFwiLlwiICYmIHRva2Vuc1s4XSAhPT0gXCIwXCIpXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRva2Vuc1s4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMTEpIHtcclxuICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzldKTtcclxuICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzExXS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIGVFbmQgPSBlU3RhcnQgKyBwYXJzZUludChleG9uU2l6ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4b24gPSB7c3RhcnQ6IGVTdGFydCwgZW5kOiBlRW5kfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID4gZUVuZCB8fCBmZWF0dXJlLmNkRW5kIDwgZmVhdHVyZS5jZFN0YXJ0KSBleG9uLnV0ciA9IHRydWU7ICAgLy8gRW50aXJlIGV4b24gaXMgVVRSXHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZFN0YXJ0ID49IGVTdGFydCAmJiBmZWF0dXJlLmNkU3RhcnQgPD0gZUVuZCkgZXhvbi5jZFN0YXJ0ID0gZmVhdHVyZS5jZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuY2RFbmQgPj0gZVN0YXJ0ICYmIGZlYXR1cmUuY2RFbmQgPD0gZUVuZCkgZXhvbi5jZEVuZCA9IGZlYXR1cmUuY2RFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZXhvbnMucHVzaChleG9uKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLm5hbWUpIGRhdGEucHVzaCh7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9KTtcclxuICAgICAgICAgICAgaWYgKFwiK1wiID09PSBmZWF0dXJlLnN0cmFuZCB8fCBcIi1cIiA9PT0gZmVhdHVyZS5zdHJhbmQpIGRhdGEucHVzaCh7bmFtZTogXCJTdHJhbmRcIiwgdmFsdWU6IGZlYXR1cmUuc3RyYW5kfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBhIFVDU0MgXCJyZWZmbGF0XCIgcmVjb3JkXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZVJlZmZsYXQodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAxMCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlID0ge1xyXG4gICAgICAgICAgICAgICAgY2hyOiB0b2tlbnNbMl0sXHJcbiAgICAgICAgICAgICAgICBzdGFydDogcGFyc2VJbnQodG9rZW5zWzRdKSxcclxuICAgICAgICAgICAgICAgIGVuZDogcGFyc2VJbnQodG9rZW5zWzVdKSxcclxuICAgICAgICAgICAgICAgIGlkOiB0b2tlbnNbMV0sXHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbnNbMF0sXHJcbiAgICAgICAgICAgICAgICBzdHJhbmQ6IHRva2Vuc1szXSxcclxuICAgICAgICAgICAgICAgIGNkU3RhcnQ6IHBhcnNlSW50KHRva2Vuc1s2XSksXHJcbiAgICAgICAgICAgICAgICBjZEVuZDogcGFyc2VJbnQodG9rZW5zWzddKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleG9uQ291bnQgPSBwYXJzZUludCh0b2tlbnNbOF0pLFxyXG4gICAgICAgICAgICBleG9uU3RhcnRzID0gdG9rZW5zWzldLnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgIGV4b25FbmRzID0gdG9rZW5zWzEwXS5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICBleG9ucyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBwYXJzZUludChleG9uU3RhcnRzW2ldKSwgZW5kOiBwYXJzZUludChleG9uRW5kc1tpXSl9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZlYXR1cmUuZXhvbnMgPSBleG9ucztcclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVQZWFrKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICBuYW1lID0gdG9rZW5zWzNdO1xyXG4gICAgICAgIHNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIHN0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgc2lnbmFsID0gcGFyc2VGbG9hdCh0b2tlbnNbNl0pO1xyXG4gICAgICAgIHBWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzddKTtcclxuICAgICAgICBxVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s4XSk7XHJcblxyXG4gICAgICAgIGlmIChzY29yZSA9PT0gMCkgc2NvcmUgPSBzaWduYWw7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBuYW1lOiBuYW1lLCBzY29yZTogc2NvcmUsIHN0cmFuZDogc3RyYW5kLCBzaWduYWw6IHNpZ25hbCxcclxuICAgICAgICAgICAgcFZhbHVlOiBwVmFsdWUsIHFWYWx1ZTogcVZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlQmVkR3JhcGgodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1szXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHZhbHVlOiB2YWx1ZX07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZyh0b2tlbnMsIHdpZykge1xyXG5cclxuICAgICAgICB2YXIgc3MsXHJcbiAgICAgICAgICAgIGVlLFxyXG4gICAgICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHdpZy5mb3JtYXQgPT09IFwiZml4ZWRTdGVwXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHNzID0gKHdpZy5pbmRleCAqIHdpZy5zdGVwKSArIHdpZy5zdGFydDtcclxuICAgICAgICAgICAgZWUgPSBzcyArIHdpZy5zcGFuO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzBdKTtcclxuICAgICAgICAgICAgKysod2lnLmluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IG51bGwgOiB7Y2hyOiB3aWcuY2hyb20sIHN0YXJ0OiBzcywgZW5kOiBlZSwgdmFsdWU6IHZhbHVlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2lnLmZvcm1hdCA9PT0gXCJ2YXJpYWJsZVN0ZXBcIikge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHNzID0gcGFyc2VJbnQodG9rZW5zWzBdLCAxMCk7XHJcbiAgICAgICAgICAgIGVlID0gc3MgKyB3aWcuc3BhbjtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBudWxsIDoge2Nocjogd2lnLmNocm9tLCBzdGFydDogc3MsIGVuZDogZWUsIHZhbHVlOiB2YWx1ZX07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJlZEdyYXBoKHRva2Vucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVBbmV1KHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHIsIHN0YXJ0LCBlbmQsIGZlYXR1cmU7XHJcblxyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDQpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIGVuZCA9IHRva2Vucy5sZW5ndGggPiAzID8gcGFyc2VJbnQodG9rZW5zWzNdKSA6IHN0YXJ0ICsgMTtcclxuXHJcbiAgICAgICAgZmVhdHVyZSA9IHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICBmZWF0dXJlLnZhbHVlID0gZmVhdHVyZS5zY29yZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUZ1c2lvbkp1bmNTcGFuKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIEZvcm1hdDpcclxuXHJcbiAgICAgICAgIDAgICAgICAgI3NjYWZmb2xkXHJcbiAgICAgICAgIDEgICAgICAgZnVzaW9uX2JyZWFrX25hbWVcclxuICAgICAgICAgMiAgICAgICBicmVha19sZWZ0XHJcbiAgICAgICAgIDMgICAgICAgYnJlYWtfcmlnaHRcclxuICAgICAgICAgNCAgICAgICBudW1fanVuY3Rpb25fcmVhZHNcclxuICAgICAgICAgNSAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3NcclxuICAgICAgICAgNiAgICAgICBzcGFubmluZ19mcmFnX2Nvb3Jkc1xyXG5cclxuICAgICAgICAgMCAgICAgICBCM0dOVDEtLU5QU1IxXHJcbiAgICAgICAgIDEgICAgICAgQjNHTlQxLS1OUFNSMXwyMjAzLTEwMTgyXHJcbiAgICAgICAgIDIgICAgICAgMjIwM1xyXG4gICAgICAgICAzICAgICAgIDEwMTgyXHJcbiAgICAgICAgIDQgICAgICAgMTg5XHJcbiAgICAgICAgIDUgICAgICAgMTEzOFxyXG4gICAgICAgICA2ICAgICAgIDE4NjAtMTM3NTcsMTc5OC0xMzgxOSwxMzkxLTE4MTI3LDE0NDMtMTcxNzQsLi4uXHJcblxyXG4gICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICB2YXIgZnVzaW9uX25hbWUgPSB0b2tlbnNbMV07XHJcbiAgICAgICAgdmFyIGp1bmN0aW9uX2xlZnQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIHZhciBqdW5jdGlvbl9yaWdodCA9IHBhcnNlSW50KHRva2Vuc1szXSk7XHJcbiAgICAgICAgdmFyIG51bV9qdW5jdGlvbl9yZWFkcyA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgdmFyIG51bV9zcGFubmluZ19mcmFncyA9IHBhcnNlSW50KHRva2Vuc1s1XSk7XHJcblxyXG4gICAgICAgIHZhciBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0ID0gdG9rZW5zWzZdO1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSA9IHtcclxuICAgICAgICAgICAgY2hyOiBjaHIsXHJcbiAgICAgICAgICAgIG5hbWU6IGZ1c2lvbl9uYW1lLFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9sZWZ0OiBqdW5jdGlvbl9sZWZ0LFxyXG4gICAgICAgICAgICBqdW5jdGlvbl9yaWdodDoganVuY3Rpb25fcmlnaHQsXHJcbiAgICAgICAgICAgIG51bV9qdW5jdGlvbl9yZWFkczogbnVtX2p1bmN0aW9uX3JlYWRzLFxyXG4gICAgICAgICAgICBudW1fc3Bhbm5pbmdfZnJhZ3M6IG51bV9zcGFubmluZ19mcmFncyxcclxuICAgICAgICAgICAgc3Bhbm5pbmdfZnJhZ19jb29yZHM6IFtdLFxyXG5cclxuICAgICAgICAgICAgc3RhcnQ6IC0xLFxyXG4gICAgICAgICAgICBlbmQ6IC0xXHJcbiAgICAgICAgfTsgLy8gc2V0IHN0YXJ0IGFuZCBlbmQgbGF0ZXIgYmFzZWQgb24gbWluL21heCBvZiBzcGFuIGNvb3Jkc1xyXG5cclxuICAgICAgICB2YXIgbWluX2Nvb3JkID0ganVuY3Rpb25fbGVmdDtcclxuICAgICAgICB2YXIgbWF4X2Nvb3JkID0ganVuY3Rpb25fcmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChudW1fc3Bhbm5pbmdfZnJhZ3MgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmRfcGFpcnMgPSBzcGFubmluZ19mcmFnX2Nvb3Jkc190ZXh0LnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkX3BhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRfY29vcmRzID0gY29vcmRfcGFpcnNbaV0uc3BsaXQoJy0nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3Bhbl9sZWZ0ID0gc3BsaXRfY29vcmRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5fcmlnaHQgPSBzcGxpdF9jb29yZHNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwYW5fbGVmdCA8IG1pbl9jb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb29yZCA9IHNwYW5fbGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzcGFuX3JpZ2h0ID4gbWF4X2Nvb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4X2Nvb3JkID0gc3Bhbl9yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuc3Bhbm5pbmdfZnJhZ19jb29yZHMucHVzaCh7bGVmdDogc3Bhbl9sZWZ0LCByaWdodDogc3Bhbl9yaWdodH0pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5zdGFydCA9IG1pbl9jb29yZDtcclxuICAgICAgICBmZWF0dXJlLmVuZCA9IG1heF9jb29yZDtcclxuXHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX1dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlR3RleEdXQVModG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgbmFtZSwgc2NvcmUsIHFWYWx1ZSwgc2lnbmFsLCBwVmFsdWU7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1szXS5zcGxpdCgnOicpWzFdKTtcclxuICAgICAgICAvL25hbWUgPSB0b2tlbnNbM107XHJcbiAgICAgICAgLy9zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICAvL3N0cmFuZCA9IHRva2Vuc1s1XS50cmltKCk7XHJcbiAgICAgICAgLy9zaWduYWwgPSBwYXJzZUZsb2F0KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgcFZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbNV0pO1xyXG4gICAgICAgIC8vcVZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbOF0pO1xyXG5cclxuICAgICAgICAvL3JldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIG5hbWU6IG5hbWUsIHNjb3JlOiBzY29yZSwgc3RyYW5kOiBzdHJhbmQsIHNpZ25hbDogc2lnbmFsLFxyXG4gICAgICAgIC8vICAgIHBWYWx1ZTogcFZhbHVlLCBxVmFsdWU6IHFWYWx1ZX07XHJcbiAgICAgICAgcmV0dXJuIHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcHZhbHVlOiBwVmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIGEgc2luZ2xlIGdmZiByZWNvcmQgKDEgbGluZSBpbiBmaWxlKS4gIEFnZ3JlZ2F0aW9ucyBzdWNoIGFzIGdlbmUgbW9kZWxzIGFyZSBjb25zdHJ1Y3RlZCBhdCBhIGhpZ2hlciBsZXZlbC5cclxuICAgICAqICAgICAgY3RnMTIzIC4gbVJOQSAgICAgICAgICAgIDEwNTAgIDkwMDAgIC4gICsgIC4gIElEPW1STkEwMDAwMTtQYXJlbnQ9Z2VuZTAwMDAxXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZUdGRih0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5Db3VudCwgY2hyLCBzdGFydCwgZW5kLCBzdHJhbmQsIHR5cGUsIHNjb3JlLCBwaGFzZSwgYXR0cmlidXRlU3RyaW5nLCBpZCwgcGFyZW50LCBjb2xvciwgbmFtZSxcclxuICAgICAgICAgICAgdHJhbnNjcmlwdF9pZCwgaSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b2tlbkNvdW50IDwgOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgICAgICAvLyBOb3QgYSB2YWxpZCBnZmYgcmVjb3JkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgdHlwZSA9IHRva2Vuc1syXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1szXSkgLSAxO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgc2NvcmUgPSBcIi5cIiA9PT0gdG9rZW5zWzVdID8gMCA6IHBhcnNlRmxvYXQodG9rZW5zWzVdKTtcclxuICAgICAgICBzdHJhbmQgPSB0b2tlbnNbNl07XHJcbiAgICAgICAgcGhhc2UgPSBcIi5cIiA9PT0gdG9rZW5zWzddID8gMCA6IHBhcnNlSW50KHRva2Vuc1s3XSk7XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nID0gdG9rZW5zWzhdO1xyXG5cclxuICAgICAgICAvLyBGaW5kIElEIGFuZCBQYXJlbnQsIG9yIHRyYW5zY3JpcHRfaWRcclxuICAgICAgICB2YXIgZGVsaW0gPSAoJ2dmZjMnID09PSBmb3JtYXQpID8gJz0nIDogL1xccysvO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlU3RyaW5nLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBrdi50cmltKCkuc3BsaXQoZGVsaW0sIDIpLCBrZXksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gdFswXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgcXVvdGVzLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJJRFwiID09PSB0WzBdKSBpZCA9IHRbMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIlBhcmVudFwiID09PSB0WzBdKSBwYXJlbnQgPSB0WzFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJjb2xvclwiID09PSB0WzBdLnRvTG93ZXJDYXNlKCkpIGNvbG9yID0gaWd2LmNyZWF0ZUNvbG9yU3RyaW5nKHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJ0cmFuc2NyaXB0X2lkXCIgPT09IHRbMF0pIGlkID0gdFsxXTsgICAgIC8vIGd0ZiBmb3JtYXRcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgbmFtZSAobGFiZWwpIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKHRoaXMubmFtZUZpZWxkKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGVzW3RoaXMubmFtZUZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZmZOYW1lRmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShnZmZOYW1lRmllbGRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZUZpZWxkID0gZ2ZmTmFtZUZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlc1t0aGlzLm5hbWVGaWVsZF07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGNocjogY2hyLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICBzY29yZTogc2NvcmUsXHJcbiAgICAgICAgICAgIHN0cmFuZDogc3RyYW5kLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZVN0cmluZzogYXR0cmlidXRlU3RyaW5nLFxyXG4gICAgICAgICAgICBwb3B1cERhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrdnMgPSB0aGlzLmF0dHJpYnV0ZVN0cmluZy5zcGxpdCgnOycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBkID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGt2cy5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga3YudHJpbSgpLnNwbGl0KGRlbGltLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPT09IDIgJiYgdFsxXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHRbMF0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRbMV0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1N0cmlwIG9mZiBxdW90ZXMsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXCInKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGQucHVzaCh7bmFtZToga2V5LCB2YWx1ZTogdmFsdWV9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIHRoZSBcInN0YW5kYXJkXCIgVUNTQyBiZWQgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyBkZWNvZGVkIGZlYXR1cmUsIG9yIG51bGwgaWYgdGhpcyBpcyBub3QgYSB2YWxpZCByZWNvcmRcclxuICAgICAqL1xyXG4gICAgZGVjb2RlQ3VzdG9tKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlLFxyXG4gICAgICAgICAgICBjaHIsIHN0YXJ0LCBlbmQsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0LCAgICAgICAgIC8vIFwidGhpc1wiIHJlZmVycyB0byBGZWF0dXJlUGFyc2VyIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvb3JkcyA9IGZvcm1hdC5jb29yZHMgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zW2Zvcm1hdC5jaHJdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zW2Zvcm1hdC5zdGFydF0pIC0gY29vcmRzO1xyXG4gICAgICAgIGVuZCA9IGZvcm1hdC5lbmQgIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHRva2Vuc1tmb3JtYXQuZW5kXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xyXG5cclxuICAgICAgICBpZiAoZm9ybWF0LmZpZWxkcykge1xyXG4gICAgICAgICAgICBmb3JtYXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IGZvcm1hdC5jaHIgJiYgaW5kZXggIT0gZm9ybWF0LnN0YXJ0ICYmIGluZGV4ICE9IGZvcm1hdC5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKipqcy9mZWF0dXJlL2ZlYXR1cmVDYWNoZS5qcyoqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYmplY3QgZm9yIGNhY2hpbmcgbGlzdHMgb2YgZmVhdHVyZXMuICBTdXBwb3J0cyBlZmZlY2llbnQgcXVlcmllcyBmb3Igc3ViLXJhbmdlICAoY2hyLCBzdGFydCwgZW5kKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlTGlzdFxyXG4gICAgICogQHBhcmFtIFRoZSBnZW5vbWljIHJhbmdlIHNwYW5uZWQgYnkgZmVhdHVyZUxpc3QgKG9wdGlvbmFsKVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuXHJcbmNsYXNzIEZlYXR1cmVDYWNoZXtcclxuICAgIGNvbnN0cnVjdG9yKGZlYXR1cmVMaXN0LCByYW5nZSkge1xyXG4gICAgICAgIHRoaXMudHJlZU1hcCA9IEZlYXR1cmVDYWNoZS5idWlsZFRyZWVNYXAoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICBxdWVyeUZlYXR1cmVzKGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmVMaXN0LCBpbnRlcnZhbEZlYXR1cmVzLCBmZWF0dXJlLCBsZW4sIGksIHRyZWUsIGludGVydmFscztcclxuXHJcbiAgICAgICAgdHJlZSA9IHRoaXMudHJlZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICBpZiAoIXRyZWUpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgaW50ZXJ2YWxzID0gdHJlZS5maW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcnZhbHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVHJpbSB0aGUgbGlzdCBvZiBmZWF0dXJlcyBpbiB0aGUgaW50ZXJ2YWxzIHRvIHRob3NlXHJcbiAgICAgICAgICAgIC8vIG92ZXJsYXBwaW5nIHRoZSByZXF1ZXN0ZWQgcmFuZ2UuXHJcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IGZlYXR1cmVzIGFyZSBzb3J0ZWQgYnkgc3RhcnQgcG9zaXRpb25cclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gW107XHJcblxyXG4gICAgICAgICAgICBpbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsRmVhdHVyZXMgPSBpbnRlcnZhbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGludGVydmFsRmVhdHVyZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IGludGVydmFsRmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBlbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlYXR1cmUuZW5kID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0LnB1c2goZmVhdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZUxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgYWxsRmVhdHVyZXMoKSB7XHJcblxyXG4gICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0cmVlTWFwID0gdGhpcy50cmVlTWFwO1xyXG4gICAgICAgIGlmICh0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmVlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJlZU1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlID0gdHJlZU1hcFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyZWUubWFwSW50ZXJ2YWxzKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGFsbEZlYXR1cmVzLmNvbmNhdChpbnRlcnZhbC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbEZlYXR1cmVzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYnVpbGRUcmVlTWFwKGZlYXR1cmVMaXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlQ2FjaGUgPSB7fSxcclxuICAgICAgICAgICAgY2hyb21vc29tZXMgPSBbXSxcclxuICAgICAgICAgICAgdHJlZU1hcCA9IHt9LFxyXG4gICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hyID0gZmVhdHVyZS5jaHIsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VuZUxpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIFwib2ZmaWNpYWxcIiBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZihnZW5vbWUpIGNociA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShjaHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdlbmVMaXN0ID0gZmVhdHVyZUNhY2hlW2Nocl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFnZW5lTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9tb3NvbWVzLnB1c2goY2hyKTtcclxuICAgICAgICAgICAgICAgICAgICBnZW5lTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVDYWNoZVtjaHJdID0gZ2VuZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VuZUxpc3QucHVzaChmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBidWlsZCBpbnRlcnZhbCB0cmVlIGZvciBlYWNoIGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hyb21vc29tZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaHIgPSBjaHJvbW9zb21lc1tpXTtcclxuICAgICAgICAgICAgICAgIHRyZWVNYXBbY2hyXSA9RmVhdHVyZUNhY2hlLmJ1aWxkSW50ZXJ2YWxUcmVlKGZlYXR1cmVDYWNoZVtjaHJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWVNYXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYW4gaW50ZXJ2YWwgdHJlZSBmcm9tIHRoZSBmZWF0dXJlIGxpc3QgZm9yIGZhc3QgaW50ZXJ2YWwgYmFzZWQgcXVlcmllcy4gICBXZSBsdW1wIGZlYXR1cmVzIGluIGdyb3Vwc1xyXG4gICAgICogb2YgMTAsIG9yIHRvdGFsIHNpemUgLyAxMDAsICAgdG8gcmVkdWNlIHNpemUgb2YgdGhlIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVMaXN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBidWlsZEludGVydmFsVHJlZShmZWF0dXJlTGlzdCkge1xyXG5cclxuICAgICAgICB2YXIgaSwgZSwgaVN0YXJ0LCBpRW5kLCB0cmVlLCBjaHVua1NpemUsIGxlbiwgc3ViQXJyYXk7XHJcblxyXG4gICAgICAgIHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICAgICAgbGVuID0gZmVhdHVyZUxpc3QubGVuZ3RoO1xyXG5cclxuICAgICAgICBjaHVua1NpemUgPSBNYXRoLm1heCgxMCwgTWF0aC5yb3VuZChsZW4gLyAxMDApKTtcclxuXHJcbiAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoZjEsIGYyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZjEuc3RhcnQgPT09IGYyLnN0YXJ0ID8gMCA6IChmMS5zdGFydCA+IGYyLnN0YXJ0ID8gMSA6IC0xKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLm1pbihsZW4sIGkgKyBjaHVua1NpemUpO1xyXG4gICAgICAgICAgICBzdWJBcnJheSA9IGZlYXR1cmVMaXN0LnNsaWNlKGksIGUpO1xyXG4gICAgICAgICAgICBpU3RhcnQgPSBzdWJBcnJheVswXS5zdGFydDtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgaUVuZCA9IGlTdGFydDtcclxuICAgICAgICAgICAgc3ViQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaUVuZCA9IE1hdGgubWF4KGlFbmQsIGZlYXR1cmUuZW5kKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRyZWUuaW5zZXJ0KGlTdGFydCwgaUVuZCwgc3ViQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuLy8qKioqKmpzL2ludGVydmFsVHJlZS5qcyoqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMQUNLID0gMTtcclxuY29uc3QgUkVEID0gMjtcclxuXHJcbmxldCBOSUwgPSB7fVxyXG5OSUwuY29sb3IgPSBCTEFDSztcclxuTklMLnBhcmVudCA9IE5JTDtcclxuTklMLmxlZnQgPSBOSUw7XHJcbk5JTC5yaWdodCA9IE5JTDtcclxuXHJcbiAgXHJcbmNsYXNzIEludGVydmFsVHJlZXtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyAgICBcclxuICAgICAgICB0aGlzLnJvb3QgPSBOSUw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGluc2VydChzdGFydCwgZW5kLCB2YWx1ZSkge1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnQsIGVuZCwgdmFsdWUpO1xyXG4gICAgICAgIHZhciB4ID0gbmV3IE5vZGUoaW50ZXJ2YWwpO1xyXG4gICAgICAgIHRoaXMudHJlZUluc2VydCh4KTtcclxuICAgICAgICB4LmNvbG9yID0gUkVEO1xyXG4gICAgICAgIHdoaWxlICh4ICE9IHRoaXMucm9vdCAmJiB4LnBhcmVudC5jb2xvciA9PSBSRUQpIHtcclxuICAgICAgICAgICAgaWYgKHgucGFyZW50ID09IHgucGFyZW50LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHgucGFyZW50LnBhcmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4LnBhcmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB4LnBhcmVudC5wYXJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIGlmICh5LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeS5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFJvdGF0ZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Um90YXRlKHgucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb290LmNvbG9yID0gQkxBQ0s7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGFydCAtIHF1ZXJ5IGludGVydmFsXHJcbiAgICAgKiBAcGFyYW0gZW5kIC0gcXVlcnkgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCBpbnRlcnZhbHMgb3ZlcmxhcHBpbmcgdGhlIHF1ZXJ5IHJlZ2lvblxyXG4gICAgICovXHJcbiAgICBmaW5kT3ZlcmxhcHBpbmcoc3RhcnQsIGVuZCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHNlYXJjaEludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0LCBlbmQsIDApO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSBOSUwpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgdmFyIGludGVydmFscyA9IHRoaXMuc2VhcmNoQWxsKHNlYXJjaEludGVydmFsLCB0aGlzLnJvb3QsIFtdKTtcclxuXHJcbiAgICAgICAgaWYoaW50ZXJ2YWxzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oaTEsIGkyKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGkxLmxvdyAtIGkyLmxvdztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHVtcCBpbmZvIG9uIGludGVydmFscyB0byBjb25zb2xlLiAgRm9yIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG4gICAgbG9nSW50ZXJ2YWxzKCkge1xyXG5cclxuICAgICAgICBsb2dOb2RlKHRoaXMucm9vdCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvZ05vZGUobm9kZSwgaW5kZW50KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpbmRlbnQ7IGkrKykgc3BhY2UgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwYWNlICsgbm9kZS5pbnRlcnZhbC5sb3cgKyBcIiBcIiArIG5vZGUuaW50ZXJ2YWwuaGlnaCk7IC8vICsgXCIgXCIgKyAobm9kZS5pbnRlcnZhbC52YWx1ZSA/IG5vZGUuaW50ZXJ2YWwudmFsdWUgOiBcIiBudWxsXCIpKTtcclxuXHJcbiAgICAgICAgICAgIGluZGVudCArPSA1O1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5sZWZ0ICE9IE5JTCkgbG9nTm9kZShub2RlLmxlZnQsIGluZGVudCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBsb2dOb2RlKG5vZGUucmlnaHQsIGluZGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbWFwSW50ZXJ2YWxzKGZ1bmMpIHtcclxuXHJcbiAgICAgICAgYXBwbHlJbnRlcnZhbCh0aGlzLnJvb3QpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhcHBseUludGVydmFsKG5vZGUpIHtcclxuXHJcbiAgICAgICAgICAgIGZ1bmMobm9kZS5pbnRlcnZhbCk7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmxlZnQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucmlnaHQgIT0gTklMKSBhcHBseUludGVydmFsKG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUsIHJlc3VsdHMpIHtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuaW50ZXJ2YWwub3ZlcmxhcHMoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlLmludGVydmFsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLmxlZnQgIT0gTklMICYmIG5vZGUubGVmdC5tYXggPj0gaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQWxsKGludGVydmFsLCBub2RlLmxlZnQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUucmlnaHQgIT0gTklMICYmIG5vZGUucmlnaHQubWluIDw9IGludGVydmFsLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUucmlnaHQsIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgbGVmdFJvdGF0ZSh4KSB7XHJcbiAgICAgICAgdmFyIHkgPSB4LnJpZ2h0O1xyXG4gICAgICAgIHgucmlnaHQgPSB5LmxlZnQ7XHJcbiAgICAgICAgaWYgKHkubGVmdCAhPSBOSUwpIHtcclxuICAgICAgICAgICAgeS5sZWZ0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5sZWZ0ID09IHgpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LmxlZnQgPSB5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQucmlnaHQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJpZ2h0Um90YXRlKHgpIHtcclxuICAgICAgICB2YXIgeSA9IHgubGVmdDtcclxuICAgICAgICB4LmxlZnQgPSB5LnJpZ2h0O1xyXG4gICAgICAgIGlmICh5LnJpZ2h0ICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5LnJpZ2h0LnBhcmVudCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHgucGFyZW50ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudC5yaWdodCA9PSB4KSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5yaWdodCA9IHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5sZWZ0ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gYXBwbHkgdXBkYXRlIG9uIHksIHNpbmNlIGl0J2xsIHkgaXMgYW4gYW5jZXN0b3JcclxuICAgICAgICAvLyBvZiB4LCBhbmQgd2lsbCBiZSB0b3VjaGVkIGJ5IGFwcGx5VXBkYXRlKCkuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90ZTogIERvZXMgbm90IG1haW50YWluIFJCIGNvbnN0cmFpbnRzLCAgdGhpcyBpcyBkb25lIHBvc3QgaW5zZXJ0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggIGEgTm9kZVxyXG4gICAgICovXHJcbiAgIHRyZWVJbnNlcnQoeCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHZhciB5ID0gTklMO1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5ID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKHguaW50ZXJ2YWwubG93IDw9IG5vZGUuaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuICAgICAgICBpZiAoeSA9PSBOSUwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0geDtcclxuICAgICAgICAgICAgeC5sZWZ0ID0geC5yaWdodCA9IE5JTDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeC5pbnRlcnZhbC5sb3cgPD0geS5pbnRlcnZhbC5sb3cpIHtcclxuICAgICAgICAgICAgICAgIHkubGVmdCA9IHg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5LnJpZ2h0ID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZSh4KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQXBwbGllcyB0aGUgc3RhdGlzdGljIHVwZGF0ZSBvbiB0aGUgbm9kZSBhbmQgaXRzIGFuY2VzdG9ycy5cclxuICAgIGFwcGx5VXBkYXRlIChub2RlKSB7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlTWF4ID0gbm9kZS5sZWZ0Lm1heCA+IG5vZGUucmlnaHQubWF4ID8gbm9kZS5sZWZ0Lm1heCA6IG5vZGUucmlnaHQubWF4O1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxIaWdoID0gbm9kZS5pbnRlcnZhbC5oaWdoO1xyXG4gICAgICAgICAgICBub2RlLm1heCA9IG5vZGVNYXggPiBpbnRlcnZhbEhpZ2ggPyBub2RlTWF4IDogaW50ZXJ2YWxIaWdoO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vZGVNaW4gPSBub2RlLmxlZnQubWluIDwgbm9kZS5yaWdodC5taW4gPyBub2RlLmxlZnQubWluIDogbm9kZS5yaWdodC5taW47XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbExvdyA9IG5vZGUuaW50ZXJ2YWwubG93O1xyXG4gICAgICAgICAgICBub2RlLm1pbiA9IG5vZGVNaW4gPCBpbnRlcnZhbExvdyA/IG5vZGVNaW4gOiBpbnRlcnZhbExvdztcclxuXHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgSW50ZXJ2YWwge1xyXG4gICAgY29uc3RydWN0b3IobG93LCBoaWdoLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93O1xyXG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIW90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgPT0gb3RoZXJJbnRlcnZhbC5sb3cgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09IG90aGVySW50ZXJ2YWwuaGlnaCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPCBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAodGhpcy5sb3cgPiBvdGhlci5sb3cpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oaWdoIDwgb3RoZXIuaGlnaClcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmhpZ2ggPiBvdGhlci5oaWdoKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBpbnRlcnZhbCBvdmVybGFwcyB0aGUgb3RoZXIuXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBzKG90aGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA8PSBvdGhlci5oaWdoICYmIG90aGVyLmxvdyA8PSB0aGlzLmhpZ2gpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy9hbGVydChlKTtcclxuICAgICAgICAgICAgaWd2LnByZXNlbnRBbGVydChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE5vZGV7XHJcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gTklMO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IE5JTDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gTklMO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gUkVEO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBHZW5vbWljSW50ZXJ2YWx7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgZmVhdHVyZXMpIHtcclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zIChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT09IHJhbmdlLmNociAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDw9IHJhbmdlLnN0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZW5kID49IHJhbmdlLmVuZDtcclxuICAgIH1cclxuICAgIHJhbmdlc1RvR2V0KHJhbmdlKXtcclxuICAgICAgICBsZXQgbmVlZHNfcmFuZ2U9ZmFsc2U7XHJcbiAgICAgICAgbGV0IHJhbmdlcz17fTtcclxuICAgICAgICBpZiAodGhpcy5jaHIgIT09IHJhbmdlLmNocil7XHJcbiAgICAgICAgICAgIHJhbmdlcy5hbGw9W3JhbmdlLnN0YXJ0LHJhbmdlLmVuZF07XHJcbiAgICAgICAgICAgIG5lZWRzX3JhbmdlPXRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQ9cmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kPXJhbmdlLmVuZDtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7ICAgXHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydDx0aGlzLnN0YXJ0KXtcclxuICAgICAgICAgICAgICAgIHJhbmdlcy5sZWZ0PVtyYW5nZS5zdGFydCx0aGlzLnN0YXJ0XTtcclxuICAgICAgICAgICAgICAgIG5lZWRzX3JhbmdlPXRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0PXJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmQ+dGhpcy5lbmQpe1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnJpZ2h0PVt0aGlzLmVuZCxyYW5nZS5lbmRdO1xyXG4gICAgICAgICAgICAgICAgbmVlZHNfcmFuZ2U9dHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kPXJhbmdlLmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5lZWRzX3JhbmdlKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEZhc3RhU2VxdWVuY2V7XHJcblxyXG4gICAgY29uc3RydWN0b3IodXJsKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsZSA9IHVybDtcclxuICAgICAgICB0aGlzLmluZGV4ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleEZpbGUgPSB0aGlzLmZpbGUgKyBcIi5mYWlcIjtcclxuICAgICAgICB9XHJcbiAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICBpbml0KCl7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuaW5kZXhlZCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicExlbmd0aCA9IHNlbGYuaW5kZXhbY2hyTmFtZV0uc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lc1tjaHJOYW1lXSA9IG5ldyBpZ3YuQ2hyb21vc29tZShjaHJOYW1lLCBvcmRlcisrLCBicExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW5kZXgsIGdldHRpbmcgY2hyIG5hbWVzIGFzIGEgc2lkZSBlZmZlY3QuICBSZWFsbHkgYmFkIHByYWN0aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5sb2FkQWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXF1ZW5jZShjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXF1ZW5jZUluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRTZXF1ZW5jZU5vbkluZGV4ZWQudGhpcyhjaHIsIHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFNlcXVlbmNlSW5kZXhlZChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZWxmLmludGVydmFsO1xyXG5cclxuICAgICAgICAgICAgaWYgKGludGVydmFsICYmIGludGVydmFsLmNvbnRhaW5zKGNociwgc3RhcnQsIGVuZCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGdldFNlcXVlbmNlRnJvbUludGVydmFsKGludGVydmFsLCBzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhY2hlIG1pc3M6IFwiICsgKGludGVydmFsID09PSB1bmRlZmluZWQgPyBcIm5pbFwiIDogaW50ZXJ2YWwuY2hyICsgXCI6XCIgKyBpbnRlcnZhbC5zdGFydCArIFwiLVwiICsgaW50ZXJ2YWwuZW5kKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIHF1ZXJ5LCB0byBtaW5pbXVtIG9mIDEwMGtiXHJcbiAgICAgICAgICAgICAgICB2YXIgcXN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcWVuZCA9IGVuZDtcclxuICAgICAgICAgICAgICAgIGlmICgoZW5kIC0gc3RhcnQpIDwgMTAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAoZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgdyAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHFzdGFydCA9IE1hdGgubWF4KDAsIGNlbnRlciAtIDUwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICBxZW5kID0gY2VudGVyICsgNTAwMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYucmVhZFNlcXVlbmNlKGNociwgcXN0YXJ0LCBxZW5kKS50aGVuKGZ1bmN0aW9uIChzZXFCeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW50ZXJ2YWwgPSBuZXcgR2Vub21pY0ludGVydmFsKGNociwgcXN0YXJ0LCBxZW5kLCBzZXFCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChzZWxmLmludGVydmFsLCBzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0IC0gaW50ZXJ2YWwuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcSA9IGludGVydmFsLmZlYXR1cmVzID8gaW50ZXJ2YWwuZmVhdHVyZXMuc3Vic3RyKG9mZnNldCwgbikgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRTZXF1ZW5jZU5vbkluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHNlcSA9IHNlbGYuc2VxdWVuY2VzW2Nocl07XHJcbiAgICAgICAgICAgIGlmIChzZXEgJiYgc2VxLmxlbmd0aCA+IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZXEuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRJbmRleCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5pbmRleCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZChzZWxmLmluZGV4RmlsZSx7fSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU5vID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMgPSBbXTsgICAgIC8vIFRPRE8gLS0gZWxpbWluYXRlIHRoaXMgc2lkZSBlZmZlY3QgISEhIVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXggPSB7fTsgICAgICAgICAgICAgICAvLyBUT0RPIC0tIGRpdHRvXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpbmVObyA8IGxlbikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmVzW2xpbmVObysrXS5zcGxpdChcIlxcdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoblRva2VucyA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW5kZXggbGluZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VzUGVyTGluZSA9IHBhcnNlSW50KHRva2Vuc1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNQZXJMaW5lID0gcGFyc2VJbnQodG9rZW5zWzRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhFbnRyeSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLCBwb3NpdGlvbjogcG9zaXRpb24sIGJhc2VzUGVyTGluZTogYmFzZXNQZXJMaW5lLCBieXRlc1BlckxpbmU6IGJ5dGVzUGVyTGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4W2Nocl0gPSBpbmRleEVudHJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVsZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkQWxsKCl7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lcyA9IHt9O1xyXG4gICAgICAgICAgICBzZWxmLnNlcXVlbmNlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5maWxlLCB7XHJcbiAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdExpbmVzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVObyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlcSA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENocixcclxuICAgICAgICAgICAgICAgICAgICBvcmRlciA9IDA7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lTm8gPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IGxpbmVzW2xpbmVObysrXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMaW5lLnN0YXJ0c1dpdGgoXCIjXCIpIHx8IG5leHRMaW5lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dExpbmUuc3RhcnRzV2l0aChcIj5cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzLnB1c2goY3VycmVudENocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlc1tjdXJyZW50Q2hyXSA9IGN1cnJlbnRTZXE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzW2N1cnJlbnRDaHJdID0gbmV3IGlndi5DaHJvbW9zb21lKGN1cnJlbnRDaHIsIG9yZGVyKyssIGN1cnJlbnRTZXEubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hyID0gbmV4dExpbmUuc3Vic3RyKDEpLnNwbGl0KFwiXFxcXHMrXCIpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VxID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXEgKz0gbmV4dExpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlYWRTZXF1ZW5jZShjaHIsIHFzdGFydCwgcWVuZCkge1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZCBzZXF1ZW5jZSBcIiArIGNociArIFwiOlwiICsgcXN0YXJ0ICsgXCItXCIgKyBxZW5kKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuZ2V0SW5kZXgoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaWR4RW50cnkgPSBzZWxmLmluZGV4W2Nocl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlkeEVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBpbmRleCBlbnRyeSBmb3IgY2hyOiBcIiArIGNocik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRhZyBpbnRlcnZhbCB3aXRoIG51bGwgc28gd2UgZG9uJ3QgdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBxc3RhcnQsIHFlbmQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgcXN0YXJ0KTsgICAgLy8gcXN0YXJ0IHNob3VsZCBuZXZlciBiZSA8IDBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oaWR4RW50cnkuc2l6ZSwgcWVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzUGVyTGluZSA9IGlkeEVudHJ5LmJ5dGVzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZXNQZXJMaW5lID0gaWR4RW50cnkuYmFzZXNQZXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGlkeEVudHJ5LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuRW5kQnl0ZXMgPSBieXRlc1BlckxpbmUgLSBiYXNlc1BlckxpbmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBNYXRoLmZsb29yKHN0YXJ0IC8gYmFzZXNQZXJMaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTGluZSA9IE1hdGguZmxvb3IoZW5kIC8gYmFzZXNQZXJMaW5lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UwID0gc3RhcnRMaW5lICogYmFzZXNQZXJMaW5lOyAgIC8vIEJhc2UgYXQgYmVnaW5uaW5nIG9mIHN0YXJ0IGxpbmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0IC0gYmFzZTA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEJ5dGUgPSBwb3NpdGlvbiArIHN0YXJ0TGluZSAqIGJ5dGVzUGVyTGluZSArIG9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UxID0gZW5kTGluZSAqIGJhc2VzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IGVuZCAtIGJhc2UxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRCeXRlID0gcG9zaXRpb24gKyBlbmRMaW5lICogYnl0ZXNQZXJMaW5lICsgb2Zmc2V0MSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IGVuZEJ5dGUgLSBzdGFydEJ5dGUgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5maWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHN0YXJ0Qnl0ZSwgc2l6ZTogYnl0ZUNvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFsbEJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbkJhc2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxQnl0ZXMgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUG9zID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc1BvcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxCeXRlc0xlbmd0aCA9IGFsbEJ5dGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuQmFzZXMgPSBNYXRoLm1pbihlbmQgLSBzdGFydCwgYmFzZXNQZXJMaW5lIC0gb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzICs9IGFsbEJ5dGVzLnN1YnN0cihzcmNQb3MsIG5CYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQb3MgKz0gKG5CYXNlcyArIG5FbmRCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgKz0gbkJhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3JjUG9zIDwgYWxsQnl0ZXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5CYXNlcyA9IE1hdGgubWluKGJhc2VzUGVyTGluZSwgYWxsQnl0ZXNMZW5ndGggLSBzcmNQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxQnl0ZXMgKz0gYWxsQnl0ZXMuc3Vic3RyKHNyY1BvcywgbkJhc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BvcyArPSAobkJhc2VzICsgbkVuZEJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc1BvcyArPSBuQmFzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VxQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtGZWF0dXJlU291cmNlLEZhc3RhU2VxdWVuY2UsQmlnQmVkRmVhdHVyZVNvdXJjZSxUYWJpeEJlZEZlYXR1cmVTb3VyY2V9Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBbkJBO0FBQ0E7QUFxQkE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUNBO0FBRUE7QUFDQTtBQUpBO0FBS0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBSEE7QUFIQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0RBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQTBlQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQXRnQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUVBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFnQ0E7Ozs7OztBQXVDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/feature.js\n");

/***/ }),

/***/ "../MLVPanel/src/igvxhr.js":
/*!****************************!*\
  !*** .Panel/src/igvxhr.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.unbgzf = exports.igvxhr = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _inflate = __webpack_require__(/*! ./vendor/inflate.js */ \"../MLVPanel/src/vendor/inflate.js\");\n\nvar _zlib_and_gzip = __webpack_require__(/*! ./vendor/zlib_and_gzip.js */ \"../MLVPanel/src/vendor/zlib_and_gzip.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar is_node = false;\ntry {\n    navigator;\n} catch (e) {\n    is_node = true;\n}\n\nvar NONE = 0;\nvar GZIP = 1;\nvar BGZF = 2;\n\nvar igvxhr = function () {\n    function igvxhr() {\n        _classCallCheck(this, igvxhr);\n    }\n\n    _createClass(igvxhr, null, [{\n        key: \"load\",\n\n\n        // Compression types\n\n\n        value: function load(url, options) {\n\n            return new Promise(function (fulfill, reject) {\n                var xhr = new XMLHttpRequest(),\n                    sendData = options.sendData,\n                    method = options.method || (sendData ? \"POST\" : \"GET\"),\n                    range = options.range,\n                    responseType = options.responseType,\n                    contentType = options.contentType,\n                    mimeType = options.mimeType,\n                    headers = options.headers,\n                    isSafari = is_node ? false : navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent),\n                    withCredentials = options.withCredentials,\n                    header_keys,\n                    key,\n                    value,\n                    i;\n\n                // Support for GCS paths.\n                //url = url.startsWith(\"gs://\") ? igv.Google.translateGoogleCloudURL(url) : url;\n\n\n                /* if (igv.Google.isGoogleURL(url)) {\r\n                       url = igv.Google.addApiKey(url);\r\n                       // Add google headers (e.g. oAuth)\r\n                     headers = headers || {};\r\n                     igv.Google.addGoogleHeaders(headers);\r\n                       // Hack to prevent caching for google storage files.  Get weird net:err-cache errors otherwise\r\n                     if (range) {\r\n                         url += url.includes(\"?\") ? \"&\" : \"?\";\r\n                         url += \"someRandomSeed=\" + Math.random().toString(36);\r\n                     }\r\n                 }\r\n                 */\n\n                xhr.open(method, url);\n\n                if (range) {\n                    var rangeEnd = range.size ? range.start + range.size - 1 : \"\";\n                    xhr.setRequestHeader(\"Range\", \"bytes=\" + range.start + \"-\" + rangeEnd);\n                }\n                if (contentType) {\n                    xhr.setRequestHeader(\"Content-Type\", contentType);\n                }\n                if (mimeType) {\n                    xhr.overrideMimeType(mimeType);\n                }\n                if (responseType) {\n                    xhr.responseType = responseType;\n                }\n                if (headers) {\n                    header_keys = Object.keys(headers);\n                    for (i = 0; i < header_keys.length; i++) {\n                        key = header_keys[i];\n                        value = headers[key];\n                        // console.log(\"Adding to header: \" + key + \"=\" + value);\n                        xhr.setRequestHeader(key, value);\n                    }\n                }\n\n                // NOTE: using withCredentials with servers that return \"*\" for access-allowed-origin will fail\n                if (withCredentials === true) {\n                    xhr.withCredentials = true;\n                }\n                xhr.timeout = 30000;\n\n                xhr.onload = function (event) {\n                    // when the url points to a local file, the status is 0 but that is no error\n                    if (xhr.status == 0 || xhr.status >= 200 && xhr.status <= 300) {\n\n                        if (range && xhr.status != 206) {\n                            handleError(\"ERROR: range-byte header was ignored for url: \" + url);\n                        } else {\n\n                            fulfill(xhr.response, xhr);\n                        }\n                    } else {\n\n                        //\n                        if (xhr.status === 416) {\n                            //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an\n                            handleError(\"Unsatisfiable range\");\n                        } else {\n                            // TODO -- better error handling\n                            handleError(\"Error accessing resource: \" + xhr.status);\n                        }\n                    }\n                };\n\n                xhr.onerror = function (event) {\n                    handleError(\"Error accessing resource: \" + url + \" Status: \" + xhr.status);\n                };\n\n                xhr.ontimeout = function (event) {\n                    handleError(\"Timed out\");\n                };\n\n                xhr.onabort = function (event) {\n                    console.log(\"Aborted\");\n                    reject(new igv.AbortLoad());\n                };\n\n                try {\n\n                    xhr.send(sendData);\n                } catch (e) {\n                    reject(e);\n                }\n\n                function handleError(message) {\n                    if (reject) {\n                        reject(message);\n                    } else {\n                        throw Error(message);\n                    }\n                }\n            });\n        }\n    }, {\n        key: \"loadArrayBuffer\",\n        value: function loadArrayBuffer(url, options) {\n\n            if (options === undefined) options = {};\n            options.responseType = \"arraybuffer\";\n            return igvxhr.load(url, options);\n        }\n    }, {\n        key: \"loadJson\",\n        value: function loadJson(url, options) {\n\n            var method = options.method || (options.sendData ? \"POST\" : \"GET\");\n\n            if (method == \"POST\") options.contentType = \"application/json\";\n\n            return new Promise(function (fulfill, reject) {\n\n                igvxhr.load(url, options).then(function (result) {\n                    if (result) {\n                        fulfill(JSON.parse(result));\n                    } else {\n                        fulfill(result);\n                    }\n                }).catch(reject);\n            });\n        }\n\n        /**\r\n         * Load a \"raw\" string.\r\n         */\n\n    }, {\n        key: \"loadString\",\n        value: function loadString(url, options) {\n\n            var compression, fn, idx;\n\n            if (options === undefined) options = {};\n\n            // Strip parameters from url\n            // TODO -- handle local files with ?\n            idx = url.indexOf(\"?\");\n            fn = idx > 0 ? url.substring(0, idx) : url;\n\n            if (options.bgz) {\n                compression = BGZF;\n            } else if (fn.endsWith(\".gz\")) {\n                compression = GZIP;\n            } else {\n                compression = NONE;\n            }\n\n            if (compression === NONE) {\n                options.mimeType = 'text/plain; charset=x-user-defined';\n                return igvxhr.load(url, options);\n            } else {\n                options.responseType = \"arraybuffer\";\n\n                return new Promise(function (fulfill, reject) {\n\n                    igvxhr.load(url, options).then(function (data) {\n                        var result = igvxhr.arrayBufferToString(data, compression);\n                        fulfill(result);\n                    }).catch(reject);\n                });\n            }\n        }\n    }, {\n        key: \"loadStringFromFile\",\n        value: function loadStringFromFile(localfile, options) {\n\n            return new Promise(function (fulfill, reject) {\n\n                var fileReader = new FileReader(),\n                    range = options.range;\n\n                fileReader.onload = function (e) {\n\n                    var compression, result;\n\n                    if (options.bgz) {\n                        compression = BGZF;\n                    } else if (localfile.name.endsWith(\".gz\")) {\n\n                        compression = GZIP;\n                    } else {\n                        compression = NONE;\n                    }\n\n                    result = igvxhr.arrayBufferToString(fileReader.result, compression);\n\n                    fulfill(result, localfile);\n                };\n\n                fileReader.onerror = function (e) {\n                    console.log(\"reject uploading local file \" + localfile.name);\n                    reject(null, fileReader);\n                };\n\n                fileReader.readAsArrayBuffer(localfile);\n            });\n        }\n    }, {\n        key: \"isCrossDomain\",\n        value: function isCrossDomain(url) {\n\n            var origin = window.location.origin;\n\n            return !url.startsWith(origin);\n        }\n    }, {\n        key: \"arrayBufferToString\",\n        value: function arrayBufferToString(arraybuffer, compression) {\n\n            var plain, inflate;\n\n            if (compression === GZIP) {\n                inflate = new _zlib_and_gzip.Zlib.Gunzip(new Uint8Array(arraybuffer));\n                plain = inflate.decompress();\n            } else if (compression === BGZF) {\n                plain = new Uint8Array(unbgzf(arraybuffer));\n            } else {\n                plain = new Uint8Array(arraybuffer);\n            }\n\n            var result = \"\";\n            for (var i = 0, len = plain.length; i < len; i++) {\n                result = result + String.fromCharCode(plain[i]);\n            }\n            return result;\n        }\n    }]);\n\n    return igvxhr;\n}();\n\n//**********js/bam/bgzf.js***************************************\n\n\nvar BLOCK_HEADER_LENGTH = 18;\nvar BLOCK_LENGTH_OFFSET = 16; // Location in the gzip block of the total block size (actually total block size - 1)\nvar BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\nvar MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\nvar GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\nvar GZIP_ID1 = 31; // Magic number\nvar GZIP_ID2 = 139; // Magic number\nvar GZIP_FLG = 4; // FEXTRA flag means there are optional fields\n\n\n// Uncompress data,  assumed to be series of bgzipped blocks\n// Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\nvar unbgzf = function unbgzf(data, lim) {\n\n    var oBlockList = [],\n        ptr = [0],\n        totalSize = 0;\n\n    lim = lim || data.byteLength - 18;\n\n    while (ptr[0] < lim) {\n\n        var ba = new Uint8Array(data, ptr[0], 18);\n\n        var xlen = ba[11] << 8 | ba[10];\n        var si1 = ba[12];\n        var si2 = ba[13];\n        var slen = ba[15] << 8 | ba[14];\n        var bsize = ba[17] << 8 | ba[16] + 1;\n\n        var start = 12 + xlen + ptr[0]; // Start of CDATA\n        var length = data.byteLength - start;\n\n        if (length < bsize + 8) break;\n\n        var unc = (0, _inflate.jszlib_inflate_buffer)(data, start, length, ptr);\n\n        ptr[0] += 8; // Skipping CRC-32 and size of uncompressed data\n\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    // Concatenate decompressed blocks\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            (0, _inflate.arrayCopy)(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n};\n\nexports.igvxhr = igvxhr;\nexports.unbgzf = unbgzf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL2lndnhoci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvaWd2eGhyLmpzP2EwODgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge2pzemxpYl9pbmZsYXRlX2J1ZmZlcixhcnJheUNvcHl9IGZyb20gXCIuL3ZlbmRvci9pbmZsYXRlLmpzXCI7XHJcbmltcG9ydCB7WmxpYn0gZnJvbSBcIi4vdmVuZG9yL3psaWJfYW5kX2d6aXAuanNcIjtcclxuXHJcbmxldCBpc19ub2RlPWZhbHNlO1xyXG50cnl7XHJcbiAgICBuYXZpZ2F0b3I7XHJcbn1jYXRjaChlKXtcclxuICAgIGlzX25vZGU9dHJ1ZTtcclxufVxyXG5cclxuXHJcblxyXG5jb25zdCBOT05FID0gMDtcclxuY29uc3QgR1pJUCA9IDE7XHJcbmNvbnN0IEJHWkYgPSAyO1xyXG5jbGFzcyBpZ3Z4aHIge1xyXG4gICBcclxuICAgIC8vIENvbXByZXNzaW9uIHR5cGVzXHJcbiAgIFxyXG5cclxuICAgIHN0YXRpYyBsb2FkKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgIFxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXHJcbiAgICAgICAgICAgICAgICBzZW5kRGF0YSA9IG9wdGlvbnMuc2VuZERhdGEsXHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAoc2VuZERhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBvcHRpb25zLnJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IG9wdGlvbnMubWltZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgaXNTYWZhcmkgPSBpc19ub2RlP2ZhbHNlOm5hdmlnYXRvci52ZW5kb3IuaW5kZXhPZihcIkFwcGxlXCIpID09IDAgJiYgL1xcc1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcclxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMsIGtleSwgdmFsdWUsIGk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBHQ1MgcGF0aHMuXHJcbiAgICAgICAgICAgLy91cmwgPSB1cmwuc3RhcnRzV2l0aChcImdzOi8vXCIpID8gaWd2Lkdvb2dsZS50cmFuc2xhdGVHb29nbGVDbG91ZFVSTCh1cmwpIDogdXJsO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAgICAvKiBpZiAoaWd2Lkdvb2dsZS5pc0dvb2dsZVVSTCh1cmwpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXJsID0gaWd2Lkdvb2dsZS5hZGRBcGlLZXkodXJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZ29vZ2xlIGhlYWRlcnMgKGUuZy4gb0F1dGgpXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGlndi5Hb29nbGUuYWRkR29vZ2xlSGVhZGVycyhoZWFkZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgY2FjaGluZyBmb3IgZ29vZ2xlIHN0b3JhZ2UgZmlsZXMuICBHZXQgd2VpcmQgbmV0OmVyci1jYWNoZSBlcnJvcnMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gdXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwic29tZVJhbmRvbVNlZWQ9XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgXHJcblxyXG4gICAgICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZUVuZCA9IHJhbmdlLnNpemUgPyByYW5nZS5zdGFydCArIHJhbmdlLnNpemUgLSAxIDogXCJcIjtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIHJhbmdlLnN0YXJ0ICsgXCItXCIgKyByYW5nZUVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkZXJfa2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcl9rZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaGVhZGVyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWRkaW5nIHRvIGhlYWRlcjogXCIgKyBrZXkgKyBcIj1cIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTk9URTogdXNpbmcgd2l0aENyZWRlbnRpYWxzIHdpdGggc2VydmVycyB0aGF0IHJldHVybiBcIipcIiBmb3IgYWNjZXNzLWFsbG93ZWQtb3JpZ2luIHdpbGwgZmFpbFxyXG4gICAgICAgICAgICBpZiAod2l0aENyZWRlbnRpYWxzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4aHIudGltZW91dD0zMDAwMDtcclxuXHJcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVybCBwb2ludHMgdG8gYSBsb2NhbCBmaWxlLCB0aGUgc3RhdHVzIGlzIDAgYnV0IHRoYXQgaXMgbm8gZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMzAwKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgeGhyLnN0YXR1cyAhPSAyMDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFUlJPUjogcmFuZ2UtYnl0ZSBoZWFkZXIgd2FzIGlnbm9yZWQgZm9yIHVybDogXCIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHhoci5yZXNwb25zZSx4aHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNDE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUcmllZCB0byByZWFkIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlLiAgIFRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMgcmV0dXJuIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiVW5zYXRpc2ZpYWJsZSByYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7Ly8gVE9ETyAtLSBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFcnJvciBhY2Nlc3NpbmcgcmVzb3VyY2U6IFwiICsgeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIkVycm9yIGFjY2Vzc2luZyByZXNvdXJjZTogXCIgKyB1cmwgKyBcIiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJUaW1lZCBvdXRcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBYm9ydGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBpZ3YuQWJvcnRMb2FkKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChzZW5kRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvYWRBcnJheUJ1ZmZlciAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICByZXR1cm4gaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvYWRKc29uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IChvcHRpb25zLnNlbmREYXRhID8gXCJQT1NUXCIgOiBcIkdFVFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBcIlBPU1RcIikgb3B0aW9ucy5jb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChKU09OLnBhcnNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBcInJhd1wiIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvYWRTdHJpbmcodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgZm4sIGlkeDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBTdHJpcCBwYXJhbWV0ZXJzIGZyb20gdXJsXHJcbiAgICAgICAgLy8gVE9ETyAtLSBoYW5kbGUgbG9jYWwgZmlsZXMgd2l0aCA/XHJcbiAgICAgICAgaWR4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgICAgIGZuID0gaWR4ID4gMCA/IHVybC5zdWJzdHJpbmcoMCwgaWR4KSA6IHVybDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmd6KSB7XHJcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm4uZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBHWklQO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBOT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBOT05FKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIHJldHVybiBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHVybCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaWd2eGhyLmFycmF5QnVmZmVyVG9TdHJpbmcoZGF0YSwgY29tcHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBsb2FkU3RyaW5nRnJvbUZpbGUobG9jYWxmaWxlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksXHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XHJcblxyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiwgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJneikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsZmlsZS5uYW1lLmVuZHNXaXRoKFwiLmd6XCIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gR1pJUDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gTk9ORTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyhmaWxlUmVhZGVyLnJlc3VsdCwgY29tcHJlc3Npb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0LCBsb2NhbGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlamVjdCB1cGxvYWRpbmcgbG9jYWwgZmlsZSBcIiArIGxvY2FsZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChudWxsLCBmaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobG9jYWxmaWxlKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzQ3Jvc3NEb21haW4odXJsKSB7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG5cclxuICAgICAgICByZXR1cm4gIXVybC5zdGFydHNXaXRoKG9yaWdpbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhcnJheUJ1ZmZlclRvU3RyaW5nIChhcnJheWJ1ZmZlciwgY29tcHJlc3Npb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYWluLCBpbmZsYXRlO1xyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IEdaSVApIHtcclxuICAgICAgICAgICAgaW5mbGF0ZSA9IG5ldyBabGliLkd1bnppcChuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcikpO1xyXG4gICAgICAgICAgICBwbGFpbiA9IGluZmxhdGUuZGVjb21wcmVzcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wcmVzc2lvbiA9PT0gQkdaRikge1xyXG4gICAgICAgICAgICBwbGFpbiA9IG5ldyBVaW50OEFycmF5KHVuYmd6ZihhcnJheWJ1ZmZlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGxhaW4gPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGxhaW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShwbGFpbltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqanMvYmFtL2JnemYuanMqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jb25zdCBCTE9DS19IRUFERVJfTEVOR1RIID0gMTg7XHJcbmNvbnN0IEJMT0NLX0xFTkdUSF9PRkZTRVQgPSAxNjsgIC8vIExvY2F0aW9uIGluIHRoZSBnemlwIGJsb2NrIG9mIHRoZSB0b3RhbCBibG9jayBzaXplIChhY3R1YWxseSB0b3RhbCBibG9jayBzaXplIC0gMSlcclxuY29uc3QgQkxPQ0tfRk9PVEVSX0xFTkdUSCA9IDg7IC8vIE51bWJlciBvZiBieXRlcyB0aGF0IGZvbGxvdyB0aGUgZGVmbGF0ZWQgZGF0YVxyXG5jb25zdCBNQVhfQ09NUFJFU1NFRF9CTE9DS19TSVpFID0gNjQgKiAxMDI0OyAvLyBXZSByZXF1aXJlIHRoYXQgYSBjb21wcmVzc2VkIGJsb2NrIChpbmNsdWRpbmcgaGVhZGVyIGFuZCBmb290ZXIsIGJlIDw9IHRoaXMpXHJcbmNvbnN0IEdaSVBfT1ZFUkhFQUQgPSBCTE9DS19IRUFERVJfTEVOR1RIICsgQkxPQ0tfRk9PVEVSX0xFTkdUSCArIDI7IC8vIEd6aXAgb3ZlcmhlYWQgaXMgdGhlIGhlYWRlciwgdGhlIGZvb3RlciwgYW5kIHRoZSBibG9jayBzaXplIChlbmNvZGVkIGFzIGEgc2hvcnQpLlxyXG5jb25zdCBHWklQX0lEMSA9IDMxOyAgIC8vIE1hZ2ljIG51bWJlclxyXG5jb25zdCBHWklQX0lEMiA9IDEzOTsgIC8vIE1hZ2ljIG51bWJlclxyXG5jb25zdCBHWklQX0ZMRyA9IDQ7IC8vIEZFWFRSQSBmbGFnIG1lYW5zIHRoZXJlIGFyZSBvcHRpb25hbCBmaWVsZHNcclxuXHJcblxyXG4gICAgLy8gVW5jb21wcmVzcyBkYXRhLCAgYXNzdW1lZCB0byBiZSBzZXJpZXMgb2YgYmd6aXBwZWQgYmxvY2tzXHJcbiAgICAvLyBDb2RlIGlzIGJhc2VkIGhlYXZpbHkgb24gYmFtLmpzLCBwYXJ0IG9mIHRoZSBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyLCAgKGMpIFRob21hcyBEb3duIDIwMDYtMjAwMS5cclxubGV0IHVuYmd6ZiA9IGZ1bmN0aW9uIChkYXRhLCBsaW0pIHtcclxuXHJcbiAgICAgICAgdmFyIG9CbG9ja0xpc3QgPSBbXSxcclxuICAgICAgICAgICAgcHRyID0gWzBdLFxyXG4gICAgICAgICAgICB0b3RhbFNpemUgPSAwO1xyXG5cclxuICAgICAgICBsaW0gPSBsaW0gfHwgZGF0YS5ieXRlTGVuZ3RoIC0gMTg7XHJcblxyXG4gICAgICAgIHdoaWxlIChwdHJbMF0gPCBsaW0pIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGRhdGEsIHB0clswXSwgMTgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHhsZW4gPSAoYmFbMTFdIDw8IDgpIHwgKGJhWzEwXSk7XHJcbiAgICAgICAgICAgIHZhciBzaTEgPSBiYVsxMl07XHJcbiAgICAgICAgICAgIHZhciBzaTIgPSBiYVsxM107XHJcbiAgICAgICAgICAgIHZhciBzbGVuID0gKGJhWzE1XSA8PCA4KSB8IChiYVsxNF0pO1xyXG4gICAgICAgICAgICB2YXIgYnNpemUgPSAoYmFbMTddIDw8IDgpIHwgKGJhWzE2XSkgKyAxO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMTIgKyB4bGVuICsgcHRyWzBdOyAgICAvLyBTdGFydCBvZiBDREFUQVxyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIC0gc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgKGJzaXplICsgOCkpIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVuYyA9IGpzemxpYl9pbmZsYXRlX2J1ZmZlcihkYXRhLCBzdGFydCwgbGVuZ3RoLCBwdHIpO1xyXG5cclxuICAgICAgICAgICAgcHRyWzBdICs9IDg7ICAgIC8vIFNraXBwaW5nIENSQy0zMiBhbmQgc2l6ZSBvZiB1bmNvbXByZXNzZWQgZGF0YVxyXG5cclxuICAgICAgICAgICAgdG90YWxTaXplICs9IHVuYy5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICBvQmxvY2tMaXN0LnB1c2godW5jKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbmNhdGVuYXRlIGRlY29tcHJlc3NlZCBibG9ja3NcclxuICAgICAgICBpZiAob0Jsb2NrTGlzdC5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb0Jsb2NrTGlzdFswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTtcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb0Jsb2NrTGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShvQmxvY2tMaXN0W2ldKTtcclxuICAgICAgICAgICAgICAgIGFycmF5Q29weShiLCAwLCBvdXQsIGN1cnNvciwgYi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yICs9IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQuYnVmZmVyO1xyXG4gICAgICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHtpZ3Z4aHIsdW5iZ3pmfTtcclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/igvxhr.js\n");

/***/ }),

/***/ "../MLVPanel/src/panel.js":
/*!***************************!*\
  !*** .Panel/src/panel.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MLVPanel = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n/**\r\n * Class representing a lightweight panel the can host multiple tracks of\r\n * different types\r\n */\n\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"../MLVPanel/src/utils.js\");\n\nvar _panel_legend = __webpack_require__(/*! ./panel_legend.js */ \"../MLVPanel/src/panel_legend.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVPanel = function () {\n    /**\r\n    * Creates a panel\r\n    * @param {array} tracks - a list of config objects describing each track\r\n    * @param {object} config - A config with the panel settings\r\n    */\n    function MLVPanel(tracks, config) {\n        _classCallCheck(this, MLVPanel);\n\n        if (!config) {\n            config = {};\n        }\n        this.fixed_height_mode = false;\n        if (config.fixed_height_mode) {\n            this.fixed_height_mode = true;\n        }\n\n        this.show_scale = true;\n        if (config.show_scale) {\n            this.show_scale = true;\n        }\n\n        var height = config.height ? config.height : 200;\n        var width = config.width ? config.width : 400;\n        var dim = { height: height, width: width };\n        var panel_div = null;\n        if (!config.div) {\n            panel_div = $(\"<div>\").height(height).width(width);\n        } else {\n            if (typeof config.div === 'string') {\n                panel_div = $(\"#\" + config.div);\n            } else {\n                panel_div = $(config.div);\n            }\n            height = panel_div.height();\n            width = panel_div.width();\n        }\n        this.tracks = {};\n        this.track_order = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = tracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var t_config = _step.value;\n\n                if (this.fixed_height_mode) {\n                    t_config.discrete = true;\n                }\n                var track = _tracks.MLVTrack.getTrack(t_config);\n                this.tracks[track.config.track_id] = track;\n                this.track_order.push(track.config.track_id);\n            }\n            //check for linked scales\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        this._tracksChanged();\n        this.legend = null;\n\n        this.trackDiv = panel_div.addClass(\"igv-track-div\").css(\"position\", \"absolute\");\n\n        this.canvas = $('<canvas class = \"igv-content-canvas\">')[0];\n        this.trackDiv.append(this.canvas);\n        this.canvas.setAttribute('width', width);\n        this.canvas.setAttribute('height', height);\n        this.ctx = this.canvas.getContext(\"2d\");\n\n        if (this.show_scale) {\n            this.addScaleCanvas(height);\n        }\n\n        this.trackDiv.append(_utils.Utils.spinner());\n\n        var icon_div = $(\"<div>\").css({ \"z-index\": 100, position: \"absolute\", top: \"2px\", right: \"2px\" }).appendTo(this.trackDiv).attr(\"class\", \"panel-icon-div\");\n\n        //for event handlers\n        this.is_dragging = false;\n        this.isMouseDown = false, this.lastMouseX = undefined;\n        this.mouseDownX = undefined;\n\n        //amount to show each side of view port\n        this.buffer_level = 1;\n\n        this.groups = {};\n\n        this.highlighted_regions = {};\n\n        //listeners\n        this.listeners = {\n            \"panel_empty\": new Map(),\n            \"panel_closed\": new Map(),\n            \"track_added\": new Map(),\n            \"track_removed\": new Map(),\n            \"view_changed\": new Map(),\n            \"feature_clicked\": new Map(),\n            \"feature_over\": new Map(),\n            \"range_selected\": new Map()\n        };\n\n        if (config.allow_user_drag) {\n            this.allowUserDrag();\n        }\n        if (config.allow_user_zoom) {\n            this.allowUserZoom();\n        }\n        if (config.allow_user_resize) {\n            this.allowUserResize(config.allow_user_resize);\n        }\n        if (config.allow_user_move) {\n            this.allowUserMove(config.allow_user_move);\n        }\n        if (config.allow_user_feature_click) {\n            this.allowUserFeatureClick();\n        }\n        if (config.allow_user_feature_over) {\n            this.allowUserFeatureOver();\n        }\n        if (config.allow_user_close) {\n            this.allowUserClose();\n        }\n        if (config.allow_user_drop) {\n            this.allowUserDrop();\n        }\n        if (config.allow_user_range_selection) {\n            this.allowUserRangeSelection();\n        }\n\n        if (config.ruler_track) {\n            this.addRulerTrack();\n        }\n        if (config.legend) {\n            this.addLegend();\n        }\n        if (config.new_layout) {\n            this.new_layout = true;\n        }\n\n        this.retries = 0;\n        this.yOffset = 0;\n    }\n\n    _createClass(MLVPanel, [{\n        key: \"_parseConfig\",\n        value: function _parseConfig(config) {\n            //check the tracks have the right settings\n            if (this.fixed_height_mode) {\n                config.discrete = true;\n                if (!config.height) {\n                    config.height = 150;\n                }\n            }\n        }\n    }, {\n        key: \"addScaleCanvas\",\n        value: function addScaleCanvas(height) {\n            this.scale_canvas = $('<canvas>').css({ position: \"absolute\", top: \"0px\", left: \"5px\" });\n            this.scale_canvas[0].setAttribute('width', 100);\n            this.scale_canvas[0].setAttribute('height', height);\n            this.scale_canvas.appendTo(this.trackDiv);\n            this.scale_ctx = this.scale_canvas[0].getContext(\"2d\");\n        }\n\n        /**\r\n        * sets the extra amount of track to draw each side of the view. A value \r\n        * of 1 will retreive 1 x the view width each side i.e. 3 x the visible window\r\n        * @param {integer} level - The type of listener - track_empty \r\n        */\n\n    }, {\n        key: \"setBufferLevel\",\n        value: function setBufferLevel(level) {\n            this.buffer_level = level;\n        }\n        /**\r\n        * Returns the element that houses the panel\r\n        * @returns {integer} level - The type of listener - track_empty \r\n        */\n\n    }, {\n        key: \"getDiv\",\n        value: function getDiv() {\n            return this.trackDiv;\n        }\n    }, {\n        key: \"addLegend\",\n        value: function addLegend() {\n            this.legend = new _panel_legend.PanelLegend(this);\n        }\n\n        /**\r\n        * Sets the highligted region\r\n        * @param {Object} location - An object containing chr, start and end\r\n        * @param {name} The name(id) of the region (used to remove the region)\r\n        * @param {String} The color to give the highligted region\r\n        */\n\n    }, {\n        key: \"setHighlightedRegion\",\n        value: function setHighlightedRegion(location, name, color) {\n            this.highlighted_regions[name] = {\n                chr: location.chr,\n                start: location.start,\n                end: location.end,\n                color: color\n            };\n            this.force_redraw = true;\n        }\n\n        /**\r\n        * Removes the highlighted region from the panel\r\n        * @param {string} name - The name of the highlighted region\r\n        * that was given when it was created.\r\n        */\n\n    }, {\n        key: \"removeHighlightedRegion\",\n        value: function removeHighlightedRegion(name) {\n            delete this.highlighted_regions[name];\n            this.force_redraw = true;\n        }\n    }, {\n        key: \"addRulerTrack\",\n        value: function addRulerTrack() {\n            var track = new _tracks.RulerTrack();\n            var config = track.getConfig();\n            this.tracks[config.track_id] = track;\n            this.track_order.unshift(config.track_id);\n            return this;\n        }\n\n        /**\r\n        * Adds a listener to the panel\r\n        * @param {string} type - The type of listener - track_empty\r\n        * @param {function} func - The function to call \r\n        * @param {string} id - The id of the handler (can be used to remove the handler)\r\n        * Optional - an id will be assigned (and returned) if not supplied\r\n        * @returns{string} The id of the handler or null if the type did not exist \r\n        */\n\n    }, {\n        key: \"addListener\",\n        value: function addListener(type, func, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return null;\n            }\n            if (!id) {\n                id = type + \"_\" + listener.size;\n            }\n            listener.set(id, func);\n            return id;\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {string} type - The type of listener - track_empty \r\n        * @param {string} id - The id of the handler to remove\r\n        * @returns{boolean} true if the listener was removed, otherwise false \r\n        */\n\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(type, id) {\n            var listener = this.listeners[type];\n            if (!listener) {\n                return false;\n            }\n            return listener.delete(id);\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {object} config - The config of the track to addTrack\r\n        * @param {integer} index - Optional, the vertical order of the track\r\n        */\n\n    }, {\n        key: \"addTrack\",\n        value: function addTrack(config, index, no_propagate) {\n            var track = _tracks.MLVTrack.getTrack(config);\n            if (this.fixed_height_mode) {\n                track.config.discrete = true;\n            }\n            this.tracks[track.config.track_id] = track;\n            if (index || index == 0) {\n                this.track_order.splice(index, 0, track.config.track_id);\n            } else {\n                this.track_order.push(track.config.track_id);\n            }\n\n            this._tracksChanged();\n            if (this.legend) {\n                this.legend.addTrack(track.config, index);\n            }\n            if (!no_propagate) {\n                this._callListeners(\"track_added\", track.config);\n            }\n        }\n    }, {\n        key: \"_callListeners\",\n        value: function _callListeners(type, config) {\n\n            this.listeners[type].forEach(function (v) {\n                v(config);\n            });\n        }\n    }, {\n        key: \"removeAllTracks\",\n        value: function removeAllTracks() {\n            var dup_array = this.track_order.slice();\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = dup_array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var id = _step2.value;\n\n                    this.removeTrack(id, true);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /**\r\n        * Removes a listener to the panel\r\n        * @param {object} config - The config of the track to add \r\n        */\n\n    }, {\n        key: \"removeTrack\",\n        value: function removeTrack(track_id, not_repaint, not_propagate) {\n            if (!this.tracks[track_id]) {\n                return null;\n            }\n            this.track_order = this.track_order.filter(function (e) {\n                return e !== track_id;\n            });\n            if (!not_repaint) {\n                this.repaint(true, true);\n            }\n\n            if (this.legend) {\n                this.legend.removeTrack(track_id);\n            }\n            var config = this.tracks[track_id].config;\n            delete this.tracks[track_id];\n            if (!not_propagate) {\n                this._callListeners(\"track_removed\", config);\n            }\n            if (this.track_order.length === 0) {\n                for (var l_id in this.listeners[\"panel_empty\"]) {\n                    this.listeners[\"panel_empty\"][l_id](this);\n                }\n            }\n            return config;\n        }\n    }, {\n        key: \"getTrackConfig\",\n        value: function getTrackConfig(track_id) {\n            var track = this.tracks[track_id];\n            return track.getConfig();\n        }\n    }, {\n        key: \"getAllTrackConfigs\",\n        value: function getAllTrackConfigs() {\n            var configs = [];\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.track_order[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var id = _step3.value;\n\n                    configs.push(this.tracks[id].getConfig());\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            return configs;\n        }\n    }, {\n        key: \"setTrackAttribute\",\n        value: function setTrackAttribute(track_id, key, value) {\n            var track = this.tracks[track_id];\n            if (!track) {\n                return;\n            }\n            track.setConfigAttribute(key, value);\n            if (key === \"scale_link_to\") {\n                this.tracks[track_id].scale_link_to = this.tracks[value];\n            }\n            if ((key === \"color\" || key === \"display\") && this.legend) {\n                this.legend.updateTrack(track_id);\n            }\n        }\n    }, {\n        key: \"setTrackAttributes\",\n        value: function setTrackAttributes(track_id, attributes) {\n            var track = this.tracks[track_id];\n            for (var key in attributes) {\n                track.setConfigAttribute(key, attributes[key]);\n                if (key === \"color\" && this.legend) {\n                    this.legend.updateTrack(track_id);\n                }\n            }\n        }\n\n        /**\r\n        * Sets the filter  function for track. \r\n        * @param {string} track_id- The id of the track\r\n        * @param {string} func - The filter function. It should accept the feature\r\n        * and return true to dispaly the feature and false to hide it. Use null \r\n        * to cancel the filter\r\n        */\n\n    }, {\n        key: \"setTrackFeatureFilter\",\n        value: function setTrackFeatureFilter(track_id, func) {\n            var track = this.tracks[track_id];\n            track.setFilterFunction(func);\n        }\n\n        /**\r\n        * Sets the filter  function for track \r\n        * @param {string} track_id- The id of the track\r\n        * @param {string} func - The color function. It should accept the feature\r\n        * and return the feature color. Use null to go back to default colors \r\n        */\n\n    }, {\n        key: \"setTrackColorFunction\",\n        value: function setTrackColorFunction(track_id, func) {\n            var track = this.tracks[track_id];\n            track.setColorFunction(func);\n        }\n    }, {\n        key: \"setTrackLabelFunction\",\n        value: function setTrackLabelFunction(track_id, func) {\n            var track = this.tracks[track_id];\n            if (track) {\n                track.label_function = func;\n            }\n        }\n    }, {\n        key: \"_tracksChanged\",\n        value: function _tracksChanged() {\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.track_order[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var t_id = _step4.value;\n\n                    var track = this.tracks[t_id];\n                    //if this track is linked to the scale of another\n                    //get pointer to the track\n                    var link_to = track.config['scale_link_to'];\n                    if (link_to) {\n                        var other_track = this.tracks[link_to];\n                        if (other_track) {\n                            track.scale_link_to = other_track;\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getCurrentTrackFeatures\",\n        value: function getCurrentTrackFeatures(track_id) {\n            var track = this.tracks[track_id];\n            return track.getCurrentFeatures(this.chr, this.start, this.end);\n        }\n\n        /**\r\n         * Updated the panel view, if chromosome start and end are supplied\r\n         * it will go to this location. If no parameters are given the panel\r\n         * will be redrawn at the same location e.g after the color, scale or another\r\n         * paramter has been set\r\n         * @param {string} force - If true then a cached image will not be used\r\n         * @param {integer} start of the region to draw\r\n         * @param {integer} end of the region to draw\r\n         */\n\n    }, {\n        key: \"update\",\n        value: function update(chr, start, end, no_propagation) {\n            this.call_update_listener = no_propagation;\n            if (chr) {\n                this.chr = chr;\n                this.start = start;\n                this.end = end;\n                this.repaint();\n            } else {\n                this.repaint(true, true);\n            }\n        }\n    }, {\n        key: \"getTracksHeight\",\n        value: function getTracksHeight() {\n            var h = 0;\n            var groups = {};\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = this.track_order[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var tid = _step5.value;\n\n                    var track = this.tracks[tid];\n                    var g = track.config.group;\n                    if (g) {\n                        if (!groups[g]) {\n                            h += track.config.height;\n                            groups[g] = true;\n                        }\n                    } else {\n                        h += track.config.height;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            return h;\n        }\n    }, {\n        key: \"getAllFeatures\",\n        value: function getAllFeatures(bpStart, bpEnd, force, data) {\n            var promises = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = this.track_order[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var track_id = _step6.value;\n\n                    var track = this.tracks[track_id];\n                    promises.push(track.getFeatures(this.chr, bpStart, bpEnd, force, data));\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            return Promise.all(promises);\n        }\n\n        /**\r\n         * Repaint the view, using a cached image if available.\r\n         * @param {boolean} force - If true then a cached image will not be used\r\n         * @param {boolean} range_from_tile Redraw the tile\r\n         */\n\n    }, {\n        key: \"repaint\",\n        value: function repaint(force, range_from_tile) {\n\n            var pixelWidth,\n                bpWidth,\n                bpStart,\n                bpEnd,\n                self = this,\n                ctx,\n                referenceFrame,\n                chr,\n                refFrameStart,\n                refFrameEnd,\n                success;\n\n            chr = this.chr;\n            refFrameStart = this.start;\n            refFrameEnd = this.end;\n            this.bpPerPixel = (this.end - this.start) / this.canvas.width;\n            var get_features = true;\n            if (this.tile && this.tile.containsRange(chr, refFrameStart, refFrameEnd, this.bpPerPixel)) {\n                get_features = false;\n            }\n            if (!get_features && !force && !this.force_redraw) {\n                this.force_redraw = false;\n                this.paintImage();\n                if (!self.call_update_listener) {\n                    self.listeners.view_changed.forEach(function (func) {\n                        func(self.chr, parseInt(self.start), parseInt(self.end));\n                    });\n                }\n                self.call_update_listener = false;\n\n                self.retries = 0;\n            } else {\n                // Expand the requested range so we can pan a bit without reloading\n                this.force_redraw = false;\n                pixelWidth = (this.buffer_level * 2 + 1) * this.canvas.width;\n                bpWidth = Math.round(pixelWidth * this.bpPerPixel);\n                bpStart = Math.max(0, Math.round(this.start - this.buffer_level * this.canvas.width * this.bpPerPixel));\n                bpEnd = bpStart + bpWidth;\n                if (self.loading) {\n                    if (force && range_from_tile) {\n                        self.update_required = true;\n                    } else {\n                        self.update_required = \"location\";\n                    }\n                    return;\n                }\n                if (range_from_tile) {\n                    if (this.tile) {\n                        bpStart = this.tile.startBP;\n                        bpEnd = this.tile.endBP;\n                    }\n                }\n\n                self.loading = { start: bpStart, end: bpEnd };\n                self.trackDiv.find(\".mlv-alert\").remove();\n\n                _utils.Utils.startSpinnerAtParentElement(self.trackDiv);\n\n                self.getAllFeatures(bpStart, bpEnd, !get_features, { pixelWidth: pixelWidth, bpPerPixel: self.bpPerPixel }).then(function (all_features) {\n\n                    if (all_features) {\n\n                        var buffer = document.createElement('canvas');\n                        buffer.width = pixelWidth;\n                        buffer.height = self.fixed_height_mode ? self.getTracksHeight() : self.canvas.height;\n                        ctx = buffer.getContext('2d');\n                        if (self.show_scale) {\n                            self.scale_buffer = document.createElement('canvas');\n                            self.scale_buffer.width = 200;\n                            self.scale_buffer.height = buffer.height;\n                            self.scale_buffer_ctx = self.scale_buffer.getContext(\"2d\");\n                        }\n\n                        var options = {\n                            context: ctx,\n                            bpStart: bpStart,\n                            bpPerPixel: self.bpPerPixel,\n                            pixelWidth: buffer.width,\n                            pixelHeight: buffer.height,\n                            chr: chr\n                        };\n                        var top = 0;\n                        self.groups = {};\n                        self.calculateMaxScale(all_features);\n                        for (var i in all_features) {\n                            var track = self.tracks[self.track_order[i]];\n                            options.features = all_features[i];\n                            var group = track.config.group;\n                            if (group) {\n                                if (!self.groups[group]) {\n                                    self.groups[group] = { top: top, height: track.config.height\n                                        //first time increase top\n                                    };top += track.config.height;\n                                }\n                                options.top = self.groups[group].top;\n                                options.height = self.groups[group].height;\n                            } else {\n                                options.top = top;\n                            }\n\n                            var disc = self.fixed_height_mode || track.config.discrete || group;\n                            if (disc) {\n                                var h = group ? options.height : track.config.height;\n                                ctx.save();\n                                ctx.rect(0, options.top, options.pixelWidth, h);\n                                ctx.clip();\n                                ctx.beginPath();\n                            }\n                            var offset = track.drawFeatures(options);\n\n                            if (disc) {\n                                ctx.restore();\n                                if (!group) {\n                                    top += track.config.height;\n                                    track.bottom = top;\n                                }\n                            } else if (offset) {\n                                top = offset;\n                            }\n\n                            if (self.show_scale) {\n\n                                track.drawScale(options.pixelHeight, self.scale_buffer_ctx);\n                            }\n                        }\n                        for (var name in self.highlighted_regions) {\n                            var region = self.highlighted_regions[name];\n                            if (self.chr !== region.chr) {\n                                continue;\n                            }\n                            if (region.end < bpStart || region.start > bpEnd) {\n                                continue;\n                            }\n                            self.drawHighlightedRegion(region, options);\n                        }\n                        self.retries = 0;\n                        self.loading = false;\n                        self.tile = new Tile(chr, bpStart, bpEnd, self.bpPerPixel, buffer);\n                        self.paintImage();\n                        if (!self.call_update_listener) {\n                            self.listeners.view_changed.forEach(function (func) {\n                                func(self.chr, parseInt(self.start), parseInt(self.end));\n                            });\n                        }\n                        self.call_update_listener = false;\n                    } else {\n                        self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);\n                    }\n                    if (self.update_required) {\n                        if (self.update_required === \"location\") {\n                            self.update(self.chr, self.start, self.end);\n                            self.update_required = false;\n                        } else {\n                            self.update_required = false;\n                            self.update();\n                        }\n                    }\n                    _utils.Utils.stopSpinnerAtParentElement(self.trackDiv);\n                }).catch(function (error) {\n                    self.loading = false;\n\n                    console.log(error);\n                    if (self.retries < 3 && error !== \"Timed out\") {\n                        self.retries++;\n                        self.repaint(force, range_from_tile);\n                    } else {\n                        _utils.Utils.stopSpinnerAtParentElement(self.trackDiv);\n                        self.loading = false;\n                        self.force_redraw = true;\n                        _utils.Utils.presentAlert(self.trackDiv, error);\n                    }\n                });\n            }\n\n            function viewIsReady() {\n                return this.track;\n            }\n        }\n    }, {\n        key: \"autoScale\",\n        value: function autoScale(features, min, max) {\n            if (!features) {\n                return { min: 0, max: 1 };\n            }\n            features.forEach(function (f) {\n                min = Math.min(min, f.value);\n                max = Math.max(max, f.value);\n            });\n            return { min: min, max: max };\n        }\n    }, {\n        key: \"calculateMaxScale\",\n        value: function calculateMaxScale(all_features) {\n            var groups = {};\n            for (var i in all_features) {\n                var track = this.tracks[this.track_order[i]];\n                track.set_scale = null;\n                var group = track.config.group;\n                if (group && track.config.scale !== \"fixed\" && !track.config.scale_link_to) {\n                    track.config.scale_group = group;\n                }\n                group = track.config.scale_group;\n                if (group) {\n                    var group_info = groups[group];\n                    if (!group_info) {\n                        group_info = { tracks: [track], features: [all_features[i]] };\n                        groups[group] = group_info;\n                    } else {\n                        group_info.features.push(all_features[i]);\n                        group_info.tracks.push(track);\n                    }\n                }\n            }\n            for (var name in groups) {\n                var g = groups[name];\n                if (!g.ignore) {\n                    var min = 0;\n                    var max = -Number.MAX_VALUE;\n                    var scale = null;\n                    var _iteratorNormalCompletion7 = true;\n                    var _didIteratorError7 = false;\n                    var _iteratorError7 = undefined;\n\n                    try {\n                        for (var _iterator7 = g.features[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                            var f = _step7.value;\n\n                            scale = this.autoScale(f, min, max);\n                            min = scale.min;\n                            max = scale.max;\n                        }\n                    } catch (err) {\n                        _didIteratorError7 = true;\n                        _iteratorError7 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                _iterator7.return();\n                            }\n                        } finally {\n                            if (_didIteratorError7) {\n                                throw _iteratorError7;\n                            }\n                        }\n                    }\n\n                    var _iteratorNormalCompletion8 = true;\n                    var _didIteratorError8 = false;\n                    var _iteratorError8 = undefined;\n\n                    try {\n                        for (var _iterator8 = g.tracks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                            var t = _step8.value;\n\n                            t.set_scale = scale;\n                        }\n                    } catch (err) {\n                        _didIteratorError8 = true;\n                        _iteratorError8 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                                _iterator8.return();\n                            }\n                        } finally {\n                            if (_didIteratorError8) {\n                                throw _iteratorError8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"drawHighlightedRegion\",\n        value: function drawHighlightedRegion(region, options) {\n            var start = (region.start - options.bpStart) / options.bpPerPixel;\n            start = start < 0 ? 0 : start;\n\n            var width = (region.end - region.start) / options.bpPerPixel;\n            width = width < 3 ? 3 : width;\n            width = width > options.pixelWidth ? options.pixelWidth : width;\n            options.context.globalAlpha = 0.1;\n            options.context.fillStyle = region.color;\n            options.context.fillRect(start, 0, width, options.pixelHeight);\n            options.context.globalAlpha = 1.0;\n        }\n    }, {\n        key: \"paintImage\",\n        value: function paintImage() {\n\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            if (this.show_scale) {\n                this.scale_ctx.clearRect(0, 0, 100, this.canvas.height);\n                this.scale_ctx.drawImage(this.scale_buffer, 0, this.yOffset);\n            }\n\n            if (this.tile) {\n                this.xOffset = Math.round((this.tile.startBP - this.start) / this.bpPerPixel);\n                this.ctx.drawImage(this.tile.image, this.xOffset, this.yOffset);\n                this.ctx.save();\n                this.ctx.restore();\n            }\n        }\n    }, {\n        key: \"allowUserFeatureOver\",\n        value: function allowUserFeatureOver() {\n            var self = this;\n\n            this.trackDiv.on(\"mousemove.feature_over\", function (e) {\n                if (self.loading) {\n                    return;\n                }\n                clearTimeout(self.moto);\n                self.moto = setTimeout(function () {\n                    if (!self.is_dragging) {\n                        var info = self.getFeatureAt(e);\n                        var i = self.mouse_over_feature;\n                        if (info.feature) {\n                            if (i && i.feature !== info.feature) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(i.track, i.feature, e, \"out\");\n                                });\n                            }\n\n                            if (!i || i.feature !== info.feature) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(info.track, info.feature, e, \"over\");\n                                });\n                                self.mouse_over_feature = info;\n                            }\n                        } else {\n                            var _i = self.mouse_over_feature;\n                            if (_i) {\n                                self.listeners.feature_over.forEach(function (func) {\n                                    func(_i.track, _i.feature, e, \"out\");\n                                });\n                                self.mouse_over_feature = null;\n                            }\n                        }\n                    }\n                }, 10);\n            });\n        }\n    }, {\n        key: \"removeFeatureOverHandler\",\n        value: function removeFeatureOverHandler() {\n            this.trackDiv.off(\"mousedown.feature_over\");\n        }\n    }, {\n        key: \"allowUserFeatureClick\",\n        value: function allowUserFeatureClick() {\n            var self = this;\n\n            this.allowUserFeatureOver();\n            this.addListener(\"feature_over\", function (track, feature, over, type) {\n                if (!feature) {\n                    self.trackDiv.css(\"cursor\", \"default\");\n                }\n                var pointer = type === \"over\" ? \"pointer\" : \"default\";\n                self.trackDiv.css(\"cursor\", pointer);\n            });\n\n            this.trackDiv.on(\"mousedown.feature_click\", function (e) {\n                if (self.loading) {\n                    return;\n                }\n                clearTimeout(self.to);\n                self.to = setTimeout(function () {\n                    if (!self.is_dragging) {\n                        var info = self.getFeatureAt(e);\n                        if (info.track) {\n                            self.listeners.feature_clicked.forEach(function (func) {\n                                func(info.track, info.feature, e);\n                            });\n                        }\n                    }\n                }, 200);\n            });\n        }\n    }, {\n        key: \"removeFeatureOverHandler\",\n        value: function removeFeatureOverHandler() {\n            this.trackDiv.off(\"mousedown.feature_click\");\n        }\n    }, {\n        key: \"allowUserDrag\",\n        value: function allowUserDrag() {\n            var self = this;\n            this.trackDiv.on(\"mousedown.draghandler\", function (e) {\n                if (e.shiftKey) {\n                    return;\n                }\n                var canvasCoords = _utils.Utils.translateMouseCoordinates(e, self.canvas);\n                self.isMouseDown = true;\n                self.start_dragging = true;\n                self.lastMouseX = canvasCoords.x;\n                self.lastMouseY = canvasCoords.y;\n                self.mouseDownX = self.lastMouseX;\n            }).on(\"mousemove.draghandler\", function (e) {\n                var canvasCoords = _utils.Utils.translateMouseCoordinates(e, self.canvas);\n                if (self.is_dragging || self.start_dragging) {\n                    var diff = canvasCoords.x - self.lastMouseX;\n                    var bp_diff = self.bpPerPixel * diff;\n                    self.start -= bp_diff;\n                    self.end -= bp_diff;\n                    var dd = self.canvas.height - self.tile.image.height;\n                    var y_diff = 0;\n                    if (dd < 0 || self.yOffset !== 0) {\n                        var _y_diff = canvasCoords.y - self.lastMouseY;\n                        self.yOffset += _y_diff;\n                        if (self.yOffset > 0) {\n                            self.yOffset = 0;\n                        } else if (self.yOffset < dd) {\n                            self.yOffset = dd;\n                        }\n                    }\n                    self.repaint();\n                    self.lastMouseX = canvasCoords.x;\n                    self.lastMouseY = canvasCoords.y;\n                    if (self.start_dragging && (diff > 5 || y_diff > 5)) {\n                        self.is_dragging = true;\n                        self.start_dragging = false;\n                    }\n                }\n            }).on(\"mouseup.draghandler\", function (e) {\n                self.is_dragging = false;\n                self.start_dragging = false;\n            });\n            return this;\n        }\n    }, {\n        key: \"removeDragHandler\",\n        value: function removeDragHandler() {\n            this.trackDiv.off(\"mousedown.draghandler mousemove.draghandler mouseup.draghandler\");\n        }\n    }, {\n        key: \"_getCoords\",\n        value: function _getCoords(e) {\n            var x = e.pageX - $(this.canvas).offset().left;\n            var y = e.pageY - $(this.canvas).offset().top;\n            return { x: x, y: y };\n        }\n    }, {\n        key: \"allowUserZoom\",\n        value: function allowUserZoom() {\n            var self = this;\n            this.trackDiv.on('mousewheel.zoom  mouse.zoom DOMMouseScroll', function (event) {\n                var deltaY = event.originalEvent.deltaY;\n                if (deltaY === undefined) {\n                    deltaY = event.originalEvent.detail;\n                }\n                if (self.loading || self.bpPerPixel < 0.05 && deltaY > 0) {\n                    return;\n                }\n\n                var canvasCoords = self._getCoords(event.originalEvent);\n                var factor = deltaY < 0 ? 2 : 0.5;\n                var mbp = self.start + canvasCoords.x * self.bpPerPixel;\n                var new_length = (self.end - self.start) * factor;\n                var new_start = mbp - canvasCoords.x / self.canvas.width * new_length;\n                self.start = new_start;\n                self.end = new_start + new_length;\n\n                self.repaint();\n            });\n            return this;\n        }\n    }, {\n        key: \"disableUserZoom\",\n        value: function disableUserZoom() {\n            this.trackDiv.off(\"mousewheel.zoom\");\n        }\n    }, {\n        key: \"allowUserRangeSelection\",\n        value: function allowUserRangeSelection() {\n            var self = this;\n            this.trackDiv.on(\"mousedown.selection\", function (e) {\n                if (e.shiftKey) {\n                    self.start_select = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    var left = self.start_select + \"px\";\n                    var td = $(this);\n                    self.select_div = $(\"<div>\").css({ \"position\": \"absolute\", \"opacity\": 0.2, \"background-color\": \"blue\", \"top\": \"0px\", \"height\": td.css(\"height\"), left: left, \"width\": \"0px\" }).appendTo(td);\n\n                    e.stopPropagation();\n                }\n            }).on(\"mousemove.selection\", function (e) {\n                if (e.shiftKey && self.start_select) {\n                    var x = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    if (x < self.start_select) {\n                        self.select_div.css({ \"left\": x + \"px\", \"width\": self.start_select - x + \"px\" });\n                    } else {\n\n                        self.select_div.css({ \"left\": self.start_select + \"px\", \"width\": x - self.start_select + \"px\" });\n                    }\n\n                    e.stopPropagation();\n                }\n            }).on(\"mouseup.selection\", function (e) {\n                if (self.start_select) {\n                    var x = _utils.Utils.translateMouseCoordinates(e, this).x;\n                    var start = self.start + self.start_select * self.bpPerPixel;\n                    var end = self.start + x * self.bpPerPixel;\n                    self.start_select = null;\n                    self.select_div.remove();\n                    if (start > end) {\n                        var temp = end;\n                        end = start;\n                        start = temp;\n                    }\n                    self.listeners.range_selected.forEach(function (func) {\n                        func(self.chr, start, end);\n                    });\n                }\n            });\n        }\n    }, {\n        key: \"removeAllowSelection\",\n        value: function removeAllowSelection() {\n            this.trackDiv.off(\"mousedown.selection mousemove.selection mouseup.selection\");\n        }\n    }, {\n        key: \"getImage\",\n        value: function getImage() {\n            var imgURL = this.canvas[0].toDataURL(MIME_TYPE);\n        }\n    }, {\n        key: \"allowUserDrop\",\n        value: function allowUserDrop() {\n            var div = this.trackDiv;\n            var self = this;\n            div.droppable({\n                over: function over(e, ui) {\n                    var track = ui.draggable.data(\"track\");\n                    var panel = ui.draggable.data(\"panel\");\n                    if (panel === self) {\n                        return;\n                    }\n                    if (track) {\n                        var icon = \"<span class='ui-icon ui-icon-check'></span>\";\n                        if (track.no_drop || self.tracks[track.track_id]) {\n                            icon = \"<span class='ui-icon  ui-icon-closethick'></span>\";\n                        }\n                        setTimeout(function () {\n                            ui.helper.prepend(icon).css(\"white-space\", \"nowrap\");\n                        }, 20);\n                    }\n                },\n                greedy: true,\n                out: function out(e, ui) {\n                    ui.helper.find(\".ui-icon\").remove();\n                },\n                drop: function drop(e, ui) {\n                    var track = $(ui.draggable[0]).data(\"track\");\n                    ui.helper.find(\".ui-icon\").remove();\n\n                    if (!track) {\n                        return;\n                    }\n                    var panel = $(ui.draggable[0]).data(\"panel\");\n\n                    if (panel === self || track.no_drop || self.tracks[track.track_id]) {\n                        return;\n                    } else {\n                        if (panel) {\n                            panel.removeTrack(track.track_id);\n                            panel.update();\n                        }\n                        self.addTrack(track);\n                        self.update();\n                    }\n                }\n            });\n            return this;\n        }\n\n        /**\r\n        * Gets the feature that was clicked\r\n        * @param {JQuery Event} e - Can be any object- all that is required is pageX and PageY\r\n        * @returns {object} An object with track - the track config at the event position(or null) and\r\n        * feature - the feature at the postition (or null). \r\n        */\n\n    }, {\n        key: \"getFeatureAt\",\n        value: function getFeatureAt(e) {\n            var co = _utils.Utils.translateMouseCoordinates(e, this.canvas);\n            co.y -= this.yOffset;\n            var gl = Math.round(this.start + co.x * this.bpPerPixel);\n            for (var t in this.tracks) {\n                var track = this.tracks[t];\n                if (co.y > track.top && co.y < track.bottom) {\n                    return { track: track,\n                        feature: track.getFeatureAt(gl, this.chr, co, this.bpPerPixel, this.ctx, this.yOffset)\n                    };\n                }\n            }\n            return { track: null, feature: null };\n        }\n    }, {\n        key: \"allowUserResize\",\n        value: function allowUserResize(direction) {\n            var handles = \"all\";\n            if (direction === \"vertical\") {\n                handles = \"n,s\";\n            } else if (direction === \"horizontal\") {\n                handles = \"e,w\";\n            }\n            var div = this.trackDiv;\n            var self = this;\n\n            div.resizable({\n\n                resize: function resize(e, ui) {\n                    e.stopPropagation();\n                    if (self.loading) {\n                        return false;\n                    }\n\n                    clearTimeout(self.to);\n                    self.to = setTimeout(function (e) {\n                        self.setWidth(ui.size.width);\n                        self.setHeight(ui.size.height);\n                        self.update();\n                    }, 100);\n                },\n                handles: handles\n\n            });\n            return this;\n        }\n\n        /**\r\n        * Allows the user to move the panel via a handle in the\r\n        * top right hand corner\r\n        * @param {string} direction - either vertical or horzontal, will restrict movement \r\n        * in this plane\r\n        * @param {boolean} if true then the panel will be constrained within its parent \r\n        */\n\n    }, {\n        key: \"allowUserMove\",\n        value: function allowUserMove(direction, contain) {\n            var axis = false;\n            var icon = \"fa-arrows-alt\";\n            if (direction == \"vertical\") {\n                axis = \"y\";\n                icon += \"-v\";\n            } else if (direction == \"horizontal\") {\n                axis = \"x\";\n                icon += \"-h\";\n            }\n            var div = this.trackDiv;\n            div.find(\".panel-icon-div\").prepend($(\"<span class='track-handle fas \" + icon + \"'></span>\").css({ \"cursor\": \"move\" }));\n            var self = this;\n            var c = false;\n            if (contain) {\n                c = \"parent\";\n            }\n            div.draggable({ handle: \".track-handle\", axis: axis, containment: c });\n            return this;\n        }\n    }, {\n        key: \"allowUserClose\",\n        value: function allowUserClose() {\n            var div = this.trackDiv;\n            var self = this;\n            var icon = $(\"<span class='fas fa-trash'></span>\").click(function () {\n                self.listeners.panel_closed.forEach(function (func) {\n                    func(self);\n                });\n                div.remove();\n            });\n            div.find(\".panel-icon-div\").append(icon);\n        }\n    }, {\n        key: \"setWidth\",\n        value: function setWidth(width) {\n            this.trackDiv.width(width);\n            this.canvas.setAttribute('width', width);\n        }\n    }, {\n        key: \"setHeight\",\n        value: function setHeight(height) {\n            $(this.trackDiv).height(height);\n            this.canvas.setAttribute('height', height);\n            if (this.show_scale) {\n                this.scale_canvas[0].setAttribute(\"height\", height);\n            }\n        }\n    }, {\n        key: \"redrawTile\",\n        value: function redrawTile(features) {\n\n            if (!this.tile) return;\n\n            var self = this,\n                chr = self.tile.chr,\n                bpStart = self.tile.startBP,\n                bpEnd = self.tile.endBP,\n                buffer = document.createElement('canvas'),\n                bpPerPixel = self.tile.scale;\n\n            buffer.width = self.tile.image.width;\n            buffer.height = self.tile.image.height;\n            var ctx = buffer.getContext('2d');\n\n            self.track.draw({\n                features: features,\n                context: ctx,\n                bpStart: bpStart,\n                bpPerPixel: bpPerPixel,\n                pixelWidth: buffer.width,\n                pixelHeight: buffer.height\n            });\n\n            self.tile = new Tile(chr, bpStart, bpEnd, bpPerPixel, buffer);\n            self.paintImage();\n        }\n    }]);\n\n    return MLVPanel;\n}();\n\nvar Tile = function () {\n    function Tile(chr, tileStart, tileEnd, scale, image) {\n        _classCallCheck(this, Tile);\n\n        this.chr = chr;\n        this.startBP = tileStart;\n        this.endBP = tileEnd;\n        this.scale = scale;\n        this.image = image;\n    }\n\n    _createClass(Tile, [{\n        key: \"containsRange\",\n        value: function containsRange(chr, start, end, scale) {\n            if (start < 0) {\n                start = 0;\n            }\n            return this.scale.toFixed(3) === scale.toFixed(3) && start >= this.startBP && end <= this.endBP && chr === this.chr;\n        }\n    }, {\n        key: \"overlapsRange\",\n        value: function overlapsRange(chr, start, end) {\n            return this.chr === chr && this.endBP >= start && this.startBP <= end;\n        }\n    }]);\n\n    return Tile;\n}();\n\nexports.MLVPanel = MLVPanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3BhbmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy9wYW5lbC5qcz9hNGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGlnaHR3ZWlnaHQgcGFuZWwgdGhlIGNhbiBob3N0IG11bHRpcGxlIHRyYWNrcyBvZlxyXG4gKiBkaWZmZXJlbnQgdHlwZXNcclxuICovXHJcbmltcG9ydCB7TUxWVHJhY2ssUnVsZXJUcmFja30gZnJvbSBcIi4vdHJhY2tzLmpzXCI7XHJcbmltcG9ydCB7VXRpbHN9IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcbmltcG9ydCB7UGFuZWxMZWdlbmR9IGZyb20gXCIuL3BhbmVsX2xlZ2VuZC5qc1wiO1xyXG5cclxuXHJcblxyXG5jbGFzcyBNTFZQYW5lbCB7XHJcblx0LyoqXHJcblx0KiBDcmVhdGVzIGEgcGFuZWxcclxuXHQqIEBwYXJhbSB7YXJyYXl9IHRyYWNrcyAtIGEgbGlzdCBvZiBjb25maWcgb2JqZWN0cyBkZXNjcmliaW5nIGVhY2ggdHJhY2tcclxuXHQqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBBIGNvbmZpZyB3aXRoIHRoZSBwYW5lbCBzZXR0aW5nc1xyXG5cdCovXHJcblx0Y29uc3RydWN0b3IgKHRyYWNrcyxjb25maWcpIHtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0Y29uZmlnPXt9O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXhlZF9oZWlnaHRfbW9kZT1mYWxzZTtcclxuXHRcdGlmIChjb25maWcuZml4ZWRfaGVpZ2h0X21vZGUpe1xyXG5cdFx0XHR0aGlzLmZpeGVkX2hlaWdodF9tb2RlPXRydWU7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXMuc2hvd19zY2FsZT10cnVlO1xyXG5cdFx0aWYgKGNvbmZpZy5zaG93X3NjYWxlKXtcclxuICAgICAgIFx0XHR0aGlzLnNob3dfc2NhbGU9dHJ1ZTtcclxuICAgICAgIFx0fVxyXG5cclxuXHRcdGxldCBoZWlnaHQ9Y29uZmlnLmhlaWdodD9jb25maWcuaGVpZ2h0OjIwMDtcclxuXHRcdGxldCB3aWR0aD0gY29uZmlnLndpZHRoP2NvbmZpZy53aWR0aDo0MDA7XHJcblx0XHRsZXQgZGltPXtoZWlnaHQ6aGVpZ2h0LHdpZHRoOndpZHRofTtcclxuXHRcdGxldCBwYW5lbF9kaXY9bnVsbDtcclxuXHRcdGlmICghY29uZmlnLmRpdil7XHJcblx0XHRcdHBhbmVsX2Rpdj0kKFwiPGRpdj5cIikuaGVpZ2h0KGhlaWdodCkud2lkdGgod2lkdGgpO1xyXG5cclxuXHRcdH1cclxuXHRcdGVsc2V7XHJcblx0XHRcdGlmICh0eXBlb2YgY29uZmlnLmRpdiA9PT0gJ3N0cmluZycgKXtcclxuXHRcdFx0XHRwYW5lbF9kaXY9JChcIiNcIitjb25maWcuZGl2KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNle1xyXG5cdFx0XHRcdHBhbmVsX2Rpdj0kKGNvbmZpZy5kaXYpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGhlaWdodD1wYW5lbF9kaXYuaGVpZ2h0KCk7XHJcblx0XHRcdHdpZHRoPXBhbmVsX2Rpdi53aWR0aCgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy50cmFja3M9e31cclxuXHRcdHRoaXMudHJhY2tfb3JkZXI9W107XHJcblx0XHRmb3IgKGxldCB0X2NvbmZpZyBvZiB0cmFja3Mpe1xyXG5cdFx0XHRpZiAodGhpcy5maXhlZF9oZWlnaHRfbW9kZSl7XHJcbiAgICBcdFx0XHR0X2NvbmZpZy5kaXNjcmV0ZT10cnVlO1xyXG4gICAgXHRcdH1cclxuXHRcdFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKHRfY29uZmlnKTtcclxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZClcclxuXHRcdH1cclxuXHRcdC8vY2hlY2sgZm9yIGxpbmtlZCBzY2FsZXNcclxuXHRcdHRoaXMuX3RyYWNrc0NoYW5nZWQoKTtcclxuXHRcdHRoaXMubGVnZW5kPSBudWxsO1xyXG5cclxuICAgICAgXHJcbiAgICAgICBcdHRoaXMudHJhY2tEaXYgPSBwYW5lbF9kaXYuYWRkQ2xhc3MoXCJpZ3YtdHJhY2stZGl2XCIpLmNzcyhcInBvc2l0aW9uXCIsXCJhYnNvbHV0ZVwiKTtcclxuXHJcblx0XHR0aGlzLmNhbnZhcyA9ICQoJzxjYW52YXMgY2xhc3MgPSBcImlndi1jb250ZW50LWNhbnZhc1wiPicpWzBdO1xyXG4gICAgICAgIHRoaXMudHJhY2tEaXYuYXBwZW5kKHRoaXMuY2FudmFzKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgXHR0aGlzLmFkZFNjYWxlQ2FudmFzKGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMudHJhY2tEaXYuYXBwZW5kKFV0aWxzLnNwaW5uZXIoKSk7XHJcblxyXG4gICAgICAgIGxldCBpY29uX2Rpdj0kKFwiPGRpdj5cIikuY3NzKHtcInotaW5kZXhcIjoxMDAscG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjJweFwiLHJpZ2h0OlwiMnB4XCJ9KS5hcHBlbmRUbyh0aGlzLnRyYWNrRGl2KVxyXG4gICAgICAgIFx0XHRcdFx0XHQgICAuYXR0cihcImNsYXNzXCIsXCJwYW5lbC1pY29uLWRpdlwiKVxyXG5cclxuXHJcbiAgICAgICAgLy9mb3IgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgIFx0dGhpcy5pc19kcmFnZ2luZz1mYWxzZTtcclxuICAgICAgIFx0dGhpcy5pc01vdXNlRG93biA9IGZhbHNlLFxyXG4gICAgICBcdHRoaXMubGFzdE1vdXNlWCA9IHVuZGVmaW5lZDtcclxuICAgICAgIFx0dGhpcy5tb3VzZURvd25YID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vYW1vdW50IHRvIHNob3cgZWFjaCBzaWRlIG9mIHZpZXcgcG9ydFxyXG4gICAgICAgXHR0aGlzLmJ1ZmZlcl9sZXZlbD0xO1xyXG5cclxuICAgICAgIFx0dGhpcy5ncm91cHM9e307XHJcblxyXG4gICAgICAgXHR0aGlzLmhpZ2hsaWdodGVkX3JlZ2lvbnM9e307XHJcblxyXG4gICAgICAgXHQvL2xpc3RlbmVyc1xyXG5cdFx0dGhpcy5saXN0ZW5lcnM9e1xyXG4gICAgICAgXHRcdFwicGFuZWxfZW1wdHlcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJwYW5lbF9jbG9zZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJ0cmFja19hZGRlZFwiOm5ldyBNYXAoKSxcclxuICAgICAgIFx0XHRcInRyYWNrX3JlbW92ZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJ2aWV3X2NoYW5nZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJmZWF0dXJlX2NsaWNrZWRcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJmZWF0dXJlX292ZXJcIjpuZXcgTWFwKCksXHJcbiAgICAgICBcdFx0XCJyYW5nZV9zZWxlY3RlZFwiOm5ldyBNYXAoKVxyXG4gICAgICAgXHR9O1xyXG5cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2RyYWcpe1xyXG4gICAgICAgXHRcdHRoaXMuYWxsb3dVc2VyRHJhZygpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl96b29tKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclpvb20oKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHRpZiAoY29uZmlnLmFsbG93X3VzZXJfcmVzaXplKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclJlc2l6ZShjb25maWcuYWxsb3dfdXNlcl9yZXNpemUpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9tb3ZlKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlck1vdmUoY29uZmlnLmFsbG93X3VzZXJfbW92ZSk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2ZlYXR1cmVfY2xpY2spe1xyXG4gICAgICAgXHRcdHRoaXMuYWxsb3dVc2VyRmVhdHVyZUNsaWNrKCk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYgKGNvbmZpZy5hbGxvd191c2VyX2ZlYXR1cmVfb3Zlcil7XHJcbiAgICAgICBcdFx0dGhpcy5hbGxvd1VzZXJGZWF0dXJlT3ZlcigpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9jbG9zZSl7XHJcbiAgICAgICBcdFx0dGhpcy5hbGxvd1VzZXJDbG9zZSgpO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdGlmIChjb25maWcuYWxsb3dfdXNlcl9kcm9wKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlckRyb3AoKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHRpZiAoY29uZmlnLmFsbG93X3VzZXJfcmFuZ2Vfc2VsZWN0aW9uKXtcclxuICAgICAgIFx0XHR0aGlzLmFsbG93VXNlclJhbmdlU2VsZWN0aW9uKCk7XHJcbiAgICAgICBcdH1cclxuXHJcbiAgICAgICBcdGlmKGNvbmZpZy5ydWxlcl90cmFjayl7XHJcbiAgICAgICBcdFx0dGhpcy5hZGRSdWxlclRyYWNrKCk7XHJcbiAgICAgICBcdH1cclxuICAgICAgIFx0aWYoY29uZmlnLmxlZ2VuZCl7XHJcbiAgICAgICBcdFx0dGhpcy5hZGRMZWdlbmQoKTtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHRpZiAoY29uZmlnLm5ld19sYXlvdXQpe1xyXG4gICAgICAgXHRcdHRoaXMubmV3X2xheW91dD10cnVlO1xyXG4gICAgICAgXHR9XHJcbiAgICAgIFxyXG4gICAgICAgXHJcbiAgICAgICBcdHRoaXMucmV0cmllcz0wO1xyXG4gICAgICAgXHR0aGlzLnlPZmZzZXQ9MDtcclxuICAgIH1cclxuXHJcbiAgICBfcGFyc2VDb25maWcoY29uZmlnKXtcclxuICAgIFx0Ly9jaGVjayB0aGUgdHJhY2tzIGhhdmUgdGhlIHJpZ2h0IHNldHRpbmdzXHJcbiAgICBcdGlmICh0aGlzLmZpeGVkX2hlaWdodF9tb2RlKXtcclxuICAgIFx0XHRjb25maWcuZGlzY3JldGU9dHJ1ZTtcclxuICAgIFx0XHRpZiAoIWNvbmZpZy5oZWlnaHQpe1xyXG4gICAgXHRcdFx0Y29uZmlnLmhlaWdodD0xNTA7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkU2NhbGVDYW52YXMoaGVpZ2h0KXtcclxuICAgIFx0dGhpcy5zY2FsZV9jYW52YXMgPSAkKCc8Y2FudmFzPicpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjBweFwiLGxlZnQ6XCI1cHhcIn0pO1xyXG4gICAgXHR0aGlzLnNjYWxlX2NhbnZhc1swXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMTAwKTtcclxuICAgICAgICB0aGlzLnNjYWxlX2NhbnZhc1swXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zY2FsZV9jYW52YXMuYXBwZW5kVG8odGhpcy50cmFja0Rpdik7XHJcbiAgICAgICAgdGhpcy5zY2FsZV9jdHg9dGhpcy5zY2FsZV9jYW52YXNbMF0uZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogc2V0cyB0aGUgZXh0cmEgYW1vdW50IG9mIHRyYWNrIHRvIGRyYXcgZWFjaCBzaWRlIG9mIHRoZSB2aWV3LiBBIHZhbHVlIFxyXG5cdCogb2YgMSB3aWxsIHJldHJlaXZlIDEgeCB0aGUgdmlldyB3aWR0aCBlYWNoIHNpZGUgaS5lLiAzIHggdGhlIHZpc2libGUgd2luZG93XHJcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGxldmVsIC0gVGhlIHR5cGUgb2YgbGlzdGVuZXIgLSB0cmFja19lbXB0eSBcclxuXHQqL1xyXG4gICAgc2V0QnVmZmVyTGV2ZWwobGV2ZWwpe1xyXG4gICAgXHR0aGlzLmJ1ZmZlcl9sZXZlbD1sZXZlbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG5cdCogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGhvdXNlcyB0aGUgcGFuZWxcclxuXHQqIEByZXR1cm5zIHtpbnRlZ2VyfSBsZXZlbCAtIFRoZSB0eXBlIG9mIGxpc3RlbmVyIC0gdHJhY2tfZW1wdHkgXHJcblx0Ki9cclxuXHJcbiAgICBnZXREaXYoKXtcclxuICAgIFx0cmV0dXJuIHRoaXMudHJhY2tEaXY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgYWRkTGVnZW5kKCl7XHJcbiAgICBcdHRoaXMubGVnZW5kID0gbmV3IFBhbmVsTGVnZW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgICAgICAvKipcclxuXHQqIFNldHMgdGhlIGhpZ2hsaWd0ZWQgcmVnaW9uXHJcblx0KiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBBbiBvYmplY3QgY29udGFpbmluZyBjaHIsIHN0YXJ0IGFuZCBlbmRcclxuXHQqIEBwYXJhbSB7bmFtZX0gVGhlIG5hbWUoaWQpIG9mIHRoZSByZWdpb24gKHVzZWQgdG8gcmVtb3ZlIHRoZSByZWdpb24pXHJcblx0KiBAcGFyYW0ge1N0cmluZ30gVGhlIGNvbG9yIHRvIGdpdmUgdGhlIGhpZ2hsaWd0ZWQgcmVnaW9uXHJcblx0Ki9cclxuICAgIHNldEhpZ2hsaWdodGVkUmVnaW9uKGxvY2F0aW9uLG5hbWUsY29sb3Ipe1xyXG4gICAgXHR0aGlzLmhpZ2hsaWdodGVkX3JlZ2lvbnNbbmFtZV09e1xyXG4gICAgXHRcdGNocjpsb2NhdGlvbi5jaHIsXHJcbiAgICBcdFx0c3RhcnQ6bG9jYXRpb24uc3RhcnQsXHJcbiAgICBcdFx0ZW5kOmxvY2F0aW9uLmVuZCxcclxuICAgIFx0XHRjb2xvcjpjb2xvclxyXG4gICAgXHR9XHJcbiAgICBcdHRoaXMuZm9yY2VfcmVkcmF3PXRydWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogUmVtb3ZlcyB0aGUgaGlnaGxpZ2h0ZWQgcmVnaW9uIGZyb20gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBoaWdobGlnaHRlZCByZWdpb25cclxuXHQqIHRoYXQgd2FzIGdpdmVuIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXHJcblx0Ki9cclxuICAgIHJlbW92ZUhpZ2hsaWdodGVkUmVnaW9uKG5hbWUpe1xyXG4gICAgXHRkZWxldGUgdGhpcy5oaWdobGlnaHRlZF9yZWdpb25zW25hbWVdO1xyXG4gICAgXHR0aGlzLmZvcmNlX3JlZHJhdz10cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIGFkZFJ1bGVyVHJhY2soKXtcclxuICAgIFx0bGV0IHRyYWNrPW5ldyBSdWxlclRyYWNrKCk7XHJcbiAgICBcdGxldCBjb25maWcgPSB0cmFjay5nZXRDb25maWcoKTtcclxuXHRcdHRoaXMudHJhY2tzW2NvbmZpZy50cmFja19pZF09dHJhY2s7XHJcblx0XHR0aGlzLnRyYWNrX29yZGVyLnVuc2hpZnQoY29uZmlnLnRyYWNrX2lkKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBwYW5lbFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0ZW5lciAtIHRyYWNrX2VtcHR5XHJcblx0KiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGhhbmRsZXIgKGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgaGFuZGxlcilcclxuXHQqIE9wdGlvbmFsIC0gYW4gaWQgd2lsbCBiZSBhc3NpZ25lZCAoYW5kIHJldHVybmVkKSBpZiBub3Qgc3VwcGxpZWRcclxuXHQqIEByZXR1cm5ze3N0cmluZ30gVGhlIGlkIG9mIHRoZSBoYW5kbGVyIG9yIG51bGwgaWYgdGhlIHR5cGUgZGlkIG5vdCBleGlzdCBcclxuXHQqL1xyXG4gICAgYWRkTGlzdGVuZXIodHlwZSxmdW5jLGlkKXtcclxuICAgIFx0bGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XHJcbiAgICBcdGlmICghbGlzdGVuZXIpe1xyXG4gICAgXHRcdHJldHVybiBudWxsO1xyXG4gICAgXHR9XHJcbiAgICBcdGlmICghaWQpe1xyXG4gICAgXHRcdGlkID0gdHlwZStcIl9cIitsaXN0ZW5lci5zaXplXHJcbiAgICBcdH1cclxuICAgIFx0bGlzdGVuZXIuc2V0KGlkLGZ1bmMpO1xyXG4gICAgXHRyZXR1cm4gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcblx0KiBSZW1vdmVzIGEgbGlzdGVuZXIgdG8gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGxpc3RlbmVyIC0gdHJhY2tfZW1wdHkgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGhhbmRsZXIgdG8gcmVtb3ZlXHJcblx0KiBAcmV0dXJuc3tib29sZWFufSB0cnVlIGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZCwgb3RoZXJ3aXNlIGZhbHNlIFxyXG5cdCovXHJcbiAgICByZW1vdmVMaXN0ZW5lcih0eXBlLGlkKXtcclxuICAgIFx0bGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XHJcbiAgICBcdGlmICghbGlzdGVuZXIpe1xyXG4gICAgXHRcdHJldHVybiBmYWxzZTtcclxuICAgIFx0fVxyXG4gICAgXHRyZXR1cm4gbGlzdGVuZXIuZGVsZXRlKGlkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgIFxyXG4gICAgLyoqXHJcblx0KiBSZW1vdmVzIGEgbGlzdGVuZXIgdG8gdGhlIHBhbmVsXHJcblx0KiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gVGhlIGNvbmZpZyBvZiB0aGUgdHJhY2sgdG8gYWRkVHJhY2tcclxuXHQqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggLSBPcHRpb25hbCwgdGhlIHZlcnRpY2FsIG9yZGVyIG9mIHRoZSB0cmFja1xyXG5cdCovXHJcbiAgICBhZGRUcmFjayhjb25maWcsaW5kZXgsbm9fcHJvcGFnYXRlKXtcclxuICAgIFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKGNvbmZpZyk7XHJcbiAgICBcdGlmICh0aGlzLmZpeGVkX2hlaWdodF9tb2RlKXtcclxuICAgIFx0XHR0cmFjay5jb25maWcuZGlzY3JldGU9dHJ1ZTtcclxuICAgIFx0fVxyXG5cdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdGlmIChpbmRleCB8fCBpbmRleD09MCl7XHJcblx0XHRcdHRoaXMudHJhY2tfb3JkZXIuc3BsaWNlKGluZGV4LDAsdHJhY2suY29uZmlnLnRyYWNrX2lkKVxyXG5cdFx0fVxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdHJhY2tzQ2hhbmdlZCgpO1xyXG5cdFx0aWYgKHRoaXMubGVnZW5kKXtcclxuICAgIFx0XHR0aGlzLmxlZ2VuZC5hZGRUcmFjayh0cmFjay5jb25maWcsaW5kZXgpO1xyXG4gICAgXHR9XHJcblx0XHRpZiAoIW5vX3Byb3BhZ2F0ZSl7XHJcblx0XHRcdHRoaXMuX2NhbGxMaXN0ZW5lcnMoXCJ0cmFja19hZGRlZFwiLHRyYWNrLmNvbmZpZyk7XHJcblx0XHR9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIF9jYWxsTGlzdGVuZXJzKHR5cGUsY29uZmlnKXtcclxuICAgIFx0ICBcclxuICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbih2KXt2KGNvbmZpZyl9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVBbGxUcmFja3MoKXtcclxuICAgIFx0bGV0IGR1cF9hcnJheSA9IHRoaXMudHJhY2tfb3JkZXIuc2xpY2UoKTtcclxuICAgIFx0Zm9yIChsZXQgaWQgb2YgZHVwX2FycmF5KXtcclxuICAgIFx0XHR0aGlzLnJlbW92ZVRyYWNrKGlkLHRydWUpXHJcbiAgICBcdH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuXHQvKipcclxuXHQqIFJlbW92ZXMgYSBsaXN0ZW5lciB0byB0aGUgcGFuZWxcclxuXHQqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBUaGUgY29uZmlnIG9mIHRoZSB0cmFjayB0byBhZGQgXHJcblx0Ki9cclxuICAgIHJlbW92ZVRyYWNrKHRyYWNrX2lkLG5vdF9yZXBhaW50LG5vdF9wcm9wYWdhdGUpe1xyXG4gICAgXHRpZiAoIXRoaXMudHJhY2tzW3RyYWNrX2lkXSl7XHJcbiAgICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgICBcdH1cclxuICAgIFx0dGhpcy50cmFja19vcmRlciA9IHRoaXMudHJhY2tfb3JkZXIuZmlsdGVyKGUgPT4gZSAhPT0gdHJhY2tfaWQpO1xyXG4gICAgXHRpZiAoIW5vdF9yZXBhaW50KXtcclxuICAgIFx0XHR0aGlzLnJlcGFpbnQodHJ1ZSx0cnVlKTtcclxuICAgIFx0fVxyXG4gICAgXHJcbiAgICBcdGlmICh0aGlzLmxlZ2VuZCl7XHJcbiAgICBcdFx0dGhpcy5sZWdlbmQucmVtb3ZlVHJhY2sodHJhY2tfaWQpO1xyXG4gICAgXHR9XHJcbiAgICBcdGxldCBjb25maWcgPSAgdGhpcy50cmFja3NbdHJhY2tfaWRdLmNvbmZpZ1xyXG4gICAgXHRkZWxldGUgdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgXHRpZiAoISBub3RfcHJvcGFnYXRlKXtcclxuICAgIFx0XHR0aGlzLl9jYWxsTGlzdGVuZXJzKFwidHJhY2tfcmVtb3ZlZFwiLGNvbmZpZyk7XHJcblx0fVxyXG4gICAgXHRpZiAodGhpcy50cmFja19vcmRlci5sZW5ndGg9PT0wKXtcclxuICAgICAgICAgICAgZm9yIChsZXQgbF9pZCBpbiB0aGlzLmxpc3RlbmVyc1tcInBhbmVsX2VtcHR5XCJdKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW1wicGFuZWxfZW1wdHlcIl1bbF9pZF0odGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VHJhY2tDb25maWcodHJhY2tfaWQpe1xyXG4gICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICBcdHJldHVybiB0cmFjay5nZXRDb25maWcoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0QWxsVHJhY2tDb25maWdzKCl7XHJcbiAgICBcdGxldCBjb25maWdzPVtdO1xyXG4gICAgXHRmb3IgKGxldCBpZCBvZiB0aGlzLnRyYWNrX29yZGVyKXtcclxuXHRcdFx0Y29uZmlncy5wdXNoKHRoaXMudHJhY2tzW2lkXS5nZXRDb25maWcoKSk7XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGNvbmZpZ3M7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldFRyYWNrQXR0cmlidXRlKHRyYWNrX2lkLGtleSx2YWx1ZSl7XHJcbiAgICBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0aWYgKCF0cmFjayl7XHJcbiAgICBcdFx0cmV0dXJuO1xyXG4gICAgXHR9XHJcbiAgICBcdHRyYWNrLnNldENvbmZpZ0F0dHJpYnV0ZShrZXksdmFsdWUpO1xyXG4gICAgXHRpZiAoa2V5PT09XCJzY2FsZV9saW5rX3RvXCIpe1xyXG4gICAgXHRcdHRoaXMudHJhY2tzW3RyYWNrX2lkXS5zY2FsZV9saW5rX3RvID0gdGhpcy50cmFja3NbdmFsdWVdO1xyXG4gICAgXHR9XHJcbiAgICBcdGlmICgoa2V5PT09XCJjb2xvclwiIHx8IGtleT09PVwiZGlzcGxheVwiKSAmJiB0aGlzLmxlZ2VuZCl7XHJcbiAgICBcdFx0dGhpcy5sZWdlbmQudXBkYXRlVHJhY2sodHJhY2tfaWQpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldFRyYWNrQXR0cmlidXRlcyh0cmFja19pZCxhdHRyaWJ1dGVzKXtcclxuICAgIFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgXHRmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcyl7XHJcbiAgICBcdFx0dHJhY2suc2V0Q29uZmlnQXR0cmlidXRlKGtleSxhdHRyaWJ1dGVzW2tleV0pO1xyXG4gICAgXHRcdGlmIChrZXk9PT1cImNvbG9yXCIgJiYgdGhpcy5sZWdlbmQpe1xyXG4gICAgICAgIFx0XHR0aGlzLmxlZ2VuZC51cGRhdGVUcmFjayh0cmFja19pZCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICBcdH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcblx0KiBTZXRzIHRoZSBmaWx0ZXIgIGZ1bmN0aW9uIGZvciB0cmFjay4gXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gdHJhY2tfaWQtIFRoZSBpZCBvZiB0aGUgdHJhY2tcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBmdW5jIC0gVGhlIGZpbHRlciBmdW5jdGlvbi4gSXQgc2hvdWxkIGFjY2VwdCB0aGUgZmVhdHVyZVxyXG5cdCogYW5kIHJldHVybiB0cnVlIHRvIGRpc3BhbHkgdGhlIGZlYXR1cmUgYW5kIGZhbHNlIHRvIGhpZGUgaXQuIFVzZSBudWxsIFxyXG5cdCogdG8gY2FuY2VsIHRoZSBmaWx0ZXJcclxuXHQqL1xyXG4gICAgc2V0VHJhY2tGZWF0dXJlRmlsdGVyKHRyYWNrX2lkLGZ1bmMpe1xyXG4gICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICBcdHRyYWNrLnNldEZpbHRlckZ1bmN0aW9uKGZ1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCogU2V0cyB0aGUgZmlsdGVyICBmdW5jdGlvbiBmb3IgdHJhY2sgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gdHJhY2tfaWQtIFRoZSBpZCBvZiB0aGUgdHJhY2tcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBmdW5jIC0gVGhlIGNvbG9yIGZ1bmN0aW9uLiBJdCBzaG91bGQgYWNjZXB0IHRoZSBmZWF0dXJlXHJcblx0KiBhbmQgcmV0dXJuIHRoZSBmZWF0dXJlIGNvbG9yLiBVc2UgbnVsbCB0byBnbyBiYWNrIHRvIGRlZmF1bHQgY29sb3JzIFxyXG5cdCovXHJcbiAgICBzZXRUcmFja0NvbG9yRnVuY3Rpb24odHJhY2tfaWQsZnVuYyl7XHJcbiAgICBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0dHJhY2suc2V0Q29sb3JGdW5jdGlvbihmdW5jKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRUcmFja0xhYmVsRnVuY3Rpb24odHJhY2tfaWQsZnVuYyl7XHJcbiAgICBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgIFx0aWYgKHRyYWNrKXtcclxuICAgIFx0XHR0cmFjay5sYWJlbF9mdW5jdGlvbj1mdW5jO1xyXG4gICAgXHR9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgXHJcblxyXG5cclxuXHJcblxyXG4gICAgX3RyYWNrc0NoYW5nZWQoKXtcclxuICAgIFx0Zm9yIChsZXQgdF9pZCBvZiB0aGlzLnRyYWNrX29yZGVyKXtcclxuICAgIFx0XHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0X2lkXTtcclxuICAgIFx0XHQvL2lmIHRoaXMgdHJhY2sgaXMgbGlua2VkIHRvIHRoZSBzY2FsZSBvZiBhbm90aGVyXHJcbiAgICBcdFx0Ly9nZXQgcG9pbnRlciB0byB0aGUgdHJhY2tcclxuICAgIFx0XHRsZXQgbGlua190byA9IHRyYWNrLmNvbmZpZ1snc2NhbGVfbGlua190byddO1xyXG4gICAgXHRcdGlmIChsaW5rX3RvKXtcclxuXHRcdFx0XHRsZXQgb3RoZXJfdHJhY2sgPSB0aGlzLnRyYWNrc1tsaW5rX3RvXTtcclxuXHRcdFx0XHRpZiAob3RoZXJfdHJhY2spe1xyXG5cdFx0XHRcdFx0dHJhY2suc2NhbGVfbGlua190bz1vdGhlcl90cmFjaztcclxuXHRcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEN1cnJlbnRUcmFja0ZlYXR1cmVzKHRyYWNrX2lkKXtcclxuICAgIFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgXHRyZXR1cm4gdHJhY2suZ2V0Q3VycmVudEZlYXR1cmVzKHRoaXMuY2hyLHRoaXMuc3RhcnQsdGhpcy5lbmQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBcclxuXHQgXHJcblx0IFxyXG5cdCBcclxuXHJcbiAgXHJcblxyXG4gICAvKipcclxuICAgICogVXBkYXRlZCB0aGUgcGFuZWwgdmlldywgaWYgY2hyb21vc29tZSBzdGFydCBhbmQgZW5kIGFyZSBzdXBwbGllZFxyXG4gICAgKiBpdCB3aWxsIGdvIHRvIHRoaXMgbG9jYXRpb24uIElmIG5vIHBhcmFtZXRlcnMgYXJlIGdpdmVuIHRoZSBwYW5lbFxyXG4gICAgKiB3aWxsIGJlIHJlZHJhd24gYXQgdGhlIHNhbWUgbG9jYXRpb24gZS5nIGFmdGVyIHRoZSBjb2xvciwgc2NhbGUgb3IgYW5vdGhlclxyXG4gICAgKiBwYXJhbXRlciBoYXMgYmVlbiBzZXRcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcmNlIC0gSWYgdHJ1ZSB0aGVuIGEgY2FjaGVkIGltYWdlIHdpbGwgbm90IGJlIHVzZWRcclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydCBvZiB0aGUgcmVnaW9uIHRvIGRyYXdcclxuICAgICogQHBhcmFtIHtpbnRlZ2VyfSBlbmQgb2YgdGhlIHJlZ2lvbiB0byBkcmF3XHJcbiAgICAqL1xyXG5cclxuICAgIHVwZGF0ZSAoY2hyLHN0YXJ0LGVuZCxub19wcm9wYWdhdGlvbikge1xyXG4gICAgXHR0aGlzLmNhbGxfdXBkYXRlX2xpc3RlbmVyPW5vX3Byb3BhZ2F0aW9uO1xyXG4gICAgICAgIGlmIChjaHIpe1xyXG4gICAgICAgICAgICB0aGlzLmNocj1jaHI7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQ9c3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kPWVuZDtcclxuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgXHR0aGlzLnJlcGFpbnQodHJ1ZSx0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBnZXRUcmFja3NIZWlnaHQoKXtcclxuICAgIFx0bGV0IGggPTA7XHJcbiAgICBcdGxldCBncm91cHM9e31cclxuICAgIFx0Zm9yIChsZXQgdGlkIG9mIHRoaXMudHJhY2tfb3JkZXIpe1xyXG4gICAgXHRcdGxldCB0cmFjaz0gIHRoaXMudHJhY2tzW3RpZF07XHJcbiAgICBcdFx0bGV0IGcgPSB0cmFjay5jb25maWcuZ3JvdXA7XHJcbiAgICBcdFx0aWYgKGcpe1xyXG4gICAgXHRcdFx0aWYgKCFncm91cHNbZ10pe1xyXG4gICAgXHRcdFx0XHRoKz10cmFjay5jb25maWcuaGVpZ2h0O1xyXG4gICAgXHRcdFx0XHRncm91cHNbZ109dHJ1ZTtcclxuICAgIFx0XHRcdH1cclxuXHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGVsc2V7XHJcblx0XHRcdFx0aCs9dHJhY2suY29uZmlnLmhlaWdodDtcclxuICAgIFx0XHR9XHJcbiAgICBcdH1cclxuICAgIFx0cmV0dXJuIGg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEFsbEZlYXR1cmVzKGJwU3RhcnQsIGJwRW5kLGZvcmNlLGRhdGEpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB0cmFja19pZCAgb2YgdGhpcy50cmFja19vcmRlcil7XHJcbiAgICAgICAgXHRsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja19pZF07XHJcbiAgICAgICAgXHRwcm9taXNlcy5wdXNoKHRyYWNrLmdldEZlYXR1cmVzKHRoaXMuY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSkpOyAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTsgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBhaW50IHRoZSB2aWV3LCB1c2luZyBhIGNhY2hlZCBpbWFnZSBpZiBhdmFpbGFibGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gSWYgdHJ1ZSB0aGVuIGEgY2FjaGVkIGltYWdlIHdpbGwgbm90IGJlIHVzZWRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmFuZ2VfZnJvbV90aWxlIFJlZHJhdyB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICByZXBhaW50KGZvcmNlLHJhbmdlX2Zyb21fdGlsZSkge1xyXG5cclxuICAgICAgIFxyXG5cdFx0XHJcbiAgICAgICAgdmFyIHBpeGVsV2lkdGgsXHJcbiAgICAgICAgICAgIGJwV2lkdGgsXHJcbiAgICAgICAgICAgIGJwU3RhcnQsXHJcbiAgICAgICAgICAgIGJwRW5kLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgY3R4LFxyXG4gICAgICAgICAgICByZWZlcmVuY2VGcmFtZSxcclxuICAgICAgICAgICAgY2hyLFxyXG4gICAgICAgICAgICByZWZGcmFtZVN0YXJ0LFxyXG4gICAgICAgICAgICByZWZGcmFtZUVuZCxcclxuICAgICAgICAgICAgc3VjY2VzcztcclxuXHJcbiAgICAgICAgY2hyID0gdGhpcy5jaHI7XHJcbiAgICAgICAgcmVmRnJhbWVTdGFydCA9IHRoaXMuc3RhcnQ7XHJcbiAgICAgICAgcmVmRnJhbWVFbmQgPSB0aGlzLmVuZDtcclxuICAgICAgICB0aGlzLmJwUGVyUGl4ZWw9KHRoaXMuZW5kLXRoaXMuc3RhcnQpL3RoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgICAgIGxldCBnZXRfZmVhdHVyZXM9dHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy50aWxlICYmIHRoaXMudGlsZS5jb250YWluc1JhbmdlKGNociwgcmVmRnJhbWVTdGFydCwgcmVmRnJhbWVFbmQsIHRoaXMuYnBQZXJQaXhlbCkpe1xyXG4gICAgICAgICAgICBnZXRfZmVhdHVyZXM9ZmFsc2U7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBpZiAoIWdldF9mZWF0dXJlcyAmJiAhZm9yY2UgJiYgIXRoaXMuZm9yY2VfcmVkcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VfcmVkcmF3PWZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnBhaW50SW1hZ2UoKTtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLmNhbGxfdXBkYXRlX2xpc3RlbmVyKXtcclxuICAgICAgICAgICAgXHRzZWxmLmxpc3RlbmVycy52aWV3X2NoYW5nZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKHNlbGYuY2hyLHBhcnNlSW50KHNlbGYuc3RhcnQpLHBhcnNlSW50KHNlbGYuZW5kKSl9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLmNhbGxfdXBkYXRlX2xpc3RlbmVyPWZhbHNlO1xyXG4gICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICBzZWxmLnJldHJpZXM9MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgcmVxdWVzdGVkIHJhbmdlIHNvIHdlIGNhbiBwYW4gYSBiaXQgd2l0aG91dCByZWxvYWRpbmdcclxuICAgICAgICAgICAgdGhpcy5mb3JjZV9yZWRyYXc9ZmFsc2U7XHJcbiAgICAgICAgICAgIHBpeGVsV2lkdGggPSAoKHRoaXMuYnVmZmVyX2xldmVsKjIpKzEpICogdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIGJwV2lkdGggPSBNYXRoLnJvdW5kKHBpeGVsV2lkdGgqdGhpcy5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgYnBTdGFydCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQodGhpcy5zdGFydC0odGhpcy5idWZmZXJfbGV2ZWwqdGhpcy5jYW52YXMud2lkdGgqdGhpcy5icFBlclBpeGVsKSkpO1xyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBicFdpZHRoO1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5sb2FkaW5nKXtcclxuICAgICAgICAgICAgXHRpZiAoZm9yY2UgJiYgcmFuZ2VfZnJvbV90aWxlKXtcclxuICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlX3JlcXVpcmVkPXRydWU7XHJcbiAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICBcdGVsc2V7XHJcbiAgICAgICAgICAgIFx0XHRzZWxmLnVwZGF0ZV9yZXF1aXJlZD1cImxvY2F0aW9uXCI7XHJcbiAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICBcdHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmFuZ2VfZnJvbV90aWxlKXtcclxuICAgICAgICAgICAgXHRpZiAodGhpcy50aWxlKXtcclxuICAgICAgICAgICAgICAgICAgICBicFN0YXJ0PXRoaXMudGlsZS5zdGFydEJQO1xyXG4gICAgICAgICAgICAgICAgICAgIGJwRW5kPXRoaXMudGlsZS5lbmRCUDtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgc2VsZi5sb2FkaW5nID0ge3N0YXJ0OiBicFN0YXJ0LCBlbmQ6IGJwRW5kfTtcclxuICAgICAgICAgICAgc2VsZi50cmFja0Rpdi5maW5kKFwiLm1sdi1hbGVydFwiKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgIFV0aWxzLnN0YXJ0U3Bpbm5lckF0UGFyZW50RWxlbWVudChzZWxmLnRyYWNrRGl2KTtcclxuXHJcblxyXG4gICAgICAgICAgICBzZWxmLmdldEFsbEZlYXR1cmVzKCBicFN0YXJ0LCBicEVuZCwhZ2V0X2ZlYXR1cmVzLHtwaXhlbFdpZHRoOnBpeGVsV2lkdGgsYnBQZXJQaXhlbDpzZWxmLmJwUGVyUGl4ZWx9KVxyXG5cclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhbGxfZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53aWR0aCA9IHBpeGVsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5oZWlnaHQgPSBzZWxmLmZpeGVkX2hlaWdodF9tb2RlP3NlbGYuZ2V0VHJhY2tzSGVpZ2h0KCk6c2VsZi5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgXHRcdFx0XHRcdHNlbGYuc2NhbGVfYnVmZmVyPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBcdFx0XHRcdFx0c2VsZi5zY2FsZV9idWZmZXIud2lkdGggPSAyMDA7XHJcbiAgICAgICAgXHRcdFx0XHRcdHNlbGYuc2NhbGVfYnVmZmVyLmhlaWdodCA9IGJ1ZmZlci5oZWlnaHQ7XHJcbiAgICAgICAgXHRcdFx0XHRcdHNlbGYuc2NhbGVfYnVmZmVyX2N0eD1zZWxmLnNjYWxlX2J1ZmZlci5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGN0eCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFN0YXJ0OiBicFN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwUGVyUGl4ZWw6IHNlbGYuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFdpZHRoOiBidWZmZXIud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxIZWlnaHQ6IGJ1ZmZlci5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyOmNoclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9wPTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXBzPXt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGN1bGF0ZU1heFNjYWxlKGFsbF9mZWF0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYWxsX2ZlYXR1cmVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRsZXQgdHJhY2sgPSBzZWxmLnRyYWNrc1tzZWxmLnRyYWNrX29yZGVyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRvcHRpb25zLmZlYXR1cmVzPWFsbF9mZWF0dXJlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRsZXQgZ3JvdXAgPSB0cmFjay5jb25maWcuZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAoZ3JvdXApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0aWYgKCFzZWxmLmdyb3Vwc1tncm91cF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0XHRzZWxmLmdyb3Vwc1tncm91cF09e3RvcDp0b3AsaGVpZ2h0OnRyYWNrLmNvbmZpZy5oZWlnaHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdC8vZmlyc3QgdGltZSBpbmNyZWFzZSB0b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdFx0dG9wKz10cmFjay5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0b3B0aW9ucy50b3A9c2VsZi5ncm91cHNbZ3JvdXBdLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdG9wdGlvbnMuaGVpZ2h0PXNlbGYuZ3JvdXBzW2dyb3VwXS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0b3B0aW9ucy50b3AgPXRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bGV0IGRpc2MgPSAgIHNlbGYuZml4ZWRfaGVpZ2h0X21vZGUgfHwgdHJhY2suY29uZmlnLmRpc2NyZXRlIHx8IGdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChkaXNjKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRcdGxldCBoPWdyb3VwP29wdGlvbnMuaGVpZ2h0OnRyYWNrLmNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnJlY3QoMCxvcHRpb25zLnRvcCxvcHRpb25zLnBpeGVsV2lkdGgsaCk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHguY2xpcCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQ9IHRyYWNrLmRyYXdGZWF0dXJlcyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2MgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0Y3R4LnJlc3RvcmUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAoIWdyb3VwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHRvcCs9dHJhY2suY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHRyYWNrLmJvdHRvbT10b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRvcD1vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNob3dfc2NhbGUpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dHJhY2suZHJhd1NjYWxlKG9wdGlvbnMucGl4ZWxIZWlnaHQsc2VsZi5zY2FsZV9idWZmZXJfY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNlbGYuaGlnaGxpZ2h0ZWRfcmVnaW9ucyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0bGV0IHJlZ2lvbiA9IHNlbGYuaGlnaGxpZ2h0ZWRfcmVnaW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRpZiAoc2VsZi5jaHIgIT09IHJlZ2lvbi5jaHIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0Y29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChyZWdpb24uZW5kPGJwU3RhcnQgfHxyZWdpb24uc3RhcnQ+YnBFbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0Y29udGludWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0c2VsZi5kcmF3SGlnaGxpZ2h0ZWRSZWdpb24ocmVnaW9uLG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmV0cmllcz0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50aWxlID0gbmV3IFRpbGUoY2hyLCBicFN0YXJ0LCBicEVuZCwgc2VsZi5icFBlclBpeGVsLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhaW50SW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNhbGxfdXBkYXRlX2xpc3RlbmVyKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHRzZWxmLmxpc3RlbmVycy52aWV3X2NoYW5nZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKHNlbGYuY2hyLHBhcnNlSW50KHNlbGYuc3RhcnQpLHBhcnNlSW50KHNlbGYuZW5kKSl9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGxfdXBkYXRlX2xpc3RlbmVyPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdHguY2xlYXJSZWN0KDAsIDAsIHNlbGYuY2FudmFzLndpZHRoLCBzZWxmLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi51cGRhdGVfcmVxdWlyZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIFx0aWYgKHNlbGYudXBkYXRlX3JlcXVpcmVkPT09XCJsb2NhdGlvblwiKXtcclxuICAgICAgICAgICAgICAgICAgICBcdFx0c2VsZi51cGRhdGUoc2VsZi5jaHIsc2VsZi5zdGFydCxzZWxmLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlX3JlcXVpcmVkPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgIFx0ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBcdFx0c2VsZi51cGRhdGVfcmVxdWlyZWQ9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICAgICAgfVx0XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuc3RvcFNwaW5uZXJBdFBhcmVudEVsZW1lbnQoc2VsZi50cmFja0Rpdik7XHJcblxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJldHJpZXM8MyAmJiBlcnJvciE9PVwiVGltZWQgb3V0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIFx0c2VsZi5yZXRyaWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRzZWxmLnJlcGFpbnQoZm9yY2UscmFuZ2VfZnJvbV90aWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5zdG9wU3Bpbm5lckF0UGFyZW50RWxlbWVudChzZWxmLnRyYWNrRGl2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkaW5nPWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZvcmNlX3JlZHJhdz10cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5wcmVzZW50QWxlcnQoc2VsZi50cmFja0RpdixlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdmlld0lzUmVhZHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xyXG4gICAgICAgIH1cclxuIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBhdXRvU2NhbGUoZmVhdHVyZXMsbWluLG1heCl7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmVzKXtcclxuICAgICAgICAgICAgICAgIFx0cmV0dXJuKHttaW46MCxtYXg6MX0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgZi52YWx1ZSk7XHJcbiAgICAgICAgICAgXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBmLnZhbHVlKTtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcdHJldHVybiB7bWluOiBtaW4sIG1heDogbWF4fTtcclxuICAgIFx0XHRcclxuICAgIH1cclxuXHJcbiAgICBjYWxjdWxhdGVNYXhTY2FsZShhbGxfZmVhdHVyZXMpe1xyXG4gICAgXHQgIGxldCBncm91cHM9e307XHJcbiAgICBcdCAgZm9yICh2YXIgaSBpbiBhbGxfZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tfb3JkZXJbaV1dO1xyXG4gICAgICAgICAgICAgIHRyYWNrLnNldF9zY2FsZT1udWxsO1xyXG4gICAgICAgICAgICAgIGxldCBncm91cCA9dHJhY2suY29uZmlnLmdyb3VwO1xyXG4gICAgICAgICAgICAgaWYgKGdyb3VwICYmIHRyYWNrLmNvbmZpZy5zY2FsZSE9PVwiZml4ZWRcIiAmJiAhKHRyYWNrLmNvbmZpZy5zY2FsZV9saW5rX3RvKSl7XHJcbiAgICAgICAgICAgICBcdFx0dHJhY2suY29uZmlnLnNjYWxlX2dyb3VwPWdyb3VwO1xyXG4gICAgICAgICAgICAgfSAgICAgICBcdFxyXG4gICAgICAgICAgICAgZ3JvdXAgPSB0cmFjay5jb25maWcuc2NhbGVfZ3JvdXBcclxuICAgICAgICAgICAgIGlmIChncm91cCl7XHJcbiAgICAgICAgICAgICBcdGxldCBncm91cF9pbmZvPSBncm91cHNbZ3JvdXBdO1xyXG4gICAgICAgICAgICAgXHRpZiAoIWdyb3VwX2luZm8pe1xyXG4gICAgICAgICAgICAgXHRcdGdyb3VwX2luZm89e3RyYWNrczpbdHJhY2tdLGZlYXR1cmVzOlthbGxfZmVhdHVyZXNbaV1dfVxyXG4gICAgICAgICAgICAgXHRcdGdyb3Vwc1tncm91cF09Z3JvdXBfaW5mb1xyXG5cclxuICAgICAgICAgICAgIFx0XHRcclxuICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgXHRlbHNle1xyXG4gICAgICAgICAgICAgXHRcdGdyb3VwX2luZm8uZmVhdHVyZXMucHVzaChhbGxfZmVhdHVyZXNbaV0pO1xyXG4gICAgICAgICAgICAgXHRcdGdyb3VwX2luZm8udHJhY2tzLnB1c2godHJhY2spO1xyXG4gICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICBcclxuICAgICAgICAgICAgIH1cclxuICAgIFx0ICB9XHJcbiAgICBcdCAgZm9yIChsZXQgbmFtZSBpbiBncm91cHMpe1xyXG4gICAgXHQgIFx0bGV0IGc9IGdyb3Vwc1tuYW1lXTtcclxuICAgIFx0ICBcdGlmICghZy5pZ25vcmUpe1xyXG4gICAgXHQgIFx0XHRsZXQgbWluPTA7XHJcbiAgICBcdCAgXHRcdGxldCBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIFx0ICBcdFx0bGV0IHNjYWxlPW51bGw7XHJcbiAgICBcdCAgXHRcdGZvciAobGV0IGYgb2YgZy5mZWF0dXJlcyl7XHJcbiAgICBcdCAgXHRcdFx0IHNjYWxlPSB0aGlzLmF1dG9TY2FsZShmLG1pbixtYXgpXHJcbiAgICBcdCAgXHRcdFx0IG1pbj0gc2NhbGUubWluO1xyXG4gICAgXHQgIFx0XHRcdCBtYXg9c2NhbGUubWF4O1xyXG4gICAgXHQgIFx0XHR9XHJcbiAgICBcdCAgXHRcdGZvciAobGV0IHQgb2YgZy50cmFja3Mpe1xyXG4gICAgXHQgIFx0XHRcdHQuc2V0X3NjYWxlPXNjYWxlO1xyXG4gICAgXHQgIFx0XHR9XHJcbiAgICBcdCAgXHR9XHJcbiAgICBcdCAgfSBcclxuICAgIH1cclxuXHJcbiAgICBkcmF3SGlnaGxpZ2h0ZWRSZWdpb24ocmVnaW9uLG9wdGlvbnMpe1xyXG4gICAgXHRsZXQgc3RhcnQ9IChyZWdpb24uc3RhcnQtb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcbiAgICBcdHN0YXJ0ID0gc3RhcnQ8MD8wOnN0YXJ0O1xyXG5cclxuICAgIFx0bGV0IHdpZHRoID0gKHJlZ2lvbi5lbmQtcmVnaW9uLnN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcbiAgICBcdHdpZHRoID0gd2lkdGg8Mz8zOndpZHRoO1xyXG4gICAgXHR3aWR0aCA9d2lkdGg+b3B0aW9ucy5waXhlbFdpZHRoP29wdGlvbnMucGl4ZWxXaWR0aDp3aWR0aDtcclxuXHRcdG9wdGlvbnMuY29udGV4dC5nbG9iYWxBbHBoYT0wLjE7XHJcblx0XHRvcHRpb25zLmNvbnRleHQuZmlsbFN0eWxlPXJlZ2lvbi5jb2xvcjtcclxuICAgIFx0b3B0aW9ucy5jb250ZXh0LmZpbGxSZWN0KHN0YXJ0LDAsd2lkdGgsb3B0aW9ucy5waXhlbEhlaWdodCk7XHJcbiAgICBcdG9wdGlvbnMuY29udGV4dC5nbG9iYWxBbHBoYT0xLjA7XHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICBwYWludEltYWdlKCkge1xyXG5cclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgXHR0aGlzLnNjYWxlX2N0eC5jbGVhclJlY3QoMCwgMCwxMDAsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgXHR0aGlzLnNjYWxlX2N0eC5kcmF3SW1hZ2UodGhpcy5zY2FsZV9idWZmZXIsMCx0aGlzLnlPZmZzZXQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50aWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMueE9mZnNldCA9IE1hdGgucm91bmQoKHRoaXMudGlsZS5zdGFydEJQIC0gdGhpcy5zdGFydCkvdGhpcy5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudGlsZS5pbWFnZSwgdGhpcy54T2Zmc2V0LCB0aGlzLnlPZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFsbG93VXNlckZlYXR1cmVPdmVyKCl7XHJcbiAgICBcdGxldCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBcdCB0aGlzLnRyYWNrRGl2Lm9uKFwibW91c2Vtb3ZlLmZlYXR1cmVfb3ZlclwiLGZ1bmN0aW9uIChlKSB7XHJcbiAgICBcdCBcdGlmIChzZWxmLmxvYWRpbmcpe1xyXG4gICAgXHQgXHRcdHJldHVybjtcclxuICAgIFx0IFx0fVxyXG4gICAgXHQgXHRjbGVhclRpbWVvdXQoc2VsZi5tb3RvKTtcclxuICAgIFx0IFx0c2VsZi5tb3RvPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgIFx0IFx0XHRpZiAoIXNlbGYuaXNfZHJhZ2dpbmcpe1xyXG5cdFx0XHRcdFx0bGV0IGluZm89c2VsZi5nZXRGZWF0dXJlQXQoZSk7XHJcblx0XHRcdFx0XHRsZXQgaSA9IHNlbGYubW91c2Vfb3Zlcl9mZWF0dXJlO1xyXG5cdFx0XHRcdFx0aWYgKGluZm8uZmVhdHVyZSApe1xyXG5cdFx0XHRcdFx0XHRpZihpICYmIGkuZmVhdHVyZSE9PWluZm8uZmVhdHVyZSl7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5saXN0ZW5lcnMuZmVhdHVyZV9vdmVyLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhpLnRyYWNrLGkuZmVhdHVyZSxlLFwib3V0XCIpfSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRpZiAoKCFpKSB8fCAoaS5mZWF0dXJlIT09aW5mby5mZWF0dXJlKSl7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5saXN0ZW5lcnMuZmVhdHVyZV9vdmVyLmZvckVhY2goKGZ1bmMpPT57ZnVuYyhpbmZvLnRyYWNrLGluZm8uZmVhdHVyZSxlLFwib3ZlclwiKX0pO1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYubW91c2Vfb3Zlcl9mZWF0dXJlPWluZm87XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2V7XHJcblx0XHRcdFx0XHRcdGxldCBpID0gc2VsZi5tb3VzZV9vdmVyX2ZlYXR1cmVcclxuXHRcdFx0XHRcdFx0aWYgKGkpe1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYubGlzdGVuZXJzLmZlYXR1cmVfb3Zlci5mb3JFYWNoKChmdW5jKT0+e2Z1bmMoaS50cmFjayxpLmZlYXR1cmUsZSxcIm91dFwiKX0pO1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYubW91c2Vfb3Zlcl9mZWF0dXJlPW51bGw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuICAgIFx0IFx0XHR9XHJcbiAgICBcdCBcdH0sMTApO1xyXG4gICAgXHQgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUZlYXR1cmVPdmVySGFuZGxlcigpe1xyXG4gICAgXHRcdHRoaXMudHJhY2tEaXYub2ZmKFwibW91c2Vkb3duLmZlYXR1cmVfb3ZlclwiKTtcclxuICAgIH1cclxuXHJcblxyXG5cdGFsbG93VXNlckZlYXR1cmVDbGljaygpe1xyXG4gICAgXHRsZXQgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgXHR0aGlzLmFsbG93VXNlckZlYXR1cmVPdmVyKCk7XHJcbiAgICBcdHRoaXMuYWRkTGlzdGVuZXIoXCJmZWF0dXJlX292ZXJcIixmdW5jdGlvbih0cmFjayxmZWF0dXJlLG92ZXIsdHlwZSl7XHJcbiAgICBcdFx0aWYoIWZlYXR1cmUpe1xyXG4gICAgXHRcdFx0c2VsZi50cmFja0Rpdi5jc3MoXCJjdXJzb3JcIixcImRlZmF1bHRcIilcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0bGV0IHBvaW50ZXI9KHR5cGU9PT1cIm92ZXJcIik/XCJwb2ludGVyXCI6XCJkZWZhdWx0XCI7XHJcbiAgICBcdFx0c2VsZi50cmFja0Rpdi5jc3MoXCJjdXJzb3JcIixwb2ludGVyKTtcclxuXHJcbiAgICBcdH0pXHJcblxyXG4gICAgXHQgdGhpcy50cmFja0Rpdi5vbihcIm1vdXNlZG93bi5mZWF0dXJlX2NsaWNrXCIsZnVuY3Rpb24gKGUpIHtcclxuICAgIFx0IFx0aWYgKHNlbGYubG9hZGluZyl7XHJcbiAgICBcdCBcdFx0cmV0dXJuO1xyXG4gICAgXHQgXHR9XHJcbiAgICBcdCBcdGNsZWFyVGltZW91dChzZWxmLnRvKTtcclxuICAgIFx0IFx0c2VsZi50bz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICBcdCBcdFx0aWYgKCFzZWxmLmlzX2RyYWdnaW5nKXtcclxuXHRcdFx0XHRcdGxldCBpbmZvPXNlbGYuZ2V0RmVhdHVyZUF0KGUpO1xyXG5cdFx0XHRcdFx0aWYgKGluZm8udHJhY2spe1xyXG5cdFx0XHRcdFx0XHRzZWxmLmxpc3RlbmVycy5mZWF0dXJlX2NsaWNrZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKGluZm8udHJhY2ssaW5mby5mZWF0dXJlLGUpfSk7XHJcblx0XHRcdFx0XHR9XHJcbiAgICBcdCBcdFx0fVxyXG4gICAgXHQgXHR9LDIwMCk7XHJcbiAgICBcdCB9KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJlbW92ZUZlYXR1cmVPdmVySGFuZGxlcigpe1xyXG4gICAgXHR0aGlzLnRyYWNrRGl2Lm9mZihcIm1vdXNlZG93bi5mZWF0dXJlX2NsaWNrXCIpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgYWxsb3dVc2VyRHJhZygpe1xyXG4gICAgXHRsZXQgc2VsZj10aGlzO1xyXG4gICAgXHQgdGhpcy50cmFja0Rpdi5vbihcIm1vdXNlZG93bi5kcmFnaGFuZGxlclwiLGZ1bmN0aW9uIChlKSB7XHJcbiAgICBcdCBcdGlmIChlLnNoaWZ0S2V5KXtcclxuICAgIFx0IFx0XHRyZXR1cm47XHJcbiAgICBcdCBcdH1cclxuICAgICAgICAgICAgdmFyIGNhbnZhc0Nvb3JkcyA9IFV0aWxzLnRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSwgc2VsZi5jYW52YXMpO1xyXG4gICAgICAgICAgICBzZWxmLmlzTW91c2VEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5zdGFydF9kcmFnZ2luZz10cnVlO1xyXG4gICAgICAgICAgICBzZWxmLmxhc3RNb3VzZVggPSBjYW52YXNDb29yZHMueDtcclxuICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VZPSBjYW52YXNDb29yZHMueTtcclxuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25YID0gc2VsZi5sYXN0TW91c2VYO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgXHQub24oXCJtb3VzZW1vdmUuZHJhZ2hhbmRsZXJcIixmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBsZXQgY2FudmFzQ29vcmRzID0gVXRpbHMudHJhbnNsYXRlTW91c2VDb29yZGluYXRlcyhlLCBzZWxmLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmlzX2RyYWdnaW5nIHx8IHNlbGYuc3RhcnRfZHJhZ2dpbmcpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjYW52YXNDb29yZHMueC1zZWxmLmxhc3RNb3VzZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnBfZGlmZj1zZWxmLmJwUGVyUGl4ZWwqZGlmZjtcclxuICAgICAgICAgICAgICAgIHNlbGYuc3RhcnQtPWJwX2RpZmY7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmVuZC09YnBfZGlmZjtcclxuICAgICAgICAgICAgICAgIGxldCBkZCA9IHNlbGYuY2FudmFzLmhlaWdodC1zZWxmLnRpbGUuaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHlfZGlmZj0wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkPDAgfHwgc2VsZi55T2Zmc2V0ICE9PTApe1xyXG4gICAgICAgICAgICAgICAgXHRsZXQgeV9kaWZmPSAgY2FudmFzQ29vcmRzLnktc2VsZi5sYXN0TW91c2VZO1xyXG4gICAgICAgICAgICAgICAgXHRzZWxmLnlPZmZzZXQrPXlfZGlmZjtcclxuICAgICAgICAgICAgICAgIFx0aWYgKHNlbGYueU9mZnNldD4wKXtcclxuICAgICAgICAgICAgICAgIFx0XHRzZWxmLnlPZmZzZXQ9MDtcclxuICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgXHRlbHNlIGlmIChzZWxmLnlPZmZzZXQ8ZGQpe1xyXG5cdFx0XHRcdFx0XHRzZWxmLnlPZmZzZXQ9ZGQ7XHJcbiAgICAgICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYucmVwYWludCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VYPWNhbnZhc0Nvb3Jkcy54O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0TW91c2VZPWNhbnZhc0Nvb3Jkcy55O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc3RhcnRfZHJhZ2dpbmcgJiYgKGRpZmY+NSB8fCB5X2RpZmY+NSkpe1xyXG4gICAgICAgICAgICAgICAgXHRzZWxmLmlzX2RyYWdnaW5nPXRydWU7XHJcbiAgICAgICAgICAgICAgICBcdHNlbGYuc3RhcnRfZHJhZ2dpbmc9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcIm1vdXNldXAuZHJhZ2hhbmRsZXJcIixmdW5jdGlvbiAoZSkgeyAgIFxyXG4gICAgICAgICAgICAgIHNlbGYuaXNfZHJhZ2dpbmc9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgc2VsZi5zdGFydF9kcmFnZ2luZz1mYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVEcmFnSGFuZGxlcigpe1xyXG4gICAgXHR0aGlzLnRyYWNrRGl2Lm9mZihcIm1vdXNlZG93bi5kcmFnaGFuZGxlciBtb3VzZW1vdmUuZHJhZ2hhbmRsZXIgbW91c2V1cC5kcmFnaGFuZGxlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Q29vcmRzKGUpe1xyXG4gICAgXHQgbGV0IHggPSBlLnBhZ2VYIC0gJCh0aGlzLmNhbnZhcykub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICAgbGV0IHkgPSBlLnBhZ2VZIC0gJCh0aGlzLmNhbnZhcykub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICByZXR1cm4ge3gseX07XHJcbiAgICBcdFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBhbGxvd1VzZXJab29tKCl7XHJcbiAgICBcdGxldCBzZWxmID0gdGhpcztcclxuICAgIFx0dGhpcy50cmFja0Rpdi5vbignbW91c2V3aGVlbC56b29tICBtb3VzZS56b29tIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0bGV0IGRlbHRhWT0gZXZlbnQub3JpZ2luYWxFdmVudC5kZWx0YVk7XHJcblx0XHRcdGlmIChkZWx0YVkgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdFx0ZGVsdGFZPWV2ZW50Lm9yaWdpbmFsRXZlbnQuZGV0YWlsXHJcblx0XHRcdH1cclxuICAgIFx0IFx0aWYgKHNlbGYubG9hZGluZyB8fCAoc2VsZi5icFBlclBpeGVsPDAuMDUgJiYgZGVsdGFZPjApKXtcclxuICAgIFx0IFx0XHRyZXR1cm47XHJcbiAgICBcdCBcdH1cclxuICAgIFx0IFx0XHJcbiAgIFxyXG4gICAgXHQgXHRsZXQgY2FudmFzQ29vcmRzID0gc2VsZi5fZ2V0Q29vcmRzKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZmFjdG9yID0gZGVsdGFZPDA/MjowLjU7XHJcbiAgICAgICAgICAgIGxldCBtYnA9IChzZWxmLnN0YXJ0KyBjYW52YXNDb29yZHMueCAqIHNlbGYuYnBQZXJQaXhlbClcclxuICAgICAgICAgICAgbGV0IG5ld19sZW5ndGggPSAoc2VsZi5lbmQtc2VsZi5zdGFydCkqZmFjdG9yO1xyXG4gICAgICAgICAgICBsZXQgbmV3X3N0YXJ0ID0gbWJwLSgoY2FudmFzQ29vcmRzLngvc2VsZi5jYW52YXMud2lkdGgpKm5ld19sZW5ndGgpO1xyXG4gICAgICAgICAgICBzZWxmLnN0YXJ0PSAgbmV3X3N0YXJ0XHJcbiAgICAgICAgICAgIHNlbGYuZW5kPSBuZXdfc3RhcnQrbmV3X2xlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNlbGYucmVwYWludCgpOyAgICAgIFxyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVVc2VyWm9vbSgpe1xyXG5cdFx0dGhpcy50cmFja0Rpdi5vZmYoXCJtb3VzZXdoZWVsLnpvb21cIik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgYWxsb3dVc2VyUmFuZ2VTZWxlY3Rpb24oKXtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50cmFja0Rpdi5vbihcIm1vdXNlZG93bi5zZWxlY3Rpb25cIixmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGFydF9zZWxlY3QgPVV0aWxzLnRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSx0aGlzKS54O1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBzZWxmLnN0YXJ0X3NlbGVjdCtcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGQgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RfZGl2PSQoXCI8ZGl2PlwiKS5jc3Moe1wicG9zaXRpb25cIjpcImFic29sdXRlXCIsXCJvcGFjaXR5XCI6MC4yLFwiYmFja2dyb3VuZC1jb2xvclwiOlwiYmx1ZVwiLFwidG9wXCI6XCIwcHhcIixcImhlaWdodFwiOnRkLmNzcyhcImhlaWdodFwiKSxsZWZ0OmxlZnQsXCJ3aWR0aFwiOlwiMHB4XCJ9KVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRkKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcIm1vdXNlbW92ZS5zZWxlY3Rpb25cIixmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgc2VsZi5zdGFydF9zZWxlY3Qpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHg9VXRpbHMudHJhbnNsYXRlTW91c2VDb29yZGluYXRlcyhlLHRoaXMpLng7XHJcbiAgICAgICAgICAgICAgICBpZiAoeDxzZWxmLnN0YXJ0X3NlbGVjdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RfZGl2LmNzcyh7XCJsZWZ0XCI6eCtcInB4XCIsXCJ3aWR0aFwiOihzZWxmLnN0YXJ0X3NlbGVjdC14KStcInB4XCJ9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RfZGl2LmNzcyh7XCJsZWZ0XCI6c2VsZi5zdGFydF9zZWxlY3QrXCJweFwiLFwid2lkdGhcIjooeC1zZWxmLnN0YXJ0X3NlbGVjdCkrXCJweFwifSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcIm1vdXNldXAuc2VsZWN0aW9uXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXJ0X3NlbGVjdCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgeD1VdGlscy50cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsdGhpcykueDtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHNlbGYuc3RhcnQgKyAoc2VsZi5zdGFydF9zZWxlY3Qqc2VsZi5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBlbmQgPSAgc2VsZi5zdGFydCArICh4KnNlbGYuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0X3NlbGVjdD1udWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RfZGl2LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0PmVuZCl7XHJcbiAgICAgICAgICAgICAgICBcdGxldCB0ZW1wPWVuZDtcclxuICAgICAgICAgICAgICAgIFx0ZW5kPXN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgXHRzdGFydD10ZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5saXN0ZW5lcnMucmFuZ2Vfc2VsZWN0ZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKHNlbGYuY2hyLHN0YXJ0LGVuZCl9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHJlbW92ZUFsbG93U2VsZWN0aW9uKCl7XHJcbiAgICBcdHRoaXMudHJhY2tEaXYub2ZmKFwibW91c2Vkb3duLnNlbGVjdGlvbiBtb3VzZW1vdmUuc2VsZWN0aW9uIG1vdXNldXAuc2VsZWN0aW9uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEltYWdlKCl7XHJcbiAgICBcdCB2YXIgaW1nVVJMID0gdGhpcy5jYW52YXNbMF0udG9EYXRhVVJMKE1JTUVfVFlQRSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgYWxsb3dVc2VyRHJvcCgpe1xyXG4gICAgICAgIGxldCBkaXYgPSB0aGlzLnRyYWNrRGl2O1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICBkaXYuZHJvcHBhYmxlKHtcclxuICAgICAgICBcdG92ZXI6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgXHRcdGxldCB0cmFjayA9IHVpLmRyYWdnYWJsZS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgXHRcdGxldCBwYW5lbCA9IHVpLmRyYWdnYWJsZS5kYXRhKFwicGFuZWxcIik7XHJcbiAgICAgICAgXHRcdGlmIChwYW5lbD09PXNlbGYpe1xyXG4gICAgICAgIFx0XHRcdHJldHVybjtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAgKHRyYWNrICl7XHJcbiAgICAgICAgXHRcdFx0bGV0IGljb24gPSBcIjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2hlY2snPjwvc3Bhbj5cIjtcclxuICAgICAgICBcdFx0XHRpZiAodHJhY2subm9fZHJvcCB8fCBzZWxmLnRyYWNrc1t0cmFjay50cmFja19pZF0pe1xyXG4gICAgICAgIFx0XHRcdFx0aWNvbj1cIjxzcGFuIGNsYXNzPSd1aS1pY29uICB1aS1pY29uLWNsb3NldGhpY2snPjwvc3Bhbj5cIlxyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgXHRcdFx0dWkuaGVscGVyLnByZXBlbmQoaWNvbikuY3NzKFwid2hpdGUtc3BhY2VcIixcIm5vd3JhcFwiKTtcclxuICAgICAgICBcdFx0XHR9LDIwKTtcclxuXHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH0sXHJcbiAgICAgICAgXHRncmVlZHk6dHJ1ZSxcclxuICAgICAgICBcdG91dDpmdW5jdGlvbihlLHVpKXtcclxuICAgICAgICBcdFx0dWkuaGVscGVyLmZpbmQoXCIudWktaWNvblwiKS5yZW1vdmUoKTtcclxuICAgICAgICBcdH0sXHJcbiAgICAgICAgICAgIGRyb3A6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gJCh1aS5kcmFnZ2FibGVbMF0pLmRhdGEoXCJ0cmFja1wiKTtcclxuICAgICAgICAgICAgICAgICB1aS5oZWxwZXIuZmluZChcIi51aS1pY29uXCIpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrKXtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgIGxldCBwYW5lbD0kKHVpLmRyYWdnYWJsZVswXSkuZGF0YShcInBhbmVsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICBpZiAocGFuZWw9PT1zZWxmIHx8IHRyYWNrLm5vX2Ryb3AgfHwgc2VsZi50cmFja3NbdHJhY2sudHJhY2tfaWRdKSB7ICBcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgXHQgaWYgKHBhbmVsKXtcclxuICAgICAgICAgICAgICAgIFx0XHQgcGFuZWwucmVtb3ZlVHJhY2sodHJhY2sudHJhY2tfaWQpO1xyXG4gICAgICAgICAgICAgICAgXHRcdCBwYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIFx0IH1cclxuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkVHJhY2sodHJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIC8qKlxyXG5cdCogR2V0cyB0aGUgZmVhdHVyZSB0aGF0IHdhcyBjbGlja2VkXHJcblx0KiBAcGFyYW0ge0pRdWVyeSBFdmVudH0gZSAtIENhbiBiZSBhbnkgb2JqZWN0LSBhbGwgdGhhdCBpcyByZXF1aXJlZCBpcyBwYWdlWCBhbmQgUGFnZVlcclxuXHQqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRyYWNrIC0gdGhlIHRyYWNrIGNvbmZpZyBhdCB0aGUgZXZlbnQgcG9zaXRpb24ob3IgbnVsbCkgYW5kXHJcblx0KiBmZWF0dXJlIC0gdGhlIGZlYXR1cmUgYXQgdGhlIHBvc3RpdGlvbiAob3IgbnVsbCkuIFxyXG5cdCovXHJcblxyXG4gICAgIGdldEZlYXR1cmVBdChlKXtcclxuICAgIFx0IGxldCBjbyA9IFV0aWxzLnRyYW5zbGF0ZU1vdXNlQ29vcmRpbmF0ZXMoZSwgdGhpcy5jYW52YXMpO1xyXG4gICAgXHQgY28ueS09dGhpcy55T2Zmc2V0O1xyXG4gICAgXHQgbGV0IGdsID0gTWF0aC5yb3VuZCh0aGlzLnN0YXJ0Kyhjby54KnRoaXMuYnBQZXJQaXhlbCkpO1xyXG4gICAgXHQgZm9yIChsZXQgdCBpbiB0aGlzLnRyYWNrcyl7XHJcbiAgICBcdCBcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RdO1xyXG4gICAgXHQgXHRpZiAoY28ueT50cmFjay50b3AgJiYgY28ueTx0cmFjay5ib3R0b20pe1xyXG4gICAgXHQgXHRcdHJldHVybiB7dHJhY2s6dHJhY2ssXHJcbiAgICBcdCBcdFx0XHRcdGZlYXR1cmU6dHJhY2suZ2V0RmVhdHVyZUF0KGdsLHRoaXMuY2hyLGNvLHRoaXMuYnBQZXJQaXhlbCx0aGlzLmN0eCx0aGlzLnlPZmZzZXQpXHJcbiAgICBcdCBcdFx0fTtcclxuICAgIFx0IFx0fVx0XHRcclxuICAgIFx0IH1cclxuICAgIFx0IHJldHVybiB7dHJhY2s6bnVsbCxmZWF0dXJlOm51bGx9O1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgYWxsb3dVc2VyUmVzaXplKGRpcmVjdGlvbil7XHJcbiAgICBcdGxldCBoYW5kbGVzPVwiYWxsXCI7XHJcbiAgICBcdGlmIChkaXJlY3Rpb249PT1cInZlcnRpY2FsXCIpe1xyXG4gICAgXHRcdGhhbmRsZXM9XCJuLHNcIjtcclxuICAgIFx0fVxyXG4gICAgXHRlbHNlIGlmIChkaXJlY3Rpb249PT1cImhvcml6b250YWxcIil7XHJcbiAgICBcdFx0aGFuZGxlcz1cImUsd1wiO1xyXG4gICAgXHR9XHJcbiAgICAgICAgbGV0IGRpdiA9IHRoaXMudHJhY2tEaXY7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG5cdFx0XHJcbiAgICAgICAgZGl2LnJlc2l6YWJsZSh7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgcmVzaXplOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICBcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIFx0aWYgKHNlbGYubG9hZGluZyl7XHJcbiAgICAgICAgICAgIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIFx0fVxyXG5cclxuICAgICAgICAgICAgXHRjbGVhclRpbWVvdXQoc2VsZi50byk7XHJcbiAgICAgICAgICAgIFx0c2VsZi50bz1zZXRUaW1lb3V0KGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5zZXRXaWR0aCh1aS5zaXplLndpZHRoKTtcclxuICAgICAgICAgICAgXHRcdHNlbGYuc2V0SGVpZ2h0KHVpLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgXHRcdHNlbGYudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIFx0fSwxMDApXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlczpoYW5kbGVzXHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuXHQqIEFsbG93cyB0aGUgdXNlciB0byBtb3ZlIHRoZSBwYW5lbCB2aWEgYSBoYW5kbGUgaW4gdGhlXHJcblx0KiB0b3AgcmlnaHQgaGFuZCBjb3JuZXJcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gLSBlaXRoZXIgdmVydGljYWwgb3IgaG9yem9udGFsLCB3aWxsIHJlc3RyaWN0IG1vdmVtZW50IFxyXG5cdCogaW4gdGhpcyBwbGFuZVxyXG5cdCogQHBhcmFtIHtib29sZWFufSBpZiB0cnVlIHRoZW4gdGhlIHBhbmVsIHdpbGwgYmUgY29uc3RyYWluZWQgd2l0aGluIGl0cyBwYXJlbnQgXHJcblx0Ki9cclxuICAgIGFsbG93VXNlck1vdmUoZGlyZWN0aW9uLGNvbnRhaW4pe1xyXG4gICAgXHRsZXQgYXhpcz1mYWxzZTtcclxuICAgIFx0bGV0IGljb249IFwiZmEtYXJyb3dzLWFsdFwiO1xyXG4gICAgXHRpZiAoZGlyZWN0aW9uPT1cInZlcnRpY2FsXCIpe1xyXG4gICAgXHRcdGF4aXM9XCJ5XCI7XHJcbiAgICBcdFx0aWNvbiArPVwiLXZcIjtcclxuICAgIFx0fVxyXG4gICAgXHRlbHNlIGlmIChkaXJlY3Rpb249PVwiaG9yaXpvbnRhbFwiKXtcclxuICAgIFx0XHRheGlzPVwieFwiO1xyXG4gICAgXHRcdGljb24rPVwiLWhcIjtcclxuICAgIFx0fVxyXG4gICAgXHRsZXQgZGl2ID0gdGhpcy50cmFja0RpdjtcclxuXHRcdGRpdi5maW5kKFwiLnBhbmVsLWljb24tZGl2XCIpLnByZXBlbmQoJChcIjxzcGFuIGNsYXNzPSd0cmFjay1oYW5kbGUgZmFzIFwiK2ljb24rXCInPjwvc3Bhbj5cIikuY3NzKHtcImN1cnNvclwiOlwibW92ZVwifSkpO1xyXG4gICAgICAgIGxldCBzZWxmID10aGlzO1xyXG4gICAgICAgIGxldCBjPWZhbHNlO1xyXG4gICAgICAgIGlmIChjb250YWluKXtcclxuICAgICAgICBcdGM9XCJwYXJlbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGl2LmRyYWdnYWJsZSh7aGFuZGxlOlwiLnRyYWNrLWhhbmRsZVwiLGF4aXM6YXhpcyxjb250YWlubWVudDpjfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgYWxsb3dVc2VyQ2xvc2UoKXtcclxuXHRcdGxldCBkaXYgPSB0aGlzLnRyYWNrRGl2O1xyXG5cdFx0bGV0IHNlbGYgPXRoaXM7XHJcblx0XHRsZXQgaWNvbj0kKFwiPHNwYW4gY2xhc3M9J2ZhcyBmYS10cmFzaCc+PC9zcGFuPlwiKVxyXG5cdFx0XHRcdC5jbGljaygoKT0+e1xyXG5cdFx0XHRcdFx0ICBzZWxmLmxpc3RlbmVycy5wYW5lbF9jbG9zZWQuZm9yRWFjaCgoZnVuYyk9PntmdW5jKHNlbGYpfSk7XHJcblx0XHRcdFx0XHRcdGRpdi5yZW1vdmUoKVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0ZGl2LmZpbmQoXCIucGFuZWwtaWNvbi1kaXZcIikuYXBwZW5kKGljb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFdpZHRoKHdpZHRoKXtcclxuICAgICAgICB0aGlzLnRyYWNrRGl2LndpZHRoKHdpZHRoKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEhlaWdodChoZWlnaHQpe1xyXG4gICAgICAgICQodGhpcy50cmFja0RpdikuaGVpZ2h0KGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd19zY2FsZSl7XHJcbiAgICAgICAgXHR0aGlzLnNjYWxlX2NhbnZhc1swXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHJlZHJhd1RpbGUoZmVhdHVyZXMpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRpbGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBjaHIgPSBzZWxmLnRpbGUuY2hyLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gc2VsZi50aWxlLnN0YXJ0QlAsXHJcbiAgICAgICAgICAgIGJwRW5kID0gc2VsZi50aWxlLmVuZEJQLFxyXG4gICAgICAgICAgICBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IHNlbGYudGlsZS5zY2FsZTtcclxuXHJcbiAgICAgICAgYnVmZmVyLndpZHRoID0gc2VsZi50aWxlLmltYWdlLndpZHRoO1xyXG4gICAgICAgIGJ1ZmZlci5oZWlnaHQgPSBzZWxmLnRpbGUuaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjdHggPSBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgIFxyXG5cclxuICAgICAgICBzZWxmLnRyYWNrLmRyYXcoe1xyXG4gICAgICAgICAgICBmZWF0dXJlczogZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGN0eCxcclxuICAgICAgICAgICAgYnBTdGFydDogYnBTdGFydCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbDogYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aDogYnVmZmVyLndpZHRoLFxyXG4gICAgICAgICAgICBwaXhlbEhlaWdodDogYnVmZmVyLmhlaWdodFxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgc2VsZi50aWxlID0gbmV3IFRpbGUoY2hyLCBicFN0YXJ0LCBicEVuZCwgYnBQZXJQaXhlbCwgYnVmZmVyKTtcclxuICAgICAgICBzZWxmLnBhaW50SW1hZ2UoKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5jbGFzcyBUaWxle1xyXG5cdGNvbnN0cnVjdG9yIChjaHIsIHRpbGVTdGFydCwgdGlsZUVuZCwgc2NhbGUsIGltYWdlKSB7XHJcblx0XHR0aGlzLmNociA9IGNocjtcclxuXHRcdHRoaXMuc3RhcnRCUCA9IHRpbGVTdGFydDtcclxuXHRcdHRoaXMuZW5kQlAgPSB0aWxlRW5kO1xyXG5cdFx0dGhpcy5zY2FsZSA9IHNjYWxlO1xyXG5cdFx0dGhpcy5pbWFnZSA9IGltYWdlO1xyXG5cdH1cclxuXHJcblx0Y29udGFpbnNSYW5nZShjaHIsIHN0YXJ0LCBlbmQsIHNjYWxlKSB7XHJcblx0XHRpZiAoc3RhcnQ8MCl7XHJcblx0XHRcdHN0YXJ0PTA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zY2FsZS50b0ZpeGVkKDMpID09PSBzY2FsZS50b0ZpeGVkKDMpICYmIHN0YXJ0ID49IHRoaXMuc3RhcnRCUCAmJiBlbmQgPD0gdGhpcy5lbmRCUCAmJiBjaHIgPT09IHRoaXMuY2hyO1xyXG5cdH1cclxuXHJcblx0b3ZlcmxhcHNSYW5nZShjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNociA9PT0gY2hyICYmIHRoaXMuZW5kQlAgPj0gc3RhcnQgJiYgdGhpcy5zdGFydEJQIDw9IGVuZDtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuXHQgXHJcbmV4cG9ydCB7TUxWUGFuZWx9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbENBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFtQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7OztBQUdBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFDQTtBQTRDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../MLVPanel/src/panel.js\n");

/***/ }),

/***/ "../MLVPanel/src/panel_legend.js":
/*!**********************************!*\
  !*** .Panel/src/panel_legend.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PanelLegend = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _track_dialog = __webpack_require__(/*! ./track_dialog.js */ \"../MLVPanel/src/track_dialog.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelLegend = function () {\n    function PanelLegend(panel, config) {\n        _classCallCheck(this, PanelLegend);\n\n        if (!config) {\n            config = {};\n        }\n\n        this.panel = panel;\n        this.track_index = {};\n        this.div = $(\"<div>\").attr({ \"class\": \"mlv-track-legend\" }).mousedown(function (e) {\n            e.stopPropagation();\n        });\n\n        if (config.draggable || config.draggable === undefined) {\n            this.div.draggable({\n                containment: \"parent\"\n            });\n        }\n\n        if (config.transparent == false || config.transparent === undefined) {\n            this.div.css(\"background-color\", \"white\");\n        }\n\n        this.li = $(\"<ul>\").css({ \"list-style-type\": \"none\", \"padding\": \"4px\", \"margin\": \"4px\" });\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = panel.track_order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var id = _step.value;\n\n                this.addTrack(panel.tracks[id].config);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        var self = this;\n        this.div.append(this.li);\n        this.li.sortable({\n            helper: \"clone\",\n            stop: function stop(e, ui) {\n                self._reOrder(ui.item);\n            }\n        });\n\n        panel.trackDiv.append(this.div);\n    }\n\n    _createClass(PanelLegend, [{\n        key: \"swapOrder\",\n        value: function swapOrder(id1, id2) {\n            var el1 = null;\n            var el2 = null;\n            this.li.children().each(function (i, el) {\n                var e = $(el);\n                var track = e.data(\"track\");\n\n                if (track.track_id === id2) {\n                    el2 = e;\n                } else if (track.track_id === id1) {\n                    el1 = e;\n                }\n            });\n\n            el1.detach();\n            el1.insertAfter(el2);\n        }\n    }, {\n        key: \"_reOrder\",\n        value: function _reOrder(item) {\n            var group = item.data(\"track\").group;\n            var item_id = item.data(\"track\").track_id;\n            var order = [];\n            var group_index = 0;\n            var other_group_members = [];\n            this.li.children().each(function (i, el) {\n                var track = $(el).data(\"track\");\n                if (group && track.group === group) {\n                    if (track.track_id === item_id) {\n                        group_index = order.length;\n                        order.push(track.track_id);\n                    } else {\n                        other_group_members.push(track.track_id);\n                    }\n                    return;\n                }\n                order.push(track.track_id);\n            });\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = other_group_members[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var tid = _step2.value;\n\n                    order.splice(group_index + 1, 0, tid);\n                    group_index++;\n                    this.track_index[tid].detach().insertAfter(item);\n                    item = this.track_index[tid];\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.panel.track_order = order;\n\n            this.panel.update();\n        }\n    }, {\n        key: \"updateTrack\",\n        value: function updateTrack(track_id) {\n            var element = this.track_index[track_id];\n            var track = element.data(\"track\");\n            element.children().each(function (index, el) {\n                el = $(el);\n                if (index == 0) {\n                    el.css(\"color\", track.color);\n                } else if (index == 1) {\n                    el.text(track.short_label);\n                }\n            });\n            this.li.width(null);\n        }\n    }, {\n        key: \"addTrack\",\n        value: function addTrack(track, index) {\n            var self = this;\n            var item = $(\"<li>\").data({ track: track, panel: this.panel }).click(function (e) {\n                new _track_dialog.MLVTrackDialog(track, self.panel);\n            });\n            var span = $(\"<span>\");\n            var icon = \"fas fa-signature\";\n            if (track.format === \"feature\") {\n                icon = \"fas fa-stream\";\n            } else if (track.format === \"ruler\") {\n                icon = \"fas fa-ruler-horizontal\";\n            }\n\n            span.attr(\"class\", icon).css({ \"color\": track.color });\n            /*if (track.format==='line'){\r\n                span.height(2);\r\n            }\r\n            if (track.display===\"line\"){\r\n                span.height(4)\r\n            }\r\n            */\n            var text = $(\"<span>\").attr(\"class\", \"mlv-track-legend-text\");\n            item.append(span).append(text);\n            var t_sp = $(\"<span>\").width(15).appendTo(item);\n            if (track.allow_user_remove) {\n                var rm = $(\"<i class='fas  fa-trash'></i>\").click(function (e) {\n                    self.panel.removeTrack(track.track_id);\n                    self.removeTrack(track.track_id);\n                }).css(\"float\", \"right\").appendTo(t_sp);\n            }\n            if (index === 0) {\n                this.li.prepend(item);\n            } else if (index) {\n                var pos_el = this.li.children()[index - 1];\n                item.insertAfter($(pos_el));\n            } else {\n                this.li.append(item);\n            }\n            this.track_index[track.track_id] = item;\n            this.updateTrack(track.track_id);\n        }\n    }, {\n        key: \"removeTrack\",\n        value: function removeTrack(track_id) {\n            this.li.children().each(function (index, element) {\n                element = $(element);\n                var t = element.data(\"track\");\n                if (t && t.track_id === track_id) {\n                    element.remove();\n                }\n            });\n            delete this.track_index[track_id];\n        }\n    }, {\n        key: \"hide\",\n        value: function hide() {\n            this.div.hide();\n        }\n    }]);\n\n    return PanelLegend;\n}();\n\nexports.PanelLegend = PanelLegend;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3BhbmVsX2xlZ2VuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvcGFuZWxfbGVnZW5kLmpzPzg1OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNTFZUcmFja0RpYWxvZ30gZnJvbSBcIi4vdHJhY2tfZGlhbG9nLmpzXCI7XHJcblxyXG5jbGFzcyBQYW5lbExlZ2VuZHtcclxuICAgIGNvbnN0cnVjdG9yKHBhbmVsLGNvbmZpZyl7XHJcbiAgICAgICAgaWYgKCFjb25maWcpe1xyXG4gICAgICAgICAgICBjb25maWc9e307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBhbmVsPXBhbmVsO1xyXG4gICAgICAgIHRoaXMudHJhY2tfaW5kZXg9e307XHJcbiAgICAgICAgdGhpcy5kaXY9JChcIjxkaXY+XCIpLmF0dHIoe1wiY2xhc3NcIjpcIm1sdi10cmFjay1sZWdlbmRcIn0pXHJcbiAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmRyYWdnYWJsZSB8fCBjb25maWcuZHJhZ2dhYmxlPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICB0aGlzLmRpdi5kcmFnZ2FibGUoe1xyXG4gICAgICAgICAgICBjb250YWlubWVudDpcInBhcmVudFwiXHJcbiAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYgKGNvbmZpZy50cmFuc3BhcmVudCA9PSBmYWxzZSB8fCBjb25maWcudHJhbnNwYXJlbnQ9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgdGhpcy5kaXYuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLFwid2hpdGVcIilcclxuICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgdGhpcy5saSA9JChcIjx1bD5cIikuY3NzKHtcImxpc3Qtc3R5bGUtdHlwZVwiOlwibm9uZVwiLFwicGFkZGluZ1wiOlwiNHB4XCIsXCJtYXJnaW5cIjpcIjRweFwifSk7XHJcbiAgICAgICAgZm9yIChsZXQgaWQgb2YgcGFuZWwudHJhY2tfb3JkZXIpe1xyXG4gICAgICAgICAgIHRoaXMuYWRkVHJhY2socGFuZWwudHJhY2tzW2lkXS5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMubGkpO1xyXG4gICAgICAgIHRoaXMubGkuc29ydGFibGUoe1xyXG4gICAgICAgICAgICBoZWxwZXI6XCJjbG9uZVwiLFxyXG4gICAgICAgICAgICBzdG9wOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICBcdHNlbGYuX3JlT3JkZXIodWkuaXRlbSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBcclxuICAgICAgICBwYW5lbC50cmFja0Rpdi5hcHBlbmQodGhpcy5kaXYpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN3YXBPcmRlcihpZDEsaWQyKXtcclxuICAgICAgICBsZXQgZWwxPW51bGw7XHJcbiAgICAgICAgbGV0IGVsMj1udWxsO1xyXG4gICAgICAgICAgIHRoaXMubGkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGksZWwpe1xyXG4gICAgICAgICAgICBsZXQgZSA9ICQoZWwpO1xyXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSAgZS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0cmFjay50cmFja19pZD09PWlkMil7XHJcbiAgICAgICAgICAgICAgICBlbDI9ZTsgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgICh0cmFjay50cmFja19pZD09PWlkMSl7XHJcbiAgICAgICAgICAgICAgICBlbDE9ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsMS5kZXRhY2goKTtcclxuICAgICAgICBlbDEuaW5zZXJ0QWZ0ZXIoZWwyKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgX3JlT3JkZXIoaXRlbSl7XHJcbiAgICAgICAgbGV0IGdyb3VwID0gaXRlbS5kYXRhKFwidHJhY2tcIikuZ3JvdXA7XHJcbiAgICAgICAgbGV0IGl0ZW1faWQ9aXRlbS5kYXRhKFwidHJhY2tcIikudHJhY2tfaWQ7XHJcbiAgICAgICAgbGV0IG9yZGVyPVtdO1xyXG4gICAgICAgIGxldCBncm91cF9pbmRleD0wO1xyXG4gICAgICAgIGxldCBvdGhlcl9ncm91cF9tZW1iZXJzPVtdXHJcbiAgICAgICAgdGhpcy5saS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oaSxlbCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFjayA9ICAkKGVsKS5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICAgICAgIGlmIChncm91cCAmJiB0cmFjay5ncm91cCA9PT1ncm91cCl7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sudHJhY2tfaWQ9PT1pdGVtX2lkKXtcclxuICAgICAgICAgICAgICAgICAgICBncm91cF9pbmRleD1vcmRlci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaCh0cmFjay50cmFja19pZClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfZ3JvdXBfbWVtYmVycy5wdXNoKHRyYWNrLnRyYWNrX2lkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9yZGVyLnB1c2godHJhY2sudHJhY2tfaWQpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgICBcclxuICAgICAgICBmb3IobGV0IHRpZCBvZiBvdGhlcl9ncm91cF9tZW1iZXJzKXtcclxuICAgICAgICAgICBvcmRlci5zcGxpY2UoZ3JvdXBfaW5kZXgrMSwwLHRpZCk7XHJcbiAgICAgICAgICAgZ3JvdXBfaW5kZXgrKztcclxuICAgICAgICAgICB0aGlzLnRyYWNrX2luZGV4W3RpZF0uZGV0YWNoKCkuaW5zZXJ0QWZ0ZXIoaXRlbSk7XHJcbiAgICAgICAgICAgaXRlbSA9ICB0aGlzLnRyYWNrX2luZGV4W3RpZF07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhbmVsLnRyYWNrX29yZGVyPW9yZGVyO1xyXG4gICAgICAgXHJcbiAgICAgICAgdGhpcy5wYW5lbC51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVUcmFjayh0cmFja19pZCl7XHJcbiAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMudHJhY2tfaW5kZXhbdHJhY2tfaWRdO1xyXG4gICAgICAgbGV0IHRyYWNrID0gZWxlbWVudC5kYXRhKFwidHJhY2tcIik7XHJcbiAgICAgICBlbGVtZW50LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpbmRleCxlbCl7XHJcbiAgICBcdCAgIGVsPSQoZWwpO1xyXG4gICAgICAgICAgIGlmIChpbmRleD09MCl7XHJcbiAgICAgICAgXHQgICBlbC5jc3MoXCJjb2xvclwiLHRyYWNrLmNvbG9yKTsgIFx0ICAgXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2UgaWYgKGluZGV4PT0xKXtcclxuICAgICAgICAgICAgICAgZWwudGV4dCggdHJhY2suc2hvcnRfbGFiZWwpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxpLndpZHRoKG51bGwpOyAgICAgICAgICAgICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhZGRUcmFjayh0cmFjayxpbmRleCl7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxldCBpdGVtID0gJChcIjxsaT5cIikuZGF0YSh7dHJhY2s6dHJhY2sscGFuZWw6dGhpcy5wYW5lbH0pXHJcbiAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBuZXcgTUxWVHJhY2tEaWFsb2codHJhY2ssc2VsZi5wYW5lbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHNwYW4gPSAkKFwiPHNwYW4+XCIpO1xyXG4gICAgICAgIGxldCBpY29uPSBcImZhcyBmYS1zaWduYXR1cmVcIlxyXG4gICAgICAgIGlmICh0cmFjay5mb3JtYXQ9PT1cImZlYXR1cmVcIil7XHJcbiAgICAgICAgICAgIGljb24gPSBcImZhcyBmYS1zdHJlYW1cIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0cmFjay5mb3JtYXQ9PT1cInJ1bGVyXCIpe1xyXG4gICAgICAgICAgICBpY29uPVwiZmFzIGZhLXJ1bGVyLWhvcml6b250YWxcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwYW4uYXR0cihcImNsYXNzXCIsaWNvbikuY3NzKHtcImNvbG9yXCI6dHJhY2suY29sb3J9KVxyXG4gICAgICAgIC8qaWYgKHRyYWNrLmZvcm1hdD09PSdsaW5lJyl7XHJcbiAgICAgICAgICAgIHNwYW4uaGVpZ2h0KDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2suZGlzcGxheT09PVwibGluZVwiKXtcclxuICAgICAgICAgICAgc3Bhbi5oZWlnaHQoNClcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICBsZXQgdGV4dCA9ICQoXCI8c3Bhbj5cIikuYXR0cihcImNsYXNzXCIsXCJtbHYtdHJhY2stbGVnZW5kLXRleHRcIik7XHJcbiAgICAgICAgaXRlbS5hcHBlbmQoc3BhbikuYXBwZW5kKHRleHQpO1xyXG4gICAgICAgIGxldCB0X3NwID0gJChcIjxzcGFuPlwiKS53aWR0aCgxNSkuYXBwZW5kVG8oaXRlbSk7XHJcbiAgICAgICAgaWYgKHRyYWNrLmFsbG93X3VzZXJfcmVtb3ZlKXtcclxuICAgICAgICAgICAgbGV0IHJtPSQoXCI8aSBjbGFzcz0nZmFzICBmYS10cmFzaCc+PC9pPlwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwucmVtb3ZlVHJhY2sodHJhY2sudHJhY2tfaWQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVUcmFjayh0cmFjay50cmFja19pZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jc3MoXCJmbG9hdFwiLFwicmlnaHRcIilcclxuICAgICAgICAgICAgLmFwcGVuZFRvKHRfc3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXg9PT0wKXtcclxuICAgICAgICAgICAgdGhpcy5saS5wcmVwZW5kKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbmRleCl7XHJcbiAgICAgICAgICAgIGxldCBwb3NfZWw9dGhpcy5saS5jaGlsZHJlbigpW2luZGV4LTFdXHJcbiAgICAgICAgICAgIGl0ZW0uaW5zZXJ0QWZ0ZXIoJChwb3NfZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5saS5hcHBlbmQoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhY2tfaW5kZXhbdHJhY2sudHJhY2tfaWRdPWl0ZW07XHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmFjayh0cmFjay50cmFja19pZCk7ICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbW92ZVRyYWNrKHRyYWNrX2lkKXtcclxuICAgICAgICB0aGlzLmxpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpbmRleCxlbGVtZW50KXtcclxuICAgICAgICAgICAgZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGxldCB0ID0gIGVsZW1lbnQuZGF0YShcInRyYWNrXCIpO1xyXG4gICAgICAgICAgICBpZiAodCAmJiB0LnRyYWNrX2lkPT09dHJhY2tfaWQpe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrX2luZGV4W3RyYWNrX2lkXTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlKCl7XHJcbiAgICAgICAgdGhpcy5kaXYuaGlkZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtQYW5lbExlZ2VuZH07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUJBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTEE7QUFDQTtBQVFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQXJCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBc0JBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUE1QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/panel_legend.js\n");

/***/ }),

/***/ "../MLVPanel/src/track_dialog.js":
/*!**********************************!*\
  !*** .Panel/src/track_dialog.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AddTrackDialog = exports.MLVTrackDialog = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tracks = __webpack_require__(/*! ./tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVTrackDialog = function () {\n    function MLVTrackDialog(config, panel) {\n        _classCallCheck(this, MLVTrackDialog);\n\n        this.config = _tracks.MLVTrack.parseConfig(config);\n        this.panel = panel;\n        this.div = $(\"<div>\").attr(\"class\", \"mlv-track-dialog\");\n\n        this.div.dialog({\n            autoOpen: true,\n            close: function close() {\n                $(this).dialog('destroy').remove();\n            },\n            title: this.config.short_label,\n            width: 250,\n            draggable: true\n\n        }).dialogFix();\n\n        this.id = MLVTrackDialog.id++;\n\n        this.init();\n    }\n\n    _createClass(MLVTrackDialog, [{\n        key: \"_updatePanelScale\",\n        value: function _updatePanelScale() {\n            if (!this.panel) {\n                return;\n            }\n            this.panel.setTrackAttribute(this.config.track_id, \"max_y\", this.config.max_y);\n            this.panel.setTrackAttribute(this.config.track_id, \"min_y\", this.config.min_y);\n            this.panel.update();\n        }\n    }, {\n        key: \"_reOrderTrack\",\n        value: function _reOrderTrack(other_track) {\n            var this_i = this.panel.track_order.indexOf(this.config.track_id);\n            var other_i = this.panel.track_order.indexOf(other_track);\n            if (this_i < other_i) {\n                var temp = this.panel.track_order[this_i];\n                this.panel.track_order[this_i] = this.panel.track_order[other_i];\n                this.panel.track_order[other_i] = temp;\n                if (this.panel.legend) {\n                    this.panel.legend.swapOrder(this.config.track_id, other_track);\n                }\n            }\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var self = this;\n\n            var color_input = $(\"<input>\").attr({ type: \"color\" }).change(function (e) {\n                var color = $(this).val();\n                self.config.color = $(this).val();\n                if (self.panel) {\n                    self.panel.setTrackAttribute(self.config.track_id, \"color\", self.config.color);\n                    self.panel.update();\n                }\n            });\n            var color_div = $(\"<div class='t-d-div'></div>\");\n\n            color_div.append(\"<label>Color</label><br>\");\n            color_div.append(color_input).appendTo(this.div);\n            color_input.val(self.config.color).height(15);\n            this.div.append(\"<hr>\");\n            if (this.config.format === \"wig\") {\n                var scale_name = \"sc-ra-name-\" + this.id;\n                var scale_div = $(\"<div class='t-d-div'></div>\").append(\"<label>Scale</label><br>\");\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"automatic\", checked: this.config.scale === \"automatic\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Automatic\"));\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"fixed\", checked: this.config.scale === \"fixed\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Fixed\"));\n                scale_div.append($(\"<input>\").attr({ type: \"radio\", value: \"dynamic\", checked: this.config.scale === \"dynamic\", name: scale_name }));\n                scale_div.append($(\"<span>\").text(\"Dynamic\"));\n                scale_div.appendTo(this.div);\n                $(\"input[name='\" + scale_name + \"']\").click(function (e) {\n                    var scale = $(\"input[name='\" + scale_name + \"']:checked\").val();\n                    self.config.scale = scale;\n                    if (scale === \"fixed\") {\n                        self.config.scale_group = \"\";\n                        self.sg_input.val(\"\");\n                    }\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"scale\", scale);\n                        self.panel.setTrackAttribute(self.config.track_id, \"scale_group\", self.config.scale_group);\n                        delete self.panel.tracks[self.config.track_id].max_y;\n                        self.panel.update();\n                    }\n                });\n                self.scale_slider = $(\"<div>\").slider({\n\n                    range: true,\n                    min: self.config.min_y,\n                    max: self.config.max_y,\n                    values: [self.config.min_y, self.config.max_y],\n                    slide: function slide(event, ui) {\n                        self.config.max_y = ui.values[1];\n                        self.config.min_y = ui.values[0];\n                        self._updatePanelScale();\n                        self.min_y_input.val(ui.values[0]);\n                        self.max_y_input.val(ui.values[1]);\n                    }\n                }).css(\"margin\", \"5px 3px\");\n                self.scale_slider.appendTo(scale_div);\n                self.scale_slider.slider(\"option\", \"values\", [self.config.min_y, self.config.max_y]);\n                self.min_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    var y = self.min_y_input.val();\n                    y = parseFloat(y);\n                    if (y < self.config.min_y) {\n                        self.scale_slider.slider(\"option\", \"min\", y);\n                    }\n                    self.scale_slider.slider(\"option\", \"values\", [y, self.config.max_y]);\n                    self.config.min_y = y;\n                    self._updatePanelScale();\n                }).appendTo(scale_div).width(40).val(self.config.min_y);\n                self.max_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    var y = self.max_y_input.val();\n                    y = parseFloat(y);\n                    var range = y - self.min_y_input.val();\n                    self.scale_slider.slider(\"option\", \"step\", range / 100);\n                    self.scale_slider.slider(\"option\", \"max\", y);\n                    self.scale_slider.slider(\"option\", \"values\", [self.config.min_y, y]);\n                    self.config.max_y = y;\n                    self._updatePanelScale();\n                }).appendTo(scale_div).width(40).css({ \"float\": \"right\" }).val(self.config.max_y);\n\n                scale_div.append(\"<br>Linked To:\");\n                var _track = this.panel.tracks[this.config.track_id];\n\n                this.link_opt = $(\"<select>\").css(\"max-width\", \"140px\").change(function (e) {\n                    var val = $(this).val();\n                    var dis = true;\n                    if (!val) {\n                        dis = false;\n                    }\n                    self.max_y_input.attr(\"disabled\", dis);\n                    self.min_y_input.attr(\"disabled\", dis);\n                    self.scale_slider.slider(\"option\", \"disabled\", dis);\n                    self._reOrderTrack(val);\n                    self.config.scale_link_to = val;\n                    self.panel.setTrackAttribute(self.config.track_id, \"scale_link_to\", val);\n\n                    self.panel.update();\n                });\n                scale_div.append(this.link_opt);\n                this.link_opt.append($(\"<option>\").val(null).text(\"none\"));\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = this.panel.track_order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var tn = _step.value;\n\n                        var c = this.panel.tracks[tn].config;\n\n                        if (c.format !== \"wig\" || c.track_id === this.config.track_id || c.scale_link_to) {\n                            continue;\n                        }\n                        this.link_opt.append($(\"<option>\").val(c.track_id).text(c.short_label));\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                this.link_opt.val(this.config.scale_link_to);\n\n                if (this.config.scale_link_to) {\n                    this.max_y_input.attr(\"disabled\", true);\n                    this.min_y_input.attr(\"disabled\", true);\n                    this.scale_slider.slider(\"option\", \"disabled\", true);\n                }\n\n                scale_div.append(\"<br>\").append(\"<span>Scale Group:</span>\");\n                this.sg_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    self.config.scale_group = $(this).val();\n                    self.panel.setTrackAttribute(self.config.track_id, \"scale_group\", self.config.scale_group);\n                    self.panel.update();\n                }).width(120);\n                this.sg_input.val(this.config.scale_group).appendTo(scale_div);\n\n                this.div.append(\"<hr>\");\n\n                this.div.append(\"<hr>\");\n\n                var display_name = \"di-ra-name-\" + this.id;\n                var display_div = $(\"<div class='t-d-div'></div>\").append(\"<label>Display</label><br>\");\n                display_div.append($(\"<input>\").attr({ type: \"radio\", value: \"fill\", checked: this.config.display === \"fill\" || !this.config.display_type, name: display_name }));\n                display_div.append($(\"<span>\").text(\"Fill\"));\n                display_div.append($(\"<input>\").attr({ type: \"radio\", value: \"line\", checked: this.config.display === \"line\", name: display_name }));\n                display_div.append($(\"<span>\").text(\"Line\"));\n                this.div.append(display_div);\n                $(\"input[name='\" + display_name + \"']\").click(function (e) {\n                    var display = $(\"input[name='\" + display_name + \"']:checked\").val();\n                    self.config.display = display;\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"display\", display);\n                        self.panel.update();\n                    }\n                });\n                display_div.append(\"<br>\");\n\n                display_div.append(\"<label>group:</label>\").append(\"<br>\");\n                var input = $(\"<input>\").on(\"blur keypress\", function (e) {\n                    if (e.type === \"keypress\" && !(e.which === 13)) {\n                        return;\n                    }\n                    self.config.group = $(this).val();\n                    self.panel.setTrackAttribute(self.config.track_id, \"group\", self.config.group);\n                    self.panel.update();\n                });\n                input.val(this.config.group).appendTo(display_div);\n\n                this.div.append(\"<hr>\");\n            }\n            var discrete_div = $(\"<div>\").append(\"<label>Discrete</label>\");\n            var check = $(\"<input>\").attr({ type: \"checkbox\" }).prop(\"checked\", this.config.discrete).click(function (e) {\n                self.config.discrete = $(this).prop(\"checked\");\n                if (self.panel) {\n                    self.panel.setTrackAttribute(self.config.track_id, \"discrete\", self.config.discrete);\n                    self.panel.update();\n                }\n                if (self.config.discrete) {\n                    self.height_div.show();\n                } else {\n                    self.height_div.hide();\n                }\n            }).appendTo(discrete_div);\n            if (this.panel.fixed_height_mode) {\n                check.attr(\"disabled\", true);\n            }\n            discrete_div.appendTo(this.div);\n\n            // if (this.config.discrete || this.panel.fixed_height_mode){\n            this.height_div = $(\"<div class='t-d-div'></div>\");\n\n            this.height_div.append(\"<label>height:</label>\").appendTo(this.div);\n\n            var height_slider = $(\"<div>\").slider({\n                min: 10,\n                max: 500,\n                value: self.config.height,\n                slide: function slide(event, ui) {\n                    self.config.height = ui.value;\n                    self.panel.setTrackAttribute(self.config.track_id, \"height\", self.config.height);\n                    self.panel.update();\n                }\n            }).css({ \"margin\": \"5px 3px\" });\n            height_slider.appendTo(this.height_div);\n            if (!self.panel.fixed_height_mode) {\n                if (!self.config.discrete) {\n                    this.height_div.hide();\n                }\n            }\n\n            if (this.config.format === \"feature\" || this.config.type === \"bam\") {\n\n                var feature_div = $(\"<div>\").append(\"<label>Feature Height</label><br>\");\n                self.feature_height_slider = $(\"<div>\").slider({\n                    max: 40,\n                    min: 3,\n                    slide: function slide(e, ui) {\n                        self.config.featureHeight = ui.value;\n                        if (self.panel) {\n                            self.panel.setTrackAttribute(self.config.track_id, \"featureHeight\", self.config.featureHeight);\n                            self.panel.update();\n                        }\n                    }\n                });\n                self.feature_height_slider.slider(\"option\", \"value\", self.config.featureHeight);\n                feature_div.append(self.feature_height_slider).appendTo(this.div);\n                this.div.append(\"<hr>\");\n            }\n            if (this.config.format === \"feature\") {\n\n                var feature_display_div = $(\"<div>\").append(\"<label>Display</label><br>\");\n\n                self.feature_display_select = $(\"<select>\").append(\"<option>EXPANDED</option>\").append(\"<option>SQUISHED</option>\").append(\"<option>COLLAPSED</option>\").change(function (e) {\n                    self.config.displayMode = $(this).val();\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"displayMode\", self.config.displayMode);\n                        self.panel.update();\n                    }\n                }).val(self.config.displayMode);\n                feature_display_div.append(self.feature_display_select).appendTo(this.div);\n                this.div.append(\"<hr>\");\n            }\n\n            var op_div = $(\"<div>\").append(\"<label>Opacity</label><br>\");\n\n            self.opacity_slider = $(\"<div>\").slider({\n                max: 1.0,\n                min: 0.0,\n                step: 0.05,\n                slide: function slide(e, ui) {\n                    self.config.opacity = ui.value;\n                    if (self.panel) {\n                        self.panel.setTrackAttribute(self.config.track_id, \"opacity\", self.config.opacity);\n                        self.panel.update();\n                    }\n                }\n            });\n            op_div.append(self.opacity_slider).appendTo(this.div);\n            self.opacity_slider.slider(\"option\", \"value\", self.config.opacity);\n            var track = this.panel.tracks[this.config.track_id];\n            track.addExtraControls(this);\n\n            var p = this.div.parent();\n        }\n    }]);\n\n    return MLVTrackDialog;\n}();\n\nvar AddTrackDialog = function () {\n    function AddTrackDialog(callback, config) {\n        _classCallCheck(this, AddTrackDialog);\n\n        if (!config) {\n            config = {};\n        }\n        this.config = config;\n        this.div = $(\"<div>\").attr(\"class\", \"add-track-dialog\");\n        this.id = MLVTrackDialog.id++;\n        this.callback = callback;\n        var self = this;\n        this.div.dialog({\n            autoOpen: true,\n            buttons: [{\n                text: \"Add\",\n                click: function click(e) {\n                    self.getConfig();\n                    $(this).dialog(\"close\");\n                }\n            }],\n            close: function close() {\n                $(this).dialog('destroy').remove();\n            },\n            title: \"Add Track\",\n            width: 250\n\n        }).dialogFix();\n\n        this.init();\n    }\n\n    _createClass(AddTrackDialog, [{\n        key: \"getConfig\",\n        value: function getConfig() {\n            var type = $(\"input[name='\" + this.type_radio + \"']:checked\").val();\n            var config = { url: this.url_input.val(), type: type, short_label: this.name_input.val() };\n            this.callback(config);\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var self = this;\n            this.div.append(\"<label>Paste URL</label>\");\n            this.url_input = $(\"<textarea>\").appendTo(this.div).css({ width: \"95%\" });\n            this.url_input.on(\"blur keypress\", function (e) {\n                if (e.originalEvent.type === \"keypress\" && e.charCode !== 13) {\n                    return;\n                }\n                self._getInfoFromUrl($(this).val());\n            });\n            this.div.append($(\"<label>Name</label>\"));\n            this.name_input = $(\"<input>\").appendTo(this.div);\n            this.div.append($(\"<label>Type</label>\"));\n            var radio_div = $(\"<div>\").appendTo(this.div);\n            this.type_radio = 'track-add-radio-' + this.id;\n            for (var type in _tracks.MLVTrack.track_types) {\n                if (this.config.allowed_track_types && this.config.allowed_track_types.indexOf(type) === -1) {\n                    continue;\n                }\n                this.addRadioButton(radio_div, type);\n            }\n        }\n    }, {\n        key: \"setAddFunction\",\n        value: function setAddFunction(func) {\n            this.callback = callback;\n        }\n    }, {\n        key: \"_getInfoFromUrl\",\n        value: function _getInfoFromUrl(url) {\n            var type = _tracks.MLVTrack.getTypeFromURL(url).type;\n            var name = _tracks.MLVTrack.calculateLabel(url);\n            if (url.includes(\"hgTracks\")) {\n                name = \"UCSC Session\";\n                type = \"ucsc_track\";\n            }\n            this.name_input.val(name);\n            $(\"[name='\" + this.type_radio + \"']\").val([type]);\n        }\n    }, {\n        key: \"addRadioButton\",\n        value: function addRadioButton(div, type) {\n            var sp = $(\"<span>\").css({ \"display\": \"inline-block\", \"margin-right\": \"3px\" });\n            sp.append($(\"<input>\").attr({ type: \"radio\", value: type, name: this.type_radio }));\n            sp.append($(\"<span>\").text(_tracks.MLVTrack.track_types[type].name));\n            div.append(sp);\n        }\n    }]);\n\n    return AddTrackDialog;\n}();\n\nMLVTrackDialog.id = 0;\n\nexports.MLVTrackDialog = MLVTrackDialog;\nexports.AddTrackDialog = AddTrackDialog;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3RyYWNrX2RpYWxvZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvdHJhY2tfZGlhbG9nLmpzP2NjZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNTFZUcmFja30gZnJvbSBcIi4vdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuY2xhc3MgTUxWVHJhY2tEaWFsb2d7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcscGFuZWwpe1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gTUxWVHJhY2sucGFyc2VDb25maWcoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnBhbmVsPXBhbmVsO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gJChcIjxkaXY+XCIpLmF0dHIoXCJjbGFzc1wiLFwibWx2LXRyYWNrLWRpYWxvZ1wiKTtcclxuICAgICAgXHJcblx0XHR0aGlzLmRpdi5kaWFsb2coe1xyXG5cdFx0XHRhdXRvT3BlbjogdHJ1ZSxcclxuXHRcdFx0Y2xvc2U6ZnVuY3Rpb24oKXtcclxuXHRcdFx0XHQkKHRoaXMpLmRpYWxvZygnZGVzdHJveScpLnJlbW92ZSgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR0aXRsZTogdGhpcy5jb25maWcuc2hvcnRfbGFiZWwsXHJcblx0XHRcdHdpZHRoOjI1MCxcclxuXHRcdFx0ZHJhZ2dhYmxlOnRydWVcclxuXHJcblx0XHR9KS5kaWFsb2dGaXgoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmlkPU1MVlRyYWNrRGlhbG9nLmlkKys7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5pbml0KCk7ICBcclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlUGFuZWxTY2FsZSgpe1xyXG4gICAgICAgIGlmICghdGhpcy5wYW5lbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZSh0aGlzLmNvbmZpZy50cmFja19pZCxcIm1heF95XCIsdGhpcy5jb25maWcubWF4X3kpO1xyXG4gICAgICAgIHRoaXMucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUodGhpcy5jb25maWcudHJhY2tfaWQsXCJtaW5feVwiLHRoaXMuY29uZmlnLm1pbl95KTtcclxuICAgICAgICB0aGlzLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9yZU9yZGVyVHJhY2sob3RoZXJfdHJhY2spe1xyXG4gICAgXHRsZXQgdGhpc19pID0gdGhpcy5wYW5lbC50cmFja19vcmRlci5pbmRleE9mKHRoaXMuY29uZmlnLnRyYWNrX2lkKTtcclxuICAgIFx0bGV0IG90aGVyX2kgPSAgdGhpcy5wYW5lbC50cmFja19vcmRlci5pbmRleE9mKG90aGVyX3RyYWNrKTtcclxuICAgIFx0aWYgKHRoaXNfaSA8IG90aGVyX2kpe1xyXG4gICAgXHRcdGxldCB0ZW1wID0gdGhpcy5wYW5lbC50cmFja19vcmRlclt0aGlzX2ldO1xyXG4gICAgXHRcdHRoaXMucGFuZWwudHJhY2tfb3JkZXJbdGhpc19pXT10aGlzLnBhbmVsLnRyYWNrX29yZGVyW290aGVyX2ldO1xyXG4gICAgXHRcdHRoaXMucGFuZWwudHJhY2tfb3JkZXJbb3RoZXJfaV09dGVtcDtcclxuICAgIFx0XHRpZiAodGhpcy5wYW5lbC5sZWdlbmQpe1xyXG4gICAgXHRcdFx0dGhpcy5wYW5lbC5sZWdlbmQuc3dhcE9yZGVyKHRoaXMuY29uZmlnLnRyYWNrX2lkLG90aGVyX3RyYWNrKVxyXG4gICAgXHRcdH1cclxuXHJcbiAgICBcdH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgICAgIFxyXG4gICAgaW5pdCgpe1xyXG4gICAgICAgIGxldCBzZWxmPXRoaXM7XHJcblxyXG4gICAgICAgIGxldCBjb2xvcl9pbnB1dD0kKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwiY29sb3JcIn0pXHJcbiAgICAgICAgLmNoYW5nZShmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gJCh0aGlzKS52YWwoKTtcclxuICAgICAgICAgICAgc2VsZi5jb25maWcuY29sb3I9JCh0aGlzKS52YWwoKTtcclxuICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShzZWxmLmNvbmZpZy50cmFja19pZCxcImNvbG9yXCIsc2VsZi5jb25maWcuY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBjb2xvcl9kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuICAgICAgIFxyXG4gICAgICAgIGNvbG9yX2Rpdi5hcHBlbmQoXCI8bGFiZWw+Q29sb3I8L2xhYmVsPjxicj5cIik7XHJcbiAgICAgICAgY29sb3JfZGl2LmFwcGVuZChjb2xvcl9pbnB1dCkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgICAgIGNvbG9yX2lucHV0LnZhbChzZWxmLmNvbmZpZy5jb2xvcikuaGVpZ2h0KDE1KTtcclxuICAgICAgICB0aGlzLmRpdi5hcHBlbmQoXCI8aHI+XCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5mb3JtYXQ9PT1cIndpZ1wiKXtcclxuICAgICAgICAgICAgbGV0IHNjYWxlX25hbWU9IFwic2MtcmEtbmFtZS1cIit0aGlzLmlkXHJcbiAgICAgICAgICAgIGxldCBzY2FsZV9kaXYgPSAkKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5TY2FsZTwvbGFiZWw+PGJyPlwiKTtcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImF1dG9tYXRpY1wiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImF1dG9tYXRpY1wiLG5hbWU6c2NhbGVfbmFtZX0pKVxyXG4gICAgICAgICAgICBzY2FsZV9kaXYuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChcIkF1dG9tYXRpY1wiKSk7XHJcbiAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcInJhZGlvXCIsdmFsdWU6XCJmaXhlZFwiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImZpeGVkXCIsbmFtZTpzY2FsZV9uYW1lfSkpXHJcbiAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoJChcIjxzcGFuPlwiKS50ZXh0KFwiRml4ZWRcIikpO1xyXG4gICAgICAgICAgICBzY2FsZV9kaXYuYXBwZW5kKCQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJyYWRpb1wiLHZhbHVlOlwiZHluYW1pY1wiLGNoZWNrZWQ6dGhpcy5jb25maWcuc2NhbGU9PT1cImR5bmFtaWNcIixuYW1lOnNjYWxlX25hbWV9KSlcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJEeW5hbWljXCIpKTtcclxuICAgICAgICAgICAgc2NhbGVfZGl2LmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuICAgICAgICAgICAgJChcImlucHV0W25hbWU9J1wiK3NjYWxlX25hbWUrXCInXVwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIGxldCBzY2FsZT0kKFwiaW5wdXRbbmFtZT0nXCIrc2NhbGVfbmFtZStcIiddOmNoZWNrZWRcIikudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zY2FsZT1zY2FsZTtcclxuICAgICAgICAgICAgICAgIGlmIChzY2FsZT09PVwiZml4ZWRcIil7XHJcbiAgICAgICAgICAgICAgICBcdHNlbGYuY29uZmlnLnNjYWxlX2dyb3VwPVwiXCI7XHJcbiAgICAgICAgICAgICAgICBcdHNlbGYuc2dfaW5wdXQudmFsKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJzY2FsZVwiLHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwic2NhbGVfZ3JvdXBcIixzZWxmLmNvbmZpZy5zY2FsZV9ncm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYucGFuZWwudHJhY2tzW3NlbGYuY29uZmlnLnRyYWNrX2lkXS5tYXhfeTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VsZi5zY2FsZV9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG5cclxuICAgICAgICAgICAgICAgIHJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWluOiBzZWxmLmNvbmZpZy5taW5feSxcclxuICAgICAgICAgICAgICAgIG1heDogc2VsZi5jb25maWcubWF4X3ksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFsgc2VsZi5jb25maWcubWluX3ksc2VsZi5jb25maWcubWF4X3kgXSxcclxuICAgICAgICAgICAgICAgIHNsaWRlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heF95PSB1aS52YWx1ZXNbIDEgXTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5feT0gdWkudmFsdWVzWyAwIF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGFuZWxTY2FsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluX3lfaW5wdXQudmFsKHVpLnZhbHVlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXhfeV9pbnB1dC52YWwodWkudmFsdWVzWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY3NzKFwibWFyZ2luXCIsXCI1cHggM3B4XCIpO1xyXG4gICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5hcHBlbmRUbyhzY2FsZV9kaXYpO1xyXG4gICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlc1wiLFtzZWxmLmNvbmZpZy5taW5feSxzZWxmLmNvbmZpZy5tYXhfeV0pO1xyXG4gICAgICAgICAgICBzZWxmLm1pbl95X2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1zZWxmLm1pbl95X2lucHV0LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgeT1wYXJzZUZsb2F0KHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHk8c2VsZi5jb25maWcubWluX3kpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2NhbGVfc2xpZGVyLnNsaWRlcihcIm9wdGlvblwiLFwibWluXCIseSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlc1wiLFt5LHNlbGYuY29uZmlnLm1heF95XSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5feT15O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlUGFuZWxTY2FsZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KS5hcHBlbmRUbyhzY2FsZV9kaXYpLndpZHRoKDQwKS52YWwoc2VsZi5jb25maWcubWluX3kpO1xyXG4gICAgICAgICAgICBzZWxmLm1heF95X2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgIGlmIChlLnR5cGU9PT1cImtleXByZXNzXCIgJiYgIShlLndoaWNoPT09MTMpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9c2VsZi5tYXhfeV9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHk9cGFyc2VGbG9hdCh5KTtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSAgPSB5IC0gc2VsZi5taW5feV9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2NhbGVfc2xpZGVyLnNsaWRlcihcIm9wdGlvblwiLFwic3RlcFwiLHJhbmdlLzEwMCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnNjYWxlX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcIm1heFwiLHkpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJ2YWx1ZXNcIixbc2VsZi5jb25maWcubWluX3kseV0pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4X3k9eTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZVBhbmVsU2NhbGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSkuYXBwZW5kVG8oc2NhbGVfZGl2KS53aWR0aCg0MCkuY3NzKHtcImZsb2F0XCI6XCJyaWdodFwifSkudmFsKHNlbGYuY29uZmlnLm1heF95KTtcclxuXHJcblx0XHRcdHNjYWxlX2Rpdi5hcHBlbmQoXCI8YnI+TGlua2VkIFRvOlwiKTtcclxuXHRcdFx0bGV0IHRyYWNrICA9IHRoaXMucGFuZWwudHJhY2tzW3RoaXMuY29uZmlnLnRyYWNrX2lkXTtcclxuICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5saW5rX29wdCA9ICQoXCI8c2VsZWN0PlwiKVxyXG4gICAgICAgICAgICBcdC5jc3MoXCJtYXgtd2lkdGhcIixcIjE0MHB4XCIpXHJcbiAgICAgICAgICAgIFx0LmNoYW5nZShmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgXHRcdGxldCB2YWw9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgIFx0XHRsZXQgZGlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgXHRcdGlmICghdmFsKXtcclxuXHRcdFx0XHRcdFx0ZGlzPWZhbHNlO1xyXG4gICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgICBcdFx0c2VsZi5tYXhfeV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkaXMpO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5taW5feV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkaXMpO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJkaXNhYmxlZFwiLGRpcyk7XHJcblx0XHRcdFx0XHRzZWxmLl9yZU9yZGVyVHJhY2sodmFsKTtcclxuXHRcdFx0XHRcdHNlbGYuY29uZmlnLnNjYWxlX2xpbmtfdG89dmFsO1xyXG4gICAgICAgICAgICBcdFx0c2VsZi5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShzZWxmLmNvbmZpZy50cmFja19pZCxcInNjYWxlX2xpbmtfdG9cIix2YWwpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHRcdHNlbGYucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcblx0XHRcdHNjYWxlX2Rpdi5hcHBlbmQodGhpcy5saW5rX29wdCk7XHJcblx0XHRcdHRoaXMubGlua19vcHQuYXBwZW5kKCQoXCI8b3B0aW9uPlwiKS52YWwobnVsbCkudGV4dChcIm5vbmVcIikpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0biBvZiB0aGlzLnBhbmVsLnRyYWNrX29yZGVyKXtcclxuICAgICAgICAgICAgXHRsZXQgYz0gdGhpcy5wYW5lbC50cmFja3NbdG5dLmNvbmZpZztcclxuXHJcbiAgICAgICAgICAgIFx0aWYgKGMuZm9ybWF0ICE9PSBcIndpZ1wiIHx8IGMudHJhY2tfaWQgPT09IHRoaXMuY29uZmlnLnRyYWNrX2lkICB8fCBjLnNjYWxlX2xpbmtfdG8gKXtcclxuICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBcdH1cclxuXHRcdFx0XHR0aGlzLmxpbmtfb3B0LmFwcGVuZCgkKFwiPG9wdGlvbj5cIikudmFsKGMudHJhY2tfaWQpLnRleHQoYy5zaG9ydF9sYWJlbCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxpbmtfb3B0LnZhbCh0aGlzLmNvbmZpZy5zY2FsZV9saW5rX3RvKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zY2FsZV9saW5rX3RvKXtcclxuICAgICAgICAgICAgXHR0aGlzLm1heF95X2lucHV0LmF0dHIoXCJkaXNhYmxlZFwiLHRydWUpO1xyXG4gICAgICAgICAgICBcdHRoaXMubWluX3lfaW5wdXQuYXR0cihcImRpc2FibGVkXCIsdHJ1ZSk7XHJcbiAgICAgICAgICAgIFx0dGhpcy5zY2FsZV9zbGlkZXIuc2xpZGVyKFwib3B0aW9uXCIsXCJkaXNhYmxlZFwiLHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuXHJcbiAgICAgICAgICAgICAgIHNjYWxlX2Rpdi5hcHBlbmQoXCI8YnI+XCIpLmFwcGVuZChcIjxzcGFuPlNjYWxlIEdyb3VwOjwvc3Bhbj5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2dfaW5wdXQ9ICQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgIGlmIChlLnR5cGU9PT1cImtleXByZXNzXCIgJiYgIShlLndoaWNoPT09MTMpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zY2FsZV9ncm91cD0kKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShzZWxmLmNvbmZpZy50cmFja19pZCxcInNjYWxlX2dyb3VwXCIsc2VsZi5jb25maWcuc2NhbGVfZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIH0pLndpZHRoKDEyMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2dfaW5wdXQudmFsKHRoaXMuY29uZmlnLnNjYWxlX2dyb3VwKS5hcHBlbmRUbyhzY2FsZV9kaXYpO1xyXG4gICAgICAgICBcclxuICAgICBcdFx0dGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgICAgICAgICBcclxuXHJcbiAgXHJcblxyXG4gICAgICAgXHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGRpc3BsYXlfbmFtZT0gXCJkaS1yYS1uYW1lLVwiK3RoaXMuaWQ7XHJcbiAgICAgICAgICAgIGxldCBkaXNwbGF5X2RpdiA9ICQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIikuYXBwZW5kKFwiPGxhYmVsPkRpc3BsYXk8L2xhYmVsPjxicj5cIik7XHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImZpbGxcIixjaGVja2VkOnRoaXMuY29uZmlnLmRpc3BsYXk9PT1cImZpbGxcIiB8fCAhdGhpcy5jb25maWcuZGlzcGxheV90eXBlLG5hbWU6ZGlzcGxheV9uYW1lfSkpXHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJGaWxsXCIpKTtcclxuICAgICAgICAgICAgZGlzcGxheV9kaXYuYXBwZW5kKCQoXCI8aW5wdXQ+XCIpLmF0dHIoe3R5cGU6XCJyYWRpb1wiLHZhbHVlOlwibGluZVwiLGNoZWNrZWQ6dGhpcy5jb25maWcuZGlzcGxheT09PVwibGluZVwiLG5hbWU6ZGlzcGxheV9uYW1lfSkpXHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJMaW5lXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpc3BsYXlfZGl2KTtcclxuICAgICAgICAgICAgICQoXCJpbnB1dFtuYW1lPSdcIitkaXNwbGF5X25hbWUrXCInXVwiKS5jbGljayhmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5PSQoXCJpbnB1dFtuYW1lPSdcIitkaXNwbGF5X25hbWUrXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZGlzcGxheT1kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5XCIsZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRpc3BsYXlfZGl2LmFwcGVuZChcIjxicj5cIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgXHJcbiAgICAgICBcclxuICAgICAgICAgICAgZGlzcGxheV9kaXYuYXBwZW5kKFwiPGxhYmVsPmdyb3VwOjwvbGFiZWw+XCIpLmFwcGVuZChcIjxicj5cIik7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dD0gJChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmdyb3VwPSQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZ3JvdXBcIixzZWxmLmNvbmZpZy5ncm91cCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlucHV0LnZhbCh0aGlzLmNvbmZpZy5ncm91cCkuYXBwZW5kVG8oZGlzcGxheV9kaXYpO1xyXG4gICAgICAgICBcclxuICAgICBcdFx0dGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuXHRcdH1cclxuXHRcdCAgICBsZXQgZGlzY3JldGVfZGl2PSQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+RGlzY3JldGU8L2xhYmVsPlwiKTtcclxuICAgICAgICAgICAgbGV0IGNoZWNrID0gJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcImNoZWNrYm94XCJ9KS5wcm9wKFwiY2hlY2tlZFwiLHRoaXMuY29uZmlnLmRpc2NyZXRlKVxyXG4gICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmRpc2NyZXRlPSQodGhpcykucHJvcChcImNoZWNrZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZGlzY3JldGVcIixzZWxmLmNvbmZpZy5kaXNjcmV0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHRzZWxmLmhlaWdodF9kaXYuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIFx0c2VsZi5oZWlnaHRfZGl2LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmRUbyhkaXNjcmV0ZV9kaXYpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYW5lbC5maXhlZF9oZWlnaHRfbW9kZSl7XHJcbiAgICAgICAgICAgIFx0Y2hlY2suYXR0cihcImRpc2FibGVkXCIsdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzY3JldGVfZGl2LmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuXHJcblxyXG5cclxuICAgICAgIFx0Ly8gaWYgKHRoaXMuY29uZmlnLmRpc2NyZXRlIHx8IHRoaXMucGFuZWwuZml4ZWRfaGVpZ2h0X21vZGUpe1xyXG4gICAgICAgXHR0aGlzLmhlaWdodF9kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuICAgICAgICBcdFxyXG5cdFx0dGhpcy5oZWlnaHRfZGl2LmFwcGVuZChcIjxsYWJlbD5oZWlnaHQ6PC9sYWJlbD5cIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cclxuICAgICAgICBsZXQgaGVpZ2h0X3NsaWRlciA9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICAgIFx0bWluOiAxMCxcclxuICAgICAgICAgICAgbWF4OiA1MDAsXHJcbiAgICAgICAgICAgIHZhbHVlOnNlbGYuY29uZmlnLmhlaWdodCxcclxuICAgICAgICAgICAgc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XHJcbiAgICAgICAgICAgIFx0c2VsZi5jb25maWcuaGVpZ2h0PSB1aS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJoZWlnaHRcIixzZWxmLmNvbmZpZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTsgXHJcbiAgICAgICAgICAgIH1cclxuXHRcdH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgIGhlaWdodF9zbGlkZXIuYXBwZW5kVG8odGhpcy5oZWlnaHRfZGl2KTtcclxuICAgICAgICBpZiAoIShzZWxmLnBhbmVsLmZpeGVkX2hlaWdodF9tb2RlKSl7XHJcbiAgICAgICAgXHRpZiAoIShzZWxmLmNvbmZpZy5kaXNjcmV0ZSkpe1xyXG4gICAgICAgIFx0XHR0aGlzLmhlaWdodF9kaXYuaGlkZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH1cclxuIFxyXG5cclxuICAgXHJcblxyXG4gICAgICAgXHJcblxyXG4gICAgICAgXHJcblxyXG4gICBcdCBpZiAodGhpcy5jb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIgfHwgdGhpcy5jb25maWcudHlwZT09PVwiYmFtXCIpe1xyXG5cclxuICAgIGxldCBmZWF0dXJlX2Rpdj0gICQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+RmVhdHVyZSBIZWlnaHQ8L2xhYmVsPjxicj5cIik7XHJcbiAgICBzZWxmLmZlYXR1cmVfaGVpZ2h0X3NsaWRlcj0kKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgIG1heDo0MCxcclxuICAgICAgIG1pbjozLFxyXG4gICAgICAgc2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodD11aS52YWx1ZTtcclxuICAgICAgICAgICBpZiAoc2VsZi5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKHNlbGYuY29uZmlnLnRyYWNrX2lkLFwiZmVhdHVyZUhlaWdodFwiLHNlbGYuY29uZmlnLmZlYXR1cmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9IFxyXG4gICAgfSk7XHJcbiAgICBzZWxmLmZlYXR1cmVfaGVpZ2h0X3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2VsZi5jb25maWcuZmVhdHVyZUhlaWdodCk7XHJcbiAgICBmZWF0dXJlX2Rpdi5hcHBlbmQoc2VsZi5mZWF0dXJlX2hlaWdodF9zbGlkZXIpLmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuICAgIHRoaXMuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIpe1xyXG5cclxuICAgIGxldCBmZWF0dXJlX2Rpc3BsYXlfZGl2PSAgJChcIjxkaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5EaXNwbGF5PC9sYWJlbD48YnI+XCIpO1xyXG5cclxuXHJcbiAgICBzZWxmLmZlYXR1cmVfZGlzcGxheV9zZWxlY3Q9JChcIjxzZWxlY3Q+XCIpLmFwcGVuZChcIjxvcHRpb24+RVhQQU5ERUQ8L29wdGlvbj5cIilcclxuICAgICAgICAgICAgLmFwcGVuZChcIjxvcHRpb24+U1FVSVNIRUQ8L29wdGlvbj5cIilcclxuICAgICAgICAgICAgLmFwcGVuZChcIjxvcHRpb24+Q09MTEFQU0VEPC9vcHRpb24+XCIpXHJcbiAgICAgICAgICAgIC5jaGFuZ2UoZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5kaXNwbGF5TW9kZT0kKHRoaXMpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5TW9kZVwiLHNlbGYuY29uZmlnLmRpc3BsYXlNb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSkudmFsKHNlbGYuY29uZmlnLmRpc3BsYXlNb2RlKTtcclxuICAgIGZlYXR1cmVfZGlzcGxheV9kaXYuYXBwZW5kKHNlbGYuZmVhdHVyZV9kaXNwbGF5X3NlbGVjdCkuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgdGhpcy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb3BfZGl2PSQoXCI8ZGl2PlwiKS5hcHBlbmQoXCI8bGFiZWw+T3BhY2l0eTwvbGFiZWw+PGJyPlwiKTtcclxuXHJcbiAgICBzZWxmLm9wYWNpdHlfc2xpZGVyPSAkKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgICBtYXg6MS4wLFxyXG4gICAgICAgIG1pbjowLjAsXHJcbiAgICAgICAgc3RlcDowLjA1LFxyXG4gICAgICAgIHNsaWRlOmZ1bmN0aW9uKGUsdWkpe1xyXG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5vcGFjaXR5ID0gdWkudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJvcGFjaXR5XCIsc2VsZi5jb25maWcub3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuICAgIG9wX2Rpdi5hcHBlbmQoc2VsZi5vcGFjaXR5X3NsaWRlcikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG4gICAgc2VsZi5vcGFjaXR5X3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2VsZi5jb25maWcub3BhY2l0eSk7XHJcbiAgICBsZXQgdHJhY2sgPSB0aGlzLnBhbmVsLnRyYWNrc1t0aGlzLmNvbmZpZy50cmFja19pZF07XHJcbiAgICB0cmFjay5hZGRFeHRyYUNvbnRyb2xzKHRoaXMpO1xyXG5cclxuICBcclxuXHJcbiAgIGxldCBwID0gdGhpcy5kaXYucGFyZW50KCk7XHJcblxyXG4gICAgfSAgICAgICBcclxufVxyXG5cclxuY2xhc3MgQWRkVHJhY2tEaWFsb2d7XHJcblx0Y29uc3RydWN0b3IoY2FsbGJhY2ssY29uZmlnKXtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0Y29uZmlnPXt9O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gJChcIjxkaXY+XCIpLmF0dHIoXCJjbGFzc1wiLFwiYWRkLXRyYWNrLWRpYWxvZ1wiKTtcclxuICAgICAgICB0aGlzLmlkPU1MVlRyYWNrRGlhbG9nLmlkKys7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjaz1jYWxsYmFja1xyXG4gICAgICAgIGxldCBzZWxmPXRoaXM7XHJcbiAgICAgICAgdGhpcy5kaXYuZGlhbG9nKHtcclxuICAgICAgIFx0XHRhdXRvT3BlbjogdHJ1ZSxcclxuICAgICAgIFx0XHRidXR0b25zOlt7XHJcbiAgICAgICBcdFx0XHR0ZXh0OlwiQWRkXCIsXHJcbiAgICAgICBcdFx0XHRjbGljazpmdW5jdGlvbihlKXtcclxuICAgICAgIFx0XHRcdFx0c2VsZi5nZXRDb25maWcoKVxyXG4gICAgICAgXHRcdFx0XHQkKHRoaXMpLmRpYWxvZyhcImNsb3NlXCIpO1xyXG4gICAgICAgXHRcdFx0fVxyXG4gICAgICAgXHRcdH1dLFxyXG4gICAgICAgICAgICBjbG9zZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kaWFsb2coJ2Rlc3Ryb3knKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBcdHRpdGxlOiBcIkFkZCBUcmFja1wiLFxyXG4gICAgICAgIFx0d2lkdGg6MjUwXHJcbiAgICAgICBcclxuICAgICAgICB9KS5kaWFsb2dGaXgoKTtcclxuXHRcdFxyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICBcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDb25maWcoKXtcdFx0XHJcblx0XHRsZXQgdHlwZSA9ICQoXCJpbnB1dFtuYW1lPSdcIit0aGlzLnR5cGVfcmFkaW8rXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG5cdFx0bGV0IGNvbmZpZz0ge3VybDp0aGlzLnVybF9pbnB1dC52YWwoKSx0eXBlOnR5cGUsc2hvcnRfbGFiZWw6dGhpcy5uYW1lX2lucHV0LnZhbCgpfTtcclxuXHRcdHRoaXMuY2FsbGJhY2soY29uZmlnKTtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0aW5pdCgpe1xyXG5cdFx0bGV0IHNlbGY9dGhpcztcclxuXHRcdHRoaXMuZGl2LmFwcGVuZChcIjxsYWJlbD5QYXN0ZSBVUkw8L2xhYmVsPlwiKTtcclxuXHRcdHRoaXMudXJsX2lucHV0PSAkKFwiPHRleHRhcmVhPlwiKS5hcHBlbmRUbyh0aGlzLmRpdikuY3NzKHt3aWR0aDpcIjk1JVwifSk7XHJcblx0XHR0aGlzLnVybF9pbnB1dC5vbihcImJsdXIga2V5cHJlc3NcIixmdW5jdGlvbihlKXtcclxuXHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudC50eXBlPT09XCJrZXlwcmVzc1wiICYmICBlLmNoYXJDb2RlICE9PTEzKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5fZ2V0SW5mb0Zyb21VcmwoKCQodGhpcykudmFsKCkpKVxyXG5cdFx0XHJcblxyXG5cdFx0fSk7XHJcblx0XHR0aGlzLmRpdi5hcHBlbmQoJChcIjxsYWJlbD5OYW1lPC9sYWJlbD5cIikpO1xyXG5cdFx0dGhpcy5uYW1lX2lucHV0ID0gJChcIjxpbnB1dD5cIikuYXBwZW5kVG8odGhpcy5kaXYpO1xyXG5cdFx0dGhpcy5kaXYuYXBwZW5kKCQoXCI8bGFiZWw+VHlwZTwvbGFiZWw+XCIpKTtcclxuXHRcdGxldCByYWRpb19kaXY9JChcIjxkaXY+XCIpLmFwcGVuZFRvKHRoaXMuZGl2KTtcclxuXHRcdHRoaXMudHlwZV9yYWRpbz0gJ3RyYWNrLWFkZC1yYWRpby0nK3RoaXMuaWRcclxuXHRcdGZvciAobGV0IHR5cGUgaW4gTUxWVHJhY2sudHJhY2tfdHlwZXMpe1xyXG5cdFx0XHRpZiAodGhpcy5jb25maWcuYWxsb3dlZF90cmFja190eXBlcyAmJiB0aGlzLmNvbmZpZy5hbGxvd2VkX3RyYWNrX3R5cGVzLmluZGV4T2YodHlwZSk9PT0tMSl7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5hZGRSYWRpb0J1dHRvbihyYWRpb19kaXYsdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QWRkRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmNhbGxiYWNrPWNhbGxiYWNrO1xyXG5cdH1cclxuXHJcblx0X2dldEluZm9Gcm9tVXJsKHVybCl7XHJcblx0XHRsZXQgdHlwZSA9IE1MVlRyYWNrLmdldFR5cGVGcm9tVVJMKHVybCkudHlwZVxyXG5cdFx0bGV0IG5hbWUgPSBNTFZUcmFjay5jYWxjdWxhdGVMYWJlbCh1cmwpO1xyXG5cdFx0aWYgKHVybC5pbmNsdWRlcyhcImhnVHJhY2tzXCIpKXtcclxuXHRcdFx0bmFtZSA9IFwiVUNTQyBTZXNzaW9uXCI7XHJcblx0XHRcdHR5cGU9IFwidWNzY190cmFja1wiXHJcblx0XHR9XHJcblx0XHR0aGlzLm5hbWVfaW5wdXQudmFsKG5hbWUpO1xyXG5cdFx0JChcIltuYW1lPSdcIit0aGlzLnR5cGVfcmFkaW8rXCInXVwiKS52YWwoW3R5cGVdKTtcclxuXHJcblx0fVxyXG5cclxuXHRhZGRSYWRpb0J1dHRvbihkaXYsIHR5cGUpe1xyXG5cdFx0bGV0IHNwID0kKFwiPHNwYW4+XCIpLmNzcyh7XCJkaXNwbGF5XCI6XCJpbmxpbmUtYmxvY2tcIixcIm1hcmdpbi1yaWdodFwiOlwiM3B4XCJ9KTtcclxuXHRcdHNwLmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTp0eXBlLG5hbWU6dGhpcy50eXBlX3JhZGlvfSkpO1xyXG5cdFx0c3AuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChNTFZUcmFjay50cmFja190eXBlc1t0eXBlXS5uYW1lKSk7XHJcblx0XHRkaXYuYXBwZW5kKHNwKTtcclxuXHJcblx0fVxyXG5cclxuXHRcclxuXHJcblxyXG59XHJcblxyXG5cclxuTUxWVHJhY2tEaWFsb2cuaWQ9MDtcclxuXHJcbmV4cG9ydCB7TUxWVHJhY2tEaWFsb2csQWRkVHJhY2tEaWFsb2d9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE3RkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQThGQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOzs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/track_dialog.js\n");

/***/ }),

/***/ "../MLVPanel/src/tracks.js":
/*!****************************!*\
  !*** .Panel/src/tracks.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Graphics = exports.MLVBigBedTrack = exports.RulerTrack = exports.MLVBedTrack = exports.MLVWigTrack = exports.MLVTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (MIT)\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2014 Broad Institute\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * of this software and associated documentation files (the \"Software\"), to deal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * in the Software without restriction, including without limitation the rights\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the Software is\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * furnished to do so, subject to the following conditions:\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be included in\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * all copies or substantial portions of the Software.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE.\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _bigwig = __webpack_require__(/*! ./bigwig.js */ \"../MLVPanel/src/bigwig.js\");\n\nvar _feature = __webpack_require__(/*! ./feature.js */ \"../MLVPanel/src/feature.js\");\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MLVTrack = function () {\n  function MLVTrack(config) {\n    _classCallCheck(this, MLVTrack);\n\n    this.config = config;\n  }\n\n  _createClass(MLVTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      //overriden by tracks with feature sources\n    }\n  }, {\n    key: \"drawScale\",\n    value: function drawScale(ctx) {\n      //overidden in tracks with scale\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return $.extend(true, {}, this.config);\n    }\n  }, {\n    key: \"setConfigAttribute\",\n    value: function setConfigAttribute(attribute, value) {\n      this.config[attribute] = value;\n      if (attribute === \"url\") {\n        this._setFeatureSource();\n      }\n    }\n  }, {\n    key: \"getFeatureAt\",\n    value: function getFeatureAt(genomicLocation, chr, yOffset, bpPerPixel) {\n      return null;\n    }\n  }, {\n    key: \"setConfig\",\n    value: function setConfig(config) {\n      if (this.config.url !== config.url) {\n        this.config = config;\n        this._setFeatureSource();\n      } else {\n        this._setFeatureSource();\n      }\n    }\n\n    /**\r\n    * Reteives the features requested, the default is just to get the features\r\n    * from the feature source \r\n    * @param {string} chr - The chromosome \r\n    * @param {integer} start - The start of the range from which to obtain features\r\n    * @param {integer} end - The end of the range from which to obtain features \r\n    * @param {boolean} force - If true then cached features should not be used\r\n    * but fresh features retrieved\r\n    * @param {Object} data - contains bp  ber pixel and width of the canvas \r\n    */\n\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n      return this.feature_source.getFeatures(chr, bpStart, bpEnd, force, data);\n    }\n  }, {\n    key: \"addExtraControls\",\n    value: function addExtraControls(div, panel) {}\n  }], [{\n    key: \"calculateLabel\",\n    value: function calculateLabel(url) {\n      if (typeof url !== \"string\") {\n        url = url[0];\n      }\n      var arr = url.split(\"/\");\n      var label = arr[arr.length - 1];\n      arr = label.split(\".\");\n      label = arr[0];\n      return label;\n    }\n  }, {\n    key: \"getTypeFromURL\",\n    value: function getTypeFromURL(url) {\n      var config = {};\n      if (typeof url !== \"string\") {\n        return config;\n      }\n      if (url.endsWith(\"bw\")) {\n        config.type = \"bigwig\";\n        config.format = \"wig\";\n      } else if (url.endsWith(\".bed.gz\")) {\n        config.type = \"bed\";\n        config.format = \"feature\";\n      } else if (url.endsWith(\".bb\") && !config.type) {\n        config.type = \"bigbed\";\n        config.format = \"feature\";\n      } else if (url.endsWith(\".fasta\")) {\n        config.type = \"fasta\";\n        config.format = \"sequence\";\n      } else if (url.endsWith(\".bam\")) {\n        config.type = \"bam\";\n        config.format = \"alignment\";\n      }\n      return config;\n    }\n  }, {\n    key: \"parseConfig\",\n    value: function parseConfig(con) {\n      var config = $.extend(true, {}, con);\n\n      if (!config.type && config.url) {\n        var info = MLVTrack.getTypeFromURL(config.url);\n        if (info.type) {\n          config.type = info.type;\n          config.format = info.format;\n        }\n      }\n      if (config.type === \"bed\" || config.type === \"bigbed\") {\n        config.format = \"feature\";\n      }\n      if (!config.short_label && config.url) {\n        config.short_label = MLVTrack.calculateLabel(config.url);\n      }\n\n      if (!config.track_id) {\n        config.track_id = config.url;\n      }\n\n      if (config.format === \"feature\") {\n        config.displayMode = config.displayMode || \"COLLAPSED\"; // COLLAPSED | EXPANDED | SQUISHED\n        config.labelDisplayMode = \"SLANT\";\n        config.squishedCallHeight = config.squishedCallHeight || 30;\n        config.expandedCallHeight = config.expandedCallHeight || 15;\n        config.featureHeight = config.featureHeight || 12;\n      }\n\n      if (config.format === \"wig\" || config.type === \"bigwig\") {\n        if (!config.scale) {\n          config.scale = \"dynamic\";\n        }\n        if (!config.min_y) {\n          config.min_y = 0;\n        }\n        if (!config.max_y) {\n          config.max_y = 100;\n        }\n        if (!config.height) {\n          config.height = 100;\n        }\n      }\n      if (config.type === \"bam\") {\n        if (!config.featureHeight) {\n          config.featureHeight = 12;\n        }\n      }\n      if (!config.height) {\n        config.height = 100;\n      }\n\n      if (!config.color) {\n        if (config.type === \"bam\") {\n          config.color = \"#D3D3D3\";\n        } else {\n          config.color = \"black\";\n        }\n      }\n      if (!config.opacity) {\n        config.opacity = 1.0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"getTrack\",\n    value: function getTrack(config) {\n      config = MLVTrack.parseConfig(config);\n      var cl = MLVTrack.track_types[config.type];\n      if (!cl) {\n        throw new Error(\"Track type \" + config.type + \" not recognised\");\n      }\n      return new cl[\"class\"](config);\n    }\n  }]);\n\n  return MLVTrack;\n}();\n\nMLVTrack.custom_tracks = {};\n\nMLVTrack.track_types = {};\n\n//*******************js/rulerTrack.js**********************\n\n\nvar RulerTrack = function (_MLVTrack) {\n  _inherits(RulerTrack, _MLVTrack);\n\n  function RulerTrack(config) {\n    _classCallCheck(this, RulerTrack);\n\n    if (!config) {\n      config = { \"track_id\": \"ruler\" + RulerTrack.count, format: \"ruler\", short_label: \"Ruler\", type: \"ruler\" };\n    }\n\n    var _this = _possibleConstructorReturn(this, (RulerTrack.__proto__ || Object.getPrototypeOf(RulerTrack)).call(this, config));\n\n    _this.height = 30;\n    _this.config.height = 30;\n    _this.name = \"\";\n\n    _this.disableButtons = true;\n    _this.ignoreTrackMenu = true;\n    _this.order = -Number.MAX_VALUE;\n\n    RulerTrack.count++;\n    return _this;\n  }\n\n  _createClass(RulerTrack, [{\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd) {\n\n      return new Promise(function (fulfill, reject) {\n        fulfill([]);\n      });\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n\n      var fontStyle,\n          ctx = options.context,\n          range,\n          ts,\n          spacing,\n          nTick,\n          x;\n\n      fontStyle = { textAlign: 'center', font: '10px PT Sans', fillStyle: \"rgba(64, 64, 64, 1)\", strokeStyle: \"rgba(64, 64, 64, 1)\" };\n\n      range = Math.floor(1100 * options.bpPerPixel);\n      ts = RulerTrack.findSpacing(range);\n      spacing = ts.majorTick;\n\n      // Find starting point closest to the current origin\n      nTick = Math.floor(options.bpStart / spacing) - 1;\n      x = 0;\n      var y_pos = options.top + this.height;\n      //canvas.setProperties({textAlign: 'center'});\n      Graphics.setProperties(ctx, fontStyle);\n      while (x < options.pixelWidth) {\n\n        var l = Math.floor(nTick * spacing),\n            shim = 2;\n\n        x = Math.round((l - 1 - options.bpStart + 0.5) / options.bpPerPixel);\n        var chrPosition = formatNumber(l / ts.unitMultiplier, 0) + \" \" + ts.majorUnit;\n\n        if (nTick % 1 == 0) {\n          Graphics.fillText(ctx, chrPosition, x, y_pos - 15);\n        }\n\n        Graphics.strokeLine(ctx, x, y_pos - 10, x, y_pos - shim);\n\n        nTick++;\n      }\n      Graphics.strokeLine(ctx, 0, y_pos - shim, options.pixelWidth, y_pos - shim);\n\n      function formatNumber(anynum, decimal) {\n        //decimal  - the number of decimals after the digit from 0 to 3\n        //-- Returns the passed number as a string in the xxx,xxx.xx format.\n        //anynum = eval(obj.value);\n        var divider = 10;\n        switch (decimal) {\n          case 0:\n            divider = 1;\n            break;\n          case 1:\n            divider = 10;\n            break;\n          case 2:\n            divider = 100;\n            break;\n          default:\n            //for 3 decimal places\n            divider = 1000;\n        }\n\n        var workNum = Math.abs(Math.round(anynum * divider) / divider);\n\n        var workStr = \"\" + workNum;\n\n        if (workStr.indexOf(\".\") == -1) {\n          workStr += \".\";\n        }\n\n        var dStr = workStr.substr(0, workStr.indexOf(\".\"));\n        var dNum = dStr - 0;\n        var pStr = workStr.substr(workStr.indexOf(\".\"));\n\n        while (pStr.length - 1 < decimal) {\n          pStr += \"0\";\n        }\n\n        if (pStr == '.') pStr = '';\n\n        //--- Adds a comma in the thousands place.\n        if (dNum >= 1000) {\n          var dLen = dStr.length;\n          dStr = parseInt(\"\" + dNum / 1000) + \",\" + dStr.substring(dLen - 3, dLen);\n        }\n\n        //-- Adds a comma in the millions place.\n        if (dNum >= 1000000) {\n          dLen = dStr.length;\n          dStr = parseInt(\"\" + dNum / 1000000) + \",\" + dStr.substring(dLen - 7, dLen);\n        }\n        var retval = dStr + pStr;\n        //-- Put numbers in parentheses if negative.\n        if (anynum < 0) {\n          retval = \"(\" + retval + \")\";\n        }\n\n        //You could include a dollar sign in the return value.\n        //retval =  \"$\"+retval\n        return retval;\n      }\n      return y_pos;\n    }\n  }], [{\n    key: \"findSpacing\",\n    value: function findSpacing(maxValue) {\n\n      if (maxValue < 10) {\n        return new TickSpacing(1, \"\", 1);\n      }\n\n      // Now man zeroes?\n      var nZeroes = Math.floor(log10(maxValue));\n      var majorUnit = \"\";\n      var unitMultiplier = 1;\n      if (nZeroes > 9) {\n        majorUnit = \"gb\";\n        unitMultiplier = 1000000000;\n      }\n      if (nZeroes > 6) {\n        majorUnit = \"mb\";\n        unitMultiplier = 1000000;\n      } else if (nZeroes > 3) {\n        majorUnit = \"kb\";\n        unitMultiplier = 1000;\n      }\n\n      var nMajorTicks = maxValue / Math.pow(10, nZeroes - 1);\n      if (nMajorTicks < 25) {\n        return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);\n      } else {\n        return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);\n      }\n\n      function log10(x) {\n        var dn = Math.log(10);\n        return Math.log(x) / dn;\n      }\n    }\n  }]);\n\n  return RulerTrack;\n}(MLVTrack);\n\nRulerTrack.count = 0;\n\nMLVTrack.track_types[\"ruler\"] = {\n  \"class\": RulerTrack,\n  name: \"Ruler\"\n\n};\n\nvar TickSpacing = function TickSpacing(majorTick, majorUnit, unitMultiplier) {\n  _classCallCheck(this, TickSpacing);\n\n  this.majorTick = majorTick;\n  this.majorUnit = majorUnit;\n  this.unitMultiplier = unitMultiplier;\n};\n\nvar MLVBedTrack = function (_MLVTrack2) {\n  _inherits(MLVBedTrack, _MLVTrack2);\n\n  function MLVBedTrack(config) {\n    _classCallCheck(this, MLVBedTrack);\n\n    var _this2 = _possibleConstructorReturn(this, (MLVBedTrack.__proto__ || Object.getPrototypeOf(MLVBedTrack)).call(this, config));\n\n    _this2._setFeatureSource();\n    _this2.filter_function = null;\n    _this2.color_function = null;\n\n    return _this2;\n  }\n\n  _createClass(MLVBedTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _feature.TabixBedFeatureSource(this.config);\n    }\n  }, {\n    key: \"setFilterFunction\",\n    value: function setFilterFunction(func) {\n      this.filter_function = func;\n    }\n  }, {\n    key: \"setColorFunction\",\n    value: function setColorFunction(func) {\n      this.color_function = func;\n    }\n  }, {\n    key: \"getCurrentFeatures\",\n    value: function getCurrentFeatures(chr, start, end) {\n      return this.feature_source.featureCache.queryFeatures(chr, start, end);\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n      var max_y_val = 0;\n      var track = this,\n          py,\n          featureList = options.features,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          pixelHeight = options.pixelHeight,\n          offset = 0,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1;\n      var top = 0;\n      if (options.top) {\n        top = options.top;\n      }\n      this.top = top;\n      var conf = this.config;\n      var windowX = 0;\n      var windowX1 = windowX + pixelWidth;\n\n      this.config.squishedCallHeight = this.config.featureHeight + 10;\n      this.config.expandedCallHeight = this.config.featureHeight / 2 + 2;\n      var ki = null;\n      if (featureList.length > 50000) {\n        ki = Math.round(featureList.length / 50000) + 1;\n      }\n\n      if (featureList) {\n        var opacity = this.config.opacity ? this.config.opacity : 1;\n        ctx.globalAlpha = opacity;\n\n        for (var gene, i = 0, len = featureList.length; i < len; i++) {\n          if (ki && i % ki !== 0) {\n            continue;\n          }\n          gene = featureList[i];\n          if (this.filter_function && !this.filter_function(gene)) {\n            gene.display = false;\n            continue;\n          }\n          gene.display = true;\n          if (gene.end < bpStart) continue;\n          if (gene.start > bpEnd) break;\n          var coord = this.calculateFeatureCoordinates(gene, bpStart, bpPerPixel);\n          var h = conf.featureHeight;\n          if (conf.displayMode === \"SQUISHED\" && gene.row != undefined) {\n            h = conf.featureHeight / 2;\n            py = conf.expandedCallHeight * gene.row + 2;\n          } else if (conf.displayMode === \"EXPANDED\" && gene.row != undefined) {\n            py = conf.squishedCallHeight * gene.row + 5;\n          } else {\n            // collapsed\n            py = 5;\n          }\n          py += top;\n          if (py + h > max_y_val) {\n            max_y_val = py + h;\n          }\n          coord.py = py;\n          coord.h = h;\n          var info = { bpPerPixel: bpPerPixel, bpStart: bpStart, pixelWidth: pixelWidth };\n          if (this.color_function) {\n            gene.color = this.color_function(gene);\n          }\n\n          this.renderFeature(gene, coord, ctx, info);\n          this.renderFeatureLabel(ctx, gene, coord.px, coord.px1, py, windowX, windowX1);\n        }\n        ctx.globalAlpha = 1;\n      } else {\n        console.log(\"No feature list\");\n      }\n      this.bottom = max_y_val;\n      if (this.config.displayMode === \"COLLAPSED\") {\n        max_y_val += 25;\n      }\n      return max_y_val;\n    }\n\n    /**\r\n       * @param ctx       the canvas 2d context\r\n       * @param feature\r\n       * @param featureX  feature start x-coordinate\r\n       * @param featureX1 feature end x-coordinate\r\n       * @param featureY  feature y-coordinate\r\n       * @param windowX   visible window start x-coordinate\r\n       * @param windowX1  visible window end x-coordinate\r\n       */\n\n  }, {\n    key: \"renderFeatureLabel\",\n    value: function renderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1) {\n      var info = this.config;\n      var geneColor, geneFontStyle, transform, boxX, boxX1, // label should be centered between these two x-coordinates\n      labelX, labelY, textFitsInBox;\n\n      // feature outside of viewable window\n      if (featureX1 < windowX || featureX > windowX1) {\n        boxX = featureX;\n        boxX1 = featureX1;\n      } else {\n        // center label within visible portion of the feature\n        boxX = Math.max(featureX, windowX);\n        boxX1 = Math.min(featureX1, windowX1);\n      }\n\n      var text = feature.name;\n      if (this.label_function) {\n        text = this.label_function(feature);\n      }\n\n      //if (igv.browser.selection && \"genes\" === this.config.type && feature.name !== undefined) {\n      // TODO -- for gtex, figure out a better way to do this\n      //geneColor = igv.browser.selection.colorForGene(feature.name);\n      //  }\n\n      textFitsInBox = boxX1 - boxX > ctx.measureText(text).width;\n      //geneColor=\"black\";\n\n      if ((textFitsInBox || geneColor) && info.displayMode != \"SQUISHED\" && text) {\n        geneFontStyle = {\n          font: '10px PT Sans',\n          textAlign: 'center',\n          fillStyle: geneColor || info.color,\n          strokeStyle: geneColor || info.color\n        };\n\n        if (info.displayMode === \"COLLAPSED\" && info.labelDisplayMode === \"SLANT\") {\n          transform = { rotate: { angle: 45 } };\n          delete geneFontStyle.textAlign;\n        }\n\n        labelX = boxX + (boxX1 - boxX) / 2;\n        labelY = getFeatureLabelY(featureY, transform);\n\n        Graphics.fillText(ctx, text, labelX, labelY, geneFontStyle, transform);\n      }\n      function getFeatureLabelY(featureY, transform) {\n        return transform ? featureY + info.featureHeight + 14 : featureY + info.featureHeight + 7;\n      }\n    }\n  }, {\n    key: \"calculateFeatureCoordinates\",\n    value: function calculateFeatureCoordinates(feature, bpStart, xScale) {\n      var px = Math.round((feature.start - bpStart) / xScale),\n          px1 = Math.round((feature.end - bpStart) / xScale),\n          pw = px1 - px;\n\n      if (pw < 3) {\n        pw = 3;\n        px -= 1;\n      }\n\n      return {\n        px: px,\n        px1: px1,\n        pw: pw\n      };\n    }\n\n    /**\r\n        * Renders the feature to the canvas\r\n        * @param feature - The feature itself\r\n        * @param coord An object containing information on where to draw the feature\r\n        * px1,px2 the left and right pixels - pw - the width\r\n        * py the top, h - the height\r\n        * @param ctx - The context to draw the feature\r\n        * @param info - An object containing information about the genomic location\r\n        * bpStart.bpPerPixel and pixelWidth\r\n        * \r\n        */\n\n  }, {\n    key: \"renderFeature\",\n    value: function renderFeature(feature, coord, ctx, info) {\n      var e,\n          x,\n          cy,\n          direction,\n          exon,\n          ePx,\n          ePx1,\n          ePxU,\n          ePw,\n          py2,\n          h2,\n          step = 20,\n          color = this.config.color;\n      if (feature.color) {\n        color = feature.color;\n      }\n\n      ctx.fillStyle = color;\n      ctx.strokeStyle = color;\n\n      cy = coord.py + coord.h / 2;\n      h2 = coord.h / 2;\n      py2 = cy - h2 / 2;\n\n      var exonCount = feature.exons ? feature.exons.length : 0;\n      if (exonCount == 0) {\n        // single-exon transcript\n        ctx.fillRect(coord.px, coord.py, coord.pw, coord.h);\n      } else {\n        // multi-exon transcript\n        coord.px = Math.max(coord.px, 0);\n        coord.px1 = Math.min(coord.px1, info.pixelWidth);\n        Graphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns\n        direction = feature.strand == '+' ? 1 : -1;\n\n        for (x = coord.px + step / 2; x < coord.px1; x += step) {\n\n          // draw arrowheads along central line indicating transcribed orientation\n          Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n          Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n        }\n        for (e = 0; e < exonCount; e++) {\n          // draw the exons\n          exon = feature.exons[e];\n          ePx = Math.round((exon.start - info.bpStart) / info.bpPerPixel);\n          ePx1 = Math.round((exon.end - info.bpStart) / info.bpPerPixel);\n          ePw = Math.max(1, ePx1 - ePx);\n\n          if (exon.utr) {\n            ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR\n          } else {\n            if (exon.cdStart) {\n              ePxU = Math.round((exon.cdStart - info.bpStart) / info.bpPerPixel);\n              ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR\n              ePw -= ePxU - ePx;\n              ePx = ePxU;\n            }\n            if (exon.cdEnd) {\n              ePxU = Math.round((exon.cdEnd - info.bpStart) / info.bpPerPixel);\n              ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR\n              ePw -= ePx1 - ePxU;\n              ePx1 = ePxU;\n            }\n\n            ctx.fillRect(ePx, coord.py, ePw, coord.h);\n\n            // Arrows\n            if (ePw > step + 5) {\n              ctx.fillStyle = \"white\";\n              ctx.strokeStyle = \"white\";\n              for (x = ePx + step / 2; x < ePx1; x += step) {\n                // draw arrowheads along central line indicating transcribed orientation\n                Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\n                Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\n              }\n              ctx.fillStyle = color;\n              ctx.strokeStyle = color;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getFeatureAt\",\n    value: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\n      var yOffset = coord.y - this.top;\n      // We use the featureCache property rather than method to avoid async load.  If the\n      // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.\n      if (this.feature_source.featureCache) {\n\n        var tolerance = 2 * bpPerPixel,\n            // We need some tolerance around genomicLocation, start with +/- 2 pixels\n        featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance),\n            row;\n\n        if (this.config.displayMode != \"COLLAPSED\") {\n          row = Math.floor(this.config.displayMode === \"SQUISHED\" ? yOffset / this.config.expandedCallHeight : yOffset / this.config.squishedCallHeight);\n        }\n\n        if (featureList && featureList.length > 0) {\n\n          var popupData = [];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var feature = _step.value;\n\n              if (feature.end >= genomicLocation - tolerance && feature.start <= genomicLocation + tolerance) {\n\n                // If row number is specified use it\n                if ((row === undefined || feature.row === undefined || row === feature.row) && feature.display) {\n                  return feature;\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return MLVBedTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"bed\"] = {\n  \"class\": MLVBedTrack,\n  name: \"bed(tabix)\"\n};\n\nvar MLVBigBedTrack = function (_MLVBedTrack) {\n  _inherits(MLVBigBedTrack, _MLVBedTrack);\n\n  function MLVBigBedTrack(config) {\n    _classCallCheck(this, MLVBigBedTrack);\n\n    return _possibleConstructorReturn(this, (MLVBigBedTrack.__proto__ || Object.getPrototypeOf(MLVBigBedTrack)).call(this, config));\n  }\n\n  _createClass(MLVBigBedTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _feature.BigBedFeatureSource(this.config);\n    }\n  }]);\n\n  return MLVBigBedTrack;\n}(MLVBedTrack);\n\nMLVTrack.track_types[\"bigbed\"] = {\n  \"class\": MLVBigBedTrack,\n  \"name\": \"BigBed\"\n\n};\n\nvar MLVWigTrack = function (_MLVTrack3) {\n  _inherits(MLVWigTrack, _MLVTrack3);\n\n  function MLVWigTrack(config) {\n    _classCallCheck(this, MLVWigTrack);\n\n    config.format = \"wig\";\n\n    var _this4 = _possibleConstructorReturn(this, (MLVWigTrack.__proto__ || Object.getPrototypeOf(MLVWigTrack)).call(this, config));\n\n    _this4._setFeatureSource();\n    return _this4;\n  }\n\n  _createClass(MLVWigTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource() {\n      this.feature_source = new _bigwig.BWSource(this.config);\n    }\n  }, {\n    key: \"drawScale\",\n    value: function drawScale(pixel_height, ctx) {\n      if (this.config.scale_link_to && this.config.group) {\n        return;\n      }\n      var bot = pixel_height;\n      var top = 0;\n\n      if (this.config.discrete) {\n        top = this.top;\n        bot = this.bottom;\n      }\n      var range = this.max_y - this.min_y;\n\n      ctx.beginPath();\n      ctx.moveTo(0, top);\n      ctx.lineTo(0, bot);\n      ctx.moveTo(0, top);\n      ctx.lineTo(20, top);\n      ctx.moveTo(0, bot);\n      ctx.lineTo(20, bot);\n      ctx.font = \"12px Arial\";\n      ctx.stroke();\n      ctx.textBaseline = \"top\";\n      ctx.fillStyle = \"black\";\n      ctx.fillText(this.max_y.toFixed(2), 20, top);\n      ctx.textBaseline = \"alphabetic\";\n      ctx.fillText(this.min_y, 20, bot);\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n      var self = this,\n          features = options.features,\n          color = self.config.color,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          pixelHeight = options.pixelHeight,\n          y_offset = this.config.discrete ? options.top : 0,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n          featureValueMinimum = void 0,\n          featureValueMaximum = void 0,\n          featureValueRange = void 0,\n          $dataRangeTrackLabel = void 0,\n          str = void 0,\n          min = void 0,\n          max = void 0;\n      if (this.config.group) {\n        pixelHeight = options.height;\n      } else if (this.config.discrete) {\n        pixelHeight = this.config.height;\n      }\n\n      if (!color) {\n        color = \"black\";\n      }\n      self.prev_coords = { x: 0, y: 0 };\n\n      if (features) {\n        if (self.scale_link_to) {\n          var t = self.scale_link_to.config;\n          if (t) {\n            self.config.scale = t.scale;\n            self.max_y = self.scale_link_to.max_y;\n            self.min_y = self.scale_link_to.min_y;\n          }\n        } else if (self.set_scale) {\n          self.min_y = self.set_scale.min;\n          self.max_y = self.set_scale.max;\n        } else if (self.max_y === undefined && self.config.scale === \"automatic\" || self.config.scale === \"dynamic\") {\n          var s = autoscale(features);\n          self.min_y = s.min;\n          self.max_y = s.max;\n        } else if (self.config.scale === \"fixed\") {\n          self.min_y = self.config.min_y;\n          self.max_y = self.config.max_y;\n        }\n\n        featureValueRange = self.max_y - self.min_y;\n\n        //$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\n        //\n        //min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\n        //max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\n        //str = '[' + min + ' - ' + max + ']';\n        //\n        //$dataRangeTrackLabel.text(str);\n        var prev_x = 0;\n        var prev_y = 0;\n        ctx.globalAlpha = this.config.opacity ? this.config.opacity : 1;\n\n        if (self.is_line) {\n          var y = (1.0 - self.config.value / featureValueRange) * pixelHeight;\n          Graphics.strokeLine(ctx, 0, y, pixelWidth, y, { \"strokeStyle\": self.config.color, \"lineWidth\": self.config.width ? self.config.width : 1 });\n        } else {\n          features.forEach(renderFeature);\n        }\n\n        ctx.globalAlpha = 1;\n        if (self.config.threshold) {\n          var _y = y_offset + (1.0 - self.config.threshold / featureValueRange) * pixelHeight;\n          Graphics.strokeLine(ctx, 0, _y, pixelWidth, _y, { \"strokeStyle\": \"black\", \"lineWidth\": 1 });\n        }\n      }\n\n      function renderFeature(feature, index, featureList) {\n\n        var yUnitless, heightUnitLess, x, y, width, height, rectEnd, rectBaseline;\n\n        if (feature.end < bpStart) return;\n        if (feature.start > bpEnd) return;\n        if (feature.end === feature.start) {\n          feature.start -= 1;\n        }\n\n        x = Math.floor((feature.start - bpStart) / bpPerPixel);\n\n        rectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\n        width = Math.max(0, rectEnd - x);\n\n        //height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\n        //rectBaseline = pixelHeight - height;\n        //canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\n\n        if (signsDiffer(self.min_y, self.max_y)) {\n\n          if (feature.value < 0) {\n            yUnitless = self.max_y / featureValueRange;\n            heightUnitLess = -feature.value / featureValueRange;\n          } else {\n            yUnitless = (self.max_y - feature.value) / featureValueRange;\n            heightUnitLess = feature.value / featureValueRange;\n          }\n        } else if (self.min_y < 0) {\n          yUnitless = 0;\n          heightUnitLess = -feature.value / featureValueRange;\n        } else {\n          yUnitless = 1.0 - (feature.value - self.min_y) / featureValueRange;\n          heightUnitLess = (feature.value + self.min_y) / featureValueRange;\n        }\n\n        y = yUnitless * pixelHeight + y_offset;\n        y = y < y_offset ? y_offset : y;\n        height = heightUnitLess * pixelHeight;\n        height = height > pixelHeight ? pixelHeight : height;\n\n        //canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\n        if (self.config.display === 'line') {\n          if (self.prev_coords.x) {\n            Graphics.strokeLine(ctx, x, y, self.prev_coords.x, self.prev_coords.y, { \"strokeStyle\": color, \"lineWidth\": 3 });\n          }\n          self.prev_coords.x = x;\n          self.prev_coords.y = y;\n        } else {\n          Graphics.fillRect(ctx, x, y, width, height, { fillStyle: color });\n        }\n      }\n      function autoscale(features) {\n        var min = 0,\n            max = -Number.MAX_VALUE;\n        features.forEach(function (f) {\n          min = Math.min(min, f.value);\n          max = Math.max(max, f.value);\n        });\n        return { min: min, max: max };\n      }\n\n      function signsDiffer(a, b) {\n        return a > 0 && b < 0 || a < 0 && b > 0;\n      }\n      this.top = y_offset;\n      this.bottom = y_offset + pixelHeight;\n      if (this.config.discrete) {\n        return this.bottom;\n      } else {\n        this.top = 0;\n        this.bottom = 0;\n      }\n    }\n  }]);\n\n  return MLVWigTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"bigwig\"] = {\n  \"class\": MLVWigTrack,\n  name: \"BigWig\"\n};\n\nvar LineTrack = function (_MLVWigTrack) {\n  _inherits(LineTrack, _MLVWigTrack);\n\n  function LineTrack(config) {\n    _classCallCheck(this, LineTrack);\n\n    var _this5 = _possibleConstructorReturn(this, (LineTrack.__proto__ || Object.getPrototypeOf(LineTrack)).call(this, config));\n\n    _this5.is_line = true;\n    return _this5;\n  }\n\n  _createClass(LineTrack, [{\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd) {\n      return new Promise(function (fulfill, reject) {\n        fulfill([]);\n      });\n    }\n  }]);\n\n  return LineTrack;\n}(MLVWigTrack);\n\nMLVTrack.track_types[\"line\"] = {\n  \"class\": LineTrack,\n  name: \"Line Track\"\n};\n\nvar SequenceTrack = function (_MLVTrack4) {\n  _inherits(SequenceTrack, _MLVTrack4);\n\n  function SequenceTrack(config) {\n    _classCallCheck(this, SequenceTrack);\n\n    var _this6 = _possibleConstructorReturn(this, (SequenceTrack.__proto__ || Object.getPrototypeOf(SequenceTrack)).call(this, config));\n\n    _this6._setFeatureSource(config);\n    _this6.sequenceType = config.sequenceType || \"dna\";\n    _this6.height = 15;\n    return _this6;\n  }\n\n  _createClass(SequenceTrack, [{\n    key: \"_setFeatureSource\",\n    value: function _setFeatureSource(config) {\n      this.feature_source = new _feature.FastaSequence(config.url);\n    }\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(chr, bpStart, bpEnd, force, data) {\n      var self = this;\n      return new Promise(function (fulfill, reject) {\n        if (data.bpPerPixel > 1 /*igv.browser.trackViewportWidthBP() > 30000*/) {\n            fulfill(null);\n          } else {\n          self.feature_source.getSequence(chr, bpStart, bpEnd).then(fulfill).catch(reject);\n        }\n      });\n    }\n  }, {\n    key: \"drawFeatures\",\n    value: function drawFeatures(options) {\n\n      var sequence = options.features,\n          ctx = options.context,\n          bpPerPixel = options.bpPerPixel,\n          bpStart = options.bpStart,\n          pixelWidth = options.pixelWidth,\n          bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n          len,\n          w,\n          y,\n          pos,\n          offset,\n          b,\n          p0,\n          p1,\n          pc,\n          c;\n\n      var y_pos1 = options.top;\n      var y_pos2 = y_pos1 + 5;\n\n      if (sequence) {\n\n        len = sequence.length;\n        w = 1 / bpPerPixel;\n\n        y = y_pos1 + this.height / 2;\n        for (pos = bpStart; pos <= bpEnd; pos++) {\n\n          offset = pos - bpStart;\n          if (offset < len) {\n            //                            var b = sequence.charAt(offset);\n            b = sequence[offset];\n            p0 = Math.floor(offset * w);\n            p1 = Math.floor((offset + 1) * w);\n            pc = Math.round((p0 + p1) / 2);\n\n            if (this.color) {\n              c = this.color;\n            } else if (\"dna\" === this.sequenceType) {\n              c = Graphics.nucleotideColors[b];\n            } else {\n              c = \"rgb(0, 0, 150)\";\n            }\n\n            if (!c) c = \"gray\";\n\n            if (bpPerPixel > 0.15) {\n\n              Graphics.fillRect(ctx, p0, y_pos1, p1 - p0, 10, { fillStyle: c });\n            } else {\n\n              Graphics.strokeText(ctx, b, pc, y, {\n                strokeStyle: c,\n                font: 'normal 10px Arial',\n                textAlign: 'center'\n              });\n            }\n          }\n        }\n      }\n      return y_pos1 + 10;\n    }\n  }]);\n\n  return SequenceTrack;\n}(MLVTrack);\n\nMLVTrack.track_types[\"fasta\"] = {\n  \"class\": SequenceTrack,\n  name: \"Fasta\"\n\n  //*******js/ifv-canvas.js***********************\n\n\n};\nvar Graphics = function () {\n  function Graphics() {\n    _classCallCheck(this, Graphics);\n  }\n\n  _createClass(Graphics, null, [{\n    key: \"setProperties\",\n    value: function setProperties(ctx, properties) {\n\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          var value = properties[key];\n          ctx[key] = value;\n        }\n      }\n    }\n  }, {\n    key: \"strokeLine\",\n    value: function strokeLine(ctx, x1, y1, x2, y2, properties) {\n\n      x1 = Math.floor(x1) + 0.5;\n      y1 = Math.floor(y1) + 0.5;\n      x2 = Math.floor(x2) + 0.5;\n      y2 = Math.floor(y2) + 0.5;\n\n      //log(\"stroke line, prop: \" + properties);\n\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"fillRect\",\n    value: function fillRect(ctx, x, y, w, h, properties) {\n\n      var c;\n      x = Math.round(x);\n      y = Math.round(y);\n\n      if (properties) {\n        ctx.save();\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.fillRect(x, y, w, h);\n\n      if (properties) ctx.restore();\n    }\n  }, {\n    key: \"fillPolygon\",\n    value: function fillPolygon(ctx, x, y, properties) {\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n      Graphics.doPath(ctx, x, y);\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: \"strokePolygon\",\n    value: function strokePolygon(ctx, x, y, properties) {\n      ctx.save();\n      if (properties) Graphics.setProperties(ctx, properties);\n      Graphics.doPath(ctx, x, y);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"fillText\",\n    value: function fillText(ctx, text, x, y, properties, transforms) {\n\n      if (properties) {\n        ctx.save();\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.save();\n\n      ctx.translate(x, y);\n      if (transforms) {\n\n        for (var transform in transforms) {\n          var value = transforms[transform];\n\n          // TODO: Add error checking for robustness\n          if (transform == 'translate') {\n            ctx.translate(value['x'], value['y']);\n          }\n          if (transform == 'rotate') {\n            ctx.rotate(value['angle'] * Math.PI / 180);\n          }\n        }\n      }\n\n      ctx.fillText(text, 0, 0);\n      ctx.restore();\n\n      if (properties) ctx.restore();\n    }\n  }, {\n    key: \"strokeText\",\n    value: function strokeText(ctx, text, x, y, properties, transforms) {\n\n      ctx.save();\n      if (properties) {\n        Graphics.setProperties(ctx, properties);\n      }\n\n      ctx.translate(x, y);\n      if (transforms) {\n\n        for (var transform in transforms) {\n          var value = transforms[transform];\n\n          // TODO: Add error checking for robustness\n          if (transform == 'translate') {\n            ctx.translate(value['x'], value['y']);\n          }\n          if (transform == 'rotate') {\n            ctx.rotate(value['angle'] * Math.PI / 180);\n          }\n        }\n      }\n\n      ctx.strokeText(text, 0, 0);\n      ctx.restore();\n    }\n  }, {\n    key: \"strokeCircle\",\n    value: function strokeCircle(ctx, x, y, radius) {\n\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }, {\n    key: \"fillCircle\",\n    value: function fillCircle(ctx, x, y, radius) {\n\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }, {\n    key: \"drawArrowhead\",\n    value: function drawArrowhead(ctx, x, y, size, lineWidth) {\n\n      ctx.save();\n      if (!size) {\n        size = 5;\n      }\n      if (lineWidth) {\n        ctx.lineWidth = lineWidth;\n      }\n      ctx.beginPath();\n      ctx.moveTo(x, y - size / 2);\n      ctx.lineTo(x, y + size / 2);\n      ctx.lineTo(x + size, y);\n      ctx.lineTo(x, y - size / 2);\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n    }\n  }, {\n    key: \"dashedLine\",\n    value: function dashedLine(ctx, x1, y1, x2, y2, dashLen, properties) {\n      ctx.save();\n      x1 = Math.round(x1);\n      y1 = Math.round(y1);\n      x2 = Math.round(x2);\n      y2 = Math.round(y2);\n      dashLen = Math.round(dashLen);\n      log(\"dashedLine\");\n      if (properties) Graphics.setProperties(ctx, properties);\n\n      if (dashLen == undefined) dashLen = 2;\n      ctx.moveTo(x1, y1);\n\n      var dX = x2 - x1;\n      var dY = y2 - y1;\n      var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n      var dashX = dX / dashes;\n      var dashY = dY / dashes;\n\n      var q = 0;\n      while (q++ < dashes) {\n        x1 += dashX;\n        y1 += dashY;\n        ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\n      }\n      ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\n\n      ctx.restore();\n    }\n  }, {\n    key: \"doPath\",\n    value: function doPath(ctx, x, y) {\n\n      var i,\n          len = x.length;\n      for (i = 0; i < len; i++) {\n        x[i] = Math.round(x[i]);\n        y[i] = Math.round(y[i]);\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(x[0], y[0]);\n      for (i = 1; i < len; i++) {\n        ctx.lineTo(x[i], y[i]);\n      }\n      ctx.closePath();\n    }\n  }]);\n\n  return Graphics;\n}();\n\nGraphics.nucleotideColors = {\n  \"A\": \"green\",\n  \"T\": \"red\",\n  \"G\": \"black\",\n  \"C\": \"blue\",\n  \"a\": \"green\",\n  \"t\": \"red\",\n  \"c\": \"black\",\n  \"g\": \"blue\"\n\n};\n\nexports.MLVTrack = MLVTrack;\nexports.MLVWigTrack = MLVWigTrack;\nexports.MLVBedTrack = MLVBedTrack;\nexports.RulerTrack = RulerTrack;\nexports.MLVBigBedTrack = MLVBigBedTrack;\nexports.Graphics = Graphics;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3RyYWNrcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzPzc2NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbmltcG9ydCB7QldTb3VyY2V9IGZyb20gXCIuL2JpZ3dpZy5qc1wiO1xyXG5pbXBvcnQge0ZlYXR1cmVTb3VyY2UsRmFzdGFTZXF1ZW5jZSxCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4vZmVhdHVyZS5qc1wiO1xyXG5cclxuXHJcbmNsYXNzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcblx0fVxyXG5cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0Ly9vdmVycmlkZW4gYnkgdHJhY2tzIHdpdGggZmVhdHVyZSBzb3VyY2VzXHJcblx0fVxyXG5cclxuXHRkcmF3U2NhbGUoY3R4KXtcclxuXHRcdC8vb3ZlcmlkZGVuIGluIHRyYWNrcyB3aXRoIHNjYWxlXHJcblx0fVxyXG5cclxuXHRnZXRDb25maWcoKXtcclxuXHRcdHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcblx0c2V0Q29uZmlnQXR0cmlidXRlKGF0dHJpYnV0ZSx2YWx1ZSl7XHJcblx0XHR0aGlzLmNvbmZpZ1thdHRyaWJ1dGVdPXZhbHVlO1xyXG4gICAgXHRpZiAoYXR0cmlidXRlPT09XCJ1cmxcIil7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcbiAgICBnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIseU9mZnNldCwgYnBQZXJQaXhlbCl7XHJcbiAgICBcdHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbmZpZyhjb25maWcpe1xyXG4gICAgXHRpZiAodGhpcy5jb25maWcudXJsICE9PSBjb25maWcudXJsKXtcclxuICAgIFx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2V7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG4gICAgIC8qKlxyXG5cdCogUmV0ZWl2ZXMgdGhlIGZlYXR1cmVzIHJlcXVlc3RlZCwgdGhlIGRlZmF1bHQgaXMganVzdCB0byBnZXQgdGhlIGZlYXR1cmVzXHJcblx0KiBmcm9tIHRoZSBmZWF0dXJlIHNvdXJjZSBcclxuXHQqIEBwYXJhbSB7c3RyaW5nfSBjaHIgLSBUaGUgY2hyb21vc29tZSBcclxuXHQqIEBwYXJhbSB7aW50ZWdlcn0gc3RhcnQgLSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlIGZyb20gd2hpY2ggdG8gb2J0YWluIGZlYXR1cmVzXHJcblx0KiBAcGFyYW0ge2ludGVnZXJ9IGVuZCAtIFRoZSBlbmQgb2YgdGhlIHJhbmdlIGZyb20gd2hpY2ggdG8gb2J0YWluIGZlYXR1cmVzIFxyXG5cdCogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIElmIHRydWUgdGhlbiBjYWNoZWQgZmVhdHVyZXMgc2hvdWxkIG5vdCBiZSB1c2VkXHJcblx0KiBidXQgZnJlc2ggZmVhdHVyZXMgcmV0cmlldmVkXHJcblx0KiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGNvbnRhaW5zIGJwICBiZXIgcGl4ZWwgYW5kIHdpZHRoIG9mIHRoZSBjYW52YXMgXHJcblx0Ki9cclxuXHRnZXRGZWF0dXJlcyAoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5mZWF0dXJlX3NvdXJjZS5nZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmb3JjZSxkYXRhKTtcclxuXHR9XHJcblxyXG5cclxuXHRzdGF0aWMgY2FsY3VsYXRlTGFiZWwodXJsKXtcclxuXHRcdGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0dXJsID0gdXJsWzBdO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGFyciA9dXJsLnNwbGl0KFwiL1wiKTtcclxuXHRcdGxldCBsYWJlbD0gYXJyW2Fyci5sZW5ndGgtMV07XHJcblx0XHRhcnI9IGxhYmVsLnNwbGl0KFwiLlwiKTtcclxuXHRcdGxhYmVsID0gYXJyWzBdO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH1cclxuXHJcblx0YWRkRXh0cmFDb250cm9scyhkaXYscGFuZWwpe1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldFR5cGVGcm9tVVJMKHVybCl7XHJcblx0XHRsZXQgY29uZmlnPXt9XHJcblx0XHRpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIil7XHJcblx0XHRcdHJldHVybiBjb25maWc7XHJcblx0XHR9XHJcblx0XHRcdGlmICh1cmwuZW5kc1dpdGgoXCJid1wiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiaWd3aWdcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwid2lnXCI7XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodXJsLmVuZHNXaXRoKFwiLmJlZC5nelwiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiZWRcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iYlwiKSAmJiAhKGNvbmZpZy50eXBlKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJiaWdiZWRcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5mYXN0YVwiKSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9XCJmYXN0YVwiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJzZXF1ZW5jZVwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iYW1cIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmFtXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImFsaWdubWVudFwiO1xyXG5cdFx0XHR9XHJcblx0XHRyZXR1cm4gY29uZmlnO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBwYXJzZUNvbmZpZyhjb24pe1xyXG5cdFx0bGV0IGNvbmZpZyA9ICQuZXh0ZW5kKHRydWUsIHt9LGNvbik7XHJcblx0XHRcclxuXHRcdGlmICghKGNvbmZpZy50eXBlKSAmJiBjb25maWcudXJsKXtcclxuXHRcdFx0bGV0IGluZm8gPSBNTFZUcmFjay5nZXRUeXBlRnJvbVVSTChjb25maWcudXJsKTtcclxuXHRcdFx0aWYgKGluZm8udHlwZSl7XHJcblx0XHRcdFx0Y29uZmlnLnR5cGU9aW5mby50eXBlO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9aW5mby5mb3JtYXQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChjb25maWcudHlwZT09PVwiYmVkXCIgfHwgY29uZmlnLnR5cGU9PT1cImJpZ2JlZFwiKXtcclxuXHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuXHRcdH1cclxuXHRcdGlmICghY29uZmlnLnNob3J0X2xhYmVsICYmIGNvbmZpZy51cmwpe1xyXG5cdFx0XHRjb25maWcuc2hvcnRfbGFiZWw9TUxWVHJhY2suY2FsY3VsYXRlTGFiZWwoY29uZmlnLnVybCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmICghY29uZmlnLnRyYWNrX2lkKXtcclxuXHRcdFx0Y29uZmlnLnRyYWNrX2lkPWNvbmZpZy51cmw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5mb3JtYXQ9PT1cImZlYXR1cmVcIil7XHJcblx0XHRcdGNvbmZpZy5kaXNwbGF5TW9kZSA9IGNvbmZpZy5kaXNwbGF5TW9kZSB8fCBcIkNPTExBUFNFRFwiOyAgICAvLyBDT0xMQVBTRUQgfCBFWFBBTkRFRCB8IFNRVUlTSEVEXHJcbiAgICAgICAgXHRjb25maWcubGFiZWxEaXNwbGF5TW9kZSA9IFwiU0xBTlRcIjtcclxuICAgICAgICBcdGNvbmZpZy5zcXVpc2hlZENhbGxIZWlnaHQgPSBjb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0IHx8IDMwO1xyXG4gICAgICAgIFx0Y29uZmlnLmV4cGFuZGVkQ2FsbEhlaWdodCA9IGNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgfHwgMTU7XHJcbiAgICAgICAgXHRjb25maWcuZmVhdHVyZUhlaWdodD1jb25maWcuZmVhdHVyZUhlaWdodCB8fCAxMjtcclxuXHRcdFxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuZm9ybWF0PT09XCJ3aWdcIiB8fCBjb25maWcudHlwZT09PVwiYmlnd2lnXCIpe1xyXG5cdFx0XHRpZiAoIWNvbmZpZy5zY2FsZSl7XHJcblx0XHRcdFx0Y29uZmlnLnNjYWxlPVwiZHluYW1pY1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghY29uZmlnLm1pbl95KXtcclxuXHRcdFx0XHRjb25maWcubWluX3k9MDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5tYXhfeSl7XHJcblx0XHRcdFx0Y29uZmlnLm1heF95PTEwMDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5oZWlnaHQpe1xyXG5cdFx0XHRcdGNvbmZpZy5oZWlnaHQ9MTAwO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoY29uZmlnLnR5cGU9PT1cImJhbVwiKXtcclxuXHRcdFx0aWYgKCFjb25maWcuZmVhdHVyZUhlaWdodCl7XHJcblx0XHRcdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9MTI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICghY29uZmlnLmhlaWdodCl7XHJcblx0XHRcdGNvbmZpZy5oZWlnaHQ9MTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29uZmlnLmNvbG9yKXtcclxuXHRcdFx0aWYgKGNvbmZpZy50eXBlPT09XCJiYW1cIil7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiI0QzRDNEM1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiYmxhY2tcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFjb25maWcub3BhY2l0eSl7XHJcblx0XHRcdGNvbmZpZy5vcGFjaXR5PTEuMDtcclxuXHRcdH1cclxuICAgICAgICAgICBcclxuXHRcdHJldHVybiBjb25maWc7XHJcblx0fVxyXG5cclxuXHJcblx0XHJcblx0c3RhdGljIGdldFRyYWNrKGNvbmZpZyl7XHJcblx0XHRjb25maWc9TUxWVHJhY2sucGFyc2VDb25maWcoY29uZmlnKTtcclxuXHRcdGxldCBjbD0gTUxWVHJhY2sudHJhY2tfdHlwZXNbY29uZmlnLnR5cGVdO1xyXG5cdFx0aWYgKCFjbCl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyYWNrIHR5cGUgXCIrIGNvbmZpZy50eXBlK1wiIG5vdCByZWNvZ25pc2VkXCIpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IGNsW1wiY2xhc3NcIl0oY29uZmlnKTtcclxuXHJcblx0fVxyXG5cdFx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3M9e307XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlcz17fVxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vKioqKioqKioqKioqKioqKioqKmpzL3J1bGVyVHJhY2suanMqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgUnVsZXJUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZyl7XHJcblx0XHRcdGNvbmZpZz17XCJ0cmFja19pZFwiOlwicnVsZXJcIitSdWxlclRyYWNrLmNvdW50LGZvcm1hdDpcInJ1bGVyXCIsc2hvcnRfbGFiZWw6XCJSdWxlclwiLHR5cGU6XCJydWxlclwifTtcclxuXHRcdH1cclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAzMDtcclxuICAgICAgICB0aGlzLmNvbmZpZy5oZWlnaHQ9MzA7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuZGlzYWJsZUJ1dHRvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVHJhY2tNZW51ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgIFxyXG4gICAgICAgIFJ1bGVyVHJhY2suY291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bGZpbGwoW10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBmb250U3R5bGUsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgIHRzLFxyXG4gICAgICAgICAgICBzcGFjaW5nLFxyXG4gICAgICAgICAgICBuVGljayxcclxuICAgICAgICAgICAgeDtcclxuXHJcbiAgICAgICAgZm9udFN0eWxlID0geyB0ZXh0QWxpZ246ICdjZW50ZXInLCBmb250OiAnMTBweCBQVCBTYW5zJywgZmlsbFN0eWxlOiBcInJnYmEoNjQsIDY0LCA2NCwgMSlcIiwgc3Ryb2tlU3R5bGU6IFwicmdiYSg2NCwgNjQsIDY0LCAxKVwiIH07XHJcblxyXG4gICAgICAgIHJhbmdlID0gTWF0aC5mbG9vcigxMTAwICogb3B0aW9ucy5icFBlclBpeGVsKTtcclxuICAgICAgICB0cyA9IFJ1bGVyVHJhY2suZmluZFNwYWNpbmcocmFuZ2UpO1xyXG4gICAgICAgIHNwYWNpbmcgPSB0cy5tYWpvclRpY2s7XHJcblxyXG4gICAgICAgIC8vIEZpbmQgc3RhcnRpbmcgcG9pbnQgY2xvc2VzdCB0byB0aGUgY3VycmVudCBvcmlnaW5cclxuICAgICAgICBuVGljayA9IE1hdGguZmxvb3Iob3B0aW9ucy5icFN0YXJ0IC8gc3BhY2luZykgLSAxO1xyXG4gICAgICAgIHggPSAwO1xyXG5cdFx0bGV0IHlfcG9zPW9wdGlvbnMudG9wK3RoaXMuaGVpZ2h0O1xyXG4gICAgICAgIC8vY2FudmFzLnNldFByb3BlcnRpZXMoe3RleHRBbGlnbjogJ2NlbnRlcid9KTtcclxuICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgZm9udFN0eWxlICk7XHJcbiAgICAgICAgd2hpbGUgKHggPCBvcHRpb25zLnBpeGVsV2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5mbG9vcihuVGljayAqIHNwYWNpbmcpLFxyXG4gICAgICAgICAgICAgICAgc2hpbSA9IDI7XHJcblxyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCgoKGwgLSAxKSAtIG9wdGlvbnMuYnBTdGFydCArIDAuNSkgLyBvcHRpb25zLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICB2YXIgY2hyUG9zaXRpb24gPSBmb3JtYXROdW1iZXIobCAvIHRzLnVuaXRNdWx0aXBsaWVyLCAwKSArIFwiIFwiICsgdHMubWFqb3JVbml0O1xyXG5cclxuICAgICAgICAgICAgaWYgKG5UaWNrICUgMSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsVGV4dChjdHgsIGNoclBvc2l0aW9uLCB4LCB5X3BvcyAtIDE1KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHgsIHlfcG9zIC0gMTAsIHgsIHlfcG9zIC0gc2hpbSk7XHJcblxyXG4gICAgICAgICAgICBuVGljaysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgMCwgeV9wb3MgLSBzaGltLCBvcHRpb25zLnBpeGVsV2lkdGgsIHlfcG9zIC0gc2hpbSk7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIoYW55bnVtLCBkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgIC8vZGVjaW1hbCAgLSB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIGFmdGVyIHRoZSBkaWdpdCBmcm9tIDAgdG8gM1xyXG4gICAgICAgICAgICAvLy0tIFJldHVybnMgdGhlIHBhc3NlZCBudW1iZXIgYXMgYSBzdHJpbmcgaW4gdGhlIHh4eCx4eHgueHggZm9ybWF0LlxyXG4gICAgICAgICAgICAvL2FueW51bSA9IGV2YWwob2JqLnZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGRpdmlkZXIgPSAxMDtcclxuICAgICAgICAgICAgc3dpdGNoIChkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAgICAgICAvL2ZvciAzIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEwMDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3b3JrTnVtID0gTWF0aC5hYnMoKE1hdGgucm91bmQoYW55bnVtICogZGl2aWRlcikgLyBkaXZpZGVyKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd29ya1N0ciA9IFwiXCIgKyB3b3JrTnVtXHJcblxyXG4gICAgICAgICAgICBpZiAod29ya1N0ci5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgd29ya1N0ciArPSBcIi5cIlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZFN0ciA9IHdvcmtTdHIuc3Vic3RyKDAsIHdvcmtTdHIuaW5kZXhPZihcIi5cIikpO1xyXG4gICAgICAgICAgICB2YXIgZE51bSA9IGRTdHIgLSAwXHJcbiAgICAgICAgICAgIHZhciBwU3RyID0gd29ya1N0ci5zdWJzdHIod29ya1N0ci5pbmRleE9mKFwiLlwiKSlcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChwU3RyLmxlbmd0aCAtIDEgPCBkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICBwU3RyICs9IFwiMFwiXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwU3RyID09ICcuJykgcFN0ciA9ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8tLS0gQWRkcyBhIGNvbW1hIGluIHRoZSB0aG91c2FuZHMgcGxhY2UuXHJcbiAgICAgICAgICAgIGlmIChkTnVtID49IDEwMDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBkTGVuID0gZFN0ci5sZW5ndGhcclxuICAgICAgICAgICAgICAgIGRTdHIgPSBwYXJzZUludChcIlwiICsgKGROdW0gLyAxMDAwKSkgKyBcIixcIiArIGRTdHIuc3Vic3RyaW5nKGRMZW4gLSAzLCBkTGVuKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy0tIEFkZHMgYSBjb21tYSBpbiB0aGUgbWlsbGlvbnMgcGxhY2UuXHJcbiAgICAgICAgICAgIGlmIChkTnVtID49IDEwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgIGRMZW4gPSBkU3RyLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgZFN0ciA9IHBhcnNlSW50KFwiXCIgKyAoZE51bSAvIDEwMDAwMDApKSArIFwiLFwiICsgZFN0ci5zdWJzdHJpbmcoZExlbiAtIDcsIGRMZW4pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IGRTdHIgKyBwU3RyXHJcbiAgICAgICAgICAgIC8vLS0gUHV0IG51bWJlcnMgaW4gcGFyZW50aGVzZXMgaWYgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIGlmIChhbnludW0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBcIihcIiArIHJldHZhbCArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1lvdSBjb3VsZCBpbmNsdWRlIGEgZG9sbGFyIHNpZ24gaW4gdGhlIHJldHVybiB2YWx1ZS5cclxuICAgICAgICAgICAgLy9yZXR2YWwgPSAgXCIkXCIrcmV0dmFsXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5X3BvcztcclxuXHJcblxyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRTcGFjaW5nKG1heFZhbHVlKSB7XHJcblxyXG4gICAgICAgIGlmIChtYXhWYWx1ZSA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoMSwgXCJcIiwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gTm93IG1hbiB6ZXJvZXM/XHJcbiAgICAgICAgdmFyIG5aZXJvZXMgPSBNYXRoLmZsb29yKGxvZzEwKG1heFZhbHVlKSk7XHJcbiAgICAgICAgdmFyIG1ham9yVW5pdCA9IFwiXCI7XHJcbiAgICAgICAgdmFyIHVuaXRNdWx0aXBsaWVyID0gMTtcclxuICAgICAgICBpZiAoblplcm9lcyA+IDkpIHtcclxuICAgICAgICAgICAgbWFqb3JVbml0ID0gXCJnYlwiO1xyXG4gICAgICAgICAgICB1bml0TXVsdGlwbGllciA9IDEwMDAwMDAwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuWmVyb2VzID4gNikge1xyXG4gICAgICAgICAgICBtYWpvclVuaXQgPSBcIm1iXCI7XHJcbiAgICAgICAgICAgIHVuaXRNdWx0aXBsaWVyID0gMTAwMDAwMDtcclxuICAgICAgICB9IGVsc2UgaWYgKG5aZXJvZXMgPiAzKSB7XHJcbiAgICAgICAgICAgIG1ham9yVW5pdCA9IFwia2JcIjtcclxuICAgICAgICAgICAgdW5pdE11bHRpcGxpZXIgPSAxMDAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5NYWpvclRpY2tzID0gbWF4VmFsdWUgLyBNYXRoLnBvdygxMCwgblplcm9lcyAtIDEpO1xyXG4gICAgICAgIGlmIChuTWFqb3JUaWNrcyA8IDI1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoTWF0aC5wb3coMTAsIG5aZXJvZXMgLSAxKSwgbWFqb3JVbml0LCB1bml0TXVsdGlwbGllcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWNrU3BhY2luZyhNYXRoLnBvdygxMCwgblplcm9lcykgLyAyLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxvZzEwKHgpIHtcclxuICAgICAgICAgICAgdmFyIGRuID0gTWF0aC5sb2coMTApO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBkbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5SdWxlclRyYWNrLmNvdW50PTA7XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcInJ1bGVyXCJdPXtcclxuXHRcImNsYXNzXCI6UnVsZXJUcmFjayxcclxuXHRuYW1lOlwiUnVsZXJcIlxyXG5cclxufVxyXG5cclxuY2xhc3MgVGlja1NwYWNpbmd7XHJcblx0Y29uc3RydWN0b3IobWFqb3JUaWNrLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgdGhpcy5tYWpvclRpY2sgPSBtYWpvclRpY2s7XHJcbiAgICAgICAgdGhpcy5tYWpvclVuaXQgPSBtYWpvclVuaXQ7XHJcbiAgICAgICAgdGhpcy51bml0TXVsdGlwbGllciA9IHVuaXRNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIFxyXG5jbGFzcyBNTFZCZWRUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG5cdFx0dGhpcy5maWx0ZXJfZnVuY3Rpb249bnVsbDtcclxuXHRcdHRoaXMuY29sb3JfZnVuY3Rpb249bnVsbDtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9IG5ldyBUYWJpeEJlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpXHJcblx0fVxyXG5cclxuXHRzZXRGaWx0ZXJGdW5jdGlvbihmdW5jKXtcclxuXHRcdHRoaXMuZmlsdGVyX2Z1bmN0aW9uPWZ1bmM7XHJcblx0fVxyXG5cdHNldENvbG9yRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmNvbG9yX2Z1bmN0aW9uPWZ1bmM7XHJcblx0fVxyXG5cclxuXHRnZXRDdXJyZW50RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCl7XHJcblx0XHRyZXR1cm4gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKTtcclxuXHR9XHJcblx0XHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHRcdGxldCBtYXhfeV92YWw9MDtcclxuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLFxyXG4gICAgICAgIFx0cHksXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBwaXhlbEhlaWdodCA9IG9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgICAgIG9mZnNldD0wLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDE7XHJcblx0IFx0bGV0IHRvcD0wO1xyXG4gICAgICAgXHRpZihvcHRpb25zLnRvcCl7XHJcbiAgICAgICAgICAgdG9wPW9wdGlvbnMudG9wO1xyXG4gICAgICAgXHR9XHJcbiAgICAgICBcdHRoaXMudG9wPXRvcDtcclxuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgIGxldCB3aW5kb3dYID0gMDtcclxuICAgICAgICBsZXQgd2luZG93WDEgPSB3aW5kb3dYICsgcGl4ZWxXaWR0aDtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0ID0gdGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCsxMDtcclxuICAgICAgICB0aGlzLmNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgPSAodGhpcy5jb25maWcuZmVhdHVyZUhlaWdodC8yKSsyO1xyXG4gICAgICAgIGxldCBraT1udWxsO1xyXG4gICAgICAgIGlmIChmZWF0dXJlTGlzdC5sZW5ndGg+NTAwMDApe1xyXG4gICAgICAgIFx0a2k9TWF0aC5yb3VuZChmZWF0dXJlTGlzdC5sZW5ndGgvNTAwMDApKzE7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIGlmIChmZWF0dXJlTGlzdCkge1xyXG4gICAgICAgIFx0bGV0IG9wYWNpdHkgPSB0aGlzLmNvbmZpZy5vcGFjaXR5P3RoaXMuY29uZmlnLm9wYWNpdHk6MTtcclxuICAgICAgICBcdGN0eC5nbG9iYWxBbHBoYT1vcGFjaXR5O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgZ2VuZSwgaSA9IDAsIGxlbiA9IGZlYXR1cmVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIFx0aWYgKGtpICYmIGkla2khPT0wKXtcclxuICAgICAgICAgICAgXHRcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBcdH1cclxuICAgICAgICAgICAgICAgIGdlbmUgPSBmZWF0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZ2VuZSkpe1xyXG4gICAgICAgICAgICAgICAgXHRnZW5lLmRpc3BsYXk9ZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2VuZS5kaXNwbGF5PXRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZS5lbmQgPCBicFN0YXJ0KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChnZW5lLnN0YXJ0ID4gYnBFbmQpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gdGhpcy5jYWxjdWxhdGVGZWF0dXJlQ29vcmRpbmF0ZXMoZ2VuZSwgYnBTdGFydCxicFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBoID0gY29uZi5mZWF0dXJlSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZi5kaXNwbGF5TW9kZSA9PT0gXCJTUVVJU0hFRFwiICYmIGdlbmUucm93ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBcdFx0aCA9IGNvbmYuZmVhdHVyZUhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIFx0XHRweSA9IGNvbmYuZXhwYW5kZWRDYWxsSGVpZ2h0ICogZ2VuZS5yb3cgKyAyO1xyXG4gICAgICAgIFx0XHR9IGVsc2UgaWYgKGNvbmYuZGlzcGxheU1vZGUgPT09IFwiRVhQQU5ERURcIiAmJiBnZW5lLnJvdyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgXHRcdHB5ID0gY29uZi5zcXVpc2hlZENhbGxIZWlnaHQgKiBnZW5lLnJvdyArIDU7XHJcbiAgICAgICAgXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAvLyBjb2xsYXBzZWRcclxuICAgICAgICAgICBcdFx0XHQgcHkgPSA1O1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHB5Kz10b3A7XHJcbiAgICAgICAgXHRcdGlmIChweStoPm1heF95X3ZhbCl7XHJcbiAgICAgICAgXHRcdFx0bWF4X3lfdmFsPXB5K2g7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0Y29vcmQucHk9cHk7XHJcbiAgICAgICAgXHRcdGNvb3JkLmg9aDtcclxuICAgICAgICBcdFx0bGV0IGluZm89e2JwUGVyUGl4ZWw6YnBQZXJQaXhlbCxicFN0YXJ0OmJwU3RhcnQscGl4ZWxXaWR0aDpwaXhlbFdpZHRofVxyXG4gICAgICAgIFx0XHRpZiAodGhpcy5jb2xvcl9mdW5jdGlvbil7XHJcbiAgICAgICAgXHRcdFx0Z2VuZS5jb2xvcj10aGlzLmNvbG9yX2Z1bmN0aW9uKGdlbmUpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGZWF0dXJlKGdlbmUsY29vcmQsY3R4LGluZm8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGZWF0dXJlTGFiZWwoY3R4LCBnZW5lLCBjb29yZC5weCwgY29vcmQucHgxLCBweSwgd2luZG93WCwgd2luZG93WDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBmZWF0dXJlIGxpc3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm90dG9tPW1heF95X3ZhbDtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuZGlzcGxheU1vZGU9PT1cIkNPTExBUFNFRFwiKXtcclxuICAgICAgICBcdG1heF95X3ZhbCs9MjU7XHJcbiAgICAgICAgfVx0XHJcbiAgICBcdHJldHVybiBtYXhfeV92YWw7XHJcbiAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgXHJcblxyXG4gICAgXHJcbiAgXHJcblx0IC8qKlxyXG4gICAgICogQHBhcmFtIGN0eCAgICAgICB0aGUgY2FudmFzIDJkIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVggIGZlYXR1cmUgc3RhcnQgeC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVgxIGZlYXR1cmUgZW5kIHgtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVZICBmZWF0dXJlIHktY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHdpbmRvd1ggICB2aXNpYmxlIHdpbmRvdyBzdGFydCB4LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aW5kb3dYMSAgdmlzaWJsZSB3aW5kb3cgZW5kIHgtY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgXHJcblxyXG5cclxuXHJcblx0cmVuZGVyRmVhdHVyZUxhYmVsKGN0eCwgZmVhdHVyZSwgZmVhdHVyZVgsIGZlYXR1cmVYMSwgZmVhdHVyZVksIHdpbmRvd1gsIHdpbmRvd1gxKSB7XHJcblx0XHRsZXQgaW5mbyA9IHRoaXMuY29uZmlnO1xyXG4gICAgICAgIHZhciBnZW5lQ29sb3IsIGdlbmVGb250U3R5bGUsIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgYm94WCwgYm94WDEsICAgIC8vIGxhYmVsIHNob3VsZCBiZSBjZW50ZXJlZCBiZXR3ZWVuIHRoZXNlIHR3byB4LWNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGxhYmVsWCwgbGFiZWxZLFxyXG4gICAgICAgICAgICB0ZXh0Rml0c0luQm94O1xyXG5cclxuICAgICAgICAvLyBmZWF0dXJlIG91dHNpZGUgb2Ygdmlld2FibGUgd2luZG93XHJcbiAgICAgICAgaWYgKGZlYXR1cmVYMSA8IHdpbmRvd1ggfHwgZmVhdHVyZVggPiB3aW5kb3dYMSkge1xyXG4gICAgICAgICAgICBib3hYID0gZmVhdHVyZVg7XHJcbiAgICAgICAgICAgIGJveFgxID0gZmVhdHVyZVgxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNlbnRlciBsYWJlbCB3aXRoaW4gdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBmZWF0dXJlXHJcbiAgICAgICAgICAgIGJveFggPSBNYXRoLm1heChmZWF0dXJlWCwgd2luZG93WCk7XHJcbiAgICAgICAgICAgIGJveFgxID0gTWF0aC5taW4oZmVhdHVyZVgxLCB3aW5kb3dYMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGV4dD0gZmVhdHVyZS5uYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmxhYmVsX2Z1bmN0aW9uKXtcclxuICAgICAgICBcdHRleHQ9dGhpcy5sYWJlbF9mdW5jdGlvbihmZWF0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICBcclxuXHJcbiAgICAgICAgLy9pZiAoaWd2LmJyb3dzZXIuc2VsZWN0aW9uICYmIFwiZ2VuZXNcIiA9PT0gdGhpcy5jb25maWcudHlwZSAmJiBmZWF0dXJlLm5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIC0tIGZvciBndGV4LCBmaWd1cmUgb3V0IGEgYmV0dGVyIHdheSB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgIC8vZ2VuZUNvbG9yID0gaWd2LmJyb3dzZXIuc2VsZWN0aW9uLmNvbG9yRm9yR2VuZShmZWF0dXJlLm5hbWUpO1xyXG4gICAgICAvLyAgfVxyXG5cclxuICAgICAgICB0ZXh0Rml0c0luQm94ID0gKGJveFgxIC0gYm94WCkgPiBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XHJcbiAgICAgICAgLy9nZW5lQ29sb3I9XCJibGFja1wiO1xyXG5cclxuICAgICAgICBpZiAoKHRleHRGaXRzSW5Cb3ggfHwgZ2VuZUNvbG9yKSAmJiBpbmZvLmRpc3BsYXlNb2RlICE9IFwiU1FVSVNIRURcIiAmJiB0ZXh0KSB7XHJcbiAgICAgICAgICAgIGdlbmVGb250U3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICBmb250OiAnMTBweCBQVCBTYW5zJyxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IGdlbmVDb2xvciB8fCBpbmZvLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IGdlbmVDb2xvciB8fCBpbmZvLmNvbG9yXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXNwbGF5TW9kZSA9PT0gXCJDT0xMQVBTRURcIiAmJiBpbmZvLmxhYmVsRGlzcGxheU1vZGUgPT09IFwiU0xBTlRcIikge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0ge3JvdGF0ZToge2FuZ2xlOiA0NX19O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdlbmVGb250U3R5bGUudGV4dEFsaWduO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYWJlbFggPSBib3hYICsgKChib3hYMSAtIGJveFgpIC8gMik7XHJcbiAgICAgICAgICAgIGxhYmVsWSA9IGdldEZlYXR1cmVMYWJlbFkoZmVhdHVyZVksIHRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICBHcmFwaGljcy5maWxsVGV4dChjdHgsIHRleHQsIGxhYmVsWCwgbGFiZWxZLCBnZW5lRm9udFN0eWxlLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRGZWF0dXJlTGFiZWxZKGZlYXR1cmVZLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICBcdHJldHVybiB0cmFuc2Zvcm0gPyBmZWF0dXJlWSArIGluZm8uZmVhdHVyZUhlaWdodCsxNCA6IGZlYXR1cmVZICsgaW5mby5mZWF0dXJlSGVpZ2h0Kzc7XHJcbiAgICBcdH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHRjYWxjdWxhdGVGZWF0dXJlQ29vcmRpbmF0ZXMoZmVhdHVyZSwgYnBTdGFydCwgeFNjYWxlKSB7XHJcbiAgICBcdHZhciBweCA9IE1hdGgucm91bmQoKGZlYXR1cmUuc3RhcnQgLSBicFN0YXJ0KSAvIHhTY2FsZSksXHJcbiAgICAgICAgcHgxID0gTWF0aC5yb3VuZCgoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIHhTY2FsZSksXHJcbiAgICAgICAgcHcgPSBweDEgLSBweDtcclxuXHJcbiAgICAgICAgaWYgKHB3IDwgMykge1xyXG4gICAgICAgIFx0cHcgPSAzO1xyXG4gICAgICAgICAgICBweCAtPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICBcdHB4OiBweCxcclxuICAgICAgICAgICAgcHgxOiBweDEsXHJcbiAgICAgICAgICAgIHB3OiBwd1xyXG4gICAgICAgIH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIGZlYXR1cmUgdG8gdGhlIGNhbnZhc1xyXG4gICAgICogQHBhcmFtIGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBpdHNlbGZcclxuICAgICAqIEBwYXJhbSBjb29yZCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvbiB3aGVyZSB0byBkcmF3IHRoZSBmZWF0dXJlXHJcbiAgICAgKiBweDEscHgyIHRoZSBsZWZ0IGFuZCByaWdodCBwaXhlbHMgLSBwdyAtIHRoZSB3aWR0aFxyXG4gICAgICogcHkgdGhlIHRvcCwgaCAtIHRoZSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0byBkcmF3IHRoZSBmZWF0dXJlXHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnZW5vbWljIGxvY2F0aW9uXHJcbiAgICAgKiBicFN0YXJ0LmJwUGVyUGl4ZWwgYW5kIHBpeGVsV2lkdGhcclxuICAgICAqIFxyXG4gICAgICovXHJcblx0XHJcblx0cmVuZGVyRmVhdHVyZShmZWF0dXJlLCBjb29yZCxjdHgsaW5mbyl7XHJcblx0XHR2YXIgZSx4LCBjeSwgZGlyZWN0aW9uLCBleG9uLCBlUHgsIGVQeDEsIGVQeFUsIGVQdywgcHkyLCBoMiwgXHJcbiAgICAgICAgICAgIHN0ZXAgPSAyMCxcclxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbmZpZy5jb2xvcjtcclxuICAgICAgICBpZiAoZmVhdHVyZS5jb2xvcikge1xyXG4gICAgICAgICAgICBjb2xvciA9IGZlYXR1cmUuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcblxyXG4gICAgICAgIGN5ID0gY29vcmQucHkgKyBjb29yZC5oIC8gMjtcclxuICAgICAgICBoMiA9IGNvb3JkLmggLyAyO1xyXG4gICAgICAgIHB5MiA9IGN5IC0gaDIgLyAyO1xyXG5cclxuXHRcdGxldCBleG9uQ291bnQgPSBmZWF0dXJlLmV4b25zID8gZmVhdHVyZS5leG9ucy5sZW5ndGggOiAwO1xyXG5cdFx0XHRpZiAoZXhvbkNvdW50ID09IDApIHtcclxuICAgICAgICAgICAgXHQvLyBzaW5nbGUtZXhvbiB0cmFuc2NyaXB0XHJcbiAgICAgICAgICAgIFx0Y3R4LmZpbGxSZWN0KGNvb3JkLnB4LCBjb29yZC5weSwgY29vcmQucHcsIGNvb3JkLmgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIC8vIG11bHRpLWV4b24gdHJhbnNjcmlwdFxyXG4gICAgICAgICAgICBjb29yZC5weD1NYXRoLm1heChjb29yZC5weCwwKTtcclxuICAgICAgICAgICAgY29vcmQucHgxPU1hdGgubWluKGNvb3JkLnB4MSxpbmZvLnBpeGVsV2lkdGgpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgY29vcmQucHggKyAxLCBjeSwgY29vcmQucHgxIC0gMSwgY3kpOyAvLyBjZW50ZXIgbGluZSBmb3IgaW50cm9uc1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBmZWF0dXJlLnN0cmFuZCA9PSAnKycgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAoIHg9Y29vcmQucHggKyBzdGVwIC8gMjsgeCA8ICBjb29yZC5weDE7IHggKz0gc3RlcCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRyYXcgYXJyb3doZWFkcyBhbG9uZyBjZW50cmFsIGxpbmUgaW5kaWNhdGluZyB0cmFuc2NyaWJlZCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHggLSBkaXJlY3Rpb24gKiAyLCBjeSAtIDIsIHgsIGN5KTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgKyAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChlID0gMDsgZSA8IGV4b25Db3VudDsgZSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkcmF3IHRoZSBleG9uc1xyXG4gICAgICAgICAgICAgICAgZXhvbiA9IGZlYXR1cmUuZXhvbnNbZV07XHJcbiAgICAgICAgICAgICAgICBlUHggPSBNYXRoLnJvdW5kKChleG9uLnN0YXJ0IC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBlUHgxID0gTWF0aC5yb3VuZCgoZXhvbi5lbmQgLSBpbmZvLmJwU3RhcnQpIC8gaW5mby5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgICAgIGVQdyA9IE1hdGgubWF4KDEsIGVQeDEgLSBlUHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleG9uLnV0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHgsIHB5MiwgZVB3LCBoMik7IC8vIEVudGlyZSBleG9uIGlzIFVUUlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4b24uY2RTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHhVID0gTWF0aC5yb3VuZCgoZXhvbi5jZFN0YXJ0IC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHgsIHB5MiwgZVB4VSAtIGVQeCwgaDIpOyAvLyBzdGFydCBpcyBVVFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB3IC09IChlUHhVIC0gZVB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4ID0gZVB4VTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleG9uLmNkRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeFUgPSBNYXRoLnJvdW5kKChleG9uLmNkRW5kIC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChlUHhVLCBweTIsIGVQeDEgLSBlUHhVLCBoMik7IC8vIHN0YXJ0IGlzIFVUUlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHcgLT0gKGVQeDEgLSBlUHhVKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4MSA9IGVQeFU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBjb29yZC5weSwgZVB3LCBjb29yZC5oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVQdyA+IHN0ZXAgKyA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh4ID0gZVB4ICsgc3RlcCAvIDI7IHggPCBlUHgxOyB4ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgYXJyb3doZWFkcyBhbG9uZyBjZW50cmFsIGxpbmUgaW5kaWNhdGluZyB0cmFuc2NyaWJlZCBvcmllbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIHggLSBkaXJlY3Rpb24gKiAyLCBjeSAtIDIsIHgsIGN5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgKyAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEZlYXR1cmVBdChnZW5vbWljTG9jYXRpb24sIGNociwgY29vcmQsIGJwUGVyUGl4ZWwpIHtcclxuXHRcdGxldCB5T2Zmc2V0PWNvb3JkLnktdGhpcy50b3A7XHJcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBmZWF0dXJlQ2FjaGUgcHJvcGVydHkgcmF0aGVyIHRoYW4gbWV0aG9kIHRvIGF2b2lkIGFzeW5jIGxvYWQuICBJZiB0aGVcclxuICAgICAgICAvLyBmZWF0dXJlIGlzIG5vdCBhbHJlYWR5IGxvYWRlZCB0aGlzIHdvbid0IHdvcmssICBidXQgdGhlIHVzZXIgd291bGRuJ3QgYmUgbW91c2luZyBvdmVyIGl0IGVpdGhlci5cclxuICAgICAgICBpZiAodGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUpIHtcclxuXHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDIgKiBicFBlclBpeGVsLCAgLy8gV2UgbmVlZCBzb21lIHRvbGVyYW5jZSBhcm91bmQgZ2Vub21pY0xvY2F0aW9uLCBzdGFydCB3aXRoICsvLSAyIHBpeGVsc1xyXG4gICAgICAgICAgICAgICAgZmVhdHVyZUxpc3QgPSB0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZS5xdWVyeUZlYXR1cmVzKGNociwgZ2Vub21pY0xvY2F0aW9uIC0gdG9sZXJhbmNlLCBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpLFxyXG4gICAgICAgICAgICAgICAgcm93O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRpc3BsYXlNb2RlICE9IFwiQ09MTEFQU0VEXCIpIHtcclxuICAgICAgICAgICAgICAgIHJvdyA9IChNYXRoLmZsb29yKSh0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZSA9PT0gXCJTUVVJU0hFRFwiID8geU9mZnNldCAvIHRoaXMuY29uZmlnLmV4cGFuZGVkQ2FsbEhlaWdodCA6IHlPZmZzZXQgLyB0aGlzLmNvbmZpZy5zcXVpc2hlZENhbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0ICYmIGZlYXR1cmVMaXN0Lmxlbmd0aCA+IDApIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBvcHVwRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZmVhdHVyZSBvZiBmZWF0dXJlTGlzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZW5kID49IGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnN0YXJ0IDw9IGdlbm9taWNMb2NhdGlvbiArIHRvbGVyYW5jZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcm93IG51bWJlciBpcyBzcGVjaWZpZWQgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93ID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZS5yb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IGZlYXR1cmUucm93KSYmICBmZWF0dXJlLmRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG59XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcImJlZFwiXT17XHJcblx0XCJjbGFzc1wiOk1MVkJlZFRyYWNrLFxyXG5cdG5hbWU6XCJiZWQodGFiaXgpXCJcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVkJpZ0JlZFRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHRcclxuXHR9XHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9bmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wiYmlnYmVkXCJdPXtcclxuXHRcImNsYXNzXCI6TUxWQmlnQmVkVHJhY2ssXHJcblx0XCJuYW1lXCI6XCJCaWdCZWRcIlxyXG5cdFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgTUxWV2lnVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0Y29uZmlnLmZvcm1hdD1cIndpZ1wiO1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPW5ldyBCV1NvdXJjZSh0aGlzLmNvbmZpZyk7XHRcclxuXHR9XHJcblxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxfaGVpZ2h0LGN0eCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcuc2NhbGVfbGlua190byAmJiB0aGlzLmNvbmZpZy5ncm91cCl7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGxldCBib3Q9IHBpeGVsX2hlaWdodDtcclxuXHRcdGxldCB0b3AgPSAwO1xyXG5cclxuXHJcblx0XHRpZiAodGhpcy5jb25maWcuZGlzY3JldGUpe1xyXG5cdFx0XHR0b3A9dGhpcy50b3A7XHJcblx0XHRcdGJvdCA9IHRoaXMuYm90dG9tO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJhbmdlPXRoaXMubWF4X3ktdGhpcy5taW5feTtcclxuXHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdGN0eC5saW5lVG8oMCxib3QpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDIwLHRvcCk7XHJcblx0XHRjdHgubW92ZVRvKDAsYm90KTtcclxuXHRcdGN0eC5saW5lVG8oMjAsYm90KTtcclxuXHRcdGN0eC5mb250PVwiMTJweCBBcmlhbFwiO1xyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZT1cInRvcFwiO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZT1cImJsYWNrXCI7XHJcblx0XHRjdHguZmlsbFRleHQodGhpcy5tYXhfeS50b0ZpeGVkKDIpLDIwLHRvcCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWluX3ksMjAsYm90KTtcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXMsXHJcblx0ICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuXHQgICAgY29sb3I9c2VsZi5jb25maWcuY29sb3IsXHJcblx0ICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuXHQgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuXHQgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuXHQgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuXHQgICAgcGl4ZWxIZWlnaHQgPW9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcblx0ICAgIHlfb2Zmc2V0PXRoaXMuY29uZmlnLmRpc2NyZXRlP29wdGlvbnMudG9wOjAsXHJcblx0ICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWluaW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWF4aW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlUmFuZ2UsXHJcblx0ICAgICRkYXRhUmFuZ2VUcmFja0xhYmVsLFxyXG5cdCAgICBzdHIsXHJcblx0ICAgIG1pbixcclxuXHQgICAgbWF4O1xyXG5cdCAgICBpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZih0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0ICAgIFx0XHRwaXhlbEhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ7XHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYoc2VsZi5zZXRfc2NhbGUpe1xyXG5cdCAgICAgICBcdFx0c2VsZi5taW5feT1zZWxmLnNldF9zY2FsZS5taW47XHJcblx0ICAgICAgIFx0XHRzZWxmLm1heF95PXNlbGYuc2V0X3NjYWxlLm1heDtcclxuXHQgICAgICAgfVxyXG5cdCAgICAgICBlbHNlIGlmICggKHNlbGYubWF4X3kgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNvbmZpZy5zY2FsZT09PVwiYXV0b21hdGljXCIpIHx8IHNlbGYuY29uZmlnLnNjYWxlPT09XCJkeW5hbWljXCIpe1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcyA9IGF1dG9zY2FsZShmZWF0dXJlcyk7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzLm1pbjtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeSA9IHMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5zY2FsZT09PVwiZml4ZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95ID0gc2VsZi5jb25maWcubWluX3k7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3k9c2VsZi5jb25maWcubWF4X3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgICAgICAgICBmZWF0dXJlVmFsdWVSYW5nZSA9IHNlbGYubWF4X3kgLSBzZWxmLm1pbl95O1xyXG5cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsID0gJCh0aGlzLnRyYWNrVmlldy50cmFja0RpdikuZmluZCgnLmlndi1kYXRhLXJhbmdlLXRyYWNrLWxhYmVsJyk7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvL21pbiA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5taW4pID09PSB0cmFjay5kYXRhUmFuZ2UubWluKSA/IHRyYWNrLmRhdGFSYW5nZS5taW4gOiB0cmFjay5kYXRhUmFuZ2UubWluLnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9tYXggPSAoTWF0aC5mbG9vcih0cmFjay5kYXRhUmFuZ2UubWF4KSA9PT0gdHJhY2suZGF0YVJhbmdlLm1heCkgPyB0cmFjay5kYXRhUmFuZ2UubWF4IDogdHJhY2suZGF0YVJhbmdlLm1heC50b0ZpeGVkKDIpO1xyXG5cdCAgICAgICAgICAgIC8vc3RyID0gJ1snICsgbWluICsgJyAtICcgKyBtYXggKyAnXSc7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsLnRleHQoc3RyKTtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl94PTA7XHJcblx0ICAgICAgICAgICAgbGV0IHByZXZfeT0wO1xyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAgID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcblx0ICAgICAgICAgXHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfbGluZSl7ICBcclxuXHQgICAgICAgICAgICAgICAgbGV0IHkgPSAoMS4wIC0gc2VsZi5jb25maWcudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZSkqcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LDAseSxwaXhlbFdpZHRoLHkse1wic3Ryb2tlU3R5bGVcIjpzZWxmLmNvbmZpZy5jb2xvcixcImxpbmVXaWR0aFwiOnNlbGYuY29uZmlnLndpZHRoP3NlbGYuY29uZmlnLndpZHRoOjF9KTtcclxuXHQgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHRmZWF0dXJlcy5mb3JFYWNoKHJlbmRlckZlYXR1cmUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgXHJcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhPTFcclxuXHQgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRocmVzaG9sZCl7XHJcblx0ICAgICAgICAgICAgIFx0ICAgIGxldCB5ID0geV9vZmZzZXQrKDEuMCAtIHNlbGYuY29uZmlnLnRocmVzaG9sZC8gZmVhdHVyZVZhbHVlUmFuZ2UpKnBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgICBcdCAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwwLHkscGl4ZWxXaWR0aCx5LHtcInN0cm9rZVN0eWxlXCI6XCJibGFja1wiLFwibGluZVdpZHRoXCI6MX0pO1xyXG5cdCAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShmZWF0dXJlLCBpbmRleCwgZmVhdHVyZUxpc3QpIHtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIHlVbml0bGVzcyxcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MsXHJcblx0ICAgICAgICAgICAgICAgIHgsXHJcblx0ICAgICAgICAgICAgICAgIHksXHJcblx0ICAgICAgICAgICAgICAgIHdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHQsXHJcblx0ICAgICAgICAgICAgICAgIHJlY3RFbmQsXHJcblx0ICAgICAgICAgICAgICAgIHJlY3RCYXNlbGluZTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKGZlYXR1cmUuZW5kIDwgYnBTdGFydCkgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0YXJ0ID4gYnBFbmQpIHJldHVybjtcclxuXHQgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZD09PWZlYXR1cmUuc3RhcnQpe1xyXG5cdCAgICAgICAgICAgIFx0ZmVhdHVyZS5zdGFydC09MTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICByZWN0RW5kID0gTWF0aC5mbG9vcigoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwpO1xyXG5cdCAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgcmVjdEVuZCAtIHgpO1xyXG5cdCAgICAgICAgICBcclxuXHJcblx0ICAgICAgICAgIFxyXG5cclxuXHQgICAgICAgICAgICAvL2hlaWdodCA9ICgoZmVhdHVyZS52YWx1ZSAtIGZlYXR1cmVWYWx1ZU1pbmltdW0pIC8gZmVhdHVyZVZhbHVlUmFuZ2UpICogcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9yZWN0QmFzZWxpbmUgPSBwaXhlbEhlaWdodCAtIGhlaWdodDtcclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdChyZWN0T3JpZ2luLCByZWN0QmFzZWxpbmUsIHJlY3RXaWR0aCwgcmVjdEhlaWdodCwge2ZpbGxTdHlsZTogdHJhY2suY29sb3J9KTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHNpZ25zRGlmZmVyKHNlbGYubWluX3ksIHNlbGYubWF4X3kpKSB7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS52YWx1ZSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IHNlbGYubWF4X3kvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gKChzZWxmLm1heF95IC0gZmVhdHVyZS52YWx1ZSkgLyBmZWF0dXJlVmFsdWVSYW5nZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IGZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5taW5feSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMDtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMS4wIC0gKChmZWF0dXJlLnZhbHVlLXNlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IChmZWF0dXJlLnZhbHVlK3NlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgIFx0eSA9ICh5VW5pdGxlc3MqcGl4ZWxIZWlnaHQpK3lfb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIHk9eTx5X29mZnNldD95X29mZnNldDp5O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHRVbml0TGVzcyAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHQ+cGl4ZWxIZWlnaHQ/cGl4ZWxIZWlnaHQ6aGVpZ2h0XHJcblxyXG5cdCAgICAgICAgICAgIC8vY2FudmFzLmZpbGxSZWN0KHgsIHlVbml0bGVzcyAqIHBpeGVsSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodCwgeyBmaWxsU3R5bGU6IGlndi5yYW5kb21SR0IoNjQsIDI1NSkgfSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRpc3BsYXk9PT0nbGluZScpe1xyXG5cdCAgICAgICAgICAgICAgICAgaWYgKHNlbGYucHJldl9jb29yZHMueCl7XHJcblx0ICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCx4LHksc2VsZi5wcmV2X2Nvb3Jkcy54LHNlbGYucHJldl9jb29yZHMueSx7XCJzdHJva2VTdHlsZVwiOmNvbG9yLFwibGluZVdpZHRoXCI6M30pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzZWxmLnByZXZfY29vcmRzLng9eDtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy55PXk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHQgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBjb2xvcn0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIFx0XHJcblxyXG5cdCAgICAgICAgICAgIFx0XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZmVhdHVyZXMpIHtcclxuICAgICAgICBcdFx0dmFyIG1pbiA9IDAsXHJcbiAgICAgICAgICAgIFx0bWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgXHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgZi52YWx1ZSk7XHJcbiAgICAgICAgICAgXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBmLnZhbHVlKTtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcdHJldHVybiB7bWluOiBtaW4sIG1heDogbWF4fTtcclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHRcdGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIChhID4gMCAmJiBiIDwgMCB8fCBhIDwgMCAmJiBiID4gMCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgXHRcdHRoaXMuYm90dG9tPXlfb2Zmc2V0K3BpeGVsSGVpZ2h0O1xyXG4gICAgXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGVsc2V7XHJcbiAgICBcdFx0XHR0aGlzLnRvcD0wO1xyXG4gICAgXHRcdFx0dGhpcy5ib3R0b209MDtcclxuICAgXHRcdFx0fVxyXG5cclxuXHQgICAgXHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wiYmlnd2lnXCJdPXtcclxuXHRcImNsYXNzXCI6TUxWV2lnVHJhY2ssXHJcblx0bmFtZTpcIkJpZ1dpZ1wiXHJcbn1cclxuXHJcblxyXG4gY2xhc3MgTGluZVRyYWNrIGV4dGVuZHMgTUxWV2lnVHJhY2t7XHJcblx0IGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHQgc3VwZXIoY29uZmlnKTtcclxuXHRcdCB0aGlzLmlzX2xpbmU9dHJ1ZTtcclxuXHQgfVxyXG5cdCBcclxuXHQgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cdFx0IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdCBmdWxmaWxsKFtdKTtcclxuXHQgICAgIH0pO1xyXG5cdCB9XHJcblx0IFxyXG5cdCBcclxuIH1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wibGluZVwiXT17XHJcblx0XCJjbGFzc1wiOkxpbmVUcmFjayxcclxuXHRuYW1lOlwiTGluZSBUcmFja1wiXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlcXVlbmNlVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpIFxyXG4gICAgICAgIHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZSA9IGNvbmZpZy5zZXF1ZW5jZVR5cGUgfHwgXCJkbmFcIjsgIFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKXtcclxuICAgIFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy51cmwpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYnBQZXJQaXhlbCA+IDEvKmlndi5icm93c2VyLnRyYWNrVmlld3BvcnRXaWR0aEJQKCkgPiAzMDAwMCovKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlX3NvdXJjZS5nZXRTZXF1ZW5jZShjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIGxlbiwgdywgeSwgcG9zLCBvZmZzZXQsIGIsIHAwLCBwMSwgcGMsIGM7XHJcblxyXG4gICAgICAgIGxldCB5X3BvczE9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgbGV0IHlfcG9zMj15X3BvczErNTtcclxuXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICBsZW4gPSBzZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHcgPSAxIC8gYnBQZXJQaXhlbDtcclxuXHJcbiAgICAgICAgICAgIHkgPSB5X3BvczErdGhpcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IGJwU3RhcnQ7IHBvcyA8PSBicEVuZDsgcG9zKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBicFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNlcXVlbmNlLmNoYXJBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZXF1ZW5jZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAwID0gTWF0aC5mbG9vcihvZmZzZXQgKiB3KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IE1hdGguZmxvb3IoKG9mZnNldCArIDEpICogdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMgPSBNYXRoLnJvdW5kKChwMCArIHAxKSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkbmFcIiA9PT0gdGhpcy5zZXF1ZW5jZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXCJyZ2IoMCwgMCwgMTUwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSBjID0gXCJncmF5XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsID4wLjE1KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHAwLCB5X3BvczEsIHAxIC0gcDAsIDEwLCB7ZmlsbFN0eWxlOiBjfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIGIsIHBjLCB5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdub3JtYWwgMTBweCBBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgcmV0dXJuIHlfcG9zMSsxMDtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJmYXN0YVwiXT17XHJcblx0XCJjbGFzc1wiOlNlcXVlbmNlVHJhY2ssXHJcblx0bmFtZTpcIkZhc3RhXCJcclxufVxyXG5cclxuXHJcblxyXG4vLyoqKioqKipqcy9pZnYtY2FudmFzLmpzKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jbGFzcyBHcmFwaGljc3tcclxuXHJcblxyXG4gICAgICAgc3RhdGljIHNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlTGluZSAoY3R4LCB4MSwgeTEsIHgyLCB5MiwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKHgxKSArIDAuNTtcclxuICAgICAgICAgICAgeTEgPSBNYXRoLmZsb29yKHkxKSArIDAuNTtcclxuICAgICAgICAgICAgeDIgPSBNYXRoLmZsb29yKHgyKSArIDAuNTtcclxuICAgICAgICAgICAgeTIgPSBNYXRoLmZsb29yKHkyKSArIDAuNTtcclxuXHJcbiAgICAgICAgICAgIC8vbG9nKFwic3Ryb2tlIGxpbmUsIHByb3A6IFwiICsgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxSZWN0KGN0eCwgeCwgeSwgdywgaCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsUG9seWdvbihjdHgsIHgsIHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5kb1BhdGgoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VQb2x5Z29uKGN0eCwgeCwgeSwgcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmRvUGF0aChjdHgsIHgsIHkpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZmlsbFRleHQoY3R4LCB0ZXh0LCB4LCB5LCBwcm9wZXJ0aWVzLCB0cmFuc2Zvcm1zKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRyYW5zZm9ybSBpbiB0cmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBZGQgZXJyb3IgY2hlY2tpbmcgZm9yIHJvYnVzdG5lc3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICd0cmFuc2xhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodmFsdWVbJ3gnXSwgdmFsdWVbJ3knXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0gPT0gJ3JvdGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSh2YWx1ZVsnYW5nbGUnXSAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VUZXh0KGN0eCwgdGV4dCwgeCwgeSwgcHJvcGVydGllcywgdHJhbnNmb3Jtcykge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRyYW5zZm9ybSBpbiB0cmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3Jtc1t0cmFuc2Zvcm1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBZGQgZXJyb3IgY2hlY2tpbmcgZm9yIHJvYnVzdG5lc3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICd0cmFuc2xhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodmFsdWVbJ3gnXSwgdmFsdWVbJ3knXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0gPT0gJ3JvdGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSh2YWx1ZVsnYW5nbGUnXSAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBzdHJva2VDaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMpIHtcclxuXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxDaXJjbGUgKGN0eCwgeCwgeSwgcmFkaXVzKSB7XHJcblxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZHJhd0Fycm93aGVhZChjdHgsIHgsIHksIHNpemUsIGxpbmVXaWR0aCkge1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5IC0gc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBzaXplIC8gMik7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHNpemUsIHkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgLSBzaXplIC8gMik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBkYXNoZWRMaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIsIGRhc2hMZW4sIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgeDEgPSBNYXRoLnJvdW5kKHgxKTtcclxuICAgICAgICAgICAgeTEgPSBNYXRoLnJvdW5kKHkxKTtcclxuICAgICAgICAgICAgeDIgPSBNYXRoLnJvdW5kKHgyKTtcclxuICAgICAgICAgICAgeTIgPSBNYXRoLnJvdW5kKHkyKTtcclxuICAgICAgICAgICAgZGFzaExlbiA9IE1hdGgucm91bmQoZGFzaExlbik7XHJcbiAgICAgICAgICAgIGxvZyhcImRhc2hlZExpbmVcIik7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGFzaExlbiA9PSB1bmRlZmluZWQpIGRhc2hMZW4gPSAyO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZFggPSB4MiAtIHgxO1xyXG4gICAgICAgICAgICB2YXIgZFkgPSB5MiAtIHkxO1xyXG4gICAgICAgICAgICB2YXIgZGFzaGVzID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpIC8gZGFzaExlbik7XHJcbiAgICAgICAgICAgIHZhciBkYXNoWCA9IGRYIC8gZGFzaGVzO1xyXG4gICAgICAgICAgICB2YXIgZGFzaFkgPSBkWSAvIGRhc2hlcztcclxuXHJcbiAgICAgICAgICAgIHZhciBxID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHErKyA8IGRhc2hlcykge1xyXG4gICAgICAgICAgICAgICAgeDEgKz0gZGFzaFg7XHJcbiAgICAgICAgICAgICAgICB5MSArPSBkYXNoWTtcclxuICAgICAgICAgICAgICAgIGN0eFtxICUgMiA9PSAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oeDEsIHkxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHhbcSAlIDIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHgyLCB5Mik7XHJcblxyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgXHJcblxyXG4gICAgICAgIHN0YXRpYyBkb1BhdGgoY3R4LCB4LCB5KSB7XHJcblxyXG5cclxuICAgICAgICBcdHZhciBpLCBsZW4gPSB4Lmxlbmd0aDtcclxuICAgICAgICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIFx0XHR4W2ldID0gTWF0aC5yb3VuZCh4W2ldKTtcclxuICAgICAgICBcdFx0eVtpXSA9IE1hdGgucm91bmQoeVtpXSk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIFx0Y3R4Lm1vdmVUbyh4WzBdLCB5WzBdKTtcclxuICAgICAgICBcdGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIFx0XHRjdHgubGluZVRvKHhbaV0sIHlbaV0pO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0Y3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuXHJcbn1cclxuXHJcbkdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnM9e1xyXG5cdFwiQVwiOlwiZ3JlZW5cIixcclxuXHRcIlRcIjpcInJlZFwiLFxyXG5cdFwiR1wiOlwiYmxhY2tcIixcclxuXHRcIkNcIjpcImJsdWVcIixcclxuXHRcImFcIjpcImdyZWVuXCIsXHJcblx0XCJ0XCI6XCJyZWRcIixcclxuXHRcImNcIjpcImJsYWNrXCIsXHJcblx0XCJnXCI6XCJibHVlXCJcclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtNTFZUcmFjayxNTFZXaWdUcmFjayxNTFZCZWRUcmFjayxSdWxlclRyYWNrLE1MVkJpZ0JlZFRyYWNrLEdyYXBoaWNzfSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7O0FBY0E7OztBQVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFqS0E7QUFDQTtBQW9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUF6VUE7QUFDQTtBQTRVQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBUEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQVNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRkE7QUFDQTtBQUVBO0FBSEE7QUFJQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBdE9BO0FBQ0E7QUEwT0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFWQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQU9BOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQXJGQTtBQUNBO0FBeUZBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBVEE7QUFVQTs7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/tracks.js\n");

/***/ }),

/***/ "../MLVPanel/src/utils.js":
/*!***************************!*\
  !*** .Panel/src/utils.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\nvar parseUri_options = {\n    strictMode: false,\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n        name: \"queryKey\",\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n};\n\nvar Utils = function () {\n    function Utils() {\n        _classCallCheck(this, Utils);\n    }\n\n    _createClass(Utils, null, [{\n        key: \"addAlphaToRGB\",\n        value: function addAlphaToRGB(rgbString, alpha) {\n\n            if (rgbString.startsWith(\"rgb\")) {\n                return rgbString.replace(\"rgb\", \"rgba\").replace(\")\", \", \" + alpha + \")\");\n            } else {\n                console.log(rgbString + \" is not an rgb style string\");\n                return rgbString;\n            }\n        }\n    }, {\n        key: \"presentAlert\",\n        value: function presentAlert(track_div, error) {\n            var div = $(\"<div>\").css({ \"position\": \"absolute\", \"background-color\": \"white\" }).attr(\"class\", \"mlv-alert\").appendTo(track_div);\n            var div1 = $(\"<div>\").css({ \"display\": \"flex\", \"justify-content\": \"center\" }).appendTo(div);\n            div1.append($('<i class=\"fas fa-exclamation-circle\"></i>').css({ color: \"red\", \"font-size\": \"16px\", \"text-align\": \"center\" }));\n            div.append($(\"<div>\" + error + \"</div>\").css({ color: \"red\", \"font-size\": \"14px\", \"text-align\": \"center\" }));\n            var left = Math.round(track_div.width() / 2 - div.width() / 2);\n            var top = Math.round(track_div.height() / 2 - div.height() / 2);\n            div.css({ \"left\": left + \"px\", top: top + \"px\" });\n        }\n    }, {\n        key: \"spinner\",\n        value: function spinner(size) {\n\n            // spinner\n            var $container, $spinner;\n\n            $spinner = $('<i class=\"fa fa-lg fa-spinner fa-spin igv-spinner\">').css({ position: \"absolute\", top: \"50%\", left: \"50%\" });\n            if (size) {\n                $spinner.css(\"font-size\", size);\n            }\n\n            return $spinner[0];\n        }\n\n        /**\r\n         * Find spinner\r\n         */\n\n    }, {\n        key: \"getSpinnerObjectWithParentElement\",\n        value: function getSpinnerObjectWithParentElement(parentElement) {\n            return parentElement.find(\"div.igv-spinner-container\");\n        }\n    }, {\n        key: \"startSpinnerAtParentElement\",\n\n\n        /**\r\n         * Start the spinner for the parent element, if it has one\r\n         */\n        value: function startSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").show();\n        }\n    }, {\n        key: \"stopSpinnerAtParentElement\",\n\n\n        /**\r\n         * Stop the spinner for the parent element, if it has one\r\n         * @param parentElement\r\n         */\n        value: function stopSpinnerAtParentElement(parentElement) {\n            parentElement.children(\".fa-spinner\").hide();\n        }\n    }, {\n        key: \"parseUri\",\n        value: function parseUri(str) {\n\n            var o = parseUri_options,\n                m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\n                uri = {},\n                i = 14;\n\n            while (i--) {\n                uri[o.key[i]] = m[i] || \"\";\n            }uri[o.q.name] = {};\n            uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n                if ($1) uri[o.q.name][$1] = $2;\n            });\n\n            return uri;\n        }\n    }, {\n        key: \"domElementRectAsString\",\n        value: function domElementRectAsString(element) {\n            return \" x \" + element.clientLeft + \" y \" + element.clientTop + \" w \" + element.clientWidth + \" h \" + element.clientHeight;\n        }\n    }, {\n        key: \"isNumber\",\n        value: function isNumber(n) {\n\n            if (\"\" === n) {\n\n                return false;\n            } else if (undefined === n) {\n\n                return false;\n            } else {\n\n                return !isNaN(parseFloat(n)) && isFinite(n);\n            }\n        }\n    }, {\n        key: \"guid\",\n        value: function guid() {\n            return (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n        }\n    }, {\n        key: \"random\",\n\n\n        // Returns a random number between min (inclusive) and max (exclusive)\n        value: function random(min, max) {\n            return Math.random() * (max - min) + min;\n        }\n    }, {\n        key: \"numberFormatter\",\n\n\n        // StackOverflow: http://stackoverflow.com/a/10810674/116169\n        value: function numberFormatter(rawNumber) {\n\n            var dec = String(rawNumber).split(/[.,]/),\n                sep = ',',\n                decsep = '.';\n\n            return dec[0].split('').reverse().reduce(function (prev, now, i) {\n                return i % 3 === 0 ? prev + sep + now : prev + now;\n            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');\n        }\n    }, {\n        key: \"numberUnFormatter\",\n        value: function numberUnFormatter(formatedNumber) {\n\n            return formatedNumber.split(\",\").join().replace(\",\", \"\", \"g\");\n        }\n    }, {\n        key: \"translateMouseCoordinates\",\n\n\n        /**\r\n         * Translate the mouse coordinates for the event to the coordinates for the given target element\r\n         * @param e\r\n         * @param target\r\n         * @returns {{x: number, y: number}}\r\n         */\n        value: function translateMouseCoordinates(e, target) {\n\n            var eFixed = $.event.fix(e),\n                // Sets pageX and pageY for browsers that don't support them\n            posx = eFixed.pageX - $(target).offset().left,\n                posy = eFixed.pageY - $(target).offset().top;\n\n            return { x: posx, y: posy };\n        }\n    }, {\n        key: \"formatPopoverText\",\n\n\n        /**\r\n         * Format markup for popover text from an array of name value pairs [{name, value}]\r\n         */\n        value: function formatPopoverText(nameValueArray) {\n\n            var markup = \"<table class=\\\"igv-popover-table\\\">\";\n\n            nameValueArray.forEach(function (nameValue) {\n\n                if (nameValue.name) {\n                    //markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</td></tr>\";\n                    markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<div class=\\\"igv-popoverNameValue\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</div>\" + \"</td></tr>\";\n                } else {\n                    // not a name/value pair\n                    markup += \"<tr><td>\" + nameValue.toString() + \"</td></tr>\";\n                }\n            });\n\n            markup += \"</table>\";\n            return markup;\n        }\n    }, {\n        key: \"throttle\",\n        value: function throttle(fn, threshhold, scope) {\n            threshhold || (threshhold = 200);\n            var last, deferTimer;\n\n            return function () {\n                var context = scope || this;\n\n                var now = +new Date(),\n                    args = arguments;\n                if (last && now < last + threshhold) {\n                    // hold on to it\n                    clearTimeout(deferTimer);\n                    deferTimer = setTimeout(function () {\n                        last = now;\n                        fn.apply(context, args);\n                    }, threshhold);\n                } else {\n                    last = now;\n                    fn.apply(context, args);\n                }\n            };\n        }\n    }, {\n        key: \"splitStringRespectingQuotes\",\n        value: function splitStringRespectingQuotes(string, delim) {\n\n            var tokens = [],\n                len = string.length,\n                i,\n                n = 0,\n                quote = false,\n                c;\n\n            if (len > 0) {\n\n                tokens[n] = string.charAt(0);\n                for (i = 1; i < len; i++) {\n                    c = string.charAt(i);\n                    if (c === '\"') {\n                        quote = !quote;\n                    } else if (!quote && c === delim) {\n                        n++;\n                        tokens[n] = \"\";\n                    } else {\n                        tokens[n] += c;\n                    }\n                }\n            }\n            return tokens;\n        }\n    }, {\n        key: \"addAjaxExtensions\",\n\n\n        /**\r\n         * Extend jQuery's ajax function to handle binary requests.   Credit to Henry Algus:\r\n         *\r\n         * http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/\r\n         */\n        value: function addAjaxExtensions() {\n\n            // use this transport for \"binary\" data type\n            $.ajaxTransport(\"+binary\", function (options, originalOptions, jqXHR) {\n\n                return {\n                    // create new XMLHttpRequest\n                    send: function send(_, callback) {\n                        // setup all variables\n                        var xhr = new XMLHttpRequest(),\n                            url = options.url,\n                            type = options.type,\n                            responseType = \"arraybuffer\",\n                            data = options.data || null;\n\n                        xhr.addEventListener('load', function () {\n                            var data = {};\n                            data[options.dataType] = xhr.response;\n                            // make callback and send data\n                            callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());\n                        });\n\n                        xhr.open(type, url);\n                        xhr.responseType = responseType;\n\n                        if (options.headers) {\n                            for (var prop in options.headers) {\n                                if (options.headers.hasOwnProperty(prop)) {\n                                    xhr.setRequestHeader(prop, options.headers[prop]);\n                                }\n                            }\n                        }\n\n                        // TODO -- set any other options values\n                    },\n                    abort: function abort() {\n                        jqXHR.abort();\n                    }\n                };\n            });\n        }\n    }, {\n        key: \"isStringOrNumber\",\n\n\n        /**\r\n         * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.\r\n         *\r\n         * @param value\r\n         * @returns boolean\r\n         */\n        value: function isStringOrNumber(value) {\n            return value.substring || value.toFixed ? true : false;\n        }\n    }, {\n        key: \"constrainBBox\",\n        value: function constrainBBox($child, $parent) {\n\n            var delta,\n                topLeft,\n                bboxChild = {},\n                bboxParent = {};\n\n            bboxParent.left = bboxParent.top = 0;\n            bboxParent.right = $parent.outerWidth();\n            bboxParent.bottom = $parent.outerHeight();\n\n            topLeft = $child.offset();\n\n            bboxChild.left = topLeft.left - $parent.offset().left;\n            bboxChild.top = topLeft.top - $parent.offset().top;\n            bboxChild.right = bboxChild.left + $child.outerWidth();\n            bboxChild.bottom = bboxChild.top + $child.outerHeight();\n\n            delta = bboxChild.bottom - bboxParent.bottom;\n            if (delta > 0) {\n\n                // clamp to trackContainer bottom\n                topLeft.top -= delta;\n\n                bboxChild.top -= delta;\n                bboxChild.bottom -= delta;\n\n                delta = bboxChild.top - bboxParent.top;\n                if (delta < 0) {\n                    topLeft.top -= delta;\n                }\n            }\n\n            return topLeft;\n        }\n    }, {\n        key: \"log\",\n        value: function log(message) {\n            if (igv.enableLogging && console && console.log) {\n                console.log(message);\n            }\n        }\n    }]);\n\n    return Utils;\n}();\n\nexports.Utils = Utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy91dGlscy5qcz81NDZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5sZXQgcGFyc2VVcmlfb3B0aW9ucyA9IHtcclxuICAgICAgICBzdHJpY3RNb2RlOiBmYWxzZSxcclxuICAgICAgICBrZXk6IFtcInNvdXJjZVwiLCBcInByb3RvY29sXCIsIFwiYXV0aG9yaXR5XCIsIFwidXNlckluZm9cIiwgXCJ1c2VyXCIsIFwicGFzc3dvcmRcIiwgXCJob3N0XCIsIFwicG9ydFwiLCBcInJlbGF0aXZlXCIsIFwicGF0aFwiLCBcImRpcmVjdG9yeVwiLCBcImZpbGVcIiwgXCJxdWVyeVwiLCBcImFuY2hvclwiXSxcclxuICAgICAgICBxOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwicXVlcnlLZXlcIixcclxuICAgICAgICAgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcnNlcjoge1xyXG4gICAgICAgICAgICBzdHJpY3Q6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXHJcbiAgICAgICAgICAgIGxvb3NlOiAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShbXjpcXC8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5jbGFzcyBVdGlsc3tcclxuXHJcbiAgICBcclxuICAgIHN0YXRpYyBhZGRBbHBoYVRvUkdCKHJnYlN0cmluZywgYWxwaGEpIHtcclxuXHJcbiAgICAgICAgaWYgKHJnYlN0cmluZy5zdGFydHNXaXRoKFwicmdiXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JTdHJpbmcucmVwbGFjZShcInJnYlwiLCBcInJnYmFcIikucmVwbGFjZShcIilcIiwgXCIsIFwiICsgYWxwaGEgKyBcIilcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmdiU3RyaW5nICsgXCIgaXMgbm90IGFuIHJnYiBzdHlsZSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JTdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcHJlc2VudEFsZXJ0KHRyYWNrX2RpdixlcnJvcil7XHJcbiAgICAgICAgbGV0IGRpdj0gJChcIjxkaXY+XCIpLmNzcyh7XCJwb3NpdGlvblwiOlwiYWJzb2x1dGVcIixcImJhY2tncm91bmQtY29sb3JcIjpcIndoaXRlXCJ9KS5hdHRyKFwiY2xhc3NcIixcIm1sdi1hbGVydFwiKS5hcHBlbmRUbyh0cmFja19kaXYpO1xyXG4gICAgICAgIGxldCBkaXYxPSAkKFwiPGRpdj5cIikuY3NzKHtcImRpc3BsYXlcIjpcImZsZXhcIixcImp1c3RpZnktY29udGVudFwiOlwiY2VudGVyXCJ9KS5hcHBlbmRUbyhkaXYpO1xyXG4gICAgICAgIGRpdjEuYXBwZW5kKCQoJzxpIGNsYXNzPVwiZmFzIGZhLWV4Y2xhbWF0aW9uLWNpcmNsZVwiPjwvaT4nKS5jc3Moe2NvbG9yOlwicmVkXCIsXCJmb250LXNpemVcIjpcIjE2cHhcIixcInRleHQtYWxpZ25cIjpcImNlbnRlclwiLH0pKTtcclxuICAgICAgICBkaXYuYXBwZW5kKCQoXCI8ZGl2PlwiK2Vycm9yK1wiPC9kaXY+XCIpLmNzcyh7Y29sb3I6XCJyZWRcIixcImZvbnQtc2l6ZVwiOlwiMTRweFwiLFwidGV4dC1hbGlnblwiOlwiY2VudGVyXCJ9KSk7XHJcbiAgICAgICAgbGV0IGxlZnQgPSBNYXRoLnJvdW5kKCh0cmFja19kaXYud2lkdGgoKS8yKS0oZGl2LndpZHRoKCkvMikpO1xyXG4gICAgICAgIGxldCB0b3AgPU1hdGgucm91bmQoKHRyYWNrX2Rpdi5oZWlnaHQoKS8yKS0oZGl2LmhlaWdodCgpLzIpKTtcclxuICAgICAgICBkaXYuY3NzKHtcImxlZnRcIjpsZWZ0K1wicHhcIix0b3A6dG9wK1wicHhcIn0pO1xyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgIFxyXG5cclxuICAgIHN0YXRpYyBzcGlubmVyKHNpemUpIHtcclxuXHJcbiAgICAgICAgLy8gc3Bpbm5lclxyXG4gICAgICAgIHZhciAkY29udGFpbmVyLFxyXG4gICAgICAgICAgICAkc3Bpbm5lcjtcclxuXHJcbiAgICAgICAgJHNwaW5uZXIgPSAkKCc8aSBjbGFzcz1cImZhIGZhLWxnIGZhLXNwaW5uZXIgZmEtc3BpbiBpZ3Ytc3Bpbm5lclwiPicpLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjUwJVwiLGxlZnQ6XCI1MCVcIn0pO1xyXG4gICAgICAgIGlmIChzaXplKSB7XHJcbiAgICAgICAgICAgICRzcGlubmVyLmNzcyhcImZvbnQtc2l6ZVwiLCBzaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgXHJcblxyXG4gICAgICAgIHJldHVybiAkc3Bpbm5lclswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgc3Bpbm5lclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U3Bpbm5lck9iamVjdFdpdGhQYXJlbnRFbGVtZW50KHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50RWxlbWVudC5maW5kKFwiZGl2Lmlndi1zcGlubmVyLWNvbnRhaW5lclwiKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0aGUgc3Bpbm5lciBmb3IgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBoYXMgb25lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdGFydFNwaW5uZXJBdFBhcmVudEVsZW1lbnQocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgcGFyZW50RWxlbWVudC5jaGlsZHJlbihcIi5mYS1zcGlubmVyXCIpLnNob3coKTsgIFxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBzcGlubmVyIGZvciB0aGUgcGFyZW50IGVsZW1lbnQsIGlmIGl0IGhhcyBvbmVcclxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdG9wU3Bpbm5lckF0UGFyZW50RWxlbWVudCAocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4oXCIuZmEtc3Bpbm5lclwiKS5oaWRlKCk7XHJcbiAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlVXJpKHN0cikge1xyXG5cclxuICAgICAgICB2YXIgbyA9IHBhcnNlVXJpX29wdGlvbnMsXHJcbiAgICAgICAgICAgIG0gPSBvLnBhcnNlcltvLnN0cmljdE1vZGUgPyBcInN0cmljdFwiIDogXCJsb29zZVwiXS5leGVjKHN0ciksXHJcbiAgICAgICAgICAgIHVyaSA9IHt9LFxyXG4gICAgICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pIHVyaVtvLmtleVtpXV0gPSBtW2ldIHx8IFwiXCI7XHJcblxyXG4gICAgICAgIHVyaVtvLnEubmFtZV0gPSB7fTtcclxuICAgICAgICB1cmlbby5rZXlbMTJdXS5yZXBsYWNlKG8ucS5wYXJzZXIsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XHJcbiAgICAgICAgICAgIGlmICgkMSkgdXJpW28ucS5uYW1lXVskMV0gPSAkMjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICBcclxuICAgIHN0YXRpYyBkb21FbGVtZW50UmVjdEFzU3RyaW5nKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gXCIgeCBcIiArIGVsZW1lbnQuY2xpZW50TGVmdCArIFwiIHkgXCIgKyBlbGVtZW50LmNsaWVudFRvcCArIFwiIHcgXCIgKyBlbGVtZW50LmNsaWVudFdpZHRoICsgXCIgaCBcIiArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgaXNOdW1iZXIobikge1xyXG5cclxuICAgICAgICBpZiAoXCJcIiA9PT0gbikge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIGlmICh1bmRlZmluZWQgPT09IG4pIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgZ3VpZCAgKCkge1xyXG4gICAgICAgIHJldHVybiAoXCIwMDAwXCIgKyAoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCA0KSA8PCAwKS50b1N0cmluZygzNikpLnNsaWNlKC00KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gKGluY2x1c2l2ZSkgYW5kIG1heCAoZXhjbHVzaXZlKVxyXG4gICAgc3RhdGljIHJhbmRvbShtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YWNrT3ZlcmZsb3c6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwODEwNjc0LzExNjE2OVxyXG4gICAgc3RhdGljIG51bWJlckZvcm1hdHRlcihyYXdOdW1iZXIpIHtcclxuXHJcbiAgICAgICAgdmFyIGRlYyA9IFN0cmluZyhyYXdOdW1iZXIpLnNwbGl0KC9bLixdLyksXHJcbiAgICAgICAgICAgIHNlcCA9ICcsJyxcclxuICAgICAgICAgICAgZGVjc2VwID0gJy4nO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVjWzBdLnNwbGl0KCcnKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBub3csIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICUgMyA9PT0gMCA/IHByZXYgKyBzZXAgKyBub3cgOiBwcmV2ICsgbm93O1xyXG4gICAgICAgICAgICB9KS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpICsgKGRlY1sxXSA/IGRlY3NlcCArIGRlY1sxXSA6ICcnKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIG51bWJlclVuRm9ybWF0dGVyIChmb3JtYXRlZE51bWJlcikge1xyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0ZWROdW1iZXIuc3BsaXQoXCIsXCIpLmpvaW4oKS5yZXBsYWNlKFwiLFwiLCBcIlwiLCBcImdcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIHRoZSBtb3VzZSBjb29yZGluYXRlcyBmb3IgdGhlIGV2ZW50IHRvIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gZVxyXG4gICAgICogQHBhcmFtIHRhcmdldFxyXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2xhdGVNb3VzZUNvb3JkaW5hdGVzKGUsIHRhcmdldCkge1xyXG5cclxuICAgICAgICB2YXIgZUZpeGVkID0gJC5ldmVudC5maXgoZSksICAgLy8gU2V0cyBwYWdlWCBhbmQgcGFnZVkgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGVtXHJcbiAgICAgICAgICAgIHBvc3ggPSBlRml4ZWQucGFnZVggLSAkKHRhcmdldCkub2Zmc2V0KCkubGVmdCxcclxuICAgICAgICAgICAgcG9zeSA9IGVGaXhlZC5wYWdlWSAtICQodGFyZ2V0KS5vZmZzZXQoKS50b3A7XHJcblxyXG4gICAgICAgIHJldHVybiB7eDogcG9zeCwgeTogcG9zeX1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0IG1hcmt1cCBmb3IgcG9wb3ZlciB0ZXh0IGZyb20gYW4gYXJyYXkgb2YgbmFtZSB2YWx1ZSBwYWlycyBbe25hbWUsIHZhbHVlfV1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZvcm1hdFBvcG92ZXJUZXh0IChuYW1lVmFsdWVBcnJheSkge1xyXG5cclxuICAgICAgICB2YXIgbWFya3VwID0gXCI8dGFibGUgY2xhc3M9XFxcImlndi1wb3BvdmVyLXRhYmxlXFxcIj5cIjtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobmFtZVZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZVZhbHVlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vbWFya3VwICs9IFwiPHRyPjx0ZCBjbGFzcz1cXFwiaWd2LXBvcG92ZXItdGRcXFwiPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJOYW1lXFxcIj5cIiArIG5hbWVWYWx1ZS5uYW1lICsgXCI8L3NwYW4+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3ZlclZhbHVlXFxcIj5cIiArIG5hbWVWYWx1ZS52YWx1ZSArIFwiPC9zcGFuPlwiICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgICAgICBtYXJrdXAgKz0gXCI8dHI+PHRkIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlci10ZFxcXCI+XCIgKyBcIjxkaXYgY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVZhbHVlXFxcIj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVxcXCI+XCIgKyBuYW1lVmFsdWUubmFtZSArIFwiPC9zcGFuPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJWYWx1ZVxcXCI+XCIgKyBuYW1lVmFsdWUudmFsdWUgKyBcIjwvc3Bhbj5cIiArIFwiPC9kaXY+XCIgKyBcIjwvdGQ+PC90cj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIG5hbWUvdmFsdWUgcGFpclxyXG4gICAgICAgICAgICAgICAgbWFya3VwICs9IFwiPHRyPjx0ZD5cIiArIG5hbWVWYWx1ZS50b1N0cmluZygpICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWFya3VwICs9IFwiPC90YWJsZT5cIjtcclxuICAgICAgICByZXR1cm4gbWFya3VwO1xyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyB0aHJvdHRsZShmbiwgdGhyZXNoaG9sZCwgc2NvcGUpIHtcclxuICAgICAgICB0aHJlc2hob2xkIHx8ICh0aHJlc2hob2xkID0gMjAwKTtcclxuICAgICAgICB2YXIgbGFzdCwgZGVmZXJUaW1lcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzY29wZSB8fCB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSxcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIG5vdyA8IGxhc3QgKyB0aHJlc2hob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBob2xkIG9uIHRvIGl0XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XHJcbiAgICAgICAgICAgICAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0sIHRocmVzaGhvbGQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgc3BsaXRTdHJpbmdSZXNwZWN0aW5nUXVvdGVzKHN0cmluZywgZGVsaW0pIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VucyA9IFtdLFxyXG4gICAgICAgICAgICBsZW4gPSBzdHJpbmcubGVuZ3RoLFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBuID0gMCxcclxuICAgICAgICAgICAgcXVvdGUgPSBmYWxzZSxcclxuICAgICAgICAgICAgYztcclxuXHJcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIHRva2Vuc1tuXSA9IHN0cmluZy5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYyA9IHN0cmluZy5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gIXF1b3RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1b3RlICYmIGMgPT09IGRlbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tuXSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbbl0gKz0gYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBqUXVlcnkncyBhamF4IGZ1bmN0aW9uIHRvIGhhbmRsZSBiaW5hcnkgcmVxdWVzdHMuICAgQ3JlZGl0IHRvIEhlbnJ5IEFsZ3VzOlxyXG4gICAgICpcclxuICAgICAqIGh0dHA6Ly93d3cuaGVucnlhbGd1cy5jb20vcmVhZGluZy1iaW5hcnktZmlsZXMtdXNpbmctanF1ZXJ5LWFqYXgvXHJcbiAgICAgKi9cclxuICAgc3RhdGljIGFkZEFqYXhFeHRlbnNpb25zICgpIHtcclxuXHJcbiAgICAgICAgLy8gdXNlIHRoaXMgdHJhbnNwb3J0IGZvciBcImJpbmFyeVwiIGRhdGEgdHlwZVxyXG4gICAgICAgICQuYWpheFRyYW5zcG9ydChcIitiaW5hcnlcIiwgZnVuY3Rpb24gKG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoXywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBhbGwgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBvcHRpb25zLnVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29wdGlvbnMuZGF0YVR5cGVdID0geGhyLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGNhbGxiYWNrIGFuZCBzZW5kIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIGRhdGEsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKHR5cGUsIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMuaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3AsIG9wdGlvbnMuaGVhZGVyc1twcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gc2V0IGFueSBvdGhlciBvcHRpb25zIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcgb3IgbnVtYmVyLiAgTm90IHVzaW5nIHR5cGVvZiBhcyBpdCBmYWlscyBvbiBib3hlZCBwcmltaXRpdmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMgYm9vbGVhblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNTdHJpbmdPck51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUuc3Vic3RyaW5nIHx8IHZhbHVlLnRvRml4ZWQpID8gdHJ1ZSA6IGZhbHNlXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBjb25zdHJhaW5CQm94KCRjaGlsZCwgJHBhcmVudCkge1xyXG5cclxuICAgICAgICB2YXIgZGVsdGEsXHJcbiAgICAgICAgICAgIHRvcExlZnQsXHJcbiAgICAgICAgICAgIGJib3hDaGlsZCA9IHt9LFxyXG4gICAgICAgICAgICBiYm94UGFyZW50ID0ge307XHJcblxyXG4gICAgICAgIGJib3hQYXJlbnQubGVmdCA9IGJib3hQYXJlbnQudG9wID0gMDtcclxuICAgICAgICBiYm94UGFyZW50LnJpZ2h0ID0gJHBhcmVudC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgYmJveFBhcmVudC5ib3R0b20gPSAkcGFyZW50Lm91dGVySGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIHRvcExlZnQgPSAkY2hpbGQub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgIGJib3hDaGlsZC5sZWZ0ID0gdG9wTGVmdC5sZWZ0IC0gJHBhcmVudC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgIGJib3hDaGlsZC50b3AgPSB0b3BMZWZ0LnRvcCAtICRwYXJlbnQub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgIGJib3hDaGlsZC5yaWdodCA9IGJib3hDaGlsZC5sZWZ0ICsgJGNoaWxkLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBiYm94Q2hpbGQuYm90dG9tID0gYmJveENoaWxkLnRvcCArICRjaGlsZC5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICBkZWx0YSA9IGJib3hDaGlsZC5ib3R0b20gLSBiYm94UGFyZW50LmJvdHRvbTtcclxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjbGFtcCB0byB0cmFja0NvbnRhaW5lciBib3R0b21cclxuICAgICAgICAgICAgdG9wTGVmdC50b3AgLT0gZGVsdGE7XHJcblxyXG4gICAgICAgICAgICBiYm94Q2hpbGQudG9wIC09IGRlbHRhO1xyXG4gICAgICAgICAgICBiYm94Q2hpbGQuYm90dG9tIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgZGVsdGEgPSBiYm94Q2hpbGQudG9wIC0gYmJveFBhcmVudC50b3A7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRvcExlZnQudG9wIC09IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRvcExlZnQ7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgbG9nKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaWd2LmVuYWJsZUxvZ2dpbmcgJiYgY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7VXRpbHN9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFQQTtBQUNBO0FBY0E7Ozs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7QUFHQTtBQUNBO0FBRUE7Ozs7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFFQTs7Ozs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBbUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/utils.js\n");

/***/ }),

/***/ "../MLVPanel/src/vendor/inflate.js":
/*!************************************!*\
  !*** .Panel/src/vendor/inflate.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS = 15; // 32K LZ77 window\nvar DEF_WBITS = MAX_WBITS;\nvar MAX_MEM_LEVEL = 9;\nvar MANY = 1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT = 0x20;\n\nvar Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\n\nvar Z_DEFLATED = 8;\n\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\nvar Z_ERRNO = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\nvar Z_VERSION_ERROR = -6;\n\nvar METHOD = 0; // waiting for method byte\nvar FLAG = 1; // waiting for flag byte\nvar DICT4 = 2; // four dictionary check bytes to go\nvar DICT3 = 3; // three dictionary check bytes to go\nvar DICT2 = 4; // two dictionary check bytes to go\nvar DICT1 = 5; // one dictionary check byte to go\nvar DICT0 = 6; // waiting for inflateSetDictionary\nvar BLOCKS = 7; // decompressing blocks\nvar CHECK4 = 8; // four check bytes to go\nvar CHECK3 = 9; // three check bytes to go\nvar CHECK2 = 10; // two check bytes to go\nvar CHECK1 = 11; // one check byte to go\nvar DONE = 12; // finished check, done\nvar BAD = 13; // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE = 0; // get type bits (3, including end bit)\nvar IB_LENS = 1; // get lengths for stored\nvar IB_STORED = 2; // processing stored block\nvar IB_TABLE = 3; // get table lengths\nvar IB_BTREE = 4; // get bit lengths tree for a dynamic block\nvar IB_DTREE = 5; // get length, distance trees for a dynamic block\nvar IB_CODES = 6; // processing fixed or dynamic block\nvar IB_DRY = 7; // output remaining window bytes\nvar IB_DONE = 8; // finished last block, done\nvar IB_BAD = 9; // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255];\nvar fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577];\n\n// Tables for deflate from PKZIP's appnote.txt.\nvar cplens = [// Copy lengths for literal codes 257..285\n3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\n\n// see note #13 above about 258\nvar cplext = [// Extra bits for literal codes 257..285\n0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n];\n\nvar cpdist = [// Copy offsets for distance codes 0..29\n1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n\nvar cpdext = [// Extra bits for distance codes\n0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {}\n\nZStream.prototype.inflateInit = function (w, nowrap) {\n  if (!w) {\n    w = DEF_WBITS;\n  }\n  if (nowrap) {\n    nowrap = false;\n  }\n  this.istate = new Inflate();\n  return this.istate.inflateInit(this, nowrap ? -w : w);\n};\n\nZStream.prototype.inflate = function (f) {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  return this.istate.inflate(this, f);\n};\n\nZStream.prototype.inflateEnd = function () {\n  if (this.istate == null) return Z_STREAM_ERROR;\n  var ret = istate.inflateEnd(this);\n  this.istate = null;\n  return ret;\n};\nZStream.prototype.inflateSync = function () {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSync(this);\n};\nZStream.prototype.inflateSetDictionary = function (dictionary, dictLength) {\n  // if(istate == null) return Z_STREAM_ERROR;\n  return istate.inflateSetDictionary(this, dictionary, dictLength);\n};\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n  this.was = [0];\n}\n\nInflate.prototype.inflateReset = function (z) {\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n\n  z.total_in = z.total_out = 0;\n  z.msg = null;\n  z.istate.mode = z.istate.nowrap != 0 ? BLOCKS : METHOD;\n  z.istate.blocks.reset(z, null);\n  return Z_OK;\n};\n\nInflate.prototype.inflateEnd = function (z) {\n  if (this.blocks != null) this.blocks.free(z);\n  this.blocks = null;\n  return Z_OK;\n};\n\nInflate.prototype.inflateInit = function (z, w) {\n  z.msg = null;\n  this.blocks = null;\n\n  // handle undocumented nowrap option (no zlib header or check)\n  var nowrap = 0;\n  if (w < 0) {\n    w = -w;\n    nowrap = 1;\n  }\n\n  // set window size\n  if (w < 8 || w > 15) {\n    this.inflateEnd(z);\n    return Z_STREAM_ERROR;\n  }\n  this.wbits = w;\n\n  z.istate.blocks = new InfBlocks(z, z.istate.nowrap != 0 ? null : this, 1 << w);\n\n  // reset state\n  this.inflateReset(z);\n  return Z_OK;\n};\n\nInflate.prototype.inflate = function (z, f) {\n  var r, b;\n\n  if (z == null || z.istate == null || z.next_in == null) return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  while (true) {\n    switch (z.istate.mode) {\n      case METHOD:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED) {\n          z.istate.mode = BAD;\n          z.msg = \"unknown compression method\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        if ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n          z.istate.mode = BAD;\n          z.msg = \"invalid window size\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n        z.istate.mode = FLAG;\n      case FLAG:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        b = z.next_in[z.next_in_index++] & 0xff;\n\n        if (((z.istate.method << 8) + b) % 31 != 0) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        if ((b & PRESET_DICT) == 0) {\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = DICT3;\n      case DICT3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = DICT2;\n      case DICT2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = DICT1;\n      case DICT1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0; // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if (r == Z_DATA_ERROR) {\n          z.istate.mode = BAD;\n          z.istate.marker = 0; // can try inflateSync\n          break;\n        }\n        if (r == Z_OK) {\n          r = f;\n        }\n        if (r != Z_STREAM_END) {\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if (z.istate.nowrap != 0) {\n          z.istate.mode = DONE;\n          break;\n        }\n        z.istate.mode = CHECK4;\n      case CHECK4:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need = (z.next_in[z.next_in_index++] & 0xff) << 24 & 0xff000000;\n        z.istate.mode = CHECK3;\n      case CHECK3:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 16 & 0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++] & 0xff) << 8 & 0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if (z.avail_in == 0) return r;r = f;\n\n        z.avail_in--;z.total_in++;\n        z.istate.need += z.next_in[z.next_in_index++] & 0xff;\n\n        if (z.istate.was[0] != z.istate.need) {\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5; // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n};\n\nInflate.prototype.inflateSetDictionary = function (z, dictionary, dictLength) {\n  var index = 0;\n  var length = dictLength;\n  if (z == null || z.istate == null || z.istate.mode != DICT0) return Z_STREAM_ERROR;\n\n  if (z._adler.adler32(1, dictionary, 0, dictLength) != z.adler) {\n    return Z_DATA_ERROR;\n  }\n\n  z.adler = z._adler.adler32(0, null, 0, 0);\n\n  if (length >= 1 << z.istate.wbits) {\n    length = (1 << z.istate.wbits) - 1;\n    index = dictLength - length;\n  }\n  z.istate.blocks.set_dictionary(dictionary, index, length);\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255];\n\nInflate.prototype.inflateSync = function (z) {\n  var n; // number of bytes to look at\n  var p; // pointer to bytes\n  var m; // number of marker bytes found in a row\n  var r, w; // temporaries to save total_in and total_out\n\n  // set up\n  if (z == null || z.istate == null) return Z_STREAM_ERROR;\n  if (z.istate.mode != BAD) {\n    z.istate.mode = BAD;\n    z.istate.marker = 0;\n  }\n  if ((n = z.avail_in) == 0) return Z_BUF_ERROR;\n  p = z.next_in_index;\n  m = z.istate.marker;\n\n  // search\n  while (n != 0 && m < 4) {\n    if (z.next_in[p] == mark[m]) {\n      m++;\n    } else if (z.next_in[p] != 0) {\n      m = 0;\n    } else {\n      m = 4 - m;\n    }\n    p++;n--;\n  }\n\n  // restore\n  z.total_in += p - z.next_in_index;\n  z.next_in_index = p;\n  z.avail_in = n;\n  z.istate.marker = m;\n\n  // return no joy or set up to restart on a new block\n  if (m != 4) {\n    return Z_DATA_ERROR;\n  }\n  r = z.total_in;w = z.total_out;\n  this.inflateReset(z);\n  z.total_in = r;z.total_out = w;\n  z.istate.mode = BLOCKS;\n  return Z_OK;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n// implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n// but removes the length bytes of the resulting empty stored block. When\n// decompressing, PPP checks that at the end of input packet, inflate is\n// waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function (z) {\n  if (z == null || z.istate == null || z.istate.blocks == null) return Z_STREAM_ERROR;\n  return z.istate.blocks.sync_point();\n};\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n  this.hufts = new Int32Array(MANY * 3);\n  this.window = new Uint8Array(w);\n  this.end = w;\n  this.checkfn = checkfn;\n  this.mode = IB_TYPE;\n  this.reset(z, null);\n\n  this.left = 0; // if STORED, bytes left to copy \n\n  this.table = 0; // table lengths (14 bits) \n  this.index = 0; // index into blens (or border) \n  this.blens = null; // bit lengths of codes \n  this.bb = new Int32Array(1); // bit length tree depth \n  this.tb = new Int32Array(1); // bit length decoding tree \n\n  this.codes = new InfCodes();\n\n  this.last = 0; // true if this block is the last block \n\n  // mode independent information \n  this.bitk = 0; // bits in bit buffer \n  this.bitb = 0; // bit buffer \n  this.read = 0; // window read pointer \n  this.write = 0; // window write pointer \n  this.check = 0; // check on output \n\n  this.inftree = new InfTree();\n}\n\nInfBlocks.prototype.reset = function (z, c) {\n  if (c) c[0] = this.check;\n  if (this.mode == IB_CODES) {\n    this.codes.free(z);\n  }\n  this.mode = IB_TYPE;\n  this.bitk = 0;\n  this.bitb = 0;\n  this.read = this.write = 0;\n\n  if (this.checkfn) z.adler = this.check = z._adler.adler32(0, null, 0, 0);\n};\n\nInfBlocks.prototype.proc = function (z, r) {\n  var t; // temporary storage\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n\n  // copy input/output information to locals (UPDATE macro restores)\n  {\n    p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n  }\n  {\n    q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n  }\n\n  // process input based on current state\n  while (true) {\n    switch (this.mode) {\n      case IB_TYPE:\n\n        while (k < 3) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n        t = b & 7;\n        this.last = t & 1;\n\n        switch (t >>> 1) {\n          case 0:\n            // stored \n            {\n              b >>>= 3;k -= 3;\n            }\n            t = k & 7; // go to byte boundary\n\n            {\n              b >>>= t;k -= t;\n            }\n            this.mode = IB_LENS; // get length of stored block\n            break;\n          case 1:\n            // fixed\n            {\n              var bl = new Int32Array(1);\n              var bd = new Int32Array(1);\n              var tl = [];\n              var td = [];\n\n              inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n            }\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_CODES;\n            break;\n          case 2:\n            // dynamic\n\n            {\n              b >>>= 3;k -= 3;\n            }\n\n            this.mode = IB_TABLE;\n            break;\n          case 3:\n            // illegal\n\n            {\n              b >>>= 3;k -= 3;\n            }\n            this.mode = BAD;\n            z.msg = \"invalid block type\";\n            r = Z_DATA_ERROR;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n        }\n        break;\n      case IB_LENS:\n        while (k < 32) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {\n          this.mode = BAD;\n          z.msg = \"invalid stored block lengths\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.left = b & 0xffff;\n        b = k = 0; // dump bits\n        this.mode = left != 0 ? IB_STORED : this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_STORED:\n        if (n == 0) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        if (m == 0) {\n          if (q == end && read != 0) {\n            q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n          }\n          if (m == 0) {\n            this.write = q;\n            r = this.inflate_flush(z, r);\n            q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n            if (q == this.end && this.read != 0) {\n              q = 0;m = q < this.read ? this.read - q - 1 : this.end - q;\n            }\n            if (m == 0) {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        t = this.left;\n        if (t > n) t = n;\n        if (t > m) t = m;\n        arrayCopy(z.next_in, p, window, q, t);\n        p += t;n -= t;\n        q += t;m -= t;\n        if ((this.left -= t) != 0) break;\n        this.mode = this.last != 0 ? IB_DRY : IB_TYPE;\n        break;\n      case IB_TABLE:\n\n        while (k < 14) {\n          if (n != 0) {\n            r = Z_OK;\n          } else {\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;\n            z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          };\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.table = t = b & 0x3fff;\n        if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {\n          this.mode = IB_BAD;\n          z.msg = \"too many length or distance symbols\";\n          r = Z_DATA_ERROR;\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);\n        if (this.blens == null || this.blens.length < t) {\n          this.blens = new Int32Array(t);\n        } else {\n          for (var i = 0; i < t; i++) {\n            this.blens[i] = 0;\n          }\n        }\n\n        {\n          b >>>= 14;k -= 14;\n        }\n\n        this.index = 0;\n        this.mode = IB_BTREE;\n      case IB_BTREE:\n        while (this.index < 4 + (this.table >>> 10)) {\n          while (k < 3) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          this.blens[INFBLOCKS_BORDER[this.index++]] = b & 7;\n\n          {\n            b >>>= 3;k -= 3;\n          }\n        }\n\n        while (this.index < 19) {\n          this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n        }\n\n        this.bb[0] = 7;\n        t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n        if (t != Z_OK) {\n          r = t;\n          if (r == Z_DATA_ERROR) {\n            this.blens = null;\n            this.mode = IB_BAD;\n          }\n\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          write = q;\n          return this.inflate_flush(z, r);\n        }\n\n        this.index = 0;\n        this.mode = IB_DTREE;\n      case IB_DTREE:\n        while (true) {\n          t = this.table;\n          if (!(this.index < 258 + (t & 0x1f) + (t >> 5 & 0x1f))) {\n            break;\n          }\n\n          var h; //int[]\n          var i, j, c;\n\n          t = this.bb[0];\n\n          while (k < t) {\n            if (n != 0) {\n              r = Z_OK;\n            } else {\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;\n              z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            };\n            n--;\n            b |= (z.next_in[p++] & 0xff) << k;\n            k += 8;\n          }\n\n          //\t  if (this.tb[0]==-1){\n          //            dlog(\"null...\");\n          //\t  }\n\n          t = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 1];\n          c = this.hufts[(this.tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n          if (c < 16) {\n            b >>>= t;k -= t;\n            this.blens[this.index++] = c;\n          } else {\n            // c == 16..18\n            i = c == 18 ? 7 : c - 14;\n            j = c == 18 ? 11 : 3;\n\n            while (k < t + i) {\n              if (n != 0) {\n                r = Z_OK;\n              } else {\n                this.bitb = b;this.bitk = k;\n                z.avail_in = n;\n                z.total_in += p - z.next_in_index;z.next_in_index = p;\n                this.write = q;\n                return this.inflate_flush(z, r);\n              };\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;\n              k += 8;\n            }\n\n            b >>>= t;k -= t;\n\n            j += b & inflate_mask[i];\n\n            b >>>= i;k -= i;\n\n            i = this.index;\n            t = this.table;\n            if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {\n              this.blens = null;\n              this.mode = IB_BAD;\n              z.msg = \"invalid bit length repeat\";\n              r = Z_DATA_ERROR;\n\n              this.bitb = b;this.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              this.write = q;\n              return this.inflate_flush(z, r);\n            }\n\n            c = c == 16 ? this.blens[i - 1] : 0;\n            do {\n              this.blens[i++] = c;\n            } while (--j != 0);\n            this.index = i;\n          }\n        }\n\n        this.tb[0] = -1;\n        {\n          var bl = new Int32Array(1);\n          var bd = new Int32Array(1);\n          var tl = new Int32Array(1);\n          var td = new Int32Array(1);\n          bl[0] = 9; // must be <= 9 for lookahead assumptions\n          bd[0] = 6; // must be <= 9 for lookahead assumptions\n\n          t = this.table;\n          t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), this.blens, bl, bd, tl, td, this.hufts, z);\n\n          if (t != Z_OK) {\n            if (t == Z_DATA_ERROR) {\n              this.blens = null;\n              this.mode = BAD;\n            }\n            r = t;\n\n            this.bitb = b;this.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            this.write = q;\n            return this.inflate_flush(z, r);\n          }\n          this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n        }\n        this.mode = IB_CODES;\n      case IB_CODES:\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n\n        if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END) {\n          return this.inflate_flush(z, r);\n        }\n        r = Z_OK;\n        this.codes.free(z);\n\n        p = z.next_in_index;n = z.avail_in;b = this.bitb;k = this.bitk;\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n\n        if (this.last == 0) {\n          this.mode = IB_TYPE;\n          break;\n        }\n        this.mode = IB_DRY;\n      case IB_DRY:\n        this.write = q;\n        r = this.inflate_flush(z, r);\n        q = this.write;m = q < this.read ? this.read - q - 1 : this.end - q;\n        if (this.read != this.write) {\n          this.bitb = b;this.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          this.write = q;\n          return this.inflate_flush(z, r);\n        }\n        this.mode = DONE;\n      case IB_DONE:\n        r = Z_STREAM_END;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n      case IB_BAD:\n        r = Z_DATA_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        this.bitb = b;this.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        this.write = q;\n        return this.inflate_flush(z, r);\n    }\n  }\n};\n\nInfBlocks.prototype.free = function (z) {\n  this.reset(z, null);\n  this.window = null;\n  this.hufts = null;\n};\n\nInfBlocks.prototype.set_dictionary = function (d, start, n) {\n  arrayCopy(d, start, window, 0, n);\n  this.read = this.write = n;\n};\n\n// Returns true if inflate is currently at the end of a block generated\n// by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function () {\n  return this.mode == IB_LENS;\n};\n\n// copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function (z, r) {\n  var n;\n  var p;\n  var q;\n\n  // local copies of source and destination pointers\n  p = z.next_out_index;\n  q = this.read;\n\n  // compute number of bytes to copy as far as end of window\n  n = (q <= this.write ? this.write : this.end) - q;\n  if (n > z.avail_out) n = z.avail_out;\n  if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n  // update counters\n  z.avail_out -= n;\n  z.total_out += n;\n\n  // update check information\n  if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n  // copy as far as end of window\n  arrayCopy(this.window, q, z.next_out, p, n);\n  p += n;\n  q += n;\n\n  // see if more to copy at beginning of window\n  if (q == this.end) {\n    // wrap pointers\n    q = 0;\n    if (this.write == this.end) this.write = 0;\n\n    // compute bytes to copy\n    n = this.write - q;\n    if (n > z.avail_out) n = z.avail_out;\n    if (n != 0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if (this.checkfn != null) z.adler = this.check = z._adler.adler32(this.check, this.window, q, n);\n\n    // copy\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n  }\n\n  // update pointers\n  z.next_out_index = p;\n  this.read = q;\n\n  // done\n  return r;\n};\n\n//\n// InfCodes.java\n//\n\nvar IC_START = 0; // x: set up for LEN\nvar IC_LEN = 1; // i: get length/literal/eob next\nvar IC_LENEXT = 2; // i: getting length extra (have base)\nvar IC_DIST = 3; // i: get distance next\nvar IC_DISTEXT = 4; // i: getting distance extra\nvar IC_COPY = 5; // o: copying bytes in window, waiting for space\nvar IC_LIT = 6; // o: got literal, waiting for output space\nvar IC_WASH = 7; // o: got eob, possibly still output waiting\nvar IC_END = 8; // x: got eob and all data flushed\nvar IC_BADCODE = 9; // x: got error\n\nfunction InfCodes() {}\n\nInfCodes.prototype.init = function (bl, bd, tl, tl_index, td, td_index, z) {\n  this.mode = IC_START;\n  this.lbits = bl;\n  this.dbits = bd;\n  this.ltree = tl;\n  this.ltree_index = tl_index;\n  this.dtree = td;\n  this.dtree_index = td_index;\n  this.tree = null;\n};\n\nInfCodes.prototype.proc = function (s, z, r) {\n  var j; // temporary storage\n  var t; // temporary pointer (int[])\n  var tindex; // temporary pointer\n  var e; // extra bits or operation\n  var b = 0; // bit buffer\n  var k = 0; // bits in bit buffer\n  var p = 0; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var f; // pointer to copy strings from\n\n  // copy input/output information to locals (UPDATE macro restores)\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // process input and output based on current state\n  while (true) {\n    switch (this.mode) {\n      // waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:\n        // x: set up for LEN\n        if (m >= 258 && n >= 10) {\n\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          r = this.inflate_fast(this.lbits, this.dbits, this.ltree, this.ltree_index, this.dtree, this.dtree_index, s, z);\n\n          p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n          q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n          if (r != Z_OK) {\n            this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n            break;\n          }\n        }\n        this.need = this.lbits;\n        this.tree = this.ltree;\n        this.tree_index = this.ltree_index;\n\n        this.mode = IC_LEN;\n      case IC_LEN:\n        // i: get length/literal/eob next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n\n        if (e == 0) {\n          // literal\n          this.lit = this.tree[tindex + 2];\n          this.mode = IC_LIT;\n          break;\n        }\n        if ((e & 16) != 0) {\n          // length\n          this.get = e & 15;\n          this.len = this.tree[tindex + 2];\n          this.mode = IC_LENEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        if ((e & 32) != 0) {\n          // end of block\n          this.mode = IC_WASH;\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid literal/length code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_LENEXT:\n        // i: getting length extra (have base)\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.len += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.need = this.dbits;\n        this.tree = this.dtree;\n        this.tree_index = this.dtree_index;\n        this.mode = IC_DIST;\n      case IC_DIST:\n        // i: get distance next\n        j = this.need;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        tindex = (this.tree_index + (b & inflate_mask[j])) * 3;\n\n        b >>= this.tree[tindex + 1];\n        k -= this.tree[tindex + 1];\n\n        e = this.tree[tindex];\n        if ((e & 16) != 0) {\n          // distance\n          this.get = e & 15;\n          this.dist = this.tree[tindex + 2];\n          this.mode = IC_DISTEXT;\n          break;\n        }\n        if ((e & 64) == 0) {\n          // next table\n          this.need = e;\n          this.tree_index = tindex / 3 + this.tree[tindex + 2];\n          break;\n        }\n        this.mode = IC_BADCODE; // invalid code\n        z.msg = \"invalid distance code\";\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_DISTEXT:\n        // i: getting distance extra\n        j = this.get;\n\n        while (k < j) {\n          if (n != 0) r = Z_OK;else {\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n            return s.inflate_flush(z, r);\n          }\n          n--;b |= (z.next_in[p++] & 0xff) << k;\n          k += 8;\n        }\n\n        this.dist += b & inflate_mask[j];\n\n        b >>= j;\n        k -= j;\n\n        this.mode = IC_COPY;\n      case IC_COPY:\n        // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while (f < 0) {\n          // modulo window size-\"while\" instead\n          f += s.end; // of \"if\" handles invalid distances\n        }\n        while (this.len != 0) {\n\n          if (m == 0) {\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.write = q;r = s.inflate_flush(z, r);\n              q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n              if (q == s.end && s.read != 0) {\n                q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n              }\n\n              if (m == 0) {\n                s.bitb = b;s.bitk = k;\n                z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n                s.write = q;\n                return s.inflate_flush(z, r);\n              }\n            }\n          }\n\n          s.window[q++] = s.window[f++];m--;\n\n          if (f == s.end) f = 0;\n          this.len--;\n        }\n        this.mode = IC_START;\n        break;\n      case IC_LIT:\n        // o: got literal, waiting for output space\n        if (m == 0) {\n          if (q == s.end && s.read != 0) {\n            q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n          }\n          if (m == 0) {\n            s.write = q;r = s.inflate_flush(z, r);\n            q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n            if (q == s.end && s.read != 0) {\n              q = 0;m = q < s.read ? s.read - q - 1 : s.end - q;\n            }\n            if (m == 0) {\n              s.bitb = b;s.bitk = k;\n              z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n              s.write = q;\n              return s.inflate_flush(z, r);\n            }\n          }\n        }\n        r = Z_OK;\n\n        s.window[q++] = this.lit;m--;\n\n        this.mode = IC_START;\n        break;\n      case IC_WASH:\n        // o: got eob, possibly more output\n        if (k > 7) {\n          // return unused byte, if any\n          k -= 8;\n          n++;\n          p--; // can always return one\n        }\n\n        s.write = q;r = s.inflate_flush(z, r);\n        q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n        if (s.read != s.write) {\n          s.bitb = b;s.bitk = k;\n          z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n          s.write = q;\n          return s.inflate_flush(z, r);\n        }\n        this.mode = IC_END;\n      case IC_END:\n        r = Z_STREAM_END;\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      case IC_BADCODE:\n        // x: got error\n\n        r = Z_DATA_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n\n      default:\n        r = Z_STREAM_ERROR;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n        return s.inflate_flush(z, r);\n    }\n  }\n};\n\nInfCodes.prototype.free = function (z) {}\n//  ZFREE(z, c);\n\n\n// Called with number of bytes left to write in window at least 258\n// (the maximum string length) and number of input bytes available\n// at least ten.  The ten bytes are six bytes for the longest length/\n// distance pair plus four bytes for overloading the bit buffer.\n\n;InfCodes.prototype.inflate_fast = function (bl, bd, tl, tl_index, td, td_index, s, z) {\n  var t; // temporary pointer\n  var tp; // temporary pointer (int[])\n  var tp_index; // temporary pointer\n  var e; // extra bits or operation\n  var b; // bit buffer\n  var k; // bits in bit buffer\n  var p; // input data pointer\n  var n; // bytes available there\n  var q; // output window write pointer\n  var m; // bytes to end of window or read pointer\n  var ml; // mask for literal/length tree\n  var md; // mask for distance tree\n  var c; // bytes to copy\n  var d; // distance back to copy from\n  var r; // copy source pointer\n\n  var tp_index_t_3; // (tp_index+t)*3\n\n  // load input, output, bit values\n  p = z.next_in_index;n = z.avail_in;b = s.bitb;k = s.bitk;\n  q = s.write;m = q < s.read ? s.read - q - 1 : s.end - q;\n\n  // initialize masks\n  ml = inflate_mask[bl];\n  md = inflate_mask[bd];\n\n  // do until not enough input or output space for fast loop\n  do {\n    // assume called with m >= 258 && n >= 10\n    // get literal/length code\n    while (k < 20) {\n      // max bits for literal/length code\n      n--;\n      b |= (z.next_in[p++] & 0xff) << k;k += 8;\n    }\n\n    t = b & ml;\n    tp = tl;\n    tp_index = tl_index;\n    tp_index_t_3 = (tp_index + t) * 3;\n    if ((e = tp[tp_index_t_3]) == 0) {\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      s.window[q++] = tp[tp_index_t_3 + 2];\n      m--;\n      continue;\n    }\n    do {\n\n      b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n      if ((e & 16) != 0) {\n        e &= 15;\n        c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n        b >>= e;k -= e;\n\n        // decode distance base of block to copy\n        while (k < 15) {\n          // max bits for distance code\n          n--;\n          b |= (z.next_in[p++] & 0xff) << k;k += 8;\n        }\n\n        t = b & md;\n        tp = td;\n        tp_index = td_index;\n        tp_index_t_3 = (tp_index + t) * 3;\n        e = tp[tp_index_t_3];\n\n        do {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          if ((e & 16) != 0) {\n            // get extra bits to add to distance base\n            e &= 15;\n            while (k < e) {\n              // get extra bits (up to 13)\n              n--;\n              b |= (z.next_in[p++] & 0xff) << k;k += 8;\n            }\n\n            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n            b >>= e;k -= e;\n\n            // do the copy\n            m -= c;\n            if (q >= d) {\n              // offset before dest\n              //  just copy\n              r = q - d;\n              if (q - r > 0 && 2 > q - r) {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              } else {\n                s.window[q++] = s.window[r++]; // minimum count is three,\n                s.window[q++] = s.window[r++]; // so unroll loop a little\n                c -= 2;\n              }\n            } else {\n              // else offset after destination\n              r = q - d;\n              do {\n                r += s.end; // force pointer in window\n              } while (r < 0); // covers invalid distances\n              e = s.end - r;\n              if (c > e) {\n                // if source crosses,\n                c -= e; // wrapped copy\n                if (q - r > 0 && e > q - r) {\n                  do {\n                    s.window[q++] = s.window[r++];\n                  } while (--e != 0);\n                } else {\n                  arrayCopy(s.window, r, s.window, q, e);\n                  q += e;r += e;e = 0;\n                }\n                r = 0; // copy rest from start of window\n              }\n            }\n\n            // copy all or what's left\n            do {\n              s.window[q++] = s.window[r++];\n            } while (--c != 0);\n            break;\n          } else if ((e & 64) == 0) {\n            t += tp[tp_index_t_3 + 2];\n            t += b & inflate_mask[e];\n            tp_index_t_3 = (tp_index + t) * 3;\n            e = tp[tp_index_t_3];\n          } else {\n            z.msg = \"invalid distance code\";\n\n            c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n            s.bitb = b;s.bitk = k;\n            z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n            s.write = q;\n\n            return Z_DATA_ERROR;\n          }\n        } while (true);\n        break;\n      }\n\n      if ((e & 64) == 0) {\n        t += tp[tp_index_t_3 + 2];\n        t += b & inflate_mask[e];\n        tp_index_t_3 = (tp_index + t) * 3;\n        if ((e = tp[tp_index_t_3]) == 0) {\n\n          b >>= tp[tp_index_t_3 + 1];k -= tp[tp_index_t_3 + 1];\n\n          s.window[q++] = tp[tp_index_t_3 + 2];\n          m--;\n          break;\n        }\n      } else if ((e & 32) != 0) {\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_STREAM_END;\n      } else {\n        z.msg = \"invalid literal/length code\";\n\n        c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n        s.bitb = b;s.bitk = k;\n        z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n        s.write = q;\n\n        return Z_DATA_ERROR;\n      }\n    } while (true);\n  } while (m >= 258 && n >= 10);\n\n  // not enough input or output--restore pointers and return\n  c = z.avail_in - n;c = k >> 3 < c ? k >> 3 : c;n += c;p -= c;k -= c << 3;\n\n  s.bitb = b;s.bitk = k;\n  z.avail_in = n;z.total_in += p - z.next_in_index;z.next_in_index = p;\n  s.write = q;\n\n  return Z_OK;\n};\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {}\n\nInfTree.prototype.huft_build = function (b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n  // Given a list of code lengths and a maximum table size, make a set of\n  // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n  // if the given code set is incomplete (the tables are still built in this\n  // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n  // lengths), or Z_MEM_ERROR if not enough memory.\n\n  var a; // counter for codes of length k\n  var f; // i repeats in table every f entries\n  var g; // maximum code length\n  var h; // table level\n  var i; // counter, current code\n  var j; // counter\n  var k; // number of bits in current code\n  var l; // bits per table (returned in m)\n  var mask; // (1 << w) - 1, to avoid cc -O bug on HP\n  var p; // pointer into c[], b[], or v[]\n  var q; // points to current table\n  var w; // bits before this table == (l * h)\n  var xp; // pointer into x\n  var y; // number of dummy codes added\n  var z; // number of entries in current table\n\n  // Generate counts for each bit length\n\n  p = 0;i = n;\n  do {\n    this.c[b[bindex + p]]++;p++;i--; // assume all entries <= BMAX\n  } while (i != 0);\n\n  if (this.c[0] == n) {\n    // null input--all zero length codes\n    t[0] = -1;\n    m[0] = 0;\n    return Z_OK;\n  }\n\n  // Find minimum and maximum length, bound *m by those\n  l = m[0];\n  for (j = 1; j <= BMAX; j++) {\n    if (this.c[j] != 0) break;\n  }k = j; // minimum code length\n  if (l < j) {\n    l = j;\n  }\n  for (i = BMAX; i != 0; i--) {\n    if (this.c[i] != 0) break;\n  }\n  g = i; // maximum code length\n  if (l > i) {\n    l = i;\n  }\n  m[0] = l;\n\n  // Adjust last length count to fill out codes, if needed\n  for (y = 1 << j; j < i; j++, y <<= 1) {\n    if ((y -= this.c[j]) < 0) {\n      return Z_DATA_ERROR;\n    }\n  }\n  if ((y -= this.c[i]) < 0) {\n    return Z_DATA_ERROR;\n  }\n  this.c[i] += y;\n\n  // Generate starting offsets into the value table for each length\n  this.x[1] = j = 0;\n  p = 1;xp = 2;\n  while (--i != 0) {\n    // note that i == g from above\n    this.x[xp] = j += this.c[p];\n    xp++;\n    p++;\n  }\n\n  // Make a table of values in order of bit lengths\n  i = 0;p = 0;\n  do {\n    if ((j = b[bindex + p]) != 0) {\n      this.v[this.x[j]++] = i;\n    }\n    p++;\n  } while (++i < n);\n  n = this.x[g]; // set n to length of v\n\n  // Generate the Huffman codes and for each, make the table entries\n  this.x[0] = i = 0; // first Huffman code is zero\n  p = 0; // grab values in bit order\n  h = -1; // no tables yet--level -1\n  w = -l; // bits decoded == (l * h)\n  this.u[0] = 0; // just to keep compilers happy\n  q = 0; // ditto\n  z = 0; // ditto\n\n  // go through the bit lengths (k already is bits in shortest code)\n  for (; k <= g; k++) {\n    a = this.c[k];\n    while (a-- != 0) {\n      // here i is the Huffman code of length k bits for value *p\n      // make tables up to required level\n      while (k > w + l) {\n        h++;\n        w += l; // previous table always l bits\n        // compute minimum size table less than or equal to l bits\n        z = g - w;\n        z = z > l ? l : z; // table size upper limit\n        if ((f = 1 << (j = k - w)) > a + 1) {\n          // try a k-w bit table\n          // too few codes for k-w bit table\n          f -= a + 1; // deduct codes from patterns left\n          xp = k;\n          if (j < z) {\n            while (++j < z) {\n              // try smaller tables up to z bits\n              if ((f <<= 1) <= this.c[++xp]) break; // enough codes to use up j bits\n              f -= this.c[xp]; // else deduct codes from patterns\n            }\n          }\n        }\n        z = 1 << j; // table entries for j-bit table\n\n        // allocate new table\n        if (this.hn[0] + z > MANY) {\n          // (note: doesn't matter for fixed)\n          return Z_DATA_ERROR; // overflow of MANY\n        }\n        this.u[h] = q = /*hp+*/this.hn[0]; // DEBUG\n        this.hn[0] += z;\n\n        // connect to last table, if there is one\n        if (h != 0) {\n          this.x[h] = i; // save pattern for backing up\n          this.r[0] = j; // bits in this table\n          this.r[1] = l; // bits to dump before this table\n          j = i >>> w - l;\n          this.r[2] = q - this.u[h - 1] - j; // offset to this table\n          arrayCopy(this.r, 0, hp, (this.u[h - 1] + j) * 3, 3); // connect to last table\n        } else {\n          t[0] = q; // first table is returned result\n        }\n      }\n\n      // set up table entry in r\n      this.r[1] = k - w;\n      if (p >= n) {\n        this.r[0] = 128 + 64; // out of values--invalid code\n      } else if (v[p] < s) {\n        this.r[0] = this.v[p] < 256 ? 0 : 32 + 64; // 256 is end-of-block\n        this.r[2] = this.v[p++]; // simple code is just the value\n      } else {\n        this.r[0] = e[this.v[p] - s] + 16 + 64; // non-simple--look up in lists\n        this.r[2] = d[this.v[p++] - s];\n      }\n\n      // fill code-like entries with r\n      f = 1 << k - w;\n      for (j = i >>> w; j < z; j += f) {\n        arrayCopy(this.r, 0, hp, (q + j) * 3, 3);\n      }\n\n      // backwards increment the k-bit code i\n      for (j = 1 << k - 1; (i & j) != 0; j >>>= 1) {\n        i ^= j;\n      }\n      i ^= j;\n\n      // backup over finished tables\n      mask = (1 << w) - 1; // needed on HP, cc -O bug\n      while ((i & mask) != this.x[h]) {\n        h--; // don't need to update q\n        w -= l;\n        mask = (1 << w) - 1;\n      }\n    }\n  }\n  // Return Z_BUF_ERROR if we were given an incomplete table\n  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n};\n\nInfTree.prototype.inflate_trees_bits = function (c, bb, tb, hp, z) {\n  var result;\n  this.initWorkArea(19);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n  if (result == Z_DATA_ERROR) {\n    z.msg = \"oversubscribed dynamic bit lengths tree\";\n  } else if (result == Z_BUF_ERROR || bb[0] == 0) {\n    z.msg = \"incomplete dynamic bit lengths tree\";\n    result = Z_DATA_ERROR;\n  }\n  return result;\n};\n\nInfTree.prototype.inflate_trees_dynamic = function (nl, nd, c, bl, bd, tl, td, hp, z) {\n  var result;\n\n  // build literal/length tree\n  this.initWorkArea(288);\n  this.hn[0] = 0;\n  result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n  if (result != Z_OK || bl[0] == 0) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed literal/length tree\";\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"incomplete literal/length tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  // build distance tree\n  this.initWorkArea(288);\n  result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n  if (result != Z_OK || bd[0] == 0 && nl > 257) {\n    if (result == Z_DATA_ERROR) {\n      z.msg = \"oversubscribed distance tree\";\n    } else if (result == Z_BUF_ERROR) {\n      z.msg = \"incomplete distance tree\";\n      result = Z_DATA_ERROR;\n    } else if (result != Z_MEM_ERROR) {\n      z.msg = \"empty distance tree with lengths\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n  }\n\n  return Z_OK;\n};\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n  bl[0] = fixed_bl;\n  bd[0] = fixed_bd;\n  tl[0] = fixed_tl;\n  td[0] = fixed_td;\n  return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function (vsize) {\n  if (this.hn == null) {\n    this.hn = new Int32Array(1);\n    this.v = new Int32Array(vsize);\n    this.c = new Int32Array(BMAX + 1);\n    this.r = new Int32Array(3);\n    this.u = new Int32Array(BMAX);\n    this.x = new Int32Array(BMAX + 1);\n  }\n  if (this.v.length < vsize) {\n    this.v = new Int32Array(vsize);\n  }\n  for (var i = 0; i < vsize; i++) {\n    this.v[i] = 0;\n  }\n  for (var i = 0; i < BMAX + 1; i++) {\n    this.c[i] = 0;\n  }\n  for (var i = 0; i < 3; i++) {\n    this.r[i] = 0;\n  }\n  //  for(int i=0; i<BMAX; i++){u[i]=0;}\n  arrayCopy(this.c, 0, this.u, 0, BMAX);\n  //  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n  arrayCopy(this.c, 0, this.x, 0, BMAX + 1);\n};\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = typeof testArray.subarray === 'function';\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n  if (count == 0) {\n    return;\n  }\n  if (!src) {\n    throw \"Undef src\";\n  } else if (!dest) {\n    throw \"Undef dest\";\n  }\n\n  if (srcOffset == 0 && count == src.length) {\n    arrayCopy_fast(src, dest, destOffset);\n  } else if (hasSubarray) {\n    arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);\n  } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n    arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n  } else {\n    arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n  }\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n  // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n  for (var i = 0; i < count; ++i) {\n    dest[destOffset + i] = src[srcOffset + i];\n  }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n  dest.set(src, destOffset);\n}\n\n// largest prime smaller than 65536\nvar ADLER_BASE = 65521;\n// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX = 5552;\n\nfunction adler32(adler, /* byte[] */buf, index, len) {\n  if (buf == null) {\n    return 1;\n  }\n\n  var s1 = adler & 0xffff;\n  var s2 = adler >> 16 & 0xffff;\n  var k;\n\n  while (len > 0) {\n    k = len < ADLER_NMAX ? len : ADLER_NMAX;\n    len -= k;\n    while (k >= 16) {\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      s1 += buf[index++] & 0xff;s2 += s1;\n      k -= 16;\n    }\n    if (k != 0) {\n      do {\n        s1 += buf[index++] & 0xff;s2 += s1;\n      } while (--k != 0);\n    }\n    s1 %= ADLER_BASE;\n    s2 %= ADLER_BASE;\n  }\n  return s2 << 16 | s1;\n}\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n  if (!start) {\n    buffer = new Uint8Array(buffer);\n  } else {\n    buffer = new Uint8Array(buffer, start, length);\n  }\n\n  var z = new ZStream();\n  z.inflateInit(DEF_WBITS, true);\n  z.next_in = buffer;\n  z.next_in_index = 0;\n  z.avail_in = buffer.length;\n\n  var oBlockList = [];\n  var totalSize = 0;\n  while (true) {\n    var obuf = new Uint8Array(32000);\n    z.next_out = obuf;\n    z.next_out_index = 0;\n    z.avail_out = obuf.length;\n    var status = z.inflate(Z_NO_FLUSH);\n    if (status != Z_OK && status != Z_STREAM_END) {\n      throw z.msg;\n    }\n    if (z.avail_out != 0) {\n      var newob = new Uint8Array(obuf.length - z.avail_out);\n      arrayCopy(obuf, 0, newob, 0, obuf.length - z.avail_out);\n      obuf = newob;\n    }\n    oBlockList.push(obuf);\n    totalSize += obuf.length;\n    if (status == Z_STREAM_END) {\n      break;\n    }\n  }\n\n  if (afterUncOffset) {\n    afterUncOffset[0] = (start || 0) + z.next_in_index;\n  }\n\n  if (oBlockList.length == 1) {\n    return oBlockList[0].buffer;\n  } else {\n    var out = new Uint8Array(totalSize);\n    var cursor = 0;\n    for (var i = 0; i < oBlockList.length; ++i) {\n      var b = oBlockList[i];\n      arrayCopy(b, 0, out, cursor, b.length);\n      cursor += b.length;\n    }\n    return out.buffer;\n  }\n}\n\nexports.jszlib_inflate_buffer = jszlib_inflate_buffer;\nexports.arrayCopy = arrayCopy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3ZlbmRvci9pbmZsYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy92ZW5kb3IvaW5mbGF0ZS5qcz82OTAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIEphdmFzY3JpcHQgWkxpYlxuLy8gQnkgVGhvbWFzIERvd24gMjAxMC0yMDExXG4vL1xuLy8gQmFzZWQgdmVyeSBoZWF2aWx5IG9uIHBvcnRpb25zIG9mIGp6bGliIChieSB5bW5rQGpjcmFmdC5jb20pLCB3aG8gaW5cbi8vIHR1cm4gY3JlZGl0cyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyIGZvciB0aGUgb3JpZ2luYWwgemxpYiBjb2RlLlxuLy9cbi8vIGluZmxhdGUuanM6IFpMaWIgaW5mbGF0ZSBjb2RlXG4vL1xuXG4vL1xuLy8gU2hhcmVkIGNvbnN0YW50c1xuLy9cblxudmFyIE1BWF9XQklUUz0xNTsgLy8gMzJLIExaNzcgd2luZG93XG52YXIgREVGX1dCSVRTPU1BWF9XQklUUztcbnZhciBNQVhfTUVNX0xFVkVMPTk7XG52YXIgTUFOWT0xNDQwO1xudmFyIEJNQVggPSAxNTtcblxuLy8gcHJlc2V0IGRpY3Rpb25hcnkgZmxhZyBpbiB6bGliIGhlYWRlclxudmFyIFBSRVNFVF9ESUNUPTB4MjA7XG5cbnZhciBaX05PX0ZMVVNIPTA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIPTE7XG52YXIgWl9TWU5DX0ZMVVNIPTI7XG52YXIgWl9GVUxMX0ZMVVNIPTM7XG52YXIgWl9GSU5JU0g9NDtcblxudmFyIFpfREVGTEFURUQ9ODtcblxudmFyIFpfT0s9MDtcbnZhciBaX1NUUkVBTV9FTkQ9MTtcbnZhciBaX05FRURfRElDVD0yO1xudmFyIFpfRVJSTk89LTE7XG52YXIgWl9TVFJFQU1fRVJST1I9LTI7XG52YXIgWl9EQVRBX0VSUk9SPS0zO1xudmFyIFpfTUVNX0VSUk9SPS00O1xudmFyIFpfQlVGX0VSUk9SPS01O1xudmFyIFpfVkVSU0lPTl9FUlJPUj0tNjtcblxudmFyIE1FVEhPRD0wOyAgIC8vIHdhaXRpbmcgZm9yIG1ldGhvZCBieXRlXG52YXIgRkxBRz0xOyAgICAgLy8gd2FpdGluZyBmb3IgZmxhZyBieXRlXG52YXIgRElDVDQ9MjsgICAgLy8gZm91ciBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDM9MzsgICAgLy8gdGhyZWUgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QyPTQ7ICAgIC8vIHR3byBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgRElDVDE9NTsgICAgLy8gb25lIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERJQ1QwPTY7ICAgIC8vIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5XG52YXIgQkxPQ0tTPTc7ICAgLy8gZGVjb21wcmVzc2luZyBibG9ja3NcbnZhciBDSEVDSzQ9ODsgICAvLyBmb3VyIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0szPTk7ICAgLy8gdGhyZWUgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzI9MTA7ICAvLyB0d28gY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBDSEVDSzE9MTE7ICAvLyBvbmUgY2hlY2sgYnl0ZSB0byBnb1xudmFyIERPTkU9MTI7ICAgIC8vIGZpbmlzaGVkIGNoZWNrLCBkb25lXG52YXIgQkFEPTEzOyAgICAgLy8gZ290IGFuIGVycm9yLS1zdGF5IGhlcmVcblxudmFyIGluZmxhdGVfbWFzayA9IFsweDAwMDAwMDAwLCAweDAwMDAwMDAxLCAweDAwMDAwMDAzLCAweDAwMDAwMDA3LCAweDAwMDAwMDBmLCAweDAwMDAwMDFmLCAweDAwMDAwMDNmLCAweDAwMDAwMDdmLCAweDAwMDAwMGZmLCAweDAwMDAwMWZmLCAweDAwMDAwM2ZmLCAweDAwMDAwN2ZmLCAweDAwMDAwZmZmLCAweDAwMDAxZmZmLCAweDAwMDAzZmZmLCAweDAwMDA3ZmZmLCAweDAwMDBmZmZmXTtcblxudmFyIElCX1RZUEU9MDsgIC8vIGdldCB0eXBlIGJpdHMgKDMsIGluY2x1ZGluZyBlbmQgYml0KVxudmFyIElCX0xFTlM9MTsgIC8vIGdldCBsZW5ndGhzIGZvciBzdG9yZWRcbnZhciBJQl9TVE9SRUQ9MjsvLyBwcm9jZXNzaW5nIHN0b3JlZCBibG9ja1xudmFyIElCX1RBQkxFPTM7IC8vIGdldCB0YWJsZSBsZW5ndGhzXG52YXIgSUJfQlRSRUU9NDsgLy8gZ2V0IGJpdCBsZW5ndGhzIHRyZWUgZm9yIGEgZHluYW1pYyBibG9ja1xudmFyIElCX0RUUkVFPTU7IC8vIGdldCBsZW5ndGgsIGRpc3RhbmNlIHRyZWVzIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9DT0RFUz02OyAvLyBwcm9jZXNzaW5nIGZpeGVkIG9yIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EUlk9NzsgICAvLyBvdXRwdXQgcmVtYWluaW5nIHdpbmRvdyBieXRlc1xudmFyIElCX0RPTkU9ODsgIC8vIGZpbmlzaGVkIGxhc3QgYmxvY2ssIGRvbmVcbnZhciBJQl9CQUQ9OTsgICAvLyBvdCBhIGRhdGEgZXJyb3ItLXN0dWNrIGhlcmVcblxudmFyIGZpeGVkX2JsID0gOTtcbnZhciBmaXhlZF9iZCA9IDU7XG5cbnZhciBmaXhlZF90bCA9IFtcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MixcbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MCxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI0LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDQsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA4LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NixcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQwLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMCxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjgsXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMixcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUyLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNixcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODQsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDgsXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk2LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY0LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjgsXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OCxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTIsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgwLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ0LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA0LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MixcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM2LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTYsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIwLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OCxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MixcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NCxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MixcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI2LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDYsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjEwLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OCxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQyLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMixcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzAsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNCxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU0LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOCxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODYsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTAsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk4LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY2LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzAsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MCxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTQsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgyLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ2LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA2LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NCxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM4LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTgsXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIyLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MCxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NCxcbiAgICA5Niw3LDI1NiwgMCw4LDgwLCAwLDgsMTYsIDg0LDgsMTE1LFxuICAgIDgyLDcsMzEsIDAsOCwxMTIsIDAsOCw0OCwgMCw5LDE5MyxcblxuICAgIDgwLDcsMTAsIDAsOCw5NiwgMCw4LDMyLCAwLDksMTYxLFxuICAgIDAsOCwwLCAwLDgsMTI4LCAwLDgsNjQsIDAsOSwyMjUsXG4gICAgODAsNyw2LCAwLDgsODgsIDAsOCwyNCwgMCw5LDE0NSxcbiAgICA4Myw3LDU5LCAwLDgsMTIwLCAwLDgsNTYsIDAsOSwyMDksXG4gICAgODEsNywxNywgMCw4LDEwNCwgMCw4LDQwLCAwLDksMTc3LFxuICAgIDAsOCw4LCAwLDgsMTM2LCAwLDgsNzIsIDAsOSwyNDEsXG4gICAgODAsNyw0LCAwLDgsODQsIDAsOCwyMCwgODUsOCwyMjcsXG4gICAgODMsNyw0MywgMCw4LDExNiwgMCw4LDUyLCAwLDksMjAxLFxuICAgIDgxLDcsMTMsIDAsOCwxMDAsIDAsOCwzNiwgMCw5LDE2OSxcbiAgICAwLDgsNCwgMCw4LDEzMiwgMCw4LDY4LCAwLDksMjMzLFxuICAgIDgwLDcsOCwgMCw4LDkyLCAwLDgsMjgsIDAsOSwxNTMsXG4gICAgODQsNyw4MywgMCw4LDEyNCwgMCw4LDYwLCAwLDksMjE3LFxuICAgIDgyLDcsMjMsIDAsOCwxMDgsIDAsOCw0NCwgMCw5LDE4NSxcbiAgICAwLDgsMTIsIDAsOCwxNDAsIDAsOCw3NiwgMCw5LDI0OSxcbiAgICA4MCw3LDMsIDAsOCw4MiwgMCw4LDE4LCA4NSw4LDE2MyxcbiAgICA4Myw3LDM1LCAwLDgsMTE0LCAwLDgsNTAsIDAsOSwxOTcsXG4gICAgODEsNywxMSwgMCw4LDk4LCAwLDgsMzQsIDAsOSwxNjUsXG4gICAgMCw4LDIsIDAsOCwxMzAsIDAsOCw2NiwgMCw5LDIyOSxcbiAgICA4MCw3LDcsIDAsOCw5MCwgMCw4LDI2LCAwLDksMTQ5LFxuICAgIDg0LDcsNjcsIDAsOCwxMjIsIDAsOCw1OCwgMCw5LDIxMyxcbiAgICA4Miw3LDE5LCAwLDgsMTA2LCAwLDgsNDIsIDAsOSwxODEsXG4gICAgMCw4LDEwLCAwLDgsMTM4LCAwLDgsNzQsIDAsOSwyNDUsXG4gICAgODAsNyw1LCAwLDgsODYsIDAsOCwyMiwgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE4LCAwLDgsNTQsIDAsOSwyMDUsXG4gICAgODEsNywxNSwgMCw4LDEwMiwgMCw4LDM4LCAwLDksMTczLFxuICAgIDAsOCw2LCAwLDgsMTM0LCAwLDgsNzAsIDAsOSwyMzcsXG4gICAgODAsNyw5LCAwLDgsOTQsIDAsOCwzMCwgMCw5LDE1NyxcbiAgICA4NCw3LDk5LCAwLDgsMTI2LCAwLDgsNjIsIDAsOSwyMjEsXG4gICAgODIsNywyNywgMCw4LDExMCwgMCw4LDQ2LCAwLDksMTg5LFxuICAgIDAsOCwxNCwgMCw4LDE0MiwgMCw4LDc4LCAwLDksMjUzLFxuICAgIDk2LDcsMjU2LCAwLDgsODEsIDAsOCwxNywgODUsOCwxMzEsXG4gICAgODIsNywzMSwgMCw4LDExMywgMCw4LDQ5LCAwLDksMTk1LFxuICAgIDgwLDcsMTAsIDAsOCw5NywgMCw4LDMzLCAwLDksMTYzLFxuICAgIDAsOCwxLCAwLDgsMTI5LCAwLDgsNjUsIDAsOSwyMjcsXG4gICAgODAsNyw2LCAwLDgsODksIDAsOCwyNSwgMCw5LDE0NyxcbiAgICA4Myw3LDU5LCAwLDgsMTIxLCAwLDgsNTcsIDAsOSwyMTEsXG4gICAgODEsNywxNywgMCw4LDEwNSwgMCw4LDQxLCAwLDksMTc5LFxuICAgIDAsOCw5LCAwLDgsMTM3LCAwLDgsNzMsIDAsOSwyNDMsXG4gICAgODAsNyw0LCAwLDgsODUsIDAsOCwyMSwgODAsOCwyNTgsXG4gICAgODMsNyw0MywgMCw4LDExNywgMCw4LDUzLCAwLDksMjAzLFxuICAgIDgxLDcsMTMsIDAsOCwxMDEsIDAsOCwzNywgMCw5LDE3MSxcbiAgICAwLDgsNSwgMCw4LDEzMywgMCw4LDY5LCAwLDksMjM1LFxuICAgIDgwLDcsOCwgMCw4LDkzLCAwLDgsMjksIDAsOSwxNTUsXG4gICAgODQsNyw4MywgMCw4LDEyNSwgMCw4LDYxLCAwLDksMjE5LFxuICAgIDgyLDcsMjMsIDAsOCwxMDksIDAsOCw0NSwgMCw5LDE4NyxcbiAgICAwLDgsMTMsIDAsOCwxNDEsIDAsOCw3NywgMCw5LDI1MSxcbiAgICA4MCw3LDMsIDAsOCw4MywgMCw4LDE5LCA4NSw4LDE5NSxcbiAgICA4Myw3LDM1LCAwLDgsMTE1LCAwLDgsNTEsIDAsOSwxOTksXG4gICAgODEsNywxMSwgMCw4LDk5LCAwLDgsMzUsIDAsOSwxNjcsXG4gICAgMCw4LDMsIDAsOCwxMzEsIDAsOCw2NywgMCw5LDIzMSxcbiAgICA4MCw3LDcsIDAsOCw5MSwgMCw4LDI3LCAwLDksMTUxLFxuICAgIDg0LDcsNjcsIDAsOCwxMjMsIDAsOCw1OSwgMCw5LDIxNSxcbiAgICA4Miw3LDE5LCAwLDgsMTA3LCAwLDgsNDMsIDAsOSwxODMsXG4gICAgMCw4LDExLCAwLDgsMTM5LCAwLDgsNzUsIDAsOSwyNDcsXG4gICAgODAsNyw1LCAwLDgsODcsIDAsOCwyMywgMTkyLDgsMCxcbiAgICA4Myw3LDUxLCAwLDgsMTE5LCAwLDgsNTUsIDAsOSwyMDcsXG4gICAgODEsNywxNSwgMCw4LDEwMywgMCw4LDM5LCAwLDksMTc1LFxuICAgIDAsOCw3LCAwLDgsMTM1LCAwLDgsNzEsIDAsOSwyMzksXG4gICAgODAsNyw5LCAwLDgsOTUsIDAsOCwzMSwgMCw5LDE1OSxcbiAgICA4NCw3LDk5LCAwLDgsMTI3LCAwLDgsNjMsIDAsOSwyMjMsXG4gICAgODIsNywyNywgMCw4LDExMSwgMCw4LDQ3LCAwLDksMTkxLFxuICAgIDAsOCwxNSwgMCw4LDE0MywgMCw4LDc5LCAwLDksMjU1XG5dO1xudmFyIGZpeGVkX3RkID0gW1xuICAgIDgwLDUsMSwgODcsNSwyNTcsIDgzLDUsMTcsIDkxLDUsNDA5NyxcbiAgICA4MSw1LDUsIDg5LDUsMTAyNSwgODUsNSw2NSwgOTMsNSwxNjM4NSxcbiAgICA4MCw1LDMsIDg4LDUsNTEzLCA4NCw1LDMzLCA5Miw1LDgxOTMsXG4gICAgODIsNSw5LCA5MCw1LDIwNDksIDg2LDUsMTI5LCAxOTIsNSwyNDU3NyxcbiAgICA4MCw1LDIsIDg3LDUsMzg1LCA4Myw1LDI1LCA5MSw1LDYxNDUsXG4gICAgODEsNSw3LCA4OSw1LDE1MzcsIDg1LDUsOTcsIDkzLDUsMjQ1NzcsXG4gICAgODAsNSw0LCA4OCw1LDc2OSwgODQsNSw0OSwgOTIsNSwxMjI4OSxcbiAgICA4Miw1LDEzLCA5MCw1LDMwNzMsIDg2LDUsMTkzLCAxOTIsNSwyNDU3N1xuXTtcblxuICAvLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxuICB2YXIgY3BsZW5zID0gWyAvLyBDb3B5IGxlbmd0aHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgICAgICAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbiAgXTtcblxuICAvLyBzZWUgbm90ZSAjMTMgYWJvdmUgYWJvdXQgMjU4XG4gIHZhciBjcGxleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGxpdGVyYWwgY29kZXMgMjU3Li4yODVcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMixcbiAgICAgICAgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgMTEyLCAxMTIgIC8vIDExMj09aW52YWxpZFxuICBdO1xuXG4gdmFyIGNwZGlzdCA9IFsgLy8gQ29weSBvZmZzZXRzIGZvciBkaXN0YW5jZSBjb2RlcyAwLi4yOVxuICAgICAgICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gICAgICAgIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgICAgICAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3N1xuICBdO1xuXG4gIHZhciBjcGRleHQgPSBbIC8vIEV4dHJhIGJpdHMgZm9yIGRpc3RhbmNlIGNvZGVzXG4gICAgICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsXG4gICAgICAgIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLFxuICAgICAgICAxMiwgMTIsIDEzLCAxM107XG5cbi8vXG4vLyBaU3RyZWFtLmphdmFcbi8vXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG59XG5cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih3LCBub3dyYXApIHtcbiAgICBpZiAoIXcpIHtcblx0dyA9IERFRl9XQklUUztcbiAgICB9XG4gICAgaWYgKG5vd3JhcCkge1xuXHRub3dyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc3RhdGUgPSBuZXcgSW5mbGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLmlzdGF0ZS5pbmZsYXRlSW5pdCh0aGlzLCBub3dyYXA/LXc6dyk7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZSh0aGlzLCBmKTtcbn1cblxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZUVuZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5pc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB2YXIgcmV0PWlzdGF0ZS5pbmZsYXRlRW5kKHRoaXMpO1xuICAgIHRoaXMuaXN0YXRlID0gbnVsbDtcbiAgICByZXR1cm4gcmV0O1xufVxuWlN0cmVhbS5wcm90b3R5cGUuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbigpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU3luYyh0aGlzKTtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZGljdGlvbmFyeSwgZGljdExlbmd0aCl7XG4gICAgLy8gaWYoaXN0YXRlID09IG51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xufVxuXG4vKlxuXG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGJvb2xlYW4gbm93cmFwKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIE1BWF9XQklUUywgbm93cmFwKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMpe1xuICAgIHJldHVybiBkZWZsYXRlSW5pdChsZXZlbCwgYml0cywgZmFsc2UpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBpbnQgYml0cywgYm9vbGVhbiBub3dyYXApe1xuICAgIGRzdGF0ZT1uZXcgRGVmbGF0ZSgpO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZUluaXQodGhpcywgbGV2ZWwsIG5vd3JhcD8tYml0czpiaXRzKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGUoaW50IGZsdXNoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpe1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGUodGhpcywgZmx1c2gpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUVuZCgpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGludCByZXQ9ZHN0YXRlLmRlZmxhdGVFbmQoKTtcbiAgICBkc3RhdGU9bnVsbDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVBhcmFtcyhpbnQgbGV2ZWwsIGludCBzdHJhdGVneSl7XG4gICAgaWYoZHN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlUGFyYW1zKHRoaXMsIGxldmVsLCBzdHJhdGVneSk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlU2V0RGljdGlvbmFyeSAoYnl0ZVtdIGRpY3Rpb25hcnksIGludCBkaWN0TGVuZ3RoKXtcbiAgICBpZihkc3RhdGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpO1xuICB9XG5cbiovXG5cbi8qXG4gIC8vIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAgLy8gdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICAvLyB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9vdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gIC8vIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAgdm9pZCBmbHVzaF9wZW5kaW5nKCl7XG4gICAgaW50IGxlbj1kc3RhdGUucGVuZGluZztcblxuICAgIGlmKGxlbj5hdmFpbF9vdXQpIGxlbj1hdmFpbF9vdXQ7XG4gICAgaWYobGVuPT0wKSByZXR1cm47XG5cbiAgICBpZihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoPD1kc3RhdGUucGVuZGluZ19vdXQgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8PW5leHRfb3V0X2luZGV4IHx8XG4gICAgICAgZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDwoZHN0YXRlLnBlbmRpbmdfb3V0K2xlbikgfHxcbiAgICAgICBuZXh0X291dC5sZW5ndGg8KG5leHRfb3V0X2luZGV4K2xlbikpe1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGgrXCIsIFwiK2RzdGF0ZS5wZW5kaW5nX291dCtcblx0XHRcdCBcIiwgXCIrbmV4dF9vdXQubGVuZ3RoK1wiLCBcIituZXh0X291dF9pbmRleCtcIiwgXCIrbGVuKTtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihcImF2YWlsX291dD1cIithdmFpbF9vdXQpO1xuICAgIH1cblxuICAgIFN5c3RlbS5hcnJheWNvcHkoZHN0YXRlLnBlbmRpbmdfYnVmLCBkc3RhdGUucGVuZGluZ19vdXQsXG5cdFx0ICAgICBuZXh0X291dCwgbmV4dF9vdXRfaW5kZXgsIGxlbik7XG5cbiAgICBuZXh0X291dF9pbmRleCs9bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nX291dCs9bGVuO1xuICAgIHRvdGFsX291dCs9bGVuO1xuICAgIGF2YWlsX291dC09bGVuO1xuICAgIGRzdGF0ZS5wZW5kaW5nLT1sZW47XG4gICAgaWYoZHN0YXRlLnBlbmRpbmc9PTApe1xuICAgICAgZHN0YXRlLnBlbmRpbmdfb3V0PTA7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICAvLyBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICAvLyB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICAvLyBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+bmV4dF9pbiBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAgLy8gKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gIGludCByZWFkX2J1ZihieXRlW10gYnVmLCBpbnQgc3RhcnQsIGludCBzaXplKSB7XG4gICAgaW50IGxlbj1hdmFpbF9pbjtcblxuICAgIGlmKGxlbj5zaXplKSBsZW49c2l6ZTtcbiAgICBpZihsZW49PTApIHJldHVybiAwO1xuXG4gICAgYXZhaWxfaW4tPWxlbjtcblxuICAgIGlmKGRzdGF0ZS5ub2hlYWRlcj09MCkge1xuICAgICAgYWRsZXI9X2FkbGVyLmFkbGVyMzIoYWRsZXIsIG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGxlbik7XG4gICAgfVxuICAgIFN5c3RlbS5hcnJheWNvcHkobmV4dF9pbiwgbmV4dF9pbl9pbmRleCwgYnVmLCBzdGFydCwgbGVuKTtcbiAgICBuZXh0X2luX2luZGV4ICArPSBsZW47XG4gICAgdG90YWxfaW4gKz0gbGVuO1xuICAgIHJldHVybiBsZW47XG4gIH1cblxuICBwdWJsaWMgdm9pZCBmcmVlKCl7XG4gICAgbmV4dF9pbj1udWxsO1xuICAgIG5leHRfb3V0PW51bGw7XG4gICAgbXNnPW51bGw7XG4gICAgX2FkbGVyPW51bGw7XG4gIH1cbn1cbiovXG5cblxuLy9cbi8vIEluZmxhdGUuamF2YVxuLy9cblxuZnVuY3Rpb24gSW5mbGF0ZSgpIHtcbiAgICB0aGlzLndhcyA9IFswXTtcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVJlc2V0ID0gZnVuY3Rpb24oeikge1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgXG4gICAgei50b3RhbF9pbiA9IHoudG90YWxfb3V0ID0gMDtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgei5pc3RhdGUubW9kZSA9IHouaXN0YXRlLm5vd3JhcCE9MCA/IEJMT0NLUyA6IE1FVEhPRDtcbiAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgbnVsbCk7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbih6KXtcbiAgICBpZih0aGlzLmJsb2NrcyAhPSBudWxsKVxuICAgICAgdGhpcy5ibG9ja3MuZnJlZSh6KTtcbiAgICB0aGlzLmJsb2Nrcz1udWxsO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKHosIHcpe1xuICAgIHoubXNnID0gbnVsbDtcbiAgICB0aGlzLmJsb2NrcyA9IG51bGw7XG5cbiAgICAvLyBoYW5kbGUgdW5kb2N1bWVudGVkIG5vd3JhcCBvcHRpb24gKG5vIHpsaWIgaGVhZGVyIG9yIGNoZWNrKVxuICAgIGxldCBub3dyYXAgPSAwO1xuICAgIGlmKHcgPCAwKXtcbiAgICAgIHcgPSAtIHc7XG4gICAgICBub3dyYXAgPSAxO1xuICAgIH1cblxuICAgIC8vIHNldCB3aW5kb3cgc2l6ZVxuICAgIGlmKHc8OCB8fHc+MTUpe1xuICAgICAgdGhpcy5pbmZsYXRlRW5kKHopO1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICB0aGlzLndiaXRzPXc7XG5cbiAgICB6LmlzdGF0ZS5ibG9ja3M9bmV3IEluZkJsb2Nrcyh6LCBcblx0XHRcdFx0ICB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBudWxsIDogdGhpcyxcblx0XHRcdFx0ICAxPDx3KTtcblxuICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgdGhpcy5pbmZsYXRlUmVzZXQoeik7XG4gICAgcmV0dXJuIFpfT0s7XG4gIH1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpe1xuICAgIHZhciByLCBiO1xuXG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwgfHwgei5uZXh0X2luID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgZiA9IGYgPT0gWl9GSU5JU0ggPyBaX0JVRl9FUlJPUiA6IFpfT0s7XG4gICAgciA9IFpfQlVGX0VSUk9SO1xuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAoei5pc3RhdGUubW9kZSl7XG4gICAgICBjYXNlIE1FVEhPRDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgaWYoKCh6LmlzdGF0ZS5tZXRob2QgPSB6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGYpIT1aX0RFRkxBVEVEKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZigoei5pc3RhdGUubWV0aG9kPj40KSs4PnouaXN0YXRlLndiaXRzKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwiaW52YWxpZCB3aW5kb3cgc2l6ZVwiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RkxBRztcbiAgICAgIGNhc2UgRkxBRzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgYiA9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGZmO1xuXG4gICAgICAgIGlmKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KStiKSAlIDMxKSE9MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW5jb3JyZWN0IGhlYWRlciBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKGImUFJFU0VUX0RJQ1QpPT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUNDtcbiAgICAgIGNhc2UgRElDVDQ6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQ9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwyNCkmMHhmZjAwMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMztcbiAgICAgIGNhc2UgRElDVDM6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MTYpJjB4ZmYwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QyO1xuICAgICAgY2FzZSBESUNUMjpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDw4KSYweGZmMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDE7XG4gICAgICBjYXNlIERJQ1QxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkICs9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpO1xuICAgICAgICB6LmFkbGVyID0gei5pc3RhdGUubmVlZDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QwO1xuICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICBjYXNlIERJQ1QwOlxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB6Lm1zZyA9IFwibmVlZCBkaWN0aW9uYXJ5XCI7XG4gICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7ICAgICAgIC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgY2FzZSBCTE9DS1M6XG5cbiAgICAgICAgciA9IHouaXN0YXRlLmJsb2Nrcy5wcm9jKHosIHIpO1xuICAgICAgICBpZihyID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAgICAgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIgPT0gWl9PSyl7XG4gICAgICAgICAgciA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYociAhPSBaX1NUUkVBTV9FTkQpe1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBmO1xuICAgICAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgei5pc3RhdGUud2FzKTtcbiAgICAgICAgaWYoei5pc3RhdGUubm93cmFwIT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlPURPTkU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZT1DSEVDSzQ7XG4gICAgICBjYXNlIENIRUNLNDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZD0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDI0KSYweGZmMDAwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPUNIRUNLMztcbiAgICAgIGNhc2UgQ0hFQ0szOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDE2KSYweGZmMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMjtcbiAgICAgIGNhc2UgQ0hFQ0syOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDgpJjB4ZmYwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMTtcbiAgICAgIGNhc2UgQ0hFQ0sxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTtcblxuICAgICAgICBpZigoKHouaXN0YXRlLndhc1swXSkpICE9ICgoei5pc3RhdGUubmVlZCkpKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbmNvcnJlY3QgZGF0YSBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHosICBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4PTA7XG4gICAgdmFyIGxlbmd0aCA9IGRpY3RMZW5ndGg7XG4gICAgaWYoej09bnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsfHwgei5pc3RhdGUubW9kZSAhPSBESUNUMClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcblxuICAgIGlmKHouX2FkbGVyLmFkbGVyMzIoMSwgZGljdGlvbmFyeSwgMCwgZGljdExlbmd0aCkhPXouYWRsZXIpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG5cbiAgICB6LmFkbGVyID0gei5fYWRsZXIuYWRsZXIzMigwLCBudWxsLCAwLCAwKTtcblxuICAgIGlmKGxlbmd0aCA+PSAoMTw8ei5pc3RhdGUud2JpdHMpKXtcbiAgICAgIGxlbmd0aCA9ICgxPDx6LmlzdGF0ZS53Yml0cyktMTtcbiAgICAgIGluZGV4PWRpY3RMZW5ndGggLSBsZW5ndGg7XG4gICAgfVxuICAgIHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcbiAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgIHJldHVybiBaX09LO1xuICB9XG5cbi8vICBzdGF0aWMgcHJpdmF0ZSBieXRlW10gbWFyayA9IHsoYnl0ZSkwLCAoYnl0ZSkwLCAoYnl0ZSkweGZmLCAoYnl0ZSkweGZmfTtcbnZhciBtYXJrID0gWzAsIDAsIDI1NSwgMjU1XVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKHope1xuICAgIHZhciBuOyAgICAgICAvLyBudW1iZXIgb2YgYnl0ZXMgdG8gbG9vayBhdFxuICAgIHZhciBwOyAgICAgICAvLyBwb2ludGVyIHRvIGJ5dGVzXG4gICAgdmFyIG07ICAgICAgIC8vIG51bWJlciBvZiBtYXJrZXIgYnl0ZXMgZm91bmQgaW4gYSByb3dcbiAgICB2YXIgciwgdzsgICAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcblxuICAgIC8vIHNldCB1cFxuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGlmKHouaXN0YXRlLm1vZGUgIT0gQkFEKXtcbiAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwO1xuICAgIH1cbiAgICBpZigobj16LmF2YWlsX2luKT09MClcbiAgICAgIHJldHVybiBaX0JVRl9FUlJPUjtcbiAgICBwPXoubmV4dF9pbl9pbmRleDtcbiAgICBtPXouaXN0YXRlLm1hcmtlcjtcblxuICAgIC8vIHNlYXJjaFxuICAgIHdoaWxlIChuIT0wICYmIG0gPCA0KXtcbiAgICAgIGlmKHoubmV4dF9pbltwXSA9PSBtYXJrW21dKXtcbiAgICAgICAgbSsrO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih6Lm5leHRfaW5bcF0hPTApe1xuICAgICAgICBtID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIG0gPSA0IC0gbTtcbiAgICAgIH1cbiAgICAgIHArKzsgbi0tO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmVcbiAgICB6LnRvdGFsX2luICs9IHAtei5uZXh0X2luX2luZGV4O1xuICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XG4gICAgei5hdmFpbF9pbiA9IG47XG4gICAgei5pc3RhdGUubWFya2VyID0gbTtcblxuICAgIC8vIHJldHVybiBubyBqb3kgb3Igc2V0IHVwIHRvIHJlc3RhcnQgb24gYSBuZXcgYmxvY2tcbiAgICBpZihtICE9IDQpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcj16LnRvdGFsX2luOyAgdz16LnRvdGFsX291dDtcbiAgICB0aGlzLmluZmxhdGVSZXNldCh6KTtcbiAgICB6LnRvdGFsX2luPXI7ICB6LnRvdGFsX291dCA9IHc7XG4gICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICByZXR1cm4gWl9PSztcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxuICAvLyBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLiBQUFAgdXNlcyBaX1NZTkNfRkxVU0hcbiAgLy8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxuICAvLyBkZWNvbXByZXNzaW5nLCBQUFAgY2hlY2tzIHRoYXQgYXQgdGhlIGVuZCBvZiBpbnB1dCBwYWNrZXQsIGluZmxhdGUgaXNcbiAgLy8gd2FpdGluZyBmb3IgdGhlc2UgbGVuZ3RoIGJ5dGVzLlxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVN5bmNQb2ludCA9IGZ1bmN0aW9uKHope1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsIHx8IHouaXN0YXRlLmJsb2NrcyA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiB6LmlzdGF0ZS5ibG9ja3Muc3luY19wb2ludCgpO1xufVxuXG5cbi8vXG4vLyBJbmZCbG9ja3MuamF2YVxuLy9cblxudmFyIElORkJMT0NLU19CT1JERVIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07XG5cbmZ1bmN0aW9uIEluZkJsb2Nrcyh6LCBjaGVja2ZuLCB3KSB7XG4gICAgdGhpcy5odWZ0cz1uZXcgSW50MzJBcnJheShNQU5ZKjMpO1xuICAgIHRoaXMud2luZG93PW5ldyBVaW50OEFycmF5KHcpO1xuICAgIHRoaXMuZW5kPXc7XG4gICAgdGhpcy5jaGVja2ZuID0gY2hlY2tmbjtcbiAgICB0aGlzLm1vZGUgPSBJQl9UWVBFO1xuICAgIHRoaXMucmVzZXQoeiwgbnVsbCk7XG5cbiAgICB0aGlzLmxlZnQgPSAwOyAgICAgICAgICAgIC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5IFxuXG4gICAgdGhpcy50YWJsZSA9IDA7ICAgICAgICAgICAvLyB0YWJsZSBsZW5ndGhzICgxNCBiaXRzKSBcbiAgICB0aGlzLmluZGV4ID0gMDsgICAgICAgICAgIC8vIGluZGV4IGludG8gYmxlbnMgKG9yIGJvcmRlcikgXG4gICAgdGhpcy5ibGVucyA9IG51bGw7ICAgICAgICAgLy8gYml0IGxlbmd0aHMgb2YgY29kZXMgXG4gICAgdGhpcy5iYj1uZXcgSW50MzJBcnJheSgxKTsgLy8gYml0IGxlbmd0aCB0cmVlIGRlcHRoIFxuICAgIHRoaXMudGI9bmV3IEludDMyQXJyYXkoMSk7IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZSBcblxuICAgIHRoaXMuY29kZXMgPSBuZXcgSW5mQ29kZXMoKTtcblxuICAgIHRoaXMubGFzdCA9IDA7ICAgICAgICAgICAgLy8gdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIHRoZSBsYXN0IGJsb2NrIFxuXG4gIC8vIG1vZGUgaW5kZXBlbmRlbnQgaW5mb3JtYXRpb24gXG4gICAgdGhpcy5iaXRrID0gMDsgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXIgXG4gICAgdGhpcy5iaXRiID0gMDsgICAgICAgICAgICAvLyBiaXQgYnVmZmVyIFxuICAgIHRoaXMucmVhZCA9IDA7ICAgICAgICAgICAgLy8gd2luZG93IHJlYWQgcG9pbnRlciBcbiAgICB0aGlzLndyaXRlID0gMDsgICAgICAgICAgIC8vIHdpbmRvdyB3cml0ZSBwb2ludGVyIFxuICAgIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAvLyBjaGVjayBvbiBvdXRwdXQgXG5cbiAgICB0aGlzLmluZnRyZWU9bmV3IEluZlRyZWUoKTtcbn1cblxuXG5cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHosIGMpe1xuICAgIGlmKGMpIGNbMF09dGhpcy5jaGVjaztcbiAgICBpZih0aGlzLm1vZGU9PUlCX0NPREVTKXtcbiAgICAgIHRoaXMuY29kZXMuZnJlZSh6KTtcbiAgICB9XG4gICAgdGhpcy5tb2RlPUlCX1RZUEU7XG4gICAgdGhpcy5iaXRrPTA7XG4gICAgdGhpcy5iaXRiPTA7XG4gICAgdGhpcy5yZWFkPXRoaXMud3JpdGU9MDtcblxuICAgIGlmKHRoaXMuY2hlY2tmbilcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKDAsIG51bGwsIDAsIDApO1xuICB9XG5cbiBJbmZCbG9ja3MucHJvdG90eXBlLnByb2MgPSBmdW5jdGlvbih6LCByKXtcbiAgICB2YXIgdDsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIGI7ICAgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG5cbiAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcbiAgICB7cD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO31cbiAgICB7cT10aGlzLndyaXRlO209KHE8dGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO31cblxuICAgIC8vIHByb2Nlc3MgaW5wdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlKHRydWUpe1xuICAgICAgc3dpdGNoICh0aGlzLm1vZGUpe1xuICAgICAgY2FzZSBJQl9UWVBFOlxuXG5cdHdoaWxlKGs8KDMpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXHR0ID0gKGIgJiA3KTtcblx0dGhpcy5sYXN0ID0gdCAmIDE7XG5cblx0c3dpdGNoICh0ID4+PiAxKXtcbiAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZWQgXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG4gICAgICAgICAgdCA9IGsgJiA3OyAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gYnl0ZSBib3VuZGFyeVxuXG4gICAgICAgICAge2I+Pj49KHQpO2stPSh0KTt9XG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfTEVOUzsgICAgICAgICAgICAgICAgICAvLyBnZXQgbGVuZ3RoIG9mIHN0b3JlZCBibG9ja1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkXG4gICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICAgIHZhciBiZD1uZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgICAgdmFyIHRsPVtdO1xuXHQgICAgICB2YXIgdGQ9W107XG5cblx0ICAgICAgaW5mbGF0ZV90cmVlc19maXhlZChibCwgYmQsIHRsLCB0ZCwgeik7XG4gICAgICAgICAgICAgIHRoaXMuY29kZXMuaW5pdChibFswXSwgYmRbMF0sIHRsWzBdLCAwLCB0ZFswXSwgMCwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG5cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9DT0RFUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljXG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cblxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX1RBQkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWxcblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuICAgICAgICAgIHRoaXMubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBibG9jayB0eXBlXCI7XG4gICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0YnJlYWs7XG4gICAgICBjYXNlIElCX0xFTlM6XG5cdHdoaWxlKGs8KDMyKSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHRpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSl7XG5cdCAgdGhpcy5tb2RlID0gQkFEO1xuXHQgIHoubXNnID0gXCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXCI7XG5cdCAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0dGhpcy5sZWZ0ID0gKGIgJiAweGZmZmYpO1xuXHRiID0gayA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW1wIGJpdHNcblx0dGhpcy5tb2RlID0gbGVmdCE9MCA/IElCX1NUT1JFRCA6ICh0aGlzLmxhc3QhPTAgPyBJQl9EUlkgOiBJQl9UWVBFKTtcblx0YnJlYWs7XG4gICAgICBjYXNlIElCX1NUT1JFRDpcblx0aWYgKG4gPT0gMCl7XG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgd3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblxuXHRpZihtPT0wKXtcblx0ICBpZihxPT1lbmQmJnJlYWQhPTApe1xuXHQgICAgcT0wOyBtPShxPHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICB9XG5cdCAgaWYobT09MCl7XG5cdCAgICB0aGlzLndyaXRlPXE7IFxuXHQgICAgcj10aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIHE9dGhpcy53cml0ZTsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgICAgaWYocT09dGhpcy5lbmQgJiYgdGhpcy5yZWFkICE9IDApe1xuXHQgICAgICBxPTA7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICAgIH1cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRyPVpfT0s7XG5cblx0dCA9IHRoaXMubGVmdDtcblx0aWYodD5uKSB0ID0gbjtcblx0aWYodD5tKSB0ID0gbTtcblx0YXJyYXlDb3B5KHoubmV4dF9pbiwgcCwgd2luZG93LCBxLCB0KTtcblx0cCArPSB0OyAgbiAtPSB0O1xuXHRxICs9IHQ7ICBtIC09IHQ7XG5cdGlmICgodGhpcy5sZWZ0IC09IHQpICE9IDApXG5cdCAgYnJlYWs7XG5cdHRoaXMubW9kZSA9ICh0aGlzLmxhc3QgIT0gMCA/IElCX0RSWSA6IElCX1RZUEUpO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfVEFCTEU6XG5cblx0d2hpbGUoazwoMTQpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMudGFibGUgPSB0ID0gKGIgJiAweDNmZmYpO1xuXHRpZiAoKHQgJiAweDFmKSA+IDI5IHx8ICgodCA+PiA1KSAmIDB4MWYpID4gMjkpXG5cdCAge1xuXHQgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgei5tc2cgPSBcInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCI7XG5cdCAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0dCA9IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKTtcblx0aWYodGhpcy5ibGVucz09bnVsbCB8fCB0aGlzLmJsZW5zLmxlbmd0aDx0KXtcblx0ICAgIHRoaXMuYmxlbnM9bmV3IEludDMyQXJyYXkodCk7XG5cdH1cblx0ZWxzZXtcblx0ICBmb3IodmFyIGk9MDsgaTx0OyBpKyspe1xuICAgICAgICAgICAgICB0aGlzLmJsZW5zW2ldPTA7XG4gICAgICAgICAgfVxuXHR9XG5cblx0e2I+Pj49KDE0KTtrLT0oMTQpO31cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0dGhpcy5tb2RlID0gSUJfQlRSRUU7XG4gICAgICBjYXNlIElCX0JUUkVFOlxuXHR3aGlsZSAodGhpcy5pbmRleCA8IDQgKyAodGhpcy50YWJsZSA+Pj4gMTApKXtcblx0ICB3aGlsZShrPCgzKSl7XG5cdCAgICBpZihuIT0wKXtcblx0ICAgICAgcj1aX09LO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9O1xuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgays9ODtcblx0ICB9XG5cblx0ICB0aGlzLmJsZW5zW0lORkJMT0NLU19CT1JERVJbdGhpcy5pbmRleCsrXV0gPSBiJjc7XG5cblx0ICB7Yj4+Pj0oMyk7ay09KDMpO31cblx0fVxuXG5cdHdoaWxlKHRoaXMuaW5kZXggPCAxOSl7XG5cdCAgdGhpcy5ibGVuc1tJTkZCTE9DS1NfQk9SREVSW3RoaXMuaW5kZXgrK11dID0gMDtcblx0fVxuXG5cdHRoaXMuYmJbMF0gPSA3O1xuXHR0ID0gdGhpcy5pbmZ0cmVlLmluZmxhdGVfdHJlZXNfYml0cyh0aGlzLmJsZW5zLCB0aGlzLmJiLCB0aGlzLnRiLCB0aGlzLmh1ZnRzLCB6KTtcblx0aWYgKHQgIT0gWl9PSyl7XG5cdCAgciA9IHQ7XG5cdCAgaWYgKHIgPT0gWl9EQVRBX0VSUk9SKXtcblx0ICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICB9XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB3cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXG5cdHRoaXMuaW5kZXggPSAwO1xuXHR0aGlzLm1vZGUgPSBJQl9EVFJFRTtcbiAgICAgIGNhc2UgSUJfRFRSRUU6XG5cdHdoaWxlICh0cnVlKXtcblx0ICB0ID0gdGhpcy50YWJsZTtcblx0ICBpZighKHRoaXMuaW5kZXggPCAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZikpKXtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblxuXHQgIHZhciBoOyAvL2ludFtdXG5cdCAgdmFyIGksIGosIGM7XG5cblx0ICB0ID0gdGhpcy5iYlswXTtcblxuXHQgIHdoaWxlKGs8KHQpKXtcblx0ICAgIGlmKG4hPTApe1xuXHQgICAgICByPVpfT0s7XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47XG5cdCAgICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH07XG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICBrKz04O1xuXHQgIH1cblxuLy9cdCAgaWYgKHRoaXMudGJbMF09PS0xKXtcbi8vICAgICAgICAgICAgZGxvZyhcIm51bGwuLi5cIik7XG4vL1x0ICB9XG5cblx0ICB0PXRoaXMuaHVmdHNbKHRoaXMudGJbMF0rKGIgJiBpbmZsYXRlX21hc2tbdF0pKSozKzFdO1xuXHQgIGM9dGhpcy5odWZ0c1sodGhpcy50YlswXSsoYiAmIGluZmxhdGVfbWFza1t0XSkpKjMrMl07XG5cblx0ICBpZiAoYyA8IDE2KXtcblx0ICAgIGI+Pj49KHQpO2stPSh0KTtcblx0ICAgIHRoaXMuYmxlbnNbdGhpcy5pbmRleCsrXSA9IGM7XG5cdCAgfVxuXHQgIGVsc2UgeyAvLyBjID09IDE2Li4xOFxuXHQgICAgaSA9IGMgPT0gMTggPyA3IDogYyAtIDE0O1xuXHQgICAgaiA9IGMgPT0gMTggPyAxMSA6IDM7XG5cblx0ICAgIHdoaWxlKGs8KHQraSkpe1xuXHQgICAgICBpZihuIT0wKXtcblx0XHRyPVpfT0s7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZXtcblx0XHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHRcdHouYXZhaWxfaW49bjtcblx0XHR6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0XHR0aGlzLndyaXRlPXE7XG5cdFx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICB9O1xuXHQgICAgICBuLS07XG5cdCAgICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgICAgays9ODtcblx0ICAgIH1cblxuXHQgICAgYj4+Pj0odCk7ay09KHQpO1xuXG5cdCAgICBqICs9IChiICYgaW5mbGF0ZV9tYXNrW2ldKTtcblxuXHQgICAgYj4+Pj0oaSk7ay09KGkpO1xuXG5cdCAgICBpID0gdGhpcy5pbmRleDtcblx0ICAgIHQgPSB0aGlzLnRhYmxlO1xuXHQgICAgaWYgKGkgKyBqID4gMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpIHx8XG5cdFx0KGMgPT0gMTYgJiYgaSA8IDEpKXtcblx0ICAgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgICAgIHoubXNnID0gXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCI7XG5cdCAgICAgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblxuXHQgICAgYyA9IGMgPT0gMTYgPyB0aGlzLmJsZW5zW2ktMV0gOiAwO1xuXHQgICAgZG97XG5cdCAgICAgIHRoaXMuYmxlbnNbaSsrXSA9IGM7XG5cdCAgICB9XG5cdCAgICB3aGlsZSAoLS1qIT0wKTtcblx0ICAgIHRoaXMuaW5kZXggPSBpO1xuXHQgIH1cblx0fVxuXG5cdHRoaXMudGJbMF09LTE7XG5cdHtcblx0ICAgIHZhciBibD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciBiZD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciB0bD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIHZhciB0ZD1uZXcgSW50MzJBcnJheSgxKTtcblx0ICAgIGJsWzBdID0gOTsgICAgICAgICAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xuXHQgICAgYmRbMF0gPSA2OyAgICAgICAgIC8vIG11c3QgYmUgPD0gOSBmb3IgbG9va2FoZWFkIGFzc3VtcHRpb25zXG5cblx0ICAgIHQgPSB0aGlzLnRhYmxlO1xuXHQgICAgdCA9IHRoaXMuaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2R5bmFtaWMoMjU3ICsgKHQgJiAweDFmKSwgXG5cdFx0XHRcdFx0ICAgICAgMSArICgodCA+PiA1KSAmIDB4MWYpLFxuXHRcdFx0XHRcdCAgICAgIHRoaXMuYmxlbnMsIGJsLCBiZCwgdGwsIHRkLCB0aGlzLmh1ZnRzLCB6KTtcblxuXHQgICAgaWYgKHQgIT0gWl9PSyl7XG5cdCAgICAgICAgaWYgKHQgPT0gWl9EQVRBX0VSUk9SKXtcblx0ICAgICAgICAgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgICAgICAgICB0aGlzLm1vZGUgPSBCQUQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHIgPSB0O1xuXG5cdCAgICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuY29kZXMuaW5pdChibFswXSwgYmRbMF0sIHRoaXMuaHVmdHMsIHRsWzBdLCB0aGlzLmh1ZnRzLCB0ZFswXSwgeik7XG5cdH1cblx0dGhpcy5tb2RlID0gSUJfQ09ERVM7XG4gICAgICBjYXNlIElCX0NPREVTOlxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjsgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblxuXHRpZiAoKHIgPSB0aGlzLmNvZGVzLnByb2ModGhpcywgeiwgcikpICE9IFpfU1RSRUFNX0VORCl7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblx0fVxuXHRyID0gWl9PSztcblx0dGhpcy5jb2Rlcy5mcmVlKHopO1xuXG5cdHA9ei5uZXh0X2luX2luZGV4OyBuPXouYXZhaWxfaW47Yj10aGlzLmJpdGI7az10aGlzLmJpdGs7XG5cdHE9dGhpcy53cml0ZTttID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cblx0aWYgKHRoaXMubGFzdD09MCl7XG5cdCAgdGhpcy5tb2RlID0gSUJfVFlQRTtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQl9EUlk7XG4gICAgICBjYXNlIElCX0RSWTpcblx0dGhpcy53cml0ZT1xOyBcblx0ciA9IHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTsgXG5cdHE9dGhpcy53cml0ZTsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHRpZiAodGhpcy5yZWFkICE9IHRoaXMud3JpdGUpe1xuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXHR9XG5cdHRoaXMubW9kZSA9IERPTkU7XG4gICAgICBjYXNlIElCX0RPTkU6XG5cdHIgPSBaX1NUUkVBTV9FTkQ7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG4gICAgICBjYXNlIElCX0JBRDpcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblxuICAgICAgZGVmYXVsdDpcblx0ciA9IFpfU1RSRUFNX0VSUk9SO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbih6KXtcbiAgICB0aGlzLnJlc2V0KHosIG51bGwpO1xuICAgIHRoaXMud2luZG93PW51bGw7XG4gICAgdGhpcy5odWZ0cz1udWxsO1xufVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLnNldF9kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZCwgc3RhcnQsIG4pe1xuICAgIGFycmF5Q29weShkLCBzdGFydCwgd2luZG93LCAwLCBuKTtcbiAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gbjtcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBcbkluZkJsb2Nrcy5wcm90b3R5cGUuc3luY19wb2ludCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PSBJQl9MRU5TO1xufVxuXG4gIC8vIGNvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBzbGlkaW5nIHdpbmRvdyB0byB0aGUgb3V0cHV0IGFyZWFcbkluZkJsb2Nrcy5wcm90b3R5cGUuaW5mbGF0ZV9mbHVzaCA9IGZ1bmN0aW9uKHosIHIpe1xuICAgIHZhciBuO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuXG4gICAgLy8gbG9jYWwgY29waWVzIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcG9pbnRlcnNcbiAgICBwID0gei5uZXh0X291dF9pbmRleDtcbiAgICBxID0gdGhpcy5yZWFkO1xuXG4gICAgLy8gY29tcHV0ZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xuICAgIG4gPSAoKHEgPD0gdGhpcy53cml0ZSA/IHRoaXMud3JpdGUgOiB0aGlzLmVuZCkgLSBxKTtcbiAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgaWYgKG4hPTAgJiYgciA9PSBaX0JVRl9FUlJPUikgciA9IFpfT0s7XG5cbiAgICAvLyB1cGRhdGUgY291bnRlcnNcbiAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgIHoudG90YWxfb3V0ICs9IG47XG5cbiAgICAvLyB1cGRhdGUgY2hlY2sgaW5mb3JtYXRpb25cbiAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKHRoaXMuY2hlY2ssIHRoaXMud2luZG93LCBxLCBuKTtcblxuICAgIC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcbiAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgIHAgKz0gbjtcbiAgICBxICs9IG47XG5cbiAgICAvLyBzZWUgaWYgbW9yZSB0byBjb3B5IGF0IGJlZ2lubmluZyBvZiB3aW5kb3dcbiAgICBpZiAocSA9PSB0aGlzLmVuZCl7XG4gICAgICAvLyB3cmFwIHBvaW50ZXJzXG4gICAgICBxID0gMDtcbiAgICAgIGlmICh0aGlzLndyaXRlID09IHRoaXMuZW5kKVxuICAgICAgICB0aGlzLndyaXRlID0gMDtcblxuICAgICAgLy8gY29tcHV0ZSBieXRlcyB0byBjb3B5XG4gICAgICBuID0gdGhpcy53cml0ZSAtIHE7XG4gICAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgICBpZiAobiE9MCAmJiByID09IFpfQlVGX0VSUk9SKSByID0gWl9PSztcblxuICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgICAgei50b3RhbF9vdXQgKz0gbjtcblxuICAgICAgLy8gdXBkYXRlIGNoZWNrIGluZm9ybWF0aW9uXG4gICAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcblx0ei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIodGhpcy5jaGVjaywgdGhpcy53aW5kb3csIHEsIG4pO1xuXG4gICAgICAvLyBjb3B5XG4gICAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgICAgcCArPSBuO1xuICAgICAgcSArPSBuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBwb2ludGVyc1xuICAgIHoubmV4dF9vdXRfaW5kZXggPSBwO1xuICAgIHRoaXMucmVhZCA9IHE7XG5cbiAgICAvLyBkb25lXG4gICAgcmV0dXJuIHI7XG4gIH1cblxuLy9cbi8vIEluZkNvZGVzLmphdmFcbi8vXG5cbnZhciBJQ19TVEFSVD0wOyAgLy8geDogc2V0IHVwIGZvciBMRU5cbnZhciBJQ19MRU49MTsgICAgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XG52YXIgSUNfTEVORVhUPTI7IC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXG52YXIgSUNfRElTVD0zOyAgIC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XG52YXIgSUNfRElTVEVYVD00Oy8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcbnZhciBJQ19DT1BZPTU7ICAgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmcgZm9yIHNwYWNlXG52YXIgSUNfTElUPTY7ICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2VcbnZhciBJQ19XQVNIPTc7ICAgLy8gbzogZ290IGVvYiwgcG9zc2libHkgc3RpbGwgb3V0cHV0IHdhaXRpbmdcbnZhciBJQ19FTkQ9ODsgICAgLy8geDogZ290IGVvYiBhbmQgYWxsIGRhdGEgZmx1c2hlZFxudmFyIElDX0JBRENPREU9OTsvLyB4OiBnb3QgZXJyb3JcblxuZnVuY3Rpb24gSW5mQ29kZXMoKSB7XG59XG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgeikge1xuICAgIHRoaXMubW9kZT1JQ19TVEFSVDtcbiAgICB0aGlzLmxiaXRzPWJsO1xuICAgIHRoaXMuZGJpdHM9YmQ7XG4gICAgdGhpcy5sdHJlZT10bDtcbiAgICB0aGlzLmx0cmVlX2luZGV4PXRsX2luZGV4O1xuICAgIHRoaXMuZHRyZWUgPSB0ZDtcbiAgICB0aGlzLmR0cmVlX2luZGV4PXRkX2luZGV4O1xuICAgIHRoaXMudHJlZT1udWxsO1xufVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUucHJvYyA9IGZ1bmN0aW9uKHMsIHosIHIpeyBcbiAgICB2YXIgajsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlciAoaW50W10pXG4gICAgdmFyIHRpbmRleDsgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciBlOyAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYj0wOyAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgaz0wOyAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwPTA7ICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgZjsgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cblxuICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxuICAgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcbiAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0IGFuZCBvdXRwdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKXtcblx0Ly8gd2FpdGluZyBmb3IgXCJpOlwiPWlucHV0LCBcIm86XCI9b3V0cHV0LCBcIng6XCI9bm90aGluZ1xuICAgICAgY2FzZSBJQ19TVEFSVDogICAgICAgICAvLyB4OiBzZXQgdXAgZm9yIExFTlxuXHRpZiAobSA+PSAyNTggJiYgbiA+PSAxMCl7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXHQgIHIgPSB0aGlzLmluZmxhdGVfZmFzdCh0aGlzLmxiaXRzLCB0aGlzLmRiaXRzLCBcblx0XHRcdCAgIHRoaXMubHRyZWUsIHRoaXMubHRyZWVfaW5kZXgsIFxuXHRcdFx0ICAgdGhpcy5kdHJlZSwgdGhpcy5kdHJlZV9pbmRleCxcblx0XHRcdCAgIHMsIHopO1xuXG5cdCAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuXHQgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgIGlmIChyICE9IFpfT0spe1xuXHQgICAgdGhpcy5tb2RlID0gciA9PSBaX1NUUkVBTV9FTkQgPyBJQ19XQVNIIDogSUNfQkFEQ09ERTtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXHR0aGlzLm5lZWQgPSB0aGlzLmxiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmx0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXg9dGhpcy5sdHJlZV9pbmRleDtcblxuXHR0aGlzLm1vZGUgPSBJQ19MRU47XG4gICAgICBjYXNlIElDX0xFTjogICAgICAgICAgIC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGluZGV4PSh0aGlzLnRyZWVfaW5kZXgrKGImaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj4+PSh0aGlzLnRyZWVbdGluZGV4KzFdKTtcblx0ay09KHRoaXMudHJlZVt0aW5kZXgrMV0pO1xuXG5cdGU9dGhpcy50cmVlW3RpbmRleF07XG5cblx0aWYoZSA9PSAwKXsgICAgICAgICAgICAgICAvLyBsaXRlcmFsXG5cdCAgdGhpcy5saXQgPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0xJVDtcblx0ICBicmVhaztcblx0fVxuXHRpZigoZSAmIDE2KSE9MCApeyAgICAgICAgICAvLyBsZW5ndGhcblx0ICB0aGlzLmdldCA9IGUgJiAxNTtcblx0ICB0aGlzLmxlbiA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfTEVORVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiAzMikhPTApeyAgICAgICAgICAgICAgIC8vIGVuZCBvZiBibG9ja1xuXHQgIHRoaXMubW9kZSA9IElDX1dBU0g7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfQkFEQ09ERTsgICAgICAgIC8vIGludmFsaWQgY29kZVxuXHR6Lm1zZyA9IFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCI7XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfTEVORVhUOiAgICAgICAgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcblx0aiA9IHRoaXMuZ2V0O1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMubGVuICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcblxuXHRiPj49ajtcblx0ay09ajtcblxuXHR0aGlzLm5lZWQgPSB0aGlzLmRiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmR0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXggPSB0aGlzLmR0cmVlX2luZGV4O1xuXHR0aGlzLm1vZGUgPSBJQ19ESVNUO1xuICAgICAgY2FzZSBJQ19ESVNUOiAgICAgICAgICAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRpbmRleD0odGhpcy50cmVlX2luZGV4KyhiICYgaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj49dGhpcy50cmVlW3RpbmRleCsxXTtcblx0ay09dGhpcy50cmVlW3RpbmRleCsxXTtcblxuXHRlID0gKHRoaXMudHJlZVt0aW5kZXhdKTtcblx0aWYoKGUgJiAxNikhPTApeyAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlXG5cdCAgdGhpcy5nZXQgPSBlICYgMTU7XG5cdCAgdGhpcy5kaXN0ID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19ESVNURVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19CQURDT0RFOyAgICAgICAgLy8gaW52YWxpZCBjb2RlXG5cdHoubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIjtcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19ESVNURVhUOiAgICAgICAvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXG5cdGogPSB0aGlzLmdldDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLmRpc3QgKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xuXG5cdGI+Pj1qO1xuXHRrLT1qO1xuXG5cdHRoaXMubW9kZSA9IElDX0NPUFk7XG4gICAgICBjYXNlIElDX0NPUFk6ICAgICAgICAgIC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxuICAgICAgICBmID0gcSAtIHRoaXMuZGlzdDtcbiAgICAgICAgd2hpbGUoZiA8IDApeyAgICAgLy8gbW9kdWxvIHdpbmRvdyBzaXplLVwid2hpbGVcIiBpbnN0ZWFkXG4gICAgICAgICAgZiArPSBzLmVuZDsgICAgIC8vIG9mIFwiaWZcIiBoYW5kbGVzIGludmFsaWQgZGlzdGFuY2VzXG5cdH1cblx0d2hpbGUgKHRoaXMubGVuIT0wKXtcblxuXHQgIGlmKG09PTApe1xuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXG5cdCAgICAgIGlmKG09PTApe1xuXHRcdHMuYml0Yj1iO3MuYml0az1rO1xuXHRcdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0XHRzLndyaXRlPXE7XG5cdFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICB9ICBcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzLndpbmRvd1txKytdPXMud2luZG93W2YrK107IG0tLTtcblxuXHQgIGlmIChmID09IHMuZW5kKVxuICAgICAgICAgICAgZiA9IDA7XG5cdCAgdGhpcy5sZW4tLTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX0xJVDogICAgICAgICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2Vcblx0aWYobT09MCl7XG5cdCAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICBpZihtPT0wKXtcblx0ICAgIHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICBzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHMud2luZG93W3ErK109dGhpcy5saXQ7IG0tLTtcblxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX1dBU0g6ICAgICAgICAgICAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBtb3JlIG91dHB1dFxuXHRpZiAoayA+IDcpeyAgICAgICAgLy8gcmV0dXJuIHVudXNlZCBieXRlLCBpZiBhbnlcblx0ICBrIC09IDg7XG5cdCAgbisrO1xuXHQgIHAtLTsgICAgICAgICAgICAgLy8gY2FuIGFsd2F5cyByZXR1cm4gb25lXG5cdH1cblxuXHRzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHRpZiAocy5yZWFkICE9IHMud3JpdGUpe1xuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0VORDtcbiAgICAgIGNhc2UgSUNfRU5EOlxuXHRyID0gWl9TVFJFQU1fRU5EO1xuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19CQURDT0RFOiAgICAgICAvLyB4OiBnb3QgZXJyb3JcblxuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBkZWZhdWx0OlxuXHRyID0gWl9TVFJFQU1fRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbkluZkNvZGVzLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oeil7XG4gICAgLy8gIFpGUkVFKHosIGMpO1xufVxuXG4gIC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcbiAgLy8gKHRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGgpIGFuZCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgYXZhaWxhYmxlXG4gIC8vIGF0IGxlYXN0IHRlbi4gIFRoZSB0ZW4gYnl0ZXMgYXJlIHNpeCBieXRlcyBmb3IgdGhlIGxvbmdlc3QgbGVuZ3RoL1xuICAvLyBkaXN0YW5jZSBwYWlyIHBsdXMgZm91ciBieXRlcyBmb3Igb3ZlcmxvYWRpbmcgdGhlIGJpdCBidWZmZXIuXG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbmZsYXRlX2Zhc3QgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyICAgdHA7ICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyIChpbnRbXSlcbiAgICB2YXIgdHBfaW5kZXg7ICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgZTsgICAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYjsgICAgICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgbWw7ICAgICAgICAgICAgICAgLy8gbWFzayBmb3IgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHZhciBtZDsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciBkaXN0YW5jZSB0cmVlXG4gICAgdmFyIGM7ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGNvcHlcbiAgICB2YXIgZDsgICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cbiAgICB2YXIgcjsgICAgICAgICAgICAgICAgLy8gY29weSBzb3VyY2UgcG9pbnRlclxuXG4gICAgdmFyIHRwX2luZGV4X3RfMzsgICAgIC8vICh0cF9pbmRleCt0KSozXG5cbiAgICAvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcbiAgICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG4gICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBtYXNrc1xuICAgIG1sID0gaW5mbGF0ZV9tYXNrW2JsXTtcbiAgICBtZCA9IGluZmxhdGVfbWFza1tiZF07XG5cbiAgICAvLyBkbyB1bnRpbCBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBzcGFjZSBmb3IgZmFzdCBsb29wXG4gICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGNhbGxlZCB3aXRoIG0gPj0gMjU4ICYmIG4gPj0gMTBcbiAgICAgIC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXG4gICAgICB3aGlsZShrPCgyMCkpeyAgICAgICAgICAgICAgLy8gbWF4IGJpdHMgZm9yIGxpdGVyYWwvbGVuZ3RoIGNvZGVcblx0bi0tO1xuXHRifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcbiAgICAgIH1cblxuICAgICAgdD0gYiZtbDtcbiAgICAgIHRwPXRsOyBcbiAgICAgIHRwX2luZGV4PXRsX2luZGV4O1xuICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuICAgICAgaWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT0gMCl7XG5cdGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0cy53aW5kb3dbcSsrXSA9IHRwW3RwX2luZGV4X3RfMysyXTtcblx0bS0tO1xuXHRjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvIHtcblxuXHRiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdGlmKChlJjE2KSE9MCl7XG5cdCAgZSAmPSAxNTtcblx0ICBjID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGIgJiBpbmZsYXRlX21hc2tbZV0pO1xuXG5cdCAgYj4+PWU7IGstPWU7XG5cblx0ICAvLyBkZWNvZGUgZGlzdGFuY2UgYmFzZSBvZiBibG9jayB0byBjb3B5XG5cdCAgd2hpbGUoazwoMTUpKXsgICAgICAgICAgIC8vIG1heCBiaXRzIGZvciBkaXN0YW5jZSBjb2RlXG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcblx0ICB9XG5cblx0ICB0PSBiJm1kO1xuXHQgIHRwPXRkO1xuXHQgIHRwX2luZGV4PXRkX2luZGV4O1xuICAgICAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICBlID0gdHBbdHBfaW5kZXhfdF8zXTtcblxuXHQgIGRvIHtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgaWYoKGUmMTYpIT0wKXtcblx0ICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2Vcblx0ICAgICAgZSAmPSAxNTtcblx0ICAgICAgd2hpbGUoazwoZSkpeyAgICAgICAgIC8vIGdldCBleHRyYSBiaXRzICh1cCB0byAxMylcblx0XHRuLS07XG5cdFx0Ynw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG5cdCAgICAgIH1cblxuXHQgICAgICBkID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGImaW5mbGF0ZV9tYXNrW2VdKTtcblxuXHQgICAgICBiPj49KGUpOyBrLT0oZSk7XG5cblx0ICAgICAgLy8gZG8gdGhlIGNvcHlcblx0ICAgICAgbSAtPSBjO1xuXHQgICAgICBpZiAocSA+PSBkKXsgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XG5cdFx0Ly8gIGp1c3QgY29weVxuXHRcdHI9cS1kO1xuXHRcdGlmKHEtcj4wICYmIDI+KHEtcikpeyAgICAgICAgICAgXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIG1pbmltdW0gY291bnQgaXMgdGhyZWUsXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIHNvIHVucm9sbCBsb29wIGEgbGl0dGxlXG5cdFx0ICBjLT0yO1xuXHRcdH1cblx0XHRlbHNle1xuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtIGNvdW50IGlzIHRocmVlLFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGwgbG9vcCBhIGxpdHRsZVxuXHRcdCAgYy09Mjtcblx0XHR9XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZXsgICAgICAgICAgICAgICAgICAvLyBlbHNlIG9mZnNldCBhZnRlciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICAgIHI9cS1kO1xuICAgICAgICAgICAgICAgIGRve1xuICAgICAgICAgICAgICAgICAgcis9cy5lbmQ7ICAgICAgICAgIC8vIGZvcmNlIHBvaW50ZXIgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgfXdoaWxlKHI8MCk7ICAgICAgICAgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXG5cdFx0ZT1zLmVuZC1yO1xuXHRcdGlmKGM+ZSl7ICAgICAgICAgICAgIC8vIGlmIHNvdXJjZSBjcm9zc2VzLFxuXHRcdCAgYy09ZTsgICAgICAgICAgICAgIC8vIHdyYXBwZWQgY29weVxuXHRcdCAgaWYocS1yPjAgJiYgZT4ocS1yKSl7ICAgICAgICAgICBcblx0XHQgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdCAgICB3aGlsZSgtLWUhPTApO1xuXHRcdCAgfVxuXHRcdCAgZWxzZXtcblx0XHQgICAgYXJyYXlDb3B5KHMud2luZG93LCByLCBzLndpbmRvdywgcSwgZSk7XG5cdFx0ICAgIHErPWU7IHIrPWU7IGU9MDtcblx0XHQgIH1cblx0XHQgIHIgPSAwOyAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdCBmcm9tIHN0YXJ0IG9mIHdpbmRvd1xuXHRcdH1cblxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gY29weSBhbGwgb3Igd2hhdCdzIGxlZnRcbiAgICAgICAgICAgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdHdoaWxlKC0tYyE9MCk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZigoZSY2NCk9PTApe1xuXHQgICAgICB0Kz10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICAgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICAgICAgZT10cFt0cF9pbmRleF90XzNdO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgei5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiO1xuXG5cdCAgICAgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG5cdCAgICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHMud3JpdGU9cTtcblxuXHQgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuXHQgICAgfVxuXHQgIH1cblx0ICB3aGlsZSh0cnVlKTtcblx0ICBicmVhaztcblx0fVxuXG5cdGlmKChlJjY0KT09MCl7XG5cdCAgdCs9dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgIGlmKChlPXRwW3RwX2luZGV4X3RfM10pPT0wKXtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgcy53aW5kb3dbcSsrXT10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICBtLS07XG5cdCAgICBicmVhaztcblx0ICB9XG5cdH1cblx0ZWxzZSBpZigoZSYzMikhPTApe1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG4gXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblxuXHQgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG5cdH1cblx0ZWxzZXtcblx0ICB6Lm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiO1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXG5cdCAgcmV0dXJuIFpfREFUQV9FUlJPUjtcblx0fVxuICAgICAgfSBcbiAgICAgIHdoaWxlKHRydWUpO1xuICAgIH0gXG4gICAgd2hpbGUobT49MjU4ICYmIG4+PSAxMCk7XG5cbiAgICAvLyBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dC0tcmVzdG9yZSBwb2ludGVycyBhbmQgcmV0dXJuXG4gICAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cbiAgICBzLmJpdGI9YjtzLmJpdGs9aztcbiAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG4gICAgcy53cml0ZT1xO1xuXG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbi8vXG4vLyBJbmZUcmVlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZlRyZWUoKSB7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmh1ZnRfYnVpbGQgPSBmdW5jdGlvbihiLCBiaW5kZXgsIG4sIHMsIGQsIGUsIHQsIG0sIGhwLCBobiwgdikge1xuXG4gICAgLy8gR2l2ZW4gYSBsaXN0IG9mIGNvZGUgbGVuZ3RocyBhbmQgYSBtYXhpbXVtIHRhYmxlIHNpemUsIG1ha2UgYSBzZXQgb2ZcbiAgICAvLyB0YWJsZXMgdG8gZGVjb2RlIHRoYXQgc2V0IG9mIGNvZGVzLiAgUmV0dXJuIFpfT0sgb24gc3VjY2VzcywgWl9CVUZfRVJST1JcbiAgICAvLyBpZiB0aGUgZ2l2ZW4gY29kZSBzZXQgaXMgaW5jb21wbGV0ZSAodGhlIHRhYmxlcyBhcmUgc3RpbGwgYnVpbHQgaW4gdGhpc1xuICAgIC8vIGNhc2UpLCBaX0RBVEFfRVJST1IgaWYgdGhlIGlucHV0IGlzIGludmFsaWQgKGFuIG92ZXItc3Vic2NyaWJlZCBzZXQgb2ZcbiAgICAvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXG5cbiAgICB2YXIgYTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXG4gICAgdmFyIGY7ICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHJlcGVhdHMgaW4gdGFibGUgZXZlcnkgZiBlbnRyaWVzXG4gICAgdmFyIGc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgdmFyIGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSBsZXZlbFxuICAgIHZhciBpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlciwgY3VycmVudCBjb2RlXG4gICAgdmFyIGo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcbiAgICB2YXIgbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcGVyIHRhYmxlIChyZXR1cm5lZCBpbiBtKVxuICAgIHZhciBtYXNrOyAgICAgICAgICAgICAgICAgICAgLy8gKDEgPDwgdykgLSAxLCB0byBhdm9pZCBjYyAtTyBidWcgb24gSFBcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMgdG8gY3VycmVudCB0YWJsZVxuICAgIHZhciB3OyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBiZWZvcmUgdGhpcyB0YWJsZSA9PSAobCAqIGgpXG4gICAgdmFyIHhwOyAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGludG8geFxuICAgIHZhciB5OyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXG4gICAgdmFyIHo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXG5cbiAgICAvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxuXG4gICAgcCA9IDA7IGkgPSBuO1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY1tiW2JpbmRleCtwXV0rKzsgcCsrOyBpLS07ICAgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcbiAgICB9d2hpbGUoaSE9MCk7XG5cbiAgICBpZih0aGlzLmNbMF0gPT0gbil7ICAgICAgICAgICAgICAgIC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xuICAgICAgdFswXSA9IC0xO1xuICAgICAgbVswXSA9IDA7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvLyBGaW5kIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoLCBib3VuZCAqbSBieSB0aG9zZVxuICAgIGwgPSBtWzBdO1xuICAgIGZvciAoaiA9IDE7IGogPD0gQk1BWDsgaisrKVxuICAgICAgaWYodGhpcy5jW2pdIT0wKSBicmVhaztcbiAgICBrID0gajsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5pbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA8IGope1xuICAgICAgbCA9IGo7XG4gICAgfVxuICAgIGZvciAoaSA9IEJNQVg7IGkhPTA7IGktLSl7XG4gICAgICBpZih0aGlzLmNbaV0hPTApIGJyZWFrO1xuICAgIH1cbiAgICBnID0gaTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA+IGkpe1xuICAgICAgbCA9IGk7XG4gICAgfVxuICAgIG1bMF0gPSBsO1xuXG4gICAgLy8gQWRqdXN0IGxhc3QgbGVuZ3RoIGNvdW50IHRvIGZpbGwgb3V0IGNvZGVzLCBpZiBuZWVkZWRcbiAgICBmb3IgKHkgPSAxIDw8IGo7IGogPCBpOyBqKyssIHkgPDw9IDEpe1xuICAgICAgaWYgKCh5IC09IHRoaXMuY1tqXSkgPCAwKXtcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh5IC09IHRoaXMuY1tpXSkgPCAwKXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHRoaXMuY1tpXSArPSB5O1xuXG4gICAgLy8gR2VuZXJhdGUgc3RhcnRpbmcgb2Zmc2V0cyBpbnRvIHRoZSB2YWx1ZSB0YWJsZSBmb3IgZWFjaCBsZW5ndGhcbiAgICB0aGlzLnhbMV0gPSBqID0gMDtcbiAgICBwID0gMTsgIHhwID0gMjtcbiAgICB3aGlsZSAoLS1pIT0wKSB7ICAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgaSA9PSBnIGZyb20gYWJvdmVcbiAgICAgIHRoaXMueFt4cF0gPSAoaiArPSB0aGlzLmNbcF0pO1xuICAgICAgeHArKztcbiAgICAgIHArKztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgdGFibGUgb2YgdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhzXG4gICAgaSA9IDA7IHAgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmICgoaiA9IGJbYmluZGV4K3BdKSAhPSAwKXtcbiAgICAgICAgdGhpcy52W3RoaXMueFtqXSsrXSA9IGk7XG4gICAgICB9XG4gICAgICBwKys7XG4gICAgfVxuICAgIHdoaWxlICgrK2kgPCBuKTtcbiAgICBuID0gdGhpcy54W2ddOyAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBuIHRvIGxlbmd0aCBvZiB2XG5cbiAgICAvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcbiAgICB0aGlzLnhbMF0gPSBpID0gMDsgICAgICAgICAgICAgICAgIC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXG4gICAgcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiB2YWx1ZXMgaW4gYml0IG9yZGVyXG4gICAgaCA9IC0xOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcbiAgICB3ID0gLWw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGRlY29kZWQgPT0gKGwgKiBoKVxuICAgIHRoaXMudVswXSA9IDA7ICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCB0byBrZWVwIGNvbXBpbGVycyBoYXBweVxuICAgIHEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdHRvXG4gICAgeiA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl0dG9cblxuICAgIC8vIGdvIHRocm91Z2ggdGhlIGJpdCBsZW5ndGhzIChrIGFscmVhZHkgaXMgYml0cyBpbiBzaG9ydGVzdCBjb2RlKVxuICAgIGZvciAoOyBrIDw9IGc7IGsrKyl7XG4gICAgICBhID0gdGhpcy5jW2tdO1xuICAgICAgd2hpbGUgKGEtLSE9MCl7XG5cdC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXG5cdC8vIG1ha2UgdGFibGVzIHVwIHRvIHJlcXVpcmVkIGxldmVsXG4gICAgICAgIHdoaWxlIChrID4gdyArIGwpe1xuICAgICAgICAgIGgrKztcbiAgICAgICAgICB3ICs9IGw7ICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0YWJsZSBhbHdheXMgbCBiaXRzXG5cdCAgLy8gY29tcHV0ZSBtaW5pbXVtIHNpemUgdGFibGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGwgYml0c1xuICAgICAgICAgIHogPSBnIC0gdztcbiAgICAgICAgICB6ID0gKHogPiBsKSA/IGwgOiB6OyAgICAgICAgLy8gdGFibGUgc2l6ZSB1cHBlciBsaW1pdFxuICAgICAgICAgIGlmKChmPTE8PChqPWstdykpPmErMSl7ICAgICAvLyB0cnkgYSBrLXcgYml0IHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvbyBmZXcgY29kZXMgZm9yIGstdyBiaXQgdGFibGVcbiAgICAgICAgICAgIGYgLT0gYSArIDE7ICAgICAgICAgICAgICAgLy8gZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnMgbGVmdFxuICAgICAgICAgICAgeHAgPSBrO1xuICAgICAgICAgICAgaWYoaiA8IHope1xuICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgeil7ICAgICAgICAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXG4gICAgICAgICAgICAgICAgaWYoKGYgPDw9IDEpIDw9IHRoaXMuY1srK3hwXSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcbiAgICAgICAgICAgICAgICBmIC09IHRoaXMuY1t4cF07ICAgICAgICAgICAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXG4gICAgICAgICAgICAgIH1cblx0ICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeiA9IDEgPDwgajsgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGVudHJpZXMgZm9yIGotYml0IHRhYmxlXG5cblx0ICAvLyBhbGxvY2F0ZSBuZXcgdGFibGVcbiAgICAgICAgICBpZiAodGhpcy5oblswXSArIHogPiBNQU5ZKXsgICAgICAgLy8gKG5vdGU6IGRvZXNuJ3QgbWF0dGVyIGZvciBmaXhlZClcbiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7ICAgICAgIC8vIG92ZXJmbG93IG9mIE1BTllcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51W2hdID0gcSA9IC8qaHArKi8gdGhpcy5oblswXTsgICAvLyBERUJVR1xuICAgICAgICAgIHRoaXMuaG5bMF0gKz0gejtcbiBcblx0ICAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZVxuXHQgIGlmKGghPTApe1xuICAgICAgICAgICAgdGhpcy54W2hdPWk7ICAgICAgICAgICAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcbiAgICAgICAgICAgIHRoaXMuclswXT1qOyAgICAgLy8gYml0cyBpbiB0aGlzIHRhYmxlXG4gICAgICAgICAgICB0aGlzLnJbMV09bDsgICAgIC8vIGJpdHMgdG8gZHVtcCBiZWZvcmUgdGhpcyB0YWJsZVxuICAgICAgICAgICAgaj1pPj4+KHcgLSBsKTtcbiAgICAgICAgICAgIHRoaXMuclsyXSA9IChxIC0gdGhpcy51W2gtMV0gLSBqKTsgICAgICAgICAgICAgICAvLyBvZmZzZXQgdG8gdGhpcyB0YWJsZVxuICAgICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsICh0aGlzLnVbaC0xXStqKSozLCAzKTsgLy8gY29ubmVjdCB0byBsYXN0IHRhYmxlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0WzBdID0gcTsgICAgICAgICAgICAgICAvLyBmaXJzdCB0YWJsZSBpcyByZXR1cm5lZCByZXN1bHRcblx0ICB9XG4gICAgICAgIH1cblxuXHQvLyBzZXQgdXAgdGFibGUgZW50cnkgaW4gclxuICAgICAgICB0aGlzLnJbMV0gPSAoayAtIHcpO1xuICAgICAgICBpZiAocCA+PSBuKXtcbiAgICAgICAgICB0aGlzLnJbMF0gPSAxMjggKyA2NDsgICAgICAvLyBvdXQgb2YgdmFsdWVzLS1pbnZhbGlkIGNvZGVcblx0fVxuICAgICAgICBlbHNlIGlmICh2W3BdIDwgcyl7XG4gICAgICAgICAgdGhpcy5yWzBdID0gKHRoaXMudltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgIC8vIDI1NiBpcyBlbmQtb2YtYmxvY2tcbiAgICAgICAgICB0aGlzLnJbMl0gPSB0aGlzLnZbcCsrXTsgICAgICAgICAgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRoaXMuclswXT0oZVt0aGlzLnZbcF0tc10rMTYrNjQpOyAvLyBub24tc2ltcGxlLS1sb29rIHVwIGluIGxpc3RzXG4gICAgICAgICAgdGhpcy5yWzJdPWRbdGhpcy52W3ArK10gLSBzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXG4gICAgICAgIGY9MTw8KGstdyk7XG4gICAgICAgIGZvciAoaj1pPj4+dztqPHo7ais9Zil7XG4gICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsIChxK2opKjMsIDMpO1xuXHR9XG5cblx0Ly8gYmFja3dhcmRzIGluY3JlbWVudCB0aGUgay1iaXQgY29kZSBpXG4gICAgICAgIGZvciAoaiA9IDEgPDwgKGsgLSAxKTsgKGkgJiBqKSE9MDsgaiA+Pj49IDEpe1xuICAgICAgICAgIGkgXj0gajtcblx0fVxuICAgICAgICBpIF49IGo7XG5cblx0Ly8gYmFja3VwIG92ZXIgZmluaXNoZWQgdGFibGVzXG4gICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7ICAgICAgLy8gbmVlZGVkIG9uIEhQLCBjYyAtTyBidWdcbiAgICAgICAgd2hpbGUgKChpICYgbWFzaykgIT0gdGhpcy54W2hdKXtcbiAgICAgICAgICBoLS07ICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXG4gICAgICAgICAgdyAtPSBsO1xuICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxuICAgIHJldHVybiB5ICE9IDAgJiYgZyAhPSAxID8gWl9CVUZfRVJST1IgOiBaX09LO1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbmZsYXRlX3RyZWVzX2JpdHMgPSBmdW5jdGlvbihjLCBiYiwgdGIsIGhwLCB6KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgxOSk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCAxOSwgMTksIG51bGwsIG51bGwsIHRiLCBiYiwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG5cbiAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICB9XG4gICAgZWxzZSBpZihyZXN1bHQgPT0gWl9CVUZfRVJST1IgfHwgYmJbMF0gPT0gMCl7XG4gICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5mbGF0ZV90cmVlc19keW5hbWljID0gZnVuY3Rpb24obmwsIG5kLCBjLCBibCwgYmQsIHRsLCB0ZCwgaHAsIHopIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gYnVpbGQgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDI4OCk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCBubCwgMjU3LCBjcGxlbnMsIGNwbGV4dCwgdGwsIGJsLCBocCwgdGhpcy5obiwgdGhpcy52KTtcbiAgICBpZiAocmVzdWx0ICE9IFpfT0sgfHwgYmxbMF0gPT0gMCl7XG4gICAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBidWlsZCBkaXN0YW5jZSB0cmVlXG4gICAgdGhpcy5pbml0V29ya0FyZWEoMjg4KTtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgdGhpcy5obiwgdGhpcy52KTtcblxuICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT0gMCAmJiBubCA+IDI1Nykpe1xuICAgICAgaWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgZGlzdGFuY2UgdHJlZVwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ID09IFpfQlVGX0VSUk9SKSB7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGRpc3RhbmNlIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpfT0s7XG59XG4vKlxuICBzdGF0aWMgaW50IGluZmxhdGVfdHJlZXNfZml4ZWQoaW50W10gYmwsICAvL2xpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXSBiZCwgIC8vZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXVtdIHRsLC8vbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdW10gdGQsLy9kaXN0YW5jZSB0cmVlIHJlc3VsdCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpTdHJlYW0geiAgLy9mb3IgbWVtb3J5IGFsbG9jYXRpb25cblx0XHRcdFx0ICl7XG5cbiovXG5cbmZ1bmN0aW9uIGluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQsIHopIHtcbiAgICBibFswXT1maXhlZF9ibDtcbiAgICBiZFswXT1maXhlZF9iZDtcbiAgICB0bFswXT1maXhlZF90bDtcbiAgICB0ZFswXT1maXhlZF90ZDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5pdFdvcmtBcmVhID0gZnVuY3Rpb24odnNpemUpe1xuICAgIGlmKHRoaXMuaG49PW51bGwpe1xuICAgICAgICB0aGlzLmhuPW5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICB0aGlzLnY9bmV3IEludDMyQXJyYXkodnNpemUpO1xuICAgICAgICB0aGlzLmM9bmV3IEludDMyQXJyYXkoQk1BWCsxKTtcbiAgICAgICAgdGhpcy5yPW5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICB0aGlzLnU9bmV3IEludDMyQXJyYXkoQk1BWCk7XG4gICAgICAgIHRoaXMueD1uZXcgSW50MzJBcnJheShCTUFYKzEpO1xuICAgIH1cbiAgICBpZih0aGlzLnYubGVuZ3RoPHZzaXplKXsgXG4gICAgICAgIHRoaXMudj1uZXcgSW50MzJBcnJheSh2c2l6ZSk7IFxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTx2c2l6ZTsgaSsrKXt0aGlzLnZbaV09MDt9XG4gICAgZm9yKHZhciBpPTA7IGk8Qk1BWCsxOyBpKyspe3RoaXMuY1tpXT0wO31cbiAgICBmb3IodmFyIGk9MDsgaTwzOyBpKyspe3RoaXMucltpXT0wO31cbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYOyBpKyspe3VbaV09MDt9XG4gICAgYXJyYXlDb3B5KHRoaXMuYywgMCwgdGhpcy51LCAwLCBCTUFYKTtcbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYKzE7IGkrKyl7eFtpXT0wO31cbiAgICBhcnJheUNvcHkodGhpcy5jLCAwLCB0aGlzLngsIDAsIEJNQVgrMSk7XG59XG5cbnZhciB0ZXN0QXJyYXkgPSBuZXcgVWludDhBcnJheSgxKTtcbnZhciBoYXNTdWJhcnJheSA9ICh0eXBlb2YgdGVzdEFycmF5LnN1YmFycmF5ID09PSAnZnVuY3Rpb24nKTtcbnZhciBoYXNTbGljZSA9IGZhbHNlOyAvKiAodHlwZW9mIHRlc3RBcnJheS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyk7ICovIC8vIENocm9tZSBzbGljZSBwZXJmb3JtYW5jZSBpcyBzbyBkaXJlIHRoYXQgd2UncmUgY3VycmVudGx5IG5vdCB1c2luZyBpdC4uLlxuXG5mdW5jdGlvbiBhcnJheUNvcHkoc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgICAgdGhyb3cgXCJVbmRlZiBzcmNcIjtcbiAgICB9IGVsc2UgaWYgKCFkZXN0KSB7XG4gICAgICAgIHRocm93IFwiVW5kZWYgZGVzdFwiO1xuICAgIH1cblxuICAgIGlmIChzcmNPZmZzZXQgPT0gMCAmJiBjb3VudCA9PSBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KHNyYywgZGVzdCwgZGVzdE9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChoYXNTdWJhcnJheSkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChzcmMuc3ViYXJyYXkoc3JjT2Zmc2V0LCBzcmNPZmZzZXQgKyBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpOyBcbiAgICB9IGVsc2UgaWYgKHNyYy5CWVRFU19QRVJfRUxFTUVOVCA9PSAxICYmIGNvdW50ID4gMTAwKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0ICsgc3JjT2Zmc2V0LCBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpO1xuICAgIH0gZWxzZSB7IFxuICAgICAgICBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpIHtcblxuICAgIC8vIGRsb2coJ19zbG93IGNhbGw6IHNyY09mZnNldD0nICsgc3JjT2Zmc2V0ICsgJzsgZGVzdE9mZnNldD0nICsgZGVzdE9mZnNldCArICc7IGNvdW50PScgKyBjb3VudCk7XG5cbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIGldID0gc3JjW3NyY09mZnNldCArIGldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlDb3B5X2Zhc3Qoc3JjLCBkZXN0LCBkZXN0T2Zmc2V0KSB7XG4gICAgZGVzdC5zZXQoc3JjLCBkZXN0T2Zmc2V0KTtcbn1cblxuXG4gIC8vIGxhcmdlc3QgcHJpbWUgc21hbGxlciB0aGFuIDY1NTM2XG52YXIgQURMRVJfQkFTRT02NTUyMTsgXG4gIC8vIE5NQVggaXMgdGhlIGxhcmdlc3QgbiBzdWNoIHRoYXQgMjU1bihuKzEpLzIgKyAobisxKShCQVNFLTEpIDw9IDJeMzItMVxudmFyIEFETEVSX05NQVg9NTU1MjtcblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgLyogYnl0ZVtdICovIGJ1ZiwgIGluZGV4LCBsZW4pe1xuICAgIGlmKGJ1ZiA9PSBudWxsKXsgcmV0dXJuIDE7IH1cblxuICAgIHZhciBzMT1hZGxlciYweGZmZmY7XG4gICAgdmFyIHMyPShhZGxlcj4+MTYpJjB4ZmZmZjtcbiAgICB2YXIgaztcblxuICAgIHdoaWxlKGxlbiA+IDApIHtcbiAgICAgIGs9bGVuPEFETEVSX05NQVg/bGVuOkFETEVSX05NQVg7XG4gICAgICBsZW4tPWs7XG4gICAgICB3aGlsZShrPj0xNil7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBrLT0xNjtcbiAgICAgIH1cbiAgICAgIGlmKGshPTApe1xuICAgICAgICBkb3tcbiAgICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSgtLWshPTApO1xuICAgICAgfVxuICAgICAgczElPUFETEVSX0JBU0U7XG4gICAgICBzMiU9QURMRVJfQkFTRTtcbiAgICB9XG4gICAgcmV0dXJuIChzMjw8MTYpfHMxO1xufVxuXG5cblxuZnVuY3Rpb24ganN6bGliX2luZmxhdGVfYnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCwgYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IG5ldyBaU3RyZWFtKCk7XG4gICAgei5pbmZsYXRlSW5pdChERUZfV0JJVFMsIHRydWUpO1xuICAgIHoubmV4dF9pbiA9IGJ1ZmZlcjtcbiAgICB6Lm5leHRfaW5faW5kZXggPSAwO1xuICAgIHouYXZhaWxfaW4gPSBidWZmZXIubGVuZ3RoO1xuXG4gICAgdmFyIG9CbG9ja0xpc3QgPSBbXTtcbiAgICB2YXIgdG90YWxTaXplID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgb2J1ZiA9IG5ldyBVaW50OEFycmF5KDMyMDAwKTtcbiAgICAgICAgei5uZXh0X291dCA9IG9idWY7XG4gICAgICAgIHoubmV4dF9vdXRfaW5kZXggPSAwO1xuICAgICAgICB6LmF2YWlsX291dCA9IG9idWYubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhdHVzID0gei5pbmZsYXRlKFpfTk9fRkxVU0gpO1xuICAgICAgICBpZiAoc3RhdHVzICE9IFpfT0sgJiYgc3RhdHVzICE9IFpfU1RSRUFNX0VORCkge1xuICAgICAgICAgICAgdGhyb3cgei5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHouYXZhaWxfb3V0ICE9IDApIHtcbiAgICAgICAgICAgIHZhciBuZXdvYiA9IG5ldyBVaW50OEFycmF5KG9idWYubGVuZ3RoIC0gei5hdmFpbF9vdXQpO1xuICAgICAgICAgICAgYXJyYXlDb3B5KG9idWYsIDAsIG5ld29iLCAwLCAob2J1Zi5sZW5ndGggLSB6LmF2YWlsX291dCkpO1xuICAgICAgICAgICAgb2J1ZiA9IG5ld29iO1xuICAgICAgICB9XG4gICAgICAgIG9CbG9ja0xpc3QucHVzaChvYnVmKTtcbiAgICAgICAgdG90YWxTaXplICs9IG9idWYubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdHVzID09IFpfU1RSRUFNX0VORCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICAgICAgYWZ0ZXJVbmNPZmZzZXRbMF0gPSAoc3RhcnQgfHwgMCkgKyB6Lm5leHRfaW5faW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF0uYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xuICAgICAgICB2YXIgY3Vyc29yID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG9CbG9ja0xpc3RbaV07XG4gICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcbiAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcbiAgICB9XG59XG5cbmV4cG9ydCB7anN6bGliX2luZmxhdGVfYnVmZmVyLGFycmF5Q29weX0iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbUlBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZJQTtBQXlJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRZQTtBQXdZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyUUE7QUF1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../MLVPanel/src/vendor/inflate.js\n");

/***/ }),

/***/ "../MLVPanel/src/vendor/zlib_and_gzip.js":
/*!******************************************!*\
  !*** .Panel/src/vendor/zlib_and_gzip.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @fileoverview Zlib namespace. Zlib  Zlib.Deflate \n * .  Inflate .\n */\n\nvar USE_TYPEDARRAY = true;\nvar ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 65000;\n\nvar Zlib = {\n  Huffman: {},\n  Util: {},\n  CRC32: {}\n};\n\n/**\n * Compression Method\n * @enum {number}\n */\nZlib.CompressionMethod = {\n  DEFLATE: 8,\n  RESERVED: 15\n};\n\n/**\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Zip = function (opt_params) {\n  opt_params = opt_params || {};\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  this.files = [];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment = opt_params['comment'];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password;\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.CompressionMethod = {\n  STORE: 0,\n  DEFLATE: 8\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.OperatingSystem = {\n  MSDOS: 0,\n  UNIX: 3,\n  MACINTOSH: 7\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.Flags = {\n  ENCRYPT: 0x0001,\n  DESCRIPTOR: 0x0008,\n  UTF8: 0x0800\n};\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\n\n/**\n * @param {Array.<number>|Uint8Array} input\n * @param {Object=} opt_params options.\n */\nZlib.Zip.prototype.addFile = function (input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {string} */\n  var filename = '' || opt_params['filename'];\n  /** @type {boolean} */\n  var compressed;\n  /** @type {number} */\n  var size = input.length;\n  /** @type {number} */\n  var crc32 = 0;\n\n  if (USE_TYPEDARRAY && input instanceof Array) {\n    input = new Uint8Array(input);\n  }\n\n  // default\n  if (typeof opt_params['compressionMethod'] !== 'number') {\n    opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;\n  }\n\n  // \n  if (opt_params['compress']) {\n    switch (opt_params['compressionMethod']) {\n      case Zlib.Zip.CompressionMethod.STORE:\n        break;\n      case Zlib.Zip.CompressionMethod.DEFLATE:\n        crc32 = Zlib.CRC32.calc(input);\n        input = this.deflateWithOption(input, opt_params);\n        compressed = true;\n        break;\n      default:\n        throw new Error('unknown compression method:' + opt_params['compressionMethod']);\n    }\n  }\n\n  this.files.push({\n    buffer: input,\n    option: opt_params,\n    compressed: compressed,\n    encrypted: false,\n    size: size,\n    crc32: crc32\n  });\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Zip.prototype.setPassword = function (password) {\n  this.password = password;\n};\n\nZlib.Zip.prototype.compress = function () {\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  var files = this.files;\n  /** @type {{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }} */\n  var file;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var op1;\n  /** @type {number} */\n  var op2;\n  /** @type {number} */\n  var op3;\n  /** @type {number} */\n  var localFileSize = 0;\n  /** @type {number} */\n  var centralDirectorySize = 0;\n  /** @type {number} */\n  var endOfCentralDirectorySize;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var needVersion;\n  /** @type {number} */\n  var flags;\n  /** @type {Zlib.Zip.CompressionMethod} */\n  var compressionMethod;\n  /** @type {Date} */\n  var date;\n  /** @type {number} */\n  var crc32;\n  /** @type {number} */\n  var size;\n  /** @type {number} */\n  var plainSize;\n  /** @type {number} */\n  var filenameLength;\n  /** @type {number} */\n  var extraFieldLength;\n  /** @type {number} */\n  var commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var filename;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var extraField;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var comment;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {*} */\n  var tmp;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var jl;\n\n  // \n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength = file.option['filename'] ? file.option['filename'].length : 0;\n    extraFieldLength = file.option['extraField'] ? file.option['extraField'].length : 0;\n    commentLength = file.option['comment'] ? file.option['comment'].length : 0;\n\n    // \n    if (!file.compressed) {\n      //  CRC32 \n      file.crc32 = Zlib.CRC32.calc(file.buffer);\n\n      switch (file.option['compressionMethod']) {\n        case Zlib.Zip.CompressionMethod.STORE:\n          break;\n        case Zlib.Zip.CompressionMethod.DEFLATE:\n          file.buffer = this.deflateWithOption(file.buffer, file.option);\n          file.compressed = true;\n          break;\n        default:\n          throw new Error('unknown compression method:' + file.option['compressionMethod']);\n      }\n    }\n\n    // encryption\n    if (file.option['password'] !== void 0 || this.password !== void 0) {\n      // init encryption\n      key = this.createEncryptionKey(file.option['password'] || this.password);\n\n      // add header\n      buffer = file.buffer;\n      if (USE_TYPEDARRAY) {\n        tmp = new Uint8Array(buffer.length + 12);\n        tmp.set(buffer, 12);\n        buffer = tmp;\n      } else {\n        buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      }\n\n      for (j = 0; j < 12; ++j) {\n        buffer[j] = this.encode(key, i === 11 ? file.crc32 & 0xff : Math.random() * 256 | 0);\n      }\n\n      // data encryption\n      for (jl = buffer.length; j < jl; ++j) {\n        buffer[j] = this.encode(key, buffer[j]);\n      }\n      file.buffer = buffer;\n    }\n\n    // \n    localFileSize +=\n    // local file header\n    30 + filenameLength +\n    // file data\n    file.buffer.length;\n\n    centralDirectorySize +=\n    // file header\n    46 + filenameLength + commentLength;\n  }\n\n  // end of central directory\n  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\n  output = new (USE_TYPEDARRAY ? Uint8Array : Array)(localFileSize + centralDirectorySize + endOfCentralDirectorySize);\n  op1 = 0;\n  op2 = localFileSize;\n  op3 = op2 + centralDirectorySize;\n\n  // \n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength = file.option['filename'] ? file.option['filename'].length : 0;\n    extraFieldLength = 0; // TODO\n    commentLength = file.option['comment'] ? file.option['comment'].length : 0;\n\n    //-------------------------------------------------------------------------\n    // local file header & file header\n    //-------------------------------------------------------------------------\n\n    offset = op1;\n\n    // signature\n    // local file header\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];\n    // file header\n    output[op2++] = Zlib.Zip.FileHeaderSignature[0];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[1];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[2];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[3];\n\n    // compressor info\n    needVersion = 20;\n    output[op2++] = needVersion & 0xff;\n    output[op2++] =\n    /** @type {Zlib.Zip.OperatingSystem} */\n    file.option['os'] || Zlib.Zip.OperatingSystem.MSDOS;\n\n    // need version\n    output[op1++] = output[op2++] = needVersion & 0xff;\n    output[op1++] = output[op2++] = needVersion >> 8 & 0xff;\n\n    // general purpose bit flag\n    flags = 0;\n    if (file.option['password'] || this.password) {\n      flags |= Zlib.Zip.Flags.ENCRYPT;\n    }\n    output[op1++] = output[op2++] = flags & 0xff;\n    output[op1++] = output[op2++] = flags >> 8 & 0xff;\n\n    // compression method\n    compressionMethod =\n    /** @type {Zlib.Zip.CompressionMethod} */\n    file.option['compressionMethod'];\n    output[op1++] = output[op2++] = compressionMethod & 0xff;\n    output[op1++] = output[op2++] = compressionMethod >> 8 & 0xff;\n\n    // date\n    date = /** @type {(Date|undefined)} */file.option['date'] || new Date();\n    output[op1++] = output[op2++] = (date.getMinutes() & 0x7) << 5 | (date.getSeconds() / 2 | 0);\n    output[op1++] = output[op2++] = date.getHours() << 3 | date.getMinutes() >> 3;\n    //\n    output[op1++] = output[op2++] = (date.getMonth() + 1 & 0x7) << 5 | date.getDate();\n    output[op1++] = output[op2++] = (date.getFullYear() - 1980 & 0x7f) << 1 | date.getMonth() + 1 >> 3;\n\n    // CRC-32\n    crc32 = file.crc32;\n    output[op1++] = output[op2++] = crc32 & 0xff;\n    output[op1++] = output[op2++] = crc32 >> 8 & 0xff;\n    output[op1++] = output[op2++] = crc32 >> 16 & 0xff;\n    output[op1++] = output[op2++] = crc32 >> 24 & 0xff;\n\n    // compressed size\n    size = file.buffer.length;\n    output[op1++] = output[op2++] = size & 0xff;\n    output[op1++] = output[op2++] = size >> 8 & 0xff;\n    output[op1++] = output[op2++] = size >> 16 & 0xff;\n    output[op1++] = output[op2++] = size >> 24 & 0xff;\n\n    // uncompressed size\n    plainSize = file.size;\n    output[op1++] = output[op2++] = plainSize & 0xff;\n    output[op1++] = output[op2++] = plainSize >> 8 & 0xff;\n    output[op1++] = output[op2++] = plainSize >> 16 & 0xff;\n    output[op1++] = output[op2++] = plainSize >> 24 & 0xff;\n\n    // filename length\n    output[op1++] = output[op2++] = filenameLength & 0xff;\n    output[op1++] = output[op2++] = filenameLength >> 8 & 0xff;\n\n    // extra field length\n    output[op1++] = output[op2++] = extraFieldLength & 0xff;\n    output[op1++] = output[op2++] = extraFieldLength >> 8 & 0xff;\n\n    // file comment length\n    output[op2++] = commentLength & 0xff;\n    output[op2++] = commentLength >> 8 & 0xff;\n\n    // disk number start\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // internal file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // external file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // relative offset of local header\n    output[op2++] = offset & 0xff;\n    output[op2++] = offset >> 8 & 0xff;\n    output[op2++] = offset >> 16 & 0xff;\n    output[op2++] = offset >> 24 & 0xff;\n\n    // filename\n    filename = file.option['filename'];\n    if (filename) {\n      if (USE_TYPEDARRAY) {\n        output.set(filename, op1);\n        output.set(filename, op2);\n        op1 += filenameLength;\n        op2 += filenameLength;\n      } else {\n        for (j = 0; j < filenameLength; ++j) {\n          output[op1++] = output[op2++] = filename[j];\n        }\n      }\n    }\n\n    // extra field\n    extraField = file.option['extraField'];\n    if (extraField) {\n      if (USE_TYPEDARRAY) {\n        output.set(extraField, op1);\n        output.set(extraField, op2);\n        op1 += extraFieldLength;\n        op2 += extraFieldLength;\n      } else {\n        for (j = 0; j < commentLength; ++j) {\n          output[op1++] = output[op2++] = extraField[j];\n        }\n      }\n    }\n\n    // comment\n    comment = file.option['comment'];\n    if (comment) {\n      if (USE_TYPEDARRAY) {\n        output.set(comment, op2);\n        op2 += commentLength;\n      } else {\n        for (j = 0; j < commentLength; ++j) {\n          output[op2++] = comment[j];\n        }\n      }\n    }\n\n    //-------------------------------------------------------------------------\n    // file data\n    //-------------------------------------------------------------------------\n\n    if (USE_TYPEDARRAY) {\n      output.set(file.buffer, op1);\n      op1 += file.buffer.length;\n    } else {\n      for (j = 0, jl = file.buffer.length; j < jl; ++j) {\n        output[op1++] = file.buffer[j];\n      }\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // end of central directory\n  //-------------------------------------------------------------------------\n\n  // signature\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];\n\n  // number of this disk\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // number of the disk with the start of the central directory\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // total number of entries in the central directory on this disk\n  output[op3++] = il & 0xff;\n  output[op3++] = il >> 8 & 0xff;\n\n  // total number of entries in the central directory\n  output[op3++] = il & 0xff;\n  output[op3++] = il >> 8 & 0xff;\n\n  // size of the central directory\n  output[op3++] = centralDirectorySize & 0xff;\n  output[op3++] = centralDirectorySize >> 8 & 0xff;\n  output[op3++] = centralDirectorySize >> 16 & 0xff;\n  output[op3++] = centralDirectorySize >> 24 & 0xff;\n\n  // offset of start of central directory with respect to the starting disk number\n  output[op3++] = localFileSize & 0xff;\n  output[op3++] = localFileSize >> 8 & 0xff;\n  output[op3++] = localFileSize >> 16 & 0xff;\n  output[op3++] = localFileSize >> 24 & 0xff;\n\n  // .ZIP file comment length\n  commentLength = this.comment ? this.comment.length : 0;\n  output[op3++] = commentLength & 0xff;\n  output[op3++] = commentLength >> 8 & 0xff;\n\n  // .ZIP file comment\n  if (this.comment) {\n    if (USE_TYPEDARRAY) {\n      output.set(this.comment, op3);\n      op3 += commentLength;\n    } else {\n      for (j = 0, jl = commentLength; j < jl; ++j) {\n        output[op3++] = this.comment[j];\n      }\n    }\n  }\n\n  return output;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input\n * @param {Object=} opt_params options.\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Zip.prototype.deflateWithOption = function (input, opt_params) {\n  /** @type {Zlib.RawDeflate} */\n  var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);\n\n  return deflator.compress();\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @return {number}\n */\nZlib.Zip.prototype.getByte = function (key) {\n  /** @type {number} */\n  var tmp = key[2] & 0xffff | 2;\n\n  return tmp * (tmp ^ 1) >> 8 & 0xff;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Zip.prototype.encode = function (key, n) {\n  /** @type {number} */\n  var tmp = this.getByte( /** @type {(Array.<number>|Uint32Array)} */key);\n\n  this.updateKeys( /** @type {(Array.<number>|Uint32Array)} */key, n);\n\n  return tmp ^ n;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @param {number} n\n */\nZlib.Zip.prototype.updateKeys = function (key, n) {\n  key[0] = Zlib.CRC32.single(key[0], n);\n  key[1] = (((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681 >>> 0) + 1 >>> 0;\n  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n * @return {!(Array.<number>|Uint32Array|Object)}\n */\nZlib.Zip.prototype.createEncryptionKey = function (password) {\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var key = [305419896, 591751049, 878082192];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  if (USE_TYPEDARRAY) {\n    key = new Uint32Array(key);\n  }\n\n  for (i = 0, il = password.length; i < il; ++i) {\n    this.updateKeys(key, password[i] & 0xff);\n  }\n\n  return key;\n};\n\n/**\n * build huffman table from length list.\n * @param {!(Array.<number>|Uint8Array)} lengths length list.\n * @return {!Array} huffman table.\n */\nZlib.Huffman.buildHuffmanTable = function (lengths) {\n  /** @type {number} length list size. */\n  var listSize = lengths.length;\n  /** @type {number} max code length for table size. */\n  var maxCodeLength = 0;\n  /** @type {number} min code length for table size. */\n  var minCodeLength = Number.POSITIVE_INFINITY;\n  /** @type {number} table size. */\n  var size;\n  /** @type {!(Array|Uint8Array)} huffman code table. */\n  var table;\n  /** @type {number} bit length. */\n  var bitLength;\n  /** @type {number} huffman code. */\n  var code;\n  /**\n   *  2^maxlength .\n   * @type {number} skip length for table filling.\n   */\n  var skip;\n  /** @type {number} reversed code. */\n  var reversed;\n  /** @type {number} reverse temp. */\n  var rtemp;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} table value. */\n  var value;\n\n  // Math.max  for-loop \n  for (i = 0, il = listSize; i < il; ++i) {\n    if (lengths[i] > maxCodeLength) {\n      maxCodeLength = lengths[i];\n    }\n    if (lengths[i] < minCodeLength) {\n      minCodeLength = lengths[i];\n    }\n  }\n\n  size = 1 << maxCodeLength;\n  table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);\n\n  // \n  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\n    for (i = 0; i < listSize; ++i) {\n      if (lengths[i] === bitLength) {\n        // \n        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\n          reversed = reversed << 1 | rtemp & 1;\n          rtemp >>= 1;\n        }\n\n        // \n        //  0 / 1 \n        // \n        // \n        value = bitLength << 16 | i;\n        for (j = reversed; j < size; j += skip) {\n          table[j] = value;\n        }\n\n        ++code;\n      }\n    }\n\n    // \n    ++bitLength;\n    code <<= 1;\n    skip <<= 1;\n  }\n\n  return [table, maxCodeLength, minCodeLength];\n};\n\n//-----------------------------------------------------------------------------\n\n/** @define {number} buffer block size. */\nvar ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\n\n//-----------------------------------------------------------------------------\n\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {Object} opt_params option parameter.\n *\n * opt_params \n *   - index: input buffer  deflate .\n *   - blockSize: .\n *   - bufferType: Zlib.RawInflate.BufferType .\n *   - resize: .\n */\nZlib.RawInflate = function (input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */\n  this.buffer;\n  /** @type {!Array.<(Array.<number>|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\n  /** @type {!(Uint8Array|Array.<number>)} output buffer. */\n  this.output;\n  /** @type {!number} output buffer pointer. */\n  this.op;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {Zlib.RawInflate.BufferType} buffer management. */\n  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['bufferSize']) {\n      this.bufferSize = opt_params['bufferSize'];\n    }\n    if (opt_params['bufferType']) {\n      this.bufferType = opt_params['bufferType'];\n    }\n    if (opt_params['resize']) {\n      this.resize = opt_params['resize'];\n    }\n  }\n\n  // initialize\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.op = Zlib.RawInflate.MaxBackwardLength;\n      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.MaxBackwardLength + this.bufferSize + Zlib.RawInflate.MaxCopyLength);\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.op = 0;\n      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflate.BufferType = {\n  BLOCK: 0,\n  ADAPTIVE: 1\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array.<number>)} inflated buffer.\n */\nZlib.RawInflate.prototype.decompress = function () {\n  while (!this.bfinal) {\n    this.parseBlock();\n  }\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      return this.concatBufferBlock();\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      return this.concatBufferDynamic();\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflate.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflate.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.Order = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.LengthCodeTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.LengthExtraTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n}([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.DistCodeTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.DistExtraTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n}([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedLiteralLengthTable = function (table) {\n  return table;\n}(function () {\n  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;\n  }\n\n  return buildHuffmanTable(lengths);\n}());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedDistanceTable = function (table) {\n  return table;\n}(function () {\n  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n}());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflate.prototype.parseBlock = function () {\n  /** @type {number} header */\n  var hdr = this.readBits(3);\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    // uncompressed\n    case 0:\n      this.parseUncompressedBlock();\n      break;\n    // fixed huffman\n    case 1:\n      this.parseFixedHuffmanBlock();\n      break;\n    // dynamic huffman\n    case 2:\n      this.parseDynamicHuffmanBlock();\n      break;\n    // reserved or other\n    default:\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflate.prototype.readBits = function (length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // input byte\n  if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength) {\n    throw new Error('input buffer is broken');\n  }\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */(1 << length) - 1;\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflate.prototype.readCodeByTable = function (table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {!(Array.<number>|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (ip >= inputLength) {\n      break;\n    }\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflate.prototype.parseUncompressedBlock = function () {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n  /** @type {number} output buffer length */\n  var olength = output.length;\n  /** @type {number} copy counter */\n  var preCopy;\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  // len\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: LEN');\n  }\n  len = input[ip++] | input[ip++] << 8;\n\n  // nlen\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: NLEN');\n  }\n  nlen = input[ip++] | input[ip++] << 8;\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // check size\n  if (ip + len > input.length) {\n    throw new Error('input buffer is broken');\n  }\n\n  // expand buffer\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      // pre copy\n      while (op + len > output.length) {\n        preCopy = olength - op;\n        len -= preCopy;\n        if (USE_TYPEDARRAY) {\n          output.set(input.subarray(ip, ip + preCopy), op);\n          op += preCopy;\n          ip += preCopy;\n        } else {\n          while (preCopy--) {\n            output[op++] = input[ip++];\n          }\n        }\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      while (op + len > output.length) {\n        output = this.expandBufferAdaptive({ fixRatio: 2 });\n      }\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n\n  // copy\n  if (USE_TYPEDARRAY) {\n    output.set(input.subarray(ip, ip + len), op);\n    op += len;\n    ip += len;\n  } else {\n    while (len--) {\n      output[op++] = input[ip++];\n    }\n  }\n\n  this.ip = ip;\n  this.op = op;\n  this.output = output;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflate.prototype.parseFixedHuffmanBlock = function () {\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(Zlib.RawInflate.FixedLiteralLengthTable, Zlib.RawInflate.FixedDistanceTable);\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(Zlib.RawInflate.FixedLiteralLengthTable, Zlib.RawInflate.FixedDistanceTable);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflate.prototype.parseDynamicHuffmanBlock = function () {\n  /** @type {number} number of literal and length codes. */\n  var hlit = this.readBits(5) + 257;\n  /** @type {number} number of distance codes. */\n  var hdist = this.readBits(5) + 1;\n  /** @type {number} number of code lengths. */\n  var hclen = this.readBits(4) + 4;\n  /** @type {!(Uint8Array|Array.<number>)} code lengths. */\n  var codeLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\n  var litlenTable;\n  /** @type {!(Uint8Array|Array.<number>)} distance code table. */\n  var distTable;\n  /** @type {!(Uint8Array|Array.<number>)} code length table. */\n  var lengthTable;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var prev;\n  /** @type {number} */\n  var repeat;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n\n  // decode code lengths\n  for (i = 0; i < hclen; ++i) {\n    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);\n  }\n  if (!USE_TYPEDARRAY) {\n    for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {\n      codeLengths[Zlib.RawInflate.Order[i]] = 0;\n    }\n  }\n\n  // decode length table\n  codeLengthsTable = buildHuffmanTable(codeLengths);\n  lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\n  for (i = 0, il = hlit + hdist; i < il;) {\n    code = this.readCodeByTable(codeLengthsTable);\n    switch (code) {\n      case 16:\n        repeat = 3 + this.readBits(2);\n        while (repeat--) {\n          lengthTable[i++] = prev;\n        }\n        break;\n      case 17:\n        repeat = 3 + this.readBits(3);\n        while (repeat--) {\n          lengthTable[i++] = 0;\n        }\n        prev = 0;\n        break;\n      case 18:\n        repeat = 11 + this.readBits(7);\n        while (repeat--) {\n          lengthTable[i++] = 0;\n        }\n        prev = 0;\n        break;\n      default:\n        lengthTable[i++] = code;\n        prev = code;\n        break;\n    }\n  }\n\n  litlenTable = USE_TYPEDARRAY ? buildHuffmanTable(lengthTable.subarray(0, hlit)) : buildHuffmanTable(lengthTable.slice(0, hlit));\n  distTable = USE_TYPEDARRAY ? buildHuffmanTable(lengthTable.subarray(hlit)) : buildHuffmanTable(lengthTable.slice(hlit));\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(litlenTable, distTable);\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(litlenTable, distTable);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * decode huffman code\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length - Zlib.RawInflate.MaxCopyLength;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op >= olength) {\n      this.op = op;\n      output = this.expandBufferBlock();\n      op = this.op;\n    }\n    while (codeLength--) {\n      output[op] = output[op++ - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * decode huffman code (adaptive)\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        output = this.expandBufferAdaptive();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op + codeLength > olength) {\n      output = this.expandBufferAdaptive();\n      olength = output.length;\n    }\n    while (codeLength--) {\n      output[op] = output[op++ - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * expand output buffer.\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.expandBufferBlock = function (opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.op - Zlib.RawInflate.MaxBackwardLength);\n  /** @type {number} backward base point */\n  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;\n  /** @type {number} copy index. */\n  var i;\n  /** @type {number} copy limit */\n  var il;\n\n  var output = this.output;\n\n  // copy to output buffer\n  if (USE_TYPEDARRAY) {\n    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));\n  } else {\n    for (i = 0, il = buffer.length; i < il; ++i) {\n      buffer[i] = output[i + Zlib.RawInflate.MaxBackwardLength];\n    }\n  }\n\n  this.blocks.push(buffer);\n  this.totalpos += buffer.length;\n\n  // copy to backward buffer\n  if (USE_TYPEDARRAY) {\n    output.set(output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength));\n  } else {\n    for (i = 0; i < Zlib.RawInflate.MaxBackwardLength; ++i) {\n      output[i] = output[backward + i];\n    }\n  }\n\n  this.op = Zlib.RawInflate.MaxBackwardLength;\n\n  return output;\n};\n\n/**\n * expand output buffer. (adaptive)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = this.input.length / this.ip + 1 | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];\n    maxInflateSize = maxHuffCode / 2 * 258 | 0;\n    newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  if (USE_TYPEDARRAY) {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  } else {\n    buffer = output;\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferBlock = function () {\n  /** @type {number} buffer pointer. */\n  var pos = 0;\n  /** @type {number} buffer pointer. */\n  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var output = this.output;\n  /** @type {!Array} blocks array. */\n  var blocks = this.blocks;\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var block;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} loop limiter. */\n  var jl;\n\n  // single buffer\n  if (blocks.length === 0) {\n    return USE_TYPEDARRAY ? this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) : this.output.slice(Zlib.RawInflate.MaxBackwardLength, this.op);\n  }\n\n  // copy to buffer\n  for (i = 0, il = blocks.length; i < il; ++i) {\n    block = blocks[i];\n    for (j = 0, jl = block.length; j < jl; ++j) {\n      buffer[pos++] = block[j];\n    }\n  }\n\n  // current buffer\n  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\n    buffer[pos++] = output[i];\n  }\n\n  this.blocks = [];\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferDynamic = function () {\n  /** @type {Array.<number>|Uint8Array} output buffer. */\n  var buffer;\n  var op = this.op;\n\n  if (USE_TYPEDARRAY) {\n    if (this.resize) {\n      buffer = new Uint8Array(op);\n      buffer.set(this.output.subarray(0, op));\n    } else {\n      buffer = this.output.subarray(0, op);\n    }\n  } else {\n    if (this.output.length > op) {\n      this.output.length = op;\n    }\n    buffer = this.output;\n  }\n\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {number} ip input buffer pointer.\n * @param {number=} opt_buffersize buffer block size.\n * @constructor\n */\nZlib.RawInflateStream = function (input, ip, opt_buffersize) {\n  /** @type {!Array.<(Array|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize = opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = ip === void 0 ? 0 : ip;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\n  /** @type {!(Uint8Array|Array)} output buffer. */\n  this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\n  /** @type {!number} output buffer pointer. */\n  this.op = 0;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {number} uncompressed block length. */\n  this.blockLength;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n  /** @type {Array} */\n  this.litlenTable;\n  /** @type {Array} */\n  this.distTable;\n  /** @type {number} */\n  this.sp = 0; // stream pointer\n  /** @type {Zlib.RawInflateStream.Status} */\n  this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n\n  //\n  // backup\n  //\n  /** @type {!number} */\n  this.ip_;\n  /** @type {!number} */\n  this.bitsbuflen_;\n  /** @type {!number} */\n  this.bitsbuf_;\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.BlockType = {\n  UNCOMPRESSED: 0,\n  FIXED: 1,\n  DYNAMIC: 2\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.Status = {\n  INITIALIZED: 0,\n  BLOCK_HEADER_START: 1,\n  BLOCK_HEADER_END: 2,\n  BLOCK_BODY_START: 3,\n  BLOCK_BODY_END: 4,\n  DECODE_BLOCK_START: 5,\n  DECODE_BLOCK_END: 6\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.RawInflateStream.prototype.decompress = function (newInput, ip) {\n  /** @type {boolean} */\n  var stop = false;\n\n  if (newInput !== void 0) {\n    this.input = newInput;\n  }\n\n  if (ip !== void 0) {\n    this.ip = ip;\n  }\n\n  // decompress\n  while (!stop) {\n    switch (this.status) {\n      // block header\n      case Zlib.RawInflateStream.Status.INITIALIZED:\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:\n        if (this.readBlockHeader() < 0) {\n          stop = true;\n        }\n        break;\n      // block body\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:\n        switch (this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.readUncompressedBlockHeader() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED:\n            if (this.parseFixedHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.parseDynamicHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      // decode data\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:\n        switch (this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.parseUncompressedBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.decodeHuffman() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:\n        if (this.bfinal) {\n          stop = true;\n        } else {\n          this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n        }\n        break;\n    }\n  }\n\n  return this.concatBuffer();\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflateStream.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflateStream.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.Order = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.LengthCodeTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.LengthExtraTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n}([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.DistCodeTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n}([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.DistExtraTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n}([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedLiteralLengthTable = function (table) {\n  return table;\n}(function () {\n  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;\n  }\n\n  return buildHuffmanTable(lengths);\n}());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedDistanceTable = function (table) {\n  return table;\n}(function () {\n  var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n}());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflateStream.prototype.readBlockHeader = function () {\n  /** @type {number} header */\n  var hdr;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;\n\n  this.save_();\n  if ((hdr = this.readBits(3)) < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    case 0:\n      // uncompressed\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;\n      break;\n    case 1:\n      // fixed huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;\n      break;\n    case 2:\n      // dynamic huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;\n      break;\n    default:\n      // reserved or other\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflateStream.prototype.readBits = function (length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    // input byte\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n\n    // concat octet\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */(1 << length) - 1;\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {Array} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflateStream.prototype.readCodeByTable = function (table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {!(Array|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} input byte */\n  var octet;\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * read uncompressed block header\n */\nZlib.RawInflateStream.prototype.readUncompressedBlockHeader = function () {\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  if (ip + 4 >= input.length) {\n    return -1;\n  }\n\n  len = input[ip++] | input[ip++] << 8;\n  nlen = input[ip++] | input[ip++] << 8;\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  this.ip = ip;\n  this.blockLength = len;\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflateStream.prototype.parseUncompressedBlock = function () {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n  var len = this.blockLength;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  // copy\n  // XXX: \n  while (len--) {\n    if (op === output.length) {\n      output = this.expandBuffer({ fixRatio: 2 });\n    }\n\n    // not enough input buffer\n    if (ip >= input.length) {\n      this.ip = ip;\n      this.op = op;\n      this.blockLength = len + 1; // \n      return -1;\n    }\n\n    output[op++] = input[ip++];\n  }\n\n  if (len < 0) {\n    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n  }\n\n  this.ip = ip;\n  this.op = op;\n\n  return 0;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;\n  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * .\n * @private\n */\nZlib.RawInflateStream.prototype.save_ = function () {\n  this.ip_ = this.ip;\n  this.bitsbuflen_ = this.bitsbuflen;\n  this.bitsbuf_ = this.bitsbuf;\n};\n\n/**\n * .\n * @private\n */\nZlib.RawInflateStream.prototype.restore_ = function () {\n  this.ip = this.ip_;\n  this.bitsbuflen = this.bitsbuflen_;\n  this.bitsbuf = this.bitsbuf_;\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {\n  /** @type {number} number of literal and length codes. */\n  var hlit;\n  /** @type {number} number of distance codes. */\n  var hdist;\n  /** @type {number} number of code lengths. */\n  var hclen;\n  /** @type {!(Uint8Array|Array)} code lengths. */\n  var codeLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflateStream.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n  /** @type {!(Uint32Array|Array)} literal and length code lengths. */\n  var litlenLengths;\n  /** @type {!(Uint32Array|Array)} distance code lengths. */\n  var distLengths;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.save_();\n  hlit = this.readBits(5) + 257;\n  hdist = this.readBits(5) + 1;\n  hclen = this.readBits(4) + 4;\n  if (hlit < 0 || hdist < 0 || hclen < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  try {\n    parseDynamicHuffmanBlockImpl.call(this);\n  } catch (e) {\n    this.restore_();\n    return -1;\n  }\n\n  function parseDynamicHuffmanBlockImpl() {\n    /** @type {number} */\n    var bits;\n    var code;\n    var prev = 0;\n    var repeat;\n    /** @type {!(Uint8Array|Array.<number>)} code length table. */\n    var lengthTable;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limit. */\n    var il;\n\n    // decode code lengths\n    for (i = 0; i < hclen; ++i) {\n      if ((bits = this.readBits(3)) < 0) {\n        throw new Error('not enough input');\n      }\n      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;\n    }\n\n    // decode length table\n    codeLengthsTable = buildHuffmanTable(codeLengths);\n    lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\n    for (i = 0, il = hlit + hdist; i < il;) {\n      code = this.readCodeByTable(codeLengthsTable);\n      if (code < 0) {\n        throw new Error('not enough input');\n      }\n      switch (code) {\n        case 16:\n          if ((bits = this.readBits(2)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) {\n            lengthTable[i++] = prev;\n          }\n          break;\n        case 17:\n          if ((bits = this.readBits(3)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) {\n            lengthTable[i++] = 0;\n          }\n          prev = 0;\n          break;\n        case 18:\n          if ((bits = this.readBits(7)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 11 + bits;\n          while (repeat--) {\n            lengthTable[i++] = 0;\n          }\n          prev = 0;\n          break;\n        default:\n          lengthTable[i++] = code;\n          prev = code;\n          break;\n      }\n    }\n\n    // literal and length code\n    litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);\n\n    // distance code\n    distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);\n\n    this.litlenTable = USE_TYPEDARRAY ? buildHuffmanTable(lengthTable.subarray(0, hlit)) : buildHuffmanTable(lengthTable.slice(0, hlit));\n    this.distTable = USE_TYPEDARRAY ? buildHuffmanTable(lengthTable.subarray(hlit)) : buildHuffmanTable(lengthTable.slice(hlit));\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * decode huffman code (dynamic)\n * @return {(number|undefined)} -1 is error.\n */\nZlib.RawInflateStream.prototype.decodeHuffman = function () {\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var litlen = this.litlenTable;\n  var dist = this.distTable;\n\n  var olength = output.length;\n  var bits;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  while (true) {\n    this.save_();\n\n    code = this.readCodeByTable(litlen);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n\n    if (code === 256) {\n      break;\n    }\n\n    // literal\n    if (code < 256) {\n      if (op === olength) {\n        output = this.expandBuffer();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];\n    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeLength += bits;\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n    codeDist = Zlib.RawInflateStream.DistCodeTable[code];\n    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeDist += bits;\n    }\n\n    // lz77 decode\n    if (op + codeLength >= olength) {\n      output = this.expandBuffer();\n      olength = output.length;\n    }\n\n    while (codeLength--) {\n      output[op] = output[op++ - codeDist];\n    }\n\n    // break\n    if (this.ip === this.input.length) {\n      this.op = op;\n      return -1;\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n\n  this.op = op;\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n};\n\n/**\n * expand output buffer. (dynamic)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflateStream.prototype.expandBuffer = function (opt_param) {\n  /** @type {!(Array|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = this.input.length / this.ip + 1 | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode = (input.length - this.ip) / this.litlenTable[2];\n    maxInflateSize = maxHuffCode / 2 * 258 | 0;\n    newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  if (USE_TYPEDARRAY) {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  } else {\n    buffer = output;\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array|Uint8Array)} output buffer.\n */\nZlib.RawInflateStream.prototype.concatBuffer = function () {\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var buffer;\n  /** @type {number} */\n  var op = this.op;\n  /** @type {Uint8Array} */\n  var tmp;\n\n  if (this.resize) {\n    if (USE_TYPEDARRAY) {\n      buffer = new Uint8Array(this.output.subarray(this.sp, op));\n    } else {\n      buffer = this.output.slice(this.sp, op);\n    }\n  } else {\n    buffer = USE_TYPEDARRAY ? this.output.subarray(this.sp, op) : this.output.slice(this.sp, op);\n  }\n\n  this.sp = op;\n\n  // compaction\n  if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {\n    this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;\n    if (USE_TYPEDARRAY) {\n      tmp = /** @type {Uint8Array} */this.output;\n      this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);\n      this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));\n    } else {\n      this.output = this.output.slice(op - Zlib.RawInflateStream.MaxBackwardLength);\n    }\n  }\n\n  return buffer;\n};\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @param {Object=} opt_params option parameters.\n *\n * opt_params \n *   - index: input buffer  deflate .\n *   - blockSize: .\n *   - verify:  adler-32 checksum .\n *   - bufferType: Zlib.Inflate.BufferType .\n *       Zlib.Inflate.BufferType  Zlib.RawInflate.BufferType .\n */\nZlib.Inflate = function (input, opt_params) {\n  /** @type {number} */\n  var bufferSize;\n  /** @type {Zlib.Inflate.BufferType} */\n  var bufferType;\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflate} */\n  this.rawinflate;\n  /** @type {(boolean|undefined)} verify flag. */\n  this.verify;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['verify']) {\n      this.verify = opt_params['verify'];\n    }\n  }\n\n  // Compression Method and Flags\n  cmf = input[this.ip++];\n  flg = input[this.ip++];\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  // RawInflate\n  this.rawinflate = new Zlib.RawInflate(input, {\n    'index': this.ip,\n    'bufferSize': opt_params['bufferSize'],\n    'bufferType': opt_params['bufferType'],\n    'resize': opt_params['resize']\n  });\n};\n\n/**\n * @enum {number}\n */\nZlib.Inflate.BufferType = Zlib.RawInflate.BufferType;\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.Inflate.prototype.decompress = function () {\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  var input = this.input;\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n  /** @type {number} adler-32 checksum */\n  var adler32;\n\n  buffer = this.rawinflate.decompress();\n  this.ip = this.rawinflate.ip;\n\n  // verify adler-32\n  if (this.verify) {\n    adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;\n\n    if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n\n  return buffer;\n};\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n/**\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @constructor\n */\nZlib.InflateStream = function (input) {\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input === void 0 ? new (USE_TYPEDARRAY ? Uint8Array : Array)() : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflateStream} */\n  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);\n  /** @type {Zlib.CompressionMethod} */\n  this.method;\n  /** @type {!(Array|Uint8Array)} */\n  this.output = this.rawinflate.output;\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.InflateStream.prototype.decompress = function (input) {\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n  /** @type {number} adler-32 checksum */\n  var adler32;\n\n  // \n  // XXX Array, Uint8Array \n  if (input !== void 0) {\n    if (USE_TYPEDARRAY) {\n      var tmp = new Uint8Array(this.input.length + input.length);\n      tmp.set(this.input, 0);\n      tmp.set(input, this.input.length);\n      this.input = tmp;\n    } else {\n      this.input = this.input.concat(input);\n    }\n  }\n\n  if (this.method === void 0) {\n    if (this.readHeader() < 0) {\n      return new (USE_TYPEDARRAY ? Uint8Array : Array)();\n    }\n  }\n\n  buffer = this.rawinflate.decompress(this.input, this.ip);\n  if (this.rawinflate.ip !== 0) {\n    this.input = USE_TYPEDARRAY ? this.input.subarray(this.rawinflate.ip) : this.input.slice(this.rawinflate.ip);\n    this.ip = 0;\n  }\n\n  // verify adler-32\n  /*\n  if (this.verify) {\n    adler32 =\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\n      input[this.ip++] << 8 | input[this.ip++];\n     if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n  */\n\n  return buffer;\n};\n\nZlib.InflateStream.prototype.readHeader = function () {\n  var ip = this.ip;\n  var input = this.input;\n\n  // Compression Method and Flags\n  var cmf = input[ip++];\n  var flg = input[ip++];\n\n  if (cmf === void 0 || flg === void 0) {\n    return -1;\n  }\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  this.ip = ip;\n};\n\n/**\n * @fileoverview GZIP (RFC1952) .\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gunzip = function (input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {Array.<Zlib.GunzipMember>} */\n  this.member = [];\n  /** @type {boolean} */\n  this.decompressed = false;\n};\n\n/**\n * @return {Array.<Zlib.GunzipMember>}\n */\nZlib.Gunzip.prototype.getMembers = function () {\n  if (!this.decompressed) {\n    this.decompress();\n  }\n\n  return this.member.slice();\n};\n\n/**\n * inflate gzip data.\n * @return {!(Array.<number>|Uint8Array)} inflated buffer.\n */\nZlib.Gunzip.prototype.decompress = function () {\n  /** @type {number} input length. */\n  var il = this.input.length;\n\n  while (this.ip < il) {\n    this.decodeMember();\n  }\n\n  this.decompressed = true;\n\n  return this.concatMember();\n};\n\n/**\n * decode gzip member.\n */\nZlib.Gunzip.prototype.decodeMember = function () {\n  /** @type {Zlib.GunzipMember} */\n  var member = new Zlib.GunzipMember();\n  /** @type {number} */\n  var isize;\n  /** @type {Zlib.RawInflate} RawInflate implementation. */\n  var rawinflate;\n  /** @type {!(Array.<number>|Uint8Array)} inflated data. */\n  var inflated;\n  /** @type {number} inflate size */\n  var inflen;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} character index in string. */\n  var ci;\n  /** @type {Array.<string>} character array. */\n  var str;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} */\n  var crc32;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  member.id1 = input[ip++];\n  member.id2 = input[ip++];\n\n  // check signature\n  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {\n    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);\n  }\n\n  // check compression method\n  member.cm = input[ip++];\n  switch (member.cm) {\n    case 8:\n      /* XXX: use Zlib const */\n      break;\n    default:\n      throw new Error('unknown compression method: ' + member.cm);\n  }\n\n  // flags\n  member.flg = input[ip++];\n\n  // modification time\n  mtime = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;\n  member.mtime = new Date(mtime * 1000);\n\n  // extra flags\n  member.xfl = input[ip++];\n\n  // operating system\n  member.os = input[ip++];\n\n  // extra\n  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {\n    member.xlen = input[ip++] | input[ip++] << 8;\n    ip = this.decodeSubField(ip, member.xlen);\n  }\n\n  // fname\n  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {\n    for (str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.name = str.join('');\n  }\n\n  // fcomment\n  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {\n    for (str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.comment = str.join('');\n  }\n\n  // fhcrc\n  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {\n    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;\n    if (member.crc16 !== (input[ip++] | input[ip++] << 8)) {\n      throw new Error('invalid header crc16');\n    }\n  }\n\n  // isize \n  // inflate\n  isize = input[input.length - 4] | input[input.length - 3] << 8 | input[input.length - 2] << 16 | input[input.length - 1] << 24;\n\n  // isize \n  //  2-bit  1/4 \n  // LZ77   2-Byte  258-Byte \n  // 1/128 \n  //  isize  512 \n  // \n  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {\n    inflen = isize;\n  }\n\n  // compressed block\n  rawinflate = new Zlib.RawInflate(input, { 'index': ip, 'bufferSize': inflen });\n  member.data = inflated = rawinflate.decompress();\n  ip = rawinflate.ip;\n\n  // crc32\n  member.crc32 = crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n  if (Zlib.CRC32.calc(inflated) !== crc32) {\n    throw new Error('invalid CRC-32 checksum: 0x' + Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));\n  }\n\n  // input size\n  member.isize = isize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n  if ((inflated.length & 0xffffffff) !== isize) {\n    throw new Error('invalid input size: ' + (inflated.length & 0xffffffff) + ' / ' + isize);\n  }\n\n  this.member.push(member);\n  this.ip = ip;\n};\n\n/**\n * \n * XXX: \n */\nZlib.Gunzip.prototype.decodeSubField = function (ip, length) {\n  return ip + length;\n};\n\n/**\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Gunzip.prototype.concatMember = function () {\n  /** @type {Array.<Zlib.GunzipMember>} */\n  var member = this.member;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var p = 0;\n  /** @type {number} */\n  var size = 0;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n\n  for (i = 0, il = member.length; i < il; ++i) {\n    size += member[i].data.length;\n  }\n\n  if (USE_TYPEDARRAY) {\n    buffer = new Uint8Array(size);\n    for (i = 0; i < il; ++i) {\n      buffer.set(member[i].data, p);\n      p += member[i].data.length;\n    }\n  } else {\n    buffer = [];\n    for (i = 0; i < il; ++i) {\n      buffer[i] = member[i].data;\n    }\n    buffer = Array.prototype.concat.apply([], buffer);\n  }\n\n  return buffer;\n};\n\n/**\n * @constructor\n */\nZlib.GunzipMember = function () {\n  /** @type {number} signature first byte. */\n  this.id1;\n  /** @type {number} signature second byte. */\n  this.id2;\n  /** @type {number} compression method. */\n  this.cm;\n  /** @type {number} flags. */\n  this.flg;\n  /** @type {Date} modification time. */\n  this.mtime;\n  /** @type {number} extra flags. */\n  this.xfl;\n  /** @type {number} operating system number. */\n  this.os;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  this.crc16;\n  /** @type {number} extra length. */\n  this.xlen;\n  /** @type {number} CRC-32 value for verification. */\n  this.crc32;\n  /** @type {number} input size modulo 32 value. */\n  this.isize;\n  /** @type {string} filename. */\n  this.name;\n  /** @type {string} comment. */\n  this.comment;\n  /** @type {!(Uint8Array|Array.<number>)} */\n  this.data;\n};\n\nZlib.GunzipMember.prototype.getName = function () {\n  return this.name;\n};\n\nZlib.GunzipMember.prototype.getData = function () {\n  return this.data;\n};\n\nZlib.GunzipMember.prototype.getMtime = function () {\n  return this.mtime;\n};\n\n/**\n * @fileoverview GZIP (RFC1952) .\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gzip = function (input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  this.output;\n  /** @type {number} output buffer. */\n  this.op = 0;\n  /** @type {!Object} flags option flags. */\n  this.flags = {};\n  /** @type {!string} filename. */\n  this.filename;\n  /** @type {!string} comment. */\n  this.comment;\n  /** @type {!Object} deflate options. */\n  this.deflateOptions;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['flags']) {\n      this.flags = opt_params['flags'];\n    }\n    if (typeof opt_params['filename'] === 'string') {\n      this.filename = opt_params['filename'];\n    }\n    if (typeof opt_params['comment'] === 'string') {\n      this.comment = opt_params['comment'];\n    }\n    if (opt_params['deflateOptions']) {\n      this.deflateOptions = opt_params['deflateOptions'];\n    }\n  }\n\n  if (!this.deflateOptions) {\n    this.deflateOptions = {};\n  }\n};\n\n/**\n * @type {number}\n * @const\n */\nZlib.Gzip.DefaultBufferSize = 0x8000;\n\n/**\n * encode gzip members.\n * @return {!(Array|Uint8Array)} gzip binary array.\n */\nZlib.Gzip.prototype.compress = function () {\n  /** @type {number} flags. */\n  var flg;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  var crc16;\n  /** @type {number} CRC-32 value for verification. */\n  var crc32;\n  /** @type {!Zlib.RawDeflate} raw deflate object. */\n  var rawdeflate;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.Gzip.DefaultBufferSize);\n  /** @type {number} output buffer pointer. */\n  var op = 0;\n\n  var input = this.input;\n  var ip = this.ip;\n  var filename = this.filename;\n  var comment = this.comment;\n\n  // check signature\n  output[op++] = 0x1f;\n  output[op++] = 0x8b;\n\n  // check compression method\n  output[op++] = 8; /* XXX: use Zlib const */\n\n  // flags\n  flg = 0;\n  if (this.flags['fname']) flg |= Zlib.Gzip.FlagsMask.FNAME;\n  if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;\n  if (this.flags['fhcrc']) flg |= Zlib.Gzip.FlagsMask.FHCRC;\n  // XXX: FTEXT\n  // XXX: FEXTRA\n  output[op++] = flg;\n\n  // modification time\n  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;\n  output[op++] = mtime & 0xff;\n  output[op++] = mtime >>> 8 & 0xff;\n  output[op++] = mtime >>> 16 & 0xff;\n  output[op++] = mtime >>> 24 & 0xff;\n\n  // extra flags\n  output[op++] = 0;\n\n  // operating system\n  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;\n\n  // extra\n  /* NOP */\n\n  // fname\n  if (this.flags['fname'] !== void 0) {\n    for (i = 0, il = filename.length; i < il; ++i) {\n      c = filename.charCodeAt(i);\n      if (c > 0xff) {\n        output[op++] = c >>> 8 & 0xff;\n      }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fcomment\n  if (this.flags['comment']) {\n    for (i = 0, il = comment.length; i < il; ++i) {\n      c = comment.charCodeAt(i);\n      if (c > 0xff) {\n        output[op++] = c >>> 8 & 0xff;\n      }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fhcrc\n  if (this.flags['fhcrc']) {\n    crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;\n    output[op++] = crc16 & 0xff;\n    output[op++] = crc16 >>> 8 & 0xff;\n  }\n\n  // add compress option\n  this.deflateOptions['outputBuffer'] = output;\n  this.deflateOptions['outputIndex'] = op;\n\n  // compress\n  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);\n  output = rawdeflate.compress();\n  op = rawdeflate.op;\n\n  // expand buffer\n  if (USE_TYPEDARRAY) {\n    if (op + 8 > output.buffer.byteLength) {\n      this.output = new Uint8Array(op + 8);\n      this.output.set(new Uint8Array(output.buffer));\n      output = this.output;\n    } else {\n      output = new Uint8Array(output.buffer);\n    }\n  }\n\n  // crc32\n  crc32 = Zlib.CRC32.calc(input);\n  output[op++] = crc32 & 0xff;\n  output[op++] = crc32 >>> 8 & 0xff;\n  output[op++] = crc32 >>> 16 & 0xff;\n  output[op++] = crc32 >>> 24 & 0xff;\n\n  // input size\n  il = input.length;\n  output[op++] = il & 0xff;\n  output[op++] = il >>> 8 & 0xff;\n  output[op++] = il >>> 16 & 0xff;\n  output[op++] = il >>> 24 & 0xff;\n\n  this.ip = ip;\n\n  if (USE_TYPEDARRAY && op < output.length) {\n    this.output = output = output.subarray(0, op);\n  }\n\n  return output;\n};\n\n/** @enum {number} */\nZlib.Gzip.OperatingSystem = {\n  FAT: 0,\n  AMIGA: 1,\n  VMS: 2,\n  UNIX: 3,\n  VM_CMS: 4,\n  ATARI_TOS: 5,\n  HPFS: 6,\n  MACINTOSH: 7,\n  Z_SYSTEM: 8,\n  CP_M: 9,\n  TOPS_20: 10,\n  NTFS: 11,\n  QDOS: 12,\n  ACORN_RISCOS: 13,\n  UNKNOWN: 255\n};\n\n/** @enum {number} */\nZlib.Gzip.FlagsMask = {\n  FTEXT: 0x01,\n  FHCRC: 0x02,\n  FEXTRA: 0x04,\n  FNAME: 0x08,\n  FCOMMENT: 0x10\n};\n\n/**\n * @fileoverview Heap Sort . .\n */\n\n/**\n * \n * @param {number} length .\n * @constructor\n */\nZlib.Heap = function (length) {\n  this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\n  this.length = 0;\n};\n\n/**\n *  index \n * @param {number} index  index.\n * @return {number}  index.\n *\n */\nZlib.Heap.prototype.getParent = function (index) {\n  return ((index - 2) / 4 | 0) * 2;\n};\n\n/**\n *  index \n * @param {number} index  index.\n * @return {number}  index.\n */\nZlib.Heap.prototype.getChild = function (index) {\n  return 2 * index + 2;\n};\n\n/**\n * Heap \n * @param {number} index  index.\n * @param {number} value .\n * @return {number} .\n */\nZlib.Heap.prototype.push = function (index, value) {\n  var current,\n      parent,\n      heap = this.buffer,\n      swap;\n\n  current = this.length;\n  heap[this.length++] = value;\n  heap[this.length++] = index;\n\n  // \n  while (current > 0) {\n    parent = this.getParent(current);\n\n    // \n    if (heap[current] > heap[parent]) {\n      swap = heap[current];\n      heap[current] = heap[parent];\n      heap[parent] = swap;\n\n      swap = heap[current + 1];\n      heap[current + 1] = heap[parent + 1];\n      heap[parent + 1] = swap;\n\n      current = parent;\n      // \n    } else {\n      break;\n    }\n  }\n\n  return this.length;\n};\n\n/**\n * Heap\n * @return {{index: number, value: number, length: number}} {index: index,\n *     value: , length: }  Object.\n */\nZlib.Heap.prototype.pop = function () {\n  var index,\n      value,\n      heap = this.buffer,\n      swap,\n      current,\n      parent;\n\n  value = heap[0];\n  index = heap[1];\n\n  // \n  this.length -= 2;\n  heap[0] = heap[this.length];\n  heap[1] = heap[this.length + 1];\n\n  parent = 0;\n  // \n  while (true) {\n    current = this.getChild(parent);\n\n    // \n    if (current >= this.length) {\n      break;\n    }\n\n    // \n    if (current + 2 < this.length && heap[current + 2] > heap[current]) {\n      current += 2;\n    }\n\n    // \n    if (heap[current] > heap[parent]) {\n      swap = heap[parent];\n      heap[parent] = heap[current];\n      heap[current] = swap;\n\n      swap = heap[parent + 1];\n      heap[parent + 1] = heap[current + 1];\n      heap[current + 1] = swap;\n    } else {\n      break;\n    }\n\n    parent = current;\n  }\n\n  return { index: index, value: value, length: this.length };\n};\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n/**\n * @fileoverview Deflate (RFC1951) .\n */\n\n/**\n * Raw Deflate \n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} input .\n * @param {Object=} opt_params option parameters.\n *\n * typed array outputBuffer  Array  Uint8Array \n * .\n * \n * .\n */\nZlib.RawDeflate = function (input, opt_params) {\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;\n  /** @type {number} */\n  this.lazy = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsLitLen;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsDist;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = USE_TYPEDARRAY && input instanceof Array ? new Uint8Array(input) : input;\n  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\n  this.output;\n  /** @type {number} pos output buffer position. */\n  this.op = 0;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['lazy']) {\n      this.lazy = opt_params['lazy'];\n    }\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n    if (opt_params['outputBuffer']) {\n      this.output = USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array ? new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\n    }\n    if (typeof opt_params['outputIndex'] === 'number') {\n      this.op = opt_params['outputIndex'];\n    }\n  }\n\n  if (!this.output) {\n    this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawDeflate.CompressionType = {\n  NONE: 0,\n  FIXED: 1,\n  DYNAMIC: 2,\n  RESERVED: 3\n};\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MinLength = 3;\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MaxLength = 258;\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.WindowSize = 0x8000;\n\n/**\n * \n * @const\n * @type {number}\n */\nZlib.RawDeflate.MaxCodeLength = 16;\n\n/**\n * \n * @const\n * @type {number}\n */\nZlib.RawDeflate.HUFMAX = 286;\n\n/**\n * \n * @const\n * @type {Array.<Array.<number, number>>}\n */\nZlib.RawDeflate.FixedHuffmanTable = function () {\n  var table = [],\n      i;\n\n  for (i = 0; i < 288; i++) {\n    switch (true) {\n      case i <= 143:\n        table.push([i + 0x030, 8]);break;\n      case i <= 255:\n        table.push([i - 144 + 0x190, 9]);break;\n      case i <= 279:\n        table.push([i - 256 + 0x000, 7]);break;\n      case i <= 287:\n        table.push([i - 280 + 0x0C0, 8]);break;\n      default:\n        throw 'invalid literal: ' + i;\n    }\n  }\n\n  return table;\n}();\n\n/**\n * DEFLATE \n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.compress = function () {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var blockArray;\n  /** @type {number} */\n  var position;\n  /** @type {number} */\n  var length;\n\n  var input = this.input;\n\n  // compression\n  switch (this.compressionType) {\n    case Zlib.RawDeflate.CompressionType.NONE:\n      // each 65535-Byte (length header: 16-bit)\n      for (position = 0, length = input.length; position < length;) {\n        blockArray = USE_TYPEDARRAY ? input.subarray(position, position + 0xffff) : input.slice(position, position + 0xffff);\n        position += blockArray.length;\n        this.makeNocompressBlock(blockArray, position === length);\n      }\n      break;\n    case Zlib.RawDeflate.CompressionType.FIXED:\n      this.output = this.makeFixedHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    case Zlib.RawDeflate.CompressionType.DYNAMIC:\n      this.output = this.makeDynamicHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    default:\n      throw 'invalid compression type';\n  }\n\n  return this.output;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeNocompressBlock = function (blockArray, isFinalBlock) {\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {number} */\n  var len;\n  /** @type {number} */\n  var nlen;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  var output = this.output;\n  var op = this.op;\n\n  // expand buffer\n  if (USE_TYPEDARRAY) {\n    output = new Uint8Array(this.output.buffer);\n    while (output.length <= op + blockArray.length + 5) {\n      output = new Uint8Array(output.length << 1);\n    }\n    output.set(this.output);\n  }\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.NONE;\n  output[op++] = bfinal | btype << 1;\n\n  // length\n  len = blockArray.length;\n  nlen = ~len + 0x10000 & 0xffff;\n  output[op++] = len & 0xff;\n  output[op++] = len >>> 8 & 0xff;\n  output[op++] = nlen & 0xff;\n  output[op++] = nlen >>> 8 & 0xff;\n\n  // copy buffer\n  if (USE_TYPEDARRAY) {\n    output.set(blockArray, op);\n    op += blockArray.length;\n    output = output.subarray(0, op);\n  } else {\n    for (i = 0, il = blockArray.length; i < il; ++i) {\n      output[op++] = blockArray[i];\n    }\n    output.length = op;\n  }\n\n  this.op = op;\n  this.output = output;\n\n  return output;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeFixedHuffmanBlock = function (blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(USE_TYPEDARRAY ? new Uint8Array(this.output.buffer) : this.output, this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.FIXED;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n  this.fixedHuffman(data, stream);\n\n  return stream.finish();\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeDynamicHuffmanBlock = function (blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(USE_TYPEDARRAY ? new Uint8Array(this.output.buffer) : this.output, this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n  /** @type {number} */\n  var hlit;\n  /** @type {number} */\n  var hdist;\n  /** @type {number} */\n  var hclen;\n  /** @const @type {Array.<number>} */\n  var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var litLenLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var litLenCodes;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var distLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var distCodes;\n  /** @type {{\n   *   codes: !(Array.<number>|Uint32Array),\n   *   freqs: !(Array.<number>|Uint8Array)\n   * }} */\n  var treeSymbols;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var treeLengths;\n  /** @type {Array} */\n  var transLengths = new Array(19);\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var treeCodes;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var bitlen;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.DYNAMIC;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n\n  // , \n  litLenLengths = this.getLengths_(this.freqsLitLen, 15);\n  litLenCodes = this.getCodesFromLengths_(litLenLengths);\n  distLengths = this.getLengths_(this.freqsDist, 7);\n  distCodes = this.getCodesFromLengths_(distLengths);\n\n  // HLIT, HDIST \n  for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\n  for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\n\n  // HCLEN\n  treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\n  treeLengths = this.getLengths_(treeSymbols.freqs, 7);\n  for (i = 0; i < 19; i++) {\n    transLengths[i] = treeLengths[hclenOrder[i]];\n  }\n  for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\n\n  treeCodes = this.getCodesFromLengths_(treeLengths);\n\n  // \n  stream.writeBits(hlit - 257, 5, true);\n  stream.writeBits(hdist - 1, 5, true);\n  stream.writeBits(hclen - 4, 4, true);\n  for (i = 0; i < hclen; i++) {\n    stream.writeBits(transLengths[i], 3, true);\n  }\n\n  // \n  for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\n    code = treeSymbols.codes[i];\n\n    stream.writeBits(treeCodes[code], treeLengths[code], true);\n\n    // extra bits\n    if (code >= 16) {\n      i++;\n      switch (code) {\n        case 16:\n          bitlen = 2;break;\n        case 17:\n          bitlen = 3;break;\n        case 18:\n          bitlen = 7;break;\n        default:\n          throw 'invalid code: ' + code;\n      }\n\n      stream.writeBits(treeSymbols.codes[i], bitlen, true);\n    }\n  }\n\n  this.dynamicHuffman(data, [litLenCodes, litLenLengths], [distCodes, distLengths], stream);\n\n  return stream.finish();\n};\n\n/**\n * ()\n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77  byte array.\n * @param {!Zlib.BitStream} stream .\n * @return {!Zlib.BitStream} .\n */\nZlib.RawDeflate.prototype.dynamicHuffman = function (dataArray, litLen, dist, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var litLenCodes;\n  /** @type {number} */\n  var litLenLengths;\n  /** @type {number} */\n  var distCodes;\n  /** @type {number} */\n  var distLengths;\n\n  litLenCodes = litLen[0];\n  litLenLengths = litLen[1];\n  distCodes = dist[0];\n  distLengths = dist[1];\n\n  //  BitStream \n  for (index = 0, length = dataArray.length; index < length; ++index) {\n    literal = dataArray[index];\n\n    // literal or length\n    stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\n\n    // \n    if (literal > 256) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      code = dataArray[++index];\n      stream.writeBits(distCodes[code], distLengths[code], true);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // \n    } else if (literal === 256) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77  byte array.\n * @param {!Zlib.BitStream} stream .\n * @return {!Zlib.BitStream} .\n */\nZlib.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n\n  //  BitStream \n  for (index = 0, length = dataArray.length; index < length; index++) {\n    literal = dataArray[index];\n\n    // \n    Zlib.BitStream.prototype.writeBits.apply(stream, Zlib.RawDeflate.FixedHuffmanTable[literal]);\n\n    // \n    if (literal > 0x100) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      stream.writeBits(dataArray[++index], 5);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // \n    } else if (literal === 0x100) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * \n * @param {!number} length .\n * @param {!number} backwardDistance .\n * @constructor\n */\nZlib.RawDeflate.Lz77Match = function (length, backwardDistance) {\n  /** @type {number} match length. */\n  this.length = length;\n  /** @type {number} backward distance. */\n  this.backwardDistance = backwardDistance;\n};\n\n/**\n * .\n * [, , ] .\n * @const\n * @type {!(Array.<number>|Uint32Array)}\n */\nZlib.RawDeflate.Lz77Match.LengthCodeTable = function (table) {\n  return USE_TYPEDARRAY ? new Uint32Array(table) : table;\n}(function () {\n  /** @type {!Array} */\n  var table = [];\n  /** @type {number} */\n  var i;\n  /** @type {!Array.<number>} */\n  var c;\n\n  for (i = 3; i <= 258; i++) {\n    c = code(i);\n    table[i] = c[2] << 24 | c[1] << 16 | c[0];\n  }\n\n  /**\n   * @param {number} length lz77 length.\n   * @return {!Array.<number>} lz77 codes.\n   */\n  function code(length) {\n    switch (true) {\n      case length === 3:\n        return [257, length - 3, 0];break;\n      case length === 4:\n        return [258, length - 4, 0];break;\n      case length === 5:\n        return [259, length - 5, 0];break;\n      case length === 6:\n        return [260, length - 6, 0];break;\n      case length === 7:\n        return [261, length - 7, 0];break;\n      case length === 8:\n        return [262, length - 8, 0];break;\n      case length === 9:\n        return [263, length - 9, 0];break;\n      case length === 10:\n        return [264, length - 10, 0];break;\n      case length <= 12:\n        return [265, length - 11, 1];break;\n      case length <= 14:\n        return [266, length - 13, 1];break;\n      case length <= 16:\n        return [267, length - 15, 1];break;\n      case length <= 18:\n        return [268, length - 17, 1];break;\n      case length <= 22:\n        return [269, length - 19, 2];break;\n      case length <= 26:\n        return [270, length - 23, 2];break;\n      case length <= 30:\n        return [271, length - 27, 2];break;\n      case length <= 34:\n        return [272, length - 31, 2];break;\n      case length <= 42:\n        return [273, length - 35, 3];break;\n      case length <= 50:\n        return [274, length - 43, 3];break;\n      case length <= 58:\n        return [275, length - 51, 3];break;\n      case length <= 66:\n        return [276, length - 59, 3];break;\n      case length <= 82:\n        return [277, length - 67, 4];break;\n      case length <= 98:\n        return [278, length - 83, 4];break;\n      case length <= 114:\n        return [279, length - 99, 4];break;\n      case length <= 130:\n        return [280, length - 115, 4];break;\n      case length <= 162:\n        return [281, length - 131, 5];break;\n      case length <= 194:\n        return [282, length - 163, 5];break;\n      case length <= 226:\n        return [283, length - 195, 5];break;\n      case length <= 257:\n        return [284, length - 227, 5];break;\n      case length === 258:\n        return [285, length - 258, 0];break;\n      default:\n        throw 'invalid length: ' + length;\n    }\n  }\n\n  return table;\n}());\n\n/**\n * \n * @param {!number} dist .\n * @return {!Array.<number>} .\n * @private\n */\nZlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {\n  /** @type {!Array.<number>} distance code table. */\n  var r;\n\n  switch (true) {\n    case dist === 1:\n      r = [0, dist - 1, 0];break;\n    case dist === 2:\n      r = [1, dist - 2, 0];break;\n    case dist === 3:\n      r = [2, dist - 3, 0];break;\n    case dist === 4:\n      r = [3, dist - 4, 0];break;\n    case dist <= 6:\n      r = [4, dist - 5, 1];break;\n    case dist <= 8:\n      r = [5, dist - 7, 1];break;\n    case dist <= 12:\n      r = [6, dist - 9, 2];break;\n    case dist <= 16:\n      r = [7, dist - 13, 2];break;\n    case dist <= 24:\n      r = [8, dist - 17, 3];break;\n    case dist <= 32:\n      r = [9, dist - 25, 3];break;\n    case dist <= 48:\n      r = [10, dist - 33, 4];break;\n    case dist <= 64:\n      r = [11, dist - 49, 4];break;\n    case dist <= 96:\n      r = [12, dist - 65, 5];break;\n    case dist <= 128:\n      r = [13, dist - 97, 5];break;\n    case dist <= 192:\n      r = [14, dist - 129, 6];break;\n    case dist <= 256:\n      r = [15, dist - 193, 6];break;\n    case dist <= 384:\n      r = [16, dist - 257, 7];break;\n    case dist <= 512:\n      r = [17, dist - 385, 7];break;\n    case dist <= 768:\n      r = [18, dist - 513, 8];break;\n    case dist <= 1024:\n      r = [19, dist - 769, 8];break;\n    case dist <= 1536:\n      r = [20, dist - 1025, 9];break;\n    case dist <= 2048:\n      r = [21, dist - 1537, 9];break;\n    case dist <= 3072:\n      r = [22, dist - 2049, 10];break;\n    case dist <= 4096:\n      r = [23, dist - 3073, 10];break;\n    case dist <= 6144:\n      r = [24, dist - 4097, 11];break;\n    case dist <= 8192:\n      r = [25, dist - 6145, 11];break;\n    case dist <= 12288:\n      r = [26, dist - 8193, 12];break;\n    case dist <= 16384:\n      r = [27, dist - 12289, 12];break;\n    case dist <= 24576:\n      r = [28, dist - 16385, 13];break;\n    case dist <= 32768:\n      r = [29, dist - 24577, 13];break;\n    default:\n      throw 'invalid distance';\n  }\n\n  return r;\n};\n\n/**\n *  LZ77 .\n * \n * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\n * @return {!Array.<number>} LZ77  byte array.\n */\nZlib.RawDeflate.Lz77Match.prototype.toLz77Array = function () {\n  /** @type {number} */\n  var length = this.length;\n  /** @type {number} */\n  var dist = this.backwardDistance;\n  /** @type {Array} */\n  var codeArray = [];\n  /** @type {number} */\n  var pos = 0;\n  /** @type {!Array.<number>} */\n  var code;\n\n  // length\n  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];\n  codeArray[pos++] = code & 0xffff;\n  codeArray[pos++] = code >> 16 & 0xff;\n  codeArray[pos++] = code >> 24;\n\n  // distance\n  code = this.getDistanceCode_(dist);\n  codeArray[pos++] = code[0];\n  codeArray[pos++] = code[1];\n  codeArray[pos++] = code[2];\n\n  return codeArray;\n};\n\n/**\n * LZ77 \n * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 .\n * @return {!(Array.<number>|Uint16Array)} LZ77 .\n */\nZlib.RawDeflate.prototype.lz77 = function (dataArray) {\n  /** @type {number} input position */\n  var position;\n  /** @type {number} input length */\n  var length;\n  /** @type {number} loop counter */\n  var i;\n  /** @type {number} loop limiter */\n  var il;\n  /** @type {number} chained-hash-table key */\n  var matchKey;\n  /** @type {Object.<number, Array.<number>>} chained-hash-table */\n  var table = {};\n  /** @const @type {number} */\n  var windowSize = Zlib.RawDeflate.WindowSize;\n  /** @type {Array.<number>} match list */\n  var matchList;\n  /** @type {Zlib.RawDeflate.Lz77Match} longest match */\n  var longestMatch;\n  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */\n  var prevMatch;\n  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\n  var lz77buf = USE_TYPEDARRAY ? new Uint16Array(dataArray.length * 2) : [];\n  /** @type {number} lz77 output buffer pointer */\n  var pos = 0;\n  /** @type {number} lz77 skip length */\n  var skipLength = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array)(286);\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array)(30);\n  /** @type {number} */\n  var lazy = this.lazy;\n  /** @type {*} temporary variable */\n  var tmp;\n\n  // \n  if (!USE_TYPEDARRAY) {\n    for (i = 0; i <= 285;) {\n      freqsLitLen[i++] = 0;\n    }\n    for (i = 0; i <= 29;) {\n      freqsDist[i++] = 0;\n    }\n  }\n  freqsLitLen[256] = 1; // EOB  1\n\n  /**\n   * \n   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.\n   * @param {!number} offset ().\n   * @private\n   */\n  function writeMatch(match, offset) {\n    /** @type {Array.<number>} */\n    var lz77Array = match.toLz77Array();\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    for (i = 0, il = lz77Array.length; i < il; ++i) {\n      lz77buf[pos++] = lz77Array[i];\n    }\n    freqsLitLen[lz77Array[0]]++;\n    freqsDist[lz77Array[3]]++;\n    skipLength = match.length + offset - 1;\n    prevMatch = null;\n  }\n\n  // LZ77 \n  for (position = 0, length = dataArray.length; position < length; ++position) {\n    // \n    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {\n      if (position + i === length) {\n        break;\n      }\n      matchKey = matchKey << 8 | dataArray[position + i];\n    }\n\n    // \n    if (table[matchKey] === void 0) {\n      table[matchKey] = [];\n    }\n    matchList = table[matchKey];\n\n    // skip\n    if (skipLength-- > 0) {\n      matchList.push(position);\n      continue;\n    }\n\n    //  ()\n    while (matchList.length > 0 && position - matchList[0] > windowSize) {\n      matchList.shift();\n    }\n\n    // \n    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {\n      if (prevMatch) {\n        writeMatch(prevMatch, -1);\n      }\n\n      for (i = 0, il = length - position; i < il; ++i) {\n        tmp = dataArray[position + i];\n        lz77buf[pos++] = tmp;\n        ++freqsLitLen[tmp];\n      }\n      break;\n    }\n\n    // \n    if (matchList.length > 0) {\n      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\n\n      if (prevMatch) {\n        // \n        if (prevMatch.length < longestMatch.length) {\n          // write previous literal\n          tmp = dataArray[position - 1];\n          lz77buf[pos++] = tmp;\n          ++freqsLitLen[tmp];\n\n          // write current match\n          writeMatch(longestMatch, 0);\n        } else {\n          // write previous match\n          writeMatch(prevMatch, -1);\n        }\n      } else if (longestMatch.length < lazy) {\n        prevMatch = longestMatch;\n      } else {\n        writeMatch(longestMatch, 0);\n      }\n      // \n    } else if (prevMatch) {\n      writeMatch(prevMatch, -1);\n    } else {\n      tmp = dataArray[position];\n      lz77buf[pos++] = tmp;\n      ++freqsLitLen[tmp];\n    }\n\n    matchList.push(position); // \n  }\n\n  // \n  lz77buf[pos++] = 256;\n  freqsLitLen[256]++;\n  this.freqsLitLen = freqsLitLen;\n  this.freqsDist = freqsDist;\n\n  return (/** @type {!(Uint16Array|Array.<number>)} */USE_TYPEDARRAY ? lz77buf.subarray(0, pos) : lz77buf\n  );\n};\n\n/**\n * \n * @param {!Object} data plain data byte array.\n * @param {!number} position plain data byte array position.\n * @param {!Array.<number>} matchList .\n * @return {!Zlib.RawDeflate.Lz77Match} .\n * @private\n */\nZlib.RawDeflate.prototype.searchLongestMatch_ = function (data, position, matchList) {\n  var match,\n      currentMatch,\n      matchMax = 0,\n      matchLength,\n      i,\n      j,\n      l,\n      dl = data.length;\n\n  //  1 \n  permatch: for (i = 0, l = matchList.length; i < l; i++) {\n    match = matchList[l - i - 1];\n    matchLength = Zlib.RawDeflate.Lz77MinLength;\n\n    // \n    if (matchMax > Zlib.RawDeflate.Lz77MinLength) {\n      for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {\n        if (data[match + j - 1] !== data[position + j - 1]) {\n          continue permatch;\n        }\n      }\n      matchLength = matchMax;\n    }\n\n    // \n    while (matchLength < Zlib.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {\n      ++matchLength;\n    }\n\n    // \n    if (matchLength > matchMax) {\n      currentMatch = match;\n      matchMax = matchLength;\n    }\n\n    // \n    if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {\n      break;\n    }\n  }\n\n  return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);\n};\n\n/**\n * Tree-Transmit Symbols \n * reference: PuTTY Deflate implementation\n * @param {number} hlit HLIT.\n * @param {!(Array.<number>|Uint8Array)} litlenLengths .\n * @param {number} hdist HDIST.\n * @param {!(Array.<number>|Uint8Array)} distLengths .\n * @return {{\n *   codes: !(Array.<number>|Uint32Array),\n *   freqs: !(Array.<number>|Uint8Array)\n * }} Tree-Transmit Symbols.\n */\nZlib.RawDeflate.prototype.getTreeSymbols_ = function (hlit, litlenLengths, hdist, distLengths) {\n  var src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\n      i,\n      j,\n      runLength,\n      l,\n      result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\n      nResult,\n      rpt,\n      freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\n\n  j = 0;\n  for (i = 0; i < hlit; i++) {\n    src[j++] = litlenLengths[i];\n  }\n  for (i = 0; i < hdist; i++) {\n    src[j++] = distLengths[i];\n  }\n\n  // \n  if (!USE_TYPEDARRAY) {\n    for (i = 0, l = freqs.length; i < l; ++i) {\n      freqs[i] = 0;\n    }\n  }\n\n  // \n  nResult = 0;\n  for (i = 0, l = src.length; i < l; i += j) {\n    // Run Length Encoding\n    for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\n\n    runLength = j;\n\n    if (src[i] === 0) {\n      // 0  3 \n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = 0;\n          freqs[0]++;\n        }\n      } else {\n        while (runLength > 0) {\n          //  138 \n          rpt = runLength < 138 ? runLength : 138;\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          // 3-10  -> 17\n          if (rpt <= 10) {\n            result[nResult++] = 17;\n            result[nResult++] = rpt - 3;\n            freqs[17]++;\n            // 11-138  -> 18\n          } else {\n            result[nResult++] = 18;\n            result[nResult++] = rpt - 11;\n            freqs[18]++;\n          }\n\n          runLength -= rpt;\n        }\n      }\n    } else {\n      result[nResult++] = src[i];\n      freqs[src[i]]++;\n      runLength--;\n\n      // 3\n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = src[i];\n          freqs[src[i]]++;\n        }\n        // 3 \n      } else {\n        while (runLength > 0) {\n          // runLength 3-6 \n          rpt = runLength < 6 ? runLength : 6;\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          result[nResult++] = 16;\n          result[nResult++] = rpt - 3;\n          freqs[16]++;\n\n          runLength -= rpt;\n        }\n      }\n    }\n  }\n\n  return {\n    codes: USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult),\n    freqs: freqs\n  };\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs .\n * @param {number} limit .\n * @return {!(Array.<number>|Uint8Array)} .\n * @private\n */\nZlib.RawDeflate.prototype.getLengths_ = function (freqs, limit) {\n  /** @type {number} */\n  var nSymbols = freqs.length;\n  /** @type {Zlib.Heap} */\n  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\n  /** @type {Array} */\n  var nodes;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var values;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // \n  if (!USE_TYPEDARRAY) {\n    for (i = 0; i < nSymbols; i++) {\n      length[i] = 0;\n    }\n  }\n\n  // \n  for (i = 0; i < nSymbols; ++i) {\n    if (freqs[i] > 0) {\n      heap.push(i, freqs[i]);\n    }\n  }\n  nodes = new Array(heap.length / 2);\n  values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\n\n  //  0  1 \n  if (nodes.length === 1) {\n    length[heap.pop().index] = 1;\n    return length;\n  }\n\n  // Reverse Package Merge Algorithm  Canonical Huffman Code \n  for (i = 0, il = heap.length / 2; i < il; ++i) {\n    nodes[i] = heap.pop();\n    values[i] = nodes[i].value;\n  }\n  codeLength = this.reversePackageMerge_(values, values.length, limit);\n\n  for (i = 0, il = nodes.length; i < il; ++i) {\n    length[nodes[i].index] = codeLength[i];\n  }\n\n  return length;\n};\n\n/**\n * Reverse Package Merge Algorithm.\n * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\n * @param {number} symbols number of symbols.\n * @param {number} limit code length limit.\n * @return {!(Array.<number>|Uint8Array)} code lengths.\n */\nZlib.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\n  /** @type {Array} */\n  var value = new Array(limit);\n  /** @type {Array} */\n  var type = new Array(limit);\n  /** @type {Array.<number>} */\n  var currentPosition = new Array(limit);\n  /** @type {number} */\n  var excess = (1 << limit) - symbols;\n  /** @type {number} */\n  var half = 1 << limit - 1;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var t;\n  /** @type {number} */\n  var weight;\n  /** @type {number} */\n  var next;\n\n  /**\n   * @param {number} j\n   */\n  function takePackage(j) {\n    /** @type {number} */\n    var x = type[j][currentPosition[j]];\n\n    if (x === symbols) {\n      takePackage(j + 1);\n      takePackage(j + 1);\n    } else {\n      --codeLength[x];\n    }\n\n    ++currentPosition[j];\n  }\n\n  minimumCost[limit - 1] = symbols;\n\n  for (j = 0; j < limit; ++j) {\n    if (excess < half) {\n      flag[j] = 0;\n    } else {\n      flag[j] = 1;\n      excess -= half;\n    }\n    excess <<= 1;\n    minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;\n  }\n  minimumCost[0] = flag[0];\n\n  value[0] = new Array(minimumCost[0]);\n  type[0] = new Array(minimumCost[0]);\n  for (j = 1; j < limit; ++j) {\n    if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {\n      minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];\n    }\n    value[j] = new Array(minimumCost[j]);\n    type[j] = new Array(minimumCost[j]);\n  }\n\n  for (i = 0; i < symbols; ++i) {\n    codeLength[i] = limit;\n  }\n\n  for (t = 0; t < minimumCost[limit - 1]; ++t) {\n    value[limit - 1][t] = freqs[t];\n    type[limit - 1][t] = t;\n  }\n\n  for (i = 0; i < limit; ++i) {\n    currentPosition[i] = 0;\n  }\n  if (flag[limit - 1] === 1) {\n    --codeLength[0];\n    ++currentPosition[limit - 1];\n  }\n\n  for (j = limit - 2; j >= 0; --j) {\n    i = 0;\n    weight = 0;\n    next = currentPosition[j + 1];\n\n    for (t = 0; t < minimumCost[j]; t++) {\n      weight = value[j + 1][next] + value[j + 1][next + 1];\n\n      if (weight > freqs[i]) {\n        value[j][t] = weight;\n        type[j][t] = symbols;\n        next += 2;\n      } else {\n        value[j][t] = freqs[i];\n        type[j][t] = i;\n        ++i;\n      }\n    }\n\n    currentPosition[j] = 0;\n    if (flag[j] === 1) {\n      takePackage(j);\n    }\n  }\n\n  return codeLength;\n};\n\n/**\n * \n * reference: PuTTY Deflate implementation\n * @param {!(Array.<number>|Uint8Array)} lengths .\n * @return {!(Array.<number>|Uint16Array)} .\n * @private\n */\nZlib.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {\n  var codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\n      count = [],\n      startCode = [],\n      code = 0,\n      i,\n      il,\n      j,\n      m;\n\n  // Count the codes of each length.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    count[lengths[i]] = (count[lengths[i]] | 0) + 1;\n  }\n\n  // Determine the starting code for each length block.\n  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {\n    startCode[i] = code;\n    code += count[i] | 0;\n    code <<= 1;\n  }\n\n  // Determine the code for each symbol. Mirrored, of course.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    code = startCode[lengths[i]];\n    startCode[lengths[i]] += 1;\n    codes[i] = 0;\n\n    for (j = 0, m = lengths[i]; j < m; j++) {\n      codes[i] = codes[i] << 1 | code & 1;\n      code >>>= 1;\n    }\n  }\n\n  return codes;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Unzip = function (input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = USE_TYPEDARRAY && input instanceof Array ? new Uint8Array(input) : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {number} */\n  this.eocdrOffset;\n  /** @type {number} */\n  this.numberOfThisDisk;\n  /** @type {number} */\n  this.startDisk;\n  /** @type {number} */\n  this.totalEntriesThisDisk;\n  /** @type {number} */\n  this.totalEntries;\n  /** @type {number} */\n  this.centralDirectorySize;\n  /** @type {number} */\n  this.centralDirectoryOffset;\n  /** @type {number} */\n  this.commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  this.fileHeaderList;\n  /** @type {Object.<string, number>} */\n  this.filenameToIndex;\n  /** @type {boolean} */\n  this.verify = opt_params['verify'] || false;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password = opt_params['password'];\n};\n\nZlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.FileHeader = function (input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.version;\n  /** @type {number} */\n  this.os;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {number} */\n  this.fileCommentLength;\n  /** @type {number} */\n  this.diskNumberStart;\n  /** @type {number} */\n  this.internalFileAttributes;\n  /** @type {number} */\n  this.externalFileAttributes;\n  /** @type {number} */\n  this.relativeOffset;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.comment;\n};\n\nZlib.Unzip.FileHeader.prototype.parse = function () {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // central file header signature\n  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {\n    throw new Error('invalid file header signature');\n  }\n\n  // version made by\n  this.version = input[ip++];\n  this.os = input[ip++];\n\n  // version needed to extract\n  this.needVersion = input[ip++] | input[ip++] << 8;\n\n  // general purpose bit flag\n  this.flags = input[ip++] | input[ip++] << 8;\n\n  // compression method\n  this.compression = input[ip++] | input[ip++] << 8;\n\n  // last mod file time\n  this.time = input[ip++] | input[ip++] << 8;\n\n  //last mod file date\n  this.date = input[ip++] | input[ip++] << 8;\n\n  // crc-32\n  this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // compressed size\n  this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | input[ip++] << 8;\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | input[ip++] << 8;\n\n  // file comment length\n  this.fileCommentLength = input[ip++] | input[ip++] << 8;\n\n  // disk number start\n  this.diskNumberStart = input[ip++] | input[ip++] << 8;\n\n  // internal file attributes\n  this.internalFileAttributes = input[ip++] | input[ip++] << 8;\n\n  // external file attributes\n  this.externalFileAttributes = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;\n\n  // relative offset of local header\n  this.relativeOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ? input.subarray(ip, ip += this.fileNameLength) : input.slice(ip, ip += this.fileNameLength));\n\n  // extra field\n  this.extraField = USE_TYPEDARRAY ? input.subarray(ip, ip += this.extraFieldLength) : input.slice(ip, ip += this.extraFieldLength);\n\n  // file comment\n  this.comment = USE_TYPEDARRAY ? input.subarray(ip, ip + this.fileCommentLength) : input.slice(ip, ip + this.fileCommentLength);\n\n  this.length = ip - this.offset;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.LocalFileHeader = function (input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n};\n\nZlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;\n\nZlib.Unzip.LocalFileHeader.prototype.parse = function () {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // local file header signature\n  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {\n    throw new Error('invalid local file header signature');\n  }\n\n  // version needed to extract\n  this.needVersion = input[ip++] | input[ip++] << 8;\n\n  // general purpose bit flag\n  this.flags = input[ip++] | input[ip++] << 8;\n\n  // compression method\n  this.compression = input[ip++] | input[ip++] << 8;\n\n  // last mod file time\n  this.time = input[ip++] | input[ip++] << 8;\n\n  //last mod file date\n  this.date = input[ip++] | input[ip++] << 8;\n\n  // crc-32\n  this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // compressed size\n  this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | input[ip++] << 8;\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | input[ip++] << 8;\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ? input.subarray(ip, ip += this.fileNameLength) : input.slice(ip, ip += this.fileNameLength));\n\n  // extra field\n  this.extraField = USE_TYPEDARRAY ? input.subarray(ip, ip += this.extraFieldLength) : input.slice(ip, ip += this.extraFieldLength);\n\n  this.length = ip - this.offset;\n};\n\nZlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  for (ip = input.length - 12; ip > 0; --ip) {\n    if (input[ip] === Zlib.Unzip.CentralDirectorySignature[0] && input[ip + 1] === Zlib.Unzip.CentralDirectorySignature[1] && input[ip + 2] === Zlib.Unzip.CentralDirectorySignature[2] && input[ip + 3] === Zlib.Unzip.CentralDirectorySignature[3]) {\n      this.eocdrOffset = ip;\n      return;\n    }\n  }\n\n  throw new Error('End of Central Directory Record not found');\n};\n\nZlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  if (!this.eocdrOffset) {\n    this.searchEndOfCentralDirectoryRecord();\n  }\n  ip = this.eocdrOffset;\n\n  // signature\n  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {\n    throw new Error('invalid signature');\n  }\n\n  // number of this disk\n  this.numberOfThisDisk = input[ip++] | input[ip++] << 8;\n\n  // number of the disk with the start of the central directory\n  this.startDisk = input[ip++] | input[ip++] << 8;\n\n  // total number of entries in the central directory on this disk\n  this.totalEntriesThisDisk = input[ip++] | input[ip++] << 8;\n\n  // total number of entries in the central directory\n  this.totalEntries = input[ip++] | input[ip++] << 8;\n\n  // size of the central directory\n  this.centralDirectorySize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // offset of start of central directory with respect to the starting disk number\n  this.centralDirectoryOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;\n\n  // .ZIP file comment length\n  this.commentLength = input[ip++] | input[ip++] << 8;\n\n  // .ZIP file comment\n  this.comment = USE_TYPEDARRAY ? input.subarray(ip, ip + this.commentLength) : input.slice(ip, ip + this.commentLength);\n};\n\nZlib.Unzip.prototype.parseFileHeader = function () {\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var filelist = [];\n  /** @type {Object.<string, number>} */\n  var filetable = {};\n  /** @type {number} */\n  var ip;\n  /** @type {Zlib.Unzip.FileHeader} */\n  var fileHeader;\n  /*: @type {number} */\n  var i;\n  /*: @type {number} */\n  var il;\n\n  if (this.fileHeaderList) {\n    return;\n  }\n\n  if (this.centralDirectoryOffset === void 0) {\n    this.parseEndOfCentralDirectoryRecord();\n  }\n  ip = this.centralDirectoryOffset;\n\n  for (i = 0, il = this.totalEntries; i < il; ++i) {\n    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);\n    fileHeader.parse();\n    ip += fileHeader.length;\n    filelist[i] = fileHeader;\n    filetable[fileHeader.filename] = i;\n  }\n\n  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {\n    throw new Error('invalid file header size');\n  }\n\n  this.fileHeaderList = filelist;\n  this.filenameToIndex = filetable;\n};\n\n/**\n * @param {number} index file header index.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} file data.\n */\nZlib.Unzip.prototype.getFileData = function (index, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList = this.fileHeaderList;\n  /** @type {Zlib.Unzip.LocalFileHeader} */\n  var localFileHeader;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var length;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {number} */\n  var crc32;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  if (!fileHeaderList) {\n    this.parseFileHeader();\n  }\n\n  if (fileHeaderList[index] === void 0) {\n    throw new Error('wrong index');\n  }\n\n  offset = fileHeaderList[index].relativeOffset;\n  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);\n  localFileHeader.parse();\n  offset += localFileHeader.length;\n  length = localFileHeader.compressedSize;\n\n  // decryption\n  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {\n    if (!(opt_params['password'] || this.password)) {\n      throw new Error('please set password');\n    }\n    key = this.createDecryptionKey(opt_params['password'] || this.password);\n\n    // encryption header\n    for (i = offset, il = offset + 12; i < il; ++i) {\n      this.decode(key, input[i]);\n    }\n    offset += 12;\n    length -= 12;\n\n    // decryption\n    for (i = offset, il = offset + length; i < il; ++i) {\n      input[i] = this.decode(key, input[i]);\n    }\n  }\n\n  switch (localFileHeader.compression) {\n    case Zlib.Unzip.CompressionMethod.STORE:\n      buffer = USE_TYPEDARRAY ? this.input.subarray(offset, offset + length) : this.input.slice(offset, offset + length);\n      break;\n    case Zlib.Unzip.CompressionMethod.DEFLATE:\n      buffer = new Zlib.RawInflate(this.input, {\n        'index': offset,\n        'bufferSize': localFileHeader.plainSize\n      }).decompress();\n      break;\n    default:\n      throw new Error('unknown compression type');\n  }\n\n  if (this.verify) {\n    crc32 = Zlib.CRC32.calc(buffer);\n    if (localFileHeader.crc32 !== crc32) {\n      throw new Error('wrong crc: file=0x' + localFileHeader.crc32.toString(16) + ', data=0x' + crc32.toString(16));\n    }\n  }\n\n  return buffer;\n};\n\n/**\n * @return {Array.<string>}\n */\nZlib.Unzip.prototype.getFilenames = function () {\n  /** @type {Array.<string>} */\n  var filenameList = [];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList;\n\n  if (!this.fileHeaderList) {\n    this.parseFileHeader();\n  }\n  fileHeaderList = this.fileHeaderList;\n\n  for (i = 0, il = fileHeaderList.length; i < il; ++i) {\n    filenameList[i] = fileHeaderList[i].filename;\n  }\n\n  return filenameList;\n};\n\n/**\n * @param {string} filename extract filename.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} decompressed data.\n */\nZlib.Unzip.prototype.decompress = function (filename, opt_params) {\n  /** @type {number} */\n  var index;\n\n  if (!this.filenameToIndex) {\n    this.parseFileHeader();\n  }\n  index = this.filenameToIndex[filename];\n\n  if (index === void 0) {\n    throw new Error(filename + ' not found');\n  }\n\n  return this.getFileData(index, opt_params);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Unzip.prototype.setPassword = function (password) {\n  this.password = password;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Unzip.prototype.decode = function (key, n) {\n  n ^= this.getByte( /** @type {(Array.<number>|Uint32Array)} */key);\n  this.updateKeys( /** @type {(Array.<number>|Uint32Array)} */key, n);\n\n  return n;\n};\n\n// common method\nZlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;\nZlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;\nZlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;\n\n/**\n * @fileoverview .\n */\n\n/**\n * Byte String  Byte Array .\n * @param {!string} str byte string.\n * @return {!Array.<number>} byte array.\n */\nZlib.Util.stringToByteArray = function (str) {\n  /** @type {!Array.<(string|number)>} */\n  var tmp = str.split('');\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  for (i = 0, il = tmp.length; i < il; i++) {\n    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;\n  }\n\n  return tmp;\n};\n\n/**\n * @fileoverview Adler32 checksum .\n */\n\n/**\n * Adler32 \n * @param {!(Array|Uint8Array|string)} array  byte array.\n * @return {number} Adler32 .\n */\nZlib.Adler32 = function (array) {\n  if (typeof array === 'string') {\n    array = Zlib.Util.stringToByteArray(array);\n  }\n  return Zlib.Adler32.update(1, array);\n};\n\n/**\n * Adler32 \n * @param {number} adler .\n * @param {!(Array|Uint8Array)} array  byte array.\n * @return {number} Adler32 .\n */\nZlib.Adler32.update = function (adler, array) {\n  /** @type {number} */\n  var s1 = adler & 0xffff;\n  /** @type {number} */\n  var s2 = adler >>> 16 & 0xffff;\n  /** @type {number} array length */\n  var len = array.length;\n  /** @type {number} loop length (don't overflow) */\n  var tlen;\n  /** @type {number} array index */\n  var i = 0;\n\n  while (len > 0) {\n    tlen = len > Zlib.Adler32.OptimizationParameter ? Zlib.Adler32.OptimizationParameter : len;\n    len -= tlen;\n    do {\n      s1 += array[i++];\n      s2 += s1;\n    } while (--tlen);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16 | s1) >>> 0;\n};\n\n/**\n * Adler32 \n *  1024 .\n * @see http://jsperf.com/adler-32-simple-vs-optimized/3\n * @define {number}\n */\nZlib.Adler32.OptimizationParameter = 1024;\n\n/**\n * \n * @constructor\n * @param {!(Array|Uint8Array)=} buffer output buffer.\n * @param {number=} bufferPosition start buffer pointer.\n */\nZlib.BitStream = function (buffer, bufferPosition) {\n  /** @type {number} buffer index. */\n  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\n  /** @type {number} bit index. */\n  this.bitindex = 0;\n  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\n  this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ? buffer : new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.BitStream.DefaultBlockSize);\n\n  //  index \n  if (this.buffer.length * 2 <= this.index) {\n    throw new Error(\"invalid index\");\n  } else if (this.buffer.length <= this.index) {\n    this.expandBuffer();\n  }\n};\n\n/**\n * .\n * @const\n * @type {number}\n */\nZlib.BitStream.DefaultBlockSize = 0x8000;\n\n/**\n * expand buffer.\n * @return {!(Array|Uint8Array)} new buffer.\n */\nZlib.BitStream.prototype.expandBuffer = function () {\n  /** @type {!(Array|Uint8Array)} old buffer. */\n  var oldbuf = this.buffer;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il = oldbuf.length;\n  /** @type {!(Array|Uint8Array)} new buffer. */\n  var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\n\n  // copy buffer\n  if (USE_TYPEDARRAY) {\n    buffer.set(oldbuf);\n  } else {\n    // XXX: loop unrolling\n    for (i = 0; i < il; ++i) {\n      buffer[i] = oldbuf[i];\n    }\n  }\n\n  return this.buffer = buffer;\n};\n\n/**\n * .\n * @param {number} number .\n * @param {number} n .\n * @param {boolean=} reverse  true.\n */\nZlib.BitStream.prototype.writeBits = function (number, n, reverse) {\n  var buffer = this.buffer;\n  var index = this.index;\n  var bitindex = this.bitindex;\n\n  /** @type {number} current octet. */\n  var current = buffer[index];\n  /** @type {number} loop counter. */\n  var i;\n\n  /**\n   * 32-bit \n   * @param {number} n 32-bit integer.\n   * @return {number} reversed 32-bit integer.\n   * @private\n   */\n  function rev32_(n) {\n    return Zlib.BitStream.ReverseTable[n & 0xFF] << 24 | Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16 | Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8 | Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];\n  }\n\n  if (reverse && n > 1) {\n    number = n > 8 ? rev32_(number) >> 32 - n : Zlib.BitStream.ReverseTable[number] >> 8 - n;\n  }\n\n  // Byte \n  if (n + bitindex < 8) {\n    current = current << n | number;\n    bitindex += n;\n    // Byte \n  } else {\n    for (i = 0; i < n; ++i) {\n      current = current << 1 | number >> n - i - 1 & 1;\n\n      // next byte\n      if (++bitindex === 8) {\n        bitindex = 0;\n        buffer[index++] = Zlib.BitStream.ReverseTable[current];\n        current = 0;\n\n        // expand\n        if (index === buffer.length) {\n          buffer = this.expandBuffer();\n        }\n      }\n    }\n  }\n  buffer[index] = current;\n\n  this.buffer = buffer;\n  this.bitindex = bitindex;\n  this.index = index;\n};\n\n/**\n * \n * @return {!(Array|Uint8Array)}  byte array .\n */\nZlib.BitStream.prototype.finish = function () {\n  var buffer = this.buffer;\n  var index = this.index;\n\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output;\n\n  // bitindex  0  index \n  if (this.bitindex > 0) {\n    buffer[index] <<= 8 - this.bitindex;\n    buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];\n    index++;\n  }\n\n  // array truncation\n  if (USE_TYPEDARRAY) {\n    output = buffer.subarray(0, index);\n  } else {\n    buffer.length = index;\n    output = buffer;\n  }\n\n  return output;\n};\n\n/**\n * 0-255 \n * @const\n * @type {!(Uint8Array|Array.<number>)}\n */\nZlib.BitStream.ReverseTable = function (table) {\n  return table;\n}(function () {\n  /** @type {!(Array|Uint8Array)} reverse table. */\n  var table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\n  /** @type {number} loop counter. */\n  var i;\n\n  // generate\n  for (i = 0; i < 256; ++i) {\n    table[i] = function (n) {\n      var r = n;\n      var s = 7;\n\n      for (n >>>= 1; n; n >>>= 1) {\n        r <<= 1;\n        r |= n & 1;\n        --s;\n      }\n\n      return (r << s & 0xff) >>> 0;\n    }(i);\n  }\n\n  return table;\n}());\n\n/**\n * @fileoverview CRC32 .\n */\n\n/** @define {boolean} */\nvar ZLIB_CRC32_COMPACT = false;\n\n/**\n * CRC32 \n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.calc = function (data, pos, length) {\n  return Zlib.CRC32.update(data, 0, pos, length);\n};\n\n/**\n * CRC32\n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number} crc CRC32.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.update = function (data, crc, pos, length) {\n  var table = Zlib.CRC32.Table;\n  var i = typeof pos === 'number' ? pos : pos = 0;\n  var il = typeof length === 'number' ? length : data.length;\n\n  crc ^= 0xffffffff;\n\n  // loop unrolling for performance\n  for (i = il & 7; i--; ++pos) {\n    crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];\n  }\n  for (i = il >> 3; i--; pos += 8) {\n    crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 1]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 2]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 3]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 4]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 5]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 6]) & 0xff];\n    crc = crc >>> 8 ^ table[(crc ^ data[pos + 7]) & 0xff];\n  }\n\n  return (crc ^ 0xffffffff) >>> 0;\n};\n\n/**\n * @param {number} num\n * @param {number} crc\n * @returns {number}\n */\nZlib.CRC32.single = function (num, crc) {\n  return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ num >>> 8) >>> 0;\n};\n\n/**\n * @type {Array.<number>}\n * @const\n * @private\n */\nZlib.CRC32.Table_ = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];\n\n/**\n * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.\n * @const\n */\nZlib.CRC32.Table = ZLIB_CRC32_COMPACT ? function () {\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var table = new (USE_TYPEDARRAY ? Uint32Array : Array)(256);\n  /** @type {number} */\n  var c;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var j;\n\n  for (i = 0; i < 256; ++i) {\n    c = i;\n    for (j = 0; j < 8; ++j) {\n      c = c & 1 ? 0xedB88320 ^ c >>> 1 : c >>> 1;\n    }\n    table[i] = c >>> 0;\n  }\n\n  return table;\n}() : USE_TYPEDARRAY ? new Uint32Array(Zlib.CRC32.Table_) : Zlib.CRC32.Table_;\n\n/**\n * @fileoverview Deflate (RFC1951) .\n * Deflate Zlib.RawDeflate .\n */\n\n/**\n * Zlib Deflate\n * @constructor\n * @param {!(Array|Uint8Array)} input  byte array.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Deflate = function (input, opt_params) {\n  /** @type {!(Array|Uint8Array)} */\n  this.input = input;\n  /** @type {!(Array|Uint8Array)} */\n  this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.Deflate.DefaultBufferSize);\n  /** @type {Zlib.Deflate.CompressionType} */\n  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;\n  /** @type {Zlib.RawDeflate} */\n  this.rawDeflate;\n  /** @type {Object} */\n  var rawDeflateOption = {};\n  /** @type {string} */\n  var prop;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n  }\n\n  // copy options\n  for (prop in opt_params) {\n    rawDeflateOption[prop] = opt_params[prop];\n  }\n\n  // set raw-deflate output buffer\n  rawDeflateOption['outputBuffer'] = this.output;\n\n  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);\n};\n\n/**\n * @const\n * @type {number} .\n */\nZlib.Deflate.DefaultBufferSize = 0x8000;\n\n/**\n * @enum {number}\n */\nZlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;\n\n/**\n * .\n * @param {!(Array|Uint8Array)} input target buffer.\n * @param {Object=} opt_params option parameters.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.compress = function (input, opt_params) {\n  return new Zlib.Deflate(input, opt_params).compress();\n};\n\n/**\n * Deflate Compression.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.prototype.compress = function () {\n  /** @type {Zlib.CompressionMethod} */\n  var cm;\n  /** @type {number} */\n  var cinfo;\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n  /** @type {number} */\n  var fcheck;\n  /** @type {number} */\n  var fdict;\n  /** @type {number} */\n  var flevel;\n  /** @type {number} */\n  var clevel;\n  /** @type {number} */\n  var adler;\n  /** @type {boolean} */\n  var error = false;\n  /** @type {!(Array|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var pos = 0;\n\n  output = this.output;\n\n  // Compression Method and Flags\n  cm = Zlib.CompressionMethod.DEFLATE;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  cmf = cinfo << 4 | cm;\n  output[pos++] = cmf;\n\n  // Flags\n  fdict = 0;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      switch (this.compressionType) {\n        case Zlib.Deflate.CompressionType.NONE:\n          flevel = 0;break;\n        case Zlib.Deflate.CompressionType.FIXED:\n          flevel = 1;break;\n        case Zlib.Deflate.CompressionType.DYNAMIC:\n          flevel = 2;break;\n        default:\n          throw new Error('unsupported compression type');\n      }\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  flg = flevel << 6 | fdict << 5;\n  fcheck = 31 - (cmf * 256 + flg) % 31;\n  flg |= fcheck;\n  output[pos++] = flg;\n\n  // Adler-32 checksum\n  adler = Zlib.Adler32(this.input);\n\n  this.rawDeflate.op = pos;\n  output = this.rawDeflate.compress();\n  pos = output.length;\n\n  if (USE_TYPEDARRAY) {\n    // subarray \n    output = new Uint8Array(output.buffer);\n    // expand buffer\n    if (output.length <= pos + 4) {\n      this.output = new Uint8Array(output.length + 4);\n      this.output.set(output);\n      output = this.output;\n    }\n    output = output.subarray(0, pos + 4);\n  }\n\n  // adler32\n  output[pos++] = adler >> 24 & 0xff;\n  output[pos++] = adler >> 16 & 0xff;\n  output[pos++] = adler >> 8 & 0xff;\n  output[pos++] = adler & 0xff;\n\n  return output;\n};\n\nexports.Zlib = Zlib;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vTUxWUGFuZWwvc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL01MVlBhbmVsL3NyYy92ZW5kb3IvemxpYl9hbmRfZ3ppcC5qcz80MDhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBabGliIG5hbWVzcGFjZS4gWmxpYiDjga7ku5Xmp5jjgavmupbmi6DjgZfjgZ/lnKfnuK7jga8gWmxpYi5EZWZsYXRlIOOBp+Wun+ijhVxuICog44GV44KM44Gm44GE44KLLiDjgZPjgozjga8gSW5mbGF0ZSDjgajjga7lhbHlrZjjgpLogIPmha7jgZfjgabjgYTjgovngrouXG4gKi9cblxudmFyIFVTRV9UWVBFREFSUkFZID0gdHJ1ZTtcbmNvbnN0IFpMSUJfU1RSRUFNX1JBV19JTkZMQVRFX0JVRkZFUl9TSVpFID0gNjUwMDA7XG5cbnZhciBabGliID0ge1xuICBIdWZmbWFuOiB7fSxcbiAgVXRpbDoge30sXG4gIENSQzMyOiB7fVxufTtcblxuXG4vKipcbiAqIENvbXByZXNzaW9uIE1ldGhvZFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuWmxpYi5Db21wcmVzc2lvbk1ldGhvZCA9IHtcbiAgREVGTEFURTogOCxcbiAgUkVTRVJWRUQ6IDE1XG59O1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblpsaWIuWmlwID0gZnVuY3Rpb24ob3B0X3BhcmFtcykge1xuICBvcHRfcGFyYW1zID0gb3B0X3BhcmFtcyB8fCB7fTtcbiAgLyoqIEB0eXBlIHtBcnJheS48e1xuICAgKiAgIGJ1ZmZlcjogIShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KSxcbiAgICogICBvcHRpb246IE9iamVjdCxcbiAgICogICBjb21wcmVzc2VkOiBib29sZWFuLFxuICAgKiAgIGVuY3J5cHRlZDogYm9vbGVhbixcbiAgICogICBzaXplOiBudW1iZXIsXG4gICAqICAgY3JjMzI6IG51bWJlclxuICAgKiB9Pn0gKi9cbiAgdGhpcy5maWxlcyA9IFtdO1xuICAvKiogQHR5cGUgeyhBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdGhpcy5jb21tZW50ID0gb3B0X3BhcmFtc1snY29tbWVudCddO1xuICAvKiogQHR5cGUgeyhBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdGhpcy5wYXNzd29yZDtcbn07XG5cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5abGliLlppcC5Db21wcmVzc2lvbk1ldGhvZCA9IHtcbiAgU1RPUkU6IDAsXG4gIERFRkxBVEU6IDhcbn07XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuWmxpYi5aaXAuT3BlcmF0aW5nU3lzdGVtID0ge1xuICBNU0RPUzogMCxcbiAgVU5JWDogMyxcbiAgTUFDSU5UT1NIOiA3XG59O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblpsaWIuWmlwLkZsYWdzID0ge1xuICBFTkNSWVBUOiAgICAweDAwMDEsXG4gIERFU0NSSVBUT1I6IDB4MDAwOCxcbiAgVVRGODogICAgICAgMHgwODAwXG59O1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqIEBjb25zdFxuICovXG5abGliLlppcC5GaWxlSGVhZGVyU2lnbmF0dXJlID0gWzB4NTAsIDB4NGIsIDB4MDEsIDB4MDJdO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqIEBjb25zdFxuICovXG5abGliLlppcC5Mb2NhbEZpbGVIZWFkZXJTaWduYXR1cmUgPSBbMHg1MCwgMHg0YiwgMHgwMywgMHgwNF07XG5cbi8qKlxuICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICogQGNvbnN0XG4gKi9cblpsaWIuWmlwLkNlbnRyYWxEaXJlY3RvcnlTaWduYXR1cmUgPSBbMHg1MCwgMHg0YiwgMHgwNSwgMHgwNl07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxVaW50OEFycmF5fSBpbnB1dFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIG9wdGlvbnMuXG4gKi9cblpsaWIuWmlwLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24oaW5wdXQsIG9wdF9wYXJhbXMpIHtcbiAgb3B0X3BhcmFtcyA9IG9wdF9wYXJhbXMgfHwge307XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgZmlsZW5hbWUgPSAnJyB8fCBvcHRfcGFyYW1zWydmaWxlbmFtZSddO1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHZhciBjb21wcmVzc2VkO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHNpemUgPSBpbnB1dC5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgY3JjMzIgPSAwO1xuXG4gIGlmIChVU0VfVFlQRURBUlJBWSAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gIH1cblxuICAvLyBkZWZhdWx0XG4gIGlmICh0eXBlb2Ygb3B0X3BhcmFtc1snY29tcHJlc3Npb25NZXRob2QnXSAhPT0gJ251bWJlcicpIHtcbiAgICBvcHRfcGFyYW1zWydjb21wcmVzc2lvbk1ldGhvZCddID0gWmxpYi5aaXAuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURTtcbiAgfVxuXG4gIC8vIOOBneOBruWgtOOBp+Wcp+e4ruOBmeOCi+WgtOWQiFxuICBpZiAob3B0X3BhcmFtc1snY29tcHJlc3MnXSkge1xuICAgIHN3aXRjaCAob3B0X3BhcmFtc1snY29tcHJlc3Npb25NZXRob2QnXSkge1xuICAgICAgY2FzZSBabGliLlppcC5Db21wcmVzc2lvbk1ldGhvZC5TVE9SRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFpsaWIuWmlwLkNvbXByZXNzaW9uTWV0aG9kLkRFRkxBVEU6XG4gICAgICAgIGNyYzMyID0gWmxpYi5DUkMzMi5jYWxjKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSB0aGlzLmRlZmxhdGVXaXRoT3B0aW9uKGlucHV0LCBvcHRfcGFyYW1zKTtcbiAgICAgICAgY29tcHJlc3NlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZDonICsgb3B0X3BhcmFtc1snY29tcHJlc3Npb25NZXRob2QnXSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5maWxlcy5wdXNoKHtcbiAgICBidWZmZXI6IGlucHV0LFxuICAgIG9wdGlvbjogb3B0X3BhcmFtcyxcbiAgICBjb21wcmVzc2VkOiBjb21wcmVzc2VkLFxuICAgIGVuY3J5cHRlZDogZmFsc2UsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBjcmMzMjogY3JjMzJcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7KEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBwYXNzd29yZFxuICovXG5abGliLlppcC5wcm90b3R5cGUuc2V0UGFzc3dvcmQgPSBmdW5jdGlvbihwYXNzd29yZCkge1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG59O1xuXG5abGliLlppcC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48e1xuICAgKiAgIGJ1ZmZlcjogIShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KSxcbiAgICogICBvcHRpb246IE9iamVjdCxcbiAgICogICBjb21wcmVzc2VkOiBib29sZWFuLFxuICAgKiAgIGVuY3J5cHRlZDogYm9vbGVhbixcbiAgICogICBzaXplOiBudW1iZXIsXG4gICAqICAgY3JjMzI6IG51bWJlclxuICAgKiB9Pn0gKi9cbiAgdmFyIGZpbGVzID0gdGhpcy5maWxlcztcbiAgLyoqIEB0eXBlIHt7XG4gICAqICAgYnVmZmVyOiAhKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpLFxuICAgKiAgIG9wdGlvbjogT2JqZWN0LFxuICAgKiAgIGNvbXByZXNzZWQ6IGJvb2xlYW4sXG4gICAqICAgZW5jcnlwdGVkOiBib29sZWFuLFxuICAgKiAgIHNpemU6IG51bWJlcixcbiAgICogICBjcmMzMjogbnVtYmVyXG4gICAqIH19ICovXG4gIHZhciBmaWxlO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBvdXRwdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgb3AxO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIG9wMjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBvcDM7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgbG9jYWxGaWxlU2l6ZSA9IDA7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgY2VudHJhbERpcmVjdG9yeVNpemUgPSAwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGVuZE9mQ2VudHJhbERpcmVjdG9yeVNpemU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgb2Zmc2V0O1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIG5lZWRWZXJzaW9uO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGZsYWdzO1xuICAvKiogQHR5cGUge1psaWIuWmlwLkNvbXByZXNzaW9uTWV0aG9kfSAqL1xuICB2YXIgY29tcHJlc3Npb25NZXRob2Q7XG4gIC8qKiBAdHlwZSB7RGF0ZX0gKi9cbiAgdmFyIGRhdGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgY3JjMzI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgc2l6ZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBwbGFpblNpemU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgZmlsZW5hbWVMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgZXh0cmFGaWVsZExlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBjb21tZW50TGVuZ3RoO1xuICAvKiogQHR5cGUgeyhBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdmFyIGZpbGVuYW1lO1xuICAvKiogQHR5cGUgeyhBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdmFyIGV4dHJhRmllbGQ7XG4gIC8qKiBAdHlwZSB7KEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgY29tbWVudDtcbiAgLyoqIEB0eXBlIHsoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBidWZmZXI7XG4gIC8qKiBAdHlwZSB7Kn0gKi9cbiAgdmFyIHRtcDtcbiAgLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPnxVaW50MzJBcnJheXxPYmplY3R9ICovXG4gIHZhciBrZXk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpbDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBqO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGpsO1xuXG4gIC8vIOODleOCoeOCpOODq+OBruWcp+e4rlxuICBmb3IgKGkgPSAwLCBpbCA9IGZpbGVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICBmaWxlID0gZmlsZXNbaV07XG4gICAgZmlsZW5hbWVMZW5ndGggPVxuICAgICAgICAoZmlsZS5vcHRpb25bJ2ZpbGVuYW1lJ10pID8gZmlsZS5vcHRpb25bJ2ZpbGVuYW1lJ10ubGVuZ3RoIDogMDtcbiAgICBleHRyYUZpZWxkTGVuZ3RoID1cbiAgICAgICAgKGZpbGUub3B0aW9uWydleHRyYUZpZWxkJ10pID8gZmlsZS5vcHRpb25bJ2V4dHJhRmllbGQnXS5sZW5ndGggOiAwO1xuICAgIGNvbW1lbnRMZW5ndGggPVxuICAgICAgICAoZmlsZS5vcHRpb25bJ2NvbW1lbnQnXSkgPyBmaWxlLm9wdGlvblsnY29tbWVudCddLmxlbmd0aCA6IDA7XG5cbiAgICAvLyDlnKfnuK7jgZXjgozjgabjgYTjgarjgYvjgaPjgZ/jgonlnKfnuK5cbiAgICBpZiAoIWZpbGUuY29tcHJlc3NlZCkge1xuICAgICAgLy8g5Zyn57iu5YmN44GrIENSQzMyIOOBruioiOeul+OCkuOBl+OBpuOBiuOBj1xuICAgICAgZmlsZS5jcmMzMiA9IFpsaWIuQ1JDMzIuY2FsYyhmaWxlLmJ1ZmZlcik7XG5cbiAgICAgIHN3aXRjaCAoZmlsZS5vcHRpb25bJ2NvbXByZXNzaW9uTWV0aG9kJ10pIHtcbiAgICAgICAgY2FzZSBabGliLlppcC5Db21wcmVzc2lvbk1ldGhvZC5TVE9SRTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBabGliLlppcC5Db21wcmVzc2lvbk1ldGhvZC5ERUZMQVRFOlxuICAgICAgICAgIGZpbGUuYnVmZmVyID0gdGhpcy5kZWZsYXRlV2l0aE9wdGlvbihmaWxlLmJ1ZmZlciwgZmlsZS5vcHRpb24pO1xuICAgICAgICAgIGZpbGUuY29tcHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZDonICsgZmlsZS5vcHRpb25bJ2NvbXByZXNzaW9uTWV0aG9kJ10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVuY3J5cHRpb25cbiAgICBpZiAoZmlsZS5vcHRpb25bJ3Bhc3N3b3JkJ10gIT09IHZvaWQgMHx8IHRoaXMucGFzc3dvcmQgIT09IHZvaWQgMCkge1xuICAgICAgLy8gaW5pdCBlbmNyeXB0aW9uXG4gICAgICBrZXkgPSB0aGlzLmNyZWF0ZUVuY3J5cHRpb25LZXkoZmlsZS5vcHRpb25bJ3Bhc3N3b3JkJ10gfHwgdGhpcy5wYXNzd29yZCk7XG5cbiAgICAgIC8vIGFkZCBoZWFkZXJcbiAgICAgIGJ1ZmZlciA9IGZpbGUuYnVmZmVyO1xuICAgICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICAgIHRtcCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyAxMik7XG4gICAgICAgIHRtcC5zZXQoYnVmZmVyLCAxMik7XG4gICAgICAgIGJ1ZmZlciA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci51bnNoaWZ0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgMTI7ICsraikge1xuICAgICAgICBidWZmZXJbal0gPSB0aGlzLmVuY29kZShcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGkgPT09IDExID8gKGZpbGUuY3JjMzIgJiAweGZmKSA6IChNYXRoLnJhbmRvbSgpICogMjU2IHwgMClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0YSBlbmNyeXB0aW9uXG4gICAgICBmb3IgKGpsID0gYnVmZmVyLmxlbmd0aDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgYnVmZmVyW2pdID0gdGhpcy5lbmNvZGUoa2V5LCBidWZmZXJbal0pO1xuICAgICAgfVxuICAgICAgZmlsZS5idWZmZXIgPSBidWZmZXI7XG4gICAgfVxuXG4gICAgLy8g5b+F6KaB44OQ44OD44OV44Kh44K144Kk44K644Gu6KiI566XXG4gICAgbG9jYWxGaWxlU2l6ZSArPVxuICAgICAgICAvLyBsb2NhbCBmaWxlIGhlYWRlclxuICAgICAgICAzMCArIGZpbGVuYW1lTGVuZ3RoICtcbiAgICAgICAgLy8gZmlsZSBkYXRhXG4gICAgICAgIGZpbGUuYnVmZmVyLmxlbmd0aDtcblxuICAgIGNlbnRyYWxEaXJlY3RvcnlTaXplICs9XG4gICAgICAgIC8vIGZpbGUgaGVhZGVyXG4gICAgICAgIDQ2ICsgZmlsZW5hbWVMZW5ndGggKyBjb21tZW50TGVuZ3RoO1xuICB9XG5cbiAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gIGVuZE9mQ2VudHJhbERpcmVjdG9yeVNpemUgPSAyMiArICh0aGlzLmNvbW1lbnQgPyB0aGlzLmNvbW1lbnQubGVuZ3RoIDogMCk7XG4gIG91dHB1dCA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKFxuICAgICAgbG9jYWxGaWxlU2l6ZSArIGNlbnRyYWxEaXJlY3RvcnlTaXplICsgZW5kT2ZDZW50cmFsRGlyZWN0b3J5U2l6ZVxuICApO1xuICBvcDEgPSAwO1xuICBvcDIgPSBsb2NhbEZpbGVTaXplO1xuICBvcDMgPSBvcDIgKyBjZW50cmFsRGlyZWN0b3J5U2l6ZTtcblxuICAvLyDjg5XjgqHjgqTjg6vjga7lnKfnuK5cbiAgZm9yIChpID0gMCwgaWwgPSBmaWxlcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgZmlsZSA9IGZpbGVzW2ldO1xuICAgIGZpbGVuYW1lTGVuZ3RoID1cbiAgICAgICAgZmlsZS5vcHRpb25bJ2ZpbGVuYW1lJ10gPyBmaWxlLm9wdGlvblsnZmlsZW5hbWUnXS5sZW5ndGggOiAgMDtcbiAgICBleHRyYUZpZWxkTGVuZ3RoID0gMDsgLy8gVE9ET1xuICAgIGNvbW1lbnRMZW5ndGggPVxuICAgICAgICBmaWxlLm9wdGlvblsnY29tbWVudCddID8gZmlsZS5vcHRpb25bJ2NvbW1lbnQnXS5sZW5ndGggOiAwO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbG9jYWwgZmlsZSBoZWFkZXIgJiBmaWxlIGhlYWRlclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgb2Zmc2V0ID0gb3AxO1xuXG4gICAgLy8gc2lnbmF0dXJlXG4gICAgLy8gbG9jYWwgZmlsZSBoZWFkZXJcbiAgICBvdXRwdXRbb3AxKytdID0gWmxpYi5aaXAuTG9jYWxGaWxlSGVhZGVyU2lnbmF0dXJlWzBdO1xuICAgIG91dHB1dFtvcDErK10gPSBabGliLlppcC5Mb2NhbEZpbGVIZWFkZXJTaWduYXR1cmVbMV07XG4gICAgb3V0cHV0W29wMSsrXSA9IFpsaWIuWmlwLkxvY2FsRmlsZUhlYWRlclNpZ25hdHVyZVsyXTtcbiAgICBvdXRwdXRbb3AxKytdID0gWmxpYi5aaXAuTG9jYWxGaWxlSGVhZGVyU2lnbmF0dXJlWzNdO1xuICAgIC8vIGZpbGUgaGVhZGVyXG4gICAgb3V0cHV0W29wMisrXSA9IFpsaWIuWmlwLkZpbGVIZWFkZXJTaWduYXR1cmVbMF07XG4gICAgb3V0cHV0W29wMisrXSA9IFpsaWIuWmlwLkZpbGVIZWFkZXJTaWduYXR1cmVbMV07XG4gICAgb3V0cHV0W29wMisrXSA9IFpsaWIuWmlwLkZpbGVIZWFkZXJTaWduYXR1cmVbMl07XG4gICAgb3V0cHV0W29wMisrXSA9IFpsaWIuWmlwLkZpbGVIZWFkZXJTaWduYXR1cmVbM107XG5cbiAgICAvLyBjb21wcmVzc29yIGluZm9cbiAgICBuZWVkVmVyc2lvbiA9IDIwO1xuICAgIG91dHB1dFtvcDIrK10gPSBuZWVkVmVyc2lvbiAmIDB4ZmY7XG4gICAgb3V0cHV0W29wMisrXSA9XG4gICAgICAgIC8qKiBAdHlwZSB7WmxpYi5aaXAuT3BlcmF0aW5nU3lzdGVtfSAqL1xuICAgICAgICAoZmlsZS5vcHRpb25bJ29zJ10pIHx8XG4gICAgICAgIFpsaWIuWmlwLk9wZXJhdGluZ1N5c3RlbS5NU0RPUztcblxuICAgIC8vIG5lZWQgdmVyc2lvblxuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gIG5lZWRWZXJzaW9uICAgICAgICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChuZWVkVmVyc2lvbiA+PiA4KSAmIDB4ZmY7XG5cbiAgICAvLyBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICBmbGFncyA9IDA7XG4gICAgaWYgKGZpbGUub3B0aW9uWydwYXNzd29yZCddIHx8IHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIGZsYWdzIHw9IFpsaWIuWmlwLkZsYWdzLkVOQ1JZUFQ7XG4gICAgfVxuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gIGZsYWdzICAgICAgICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChmbGFncyA+PiA4KSAmIDB4ZmY7XG5cbiAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBjb21wcmVzc2lvbk1ldGhvZCA9XG4gICAgICAgIC8qKiBAdHlwZSB7WmxpYi5aaXAuQ29tcHJlc3Npb25NZXRob2R9ICovXG4gICAgICAgIChmaWxlLm9wdGlvblsnY29tcHJlc3Npb25NZXRob2QnXSk7XG4gICAgb3V0cHV0W29wMSsrXSA9IG91dHB1dFtvcDIrK10gPSAgY29tcHJlc3Npb25NZXRob2QgICAgICAgJiAweGZmO1xuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gKGNvbXByZXNzaW9uTWV0aG9kID4+IDgpICYgMHhmZjtcblxuICAgIC8vIGRhdGVcbiAgICBkYXRlID0gLyoqIEB0eXBlIHsoRGF0ZXx1bmRlZmluZWQpfSAqLyhmaWxlLm9wdGlvblsnZGF0ZSddKSB8fCBuZXcgRGF0ZSgpO1xuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID1cbiAgICAgICAgKChkYXRlLmdldE1pbnV0ZXMoKSAmIDB4NykgPDwgNSkgfFxuICAgICAgICAoZGF0ZS5nZXRTZWNvbmRzKCkgLyAyIHwgMCk7XG4gICAgb3V0cHV0W29wMSsrXSA9IG91dHB1dFtvcDIrK10gPVxuICAgICAgICAoZGF0ZS5nZXRIb3VycygpICAgPDwgMykgfFxuICAgICAgICAoZGF0ZS5nZXRNaW51dGVzKCkgPj4gMyk7XG4gICAgLy9cbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9XG4gICAgICAgICgoZGF0ZS5nZXRNb250aCgpICsgMSAmIDB4NykgPDwgNSkgfFxuICAgICAgICAoZGF0ZS5nZXREYXRlKCkpO1xuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID1cbiAgICAgICAgKChkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTgwICYgMHg3ZikgPDwgMSkgfFxuICAgICAgICAoZGF0ZS5nZXRNb250aCgpICsgMSA+PiAzKTtcblxuICAgIC8vIENSQy0zMlxuICAgIGNyYzMyID0gZmlsZS5jcmMzMjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9ICBjcmMzMiAgICAgICAgJiAweGZmO1xuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gKGNyYzMyID4+ICA4KSAmIDB4ZmY7XG4gICAgb3V0cHV0W29wMSsrXSA9IG91dHB1dFtvcDIrK10gPSAoY3JjMzIgPj4gMTYpICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChjcmMzMiA+PiAyNCkgJiAweGZmO1xuXG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgc2l6ZSA9IGZpbGUuYnVmZmVyLmxlbmd0aDtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9ICBzaXplICAgICAgICAmIDB4ZmY7XG4gICAgb3V0cHV0W29wMSsrXSA9IG91dHB1dFtvcDIrK10gPSAoc2l6ZSA+PiAgOCkgJiAweGZmO1xuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG5cbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIHBsYWluU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9ICBwbGFpblNpemUgICAgICAgICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChwbGFpblNpemUgPj4gIDgpICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChwbGFpblNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChwbGFpblNpemUgPj4gMjQpICYgMHhmZjtcblxuICAgIC8vIGZpbGVuYW1lIGxlbmd0aFxuICAgIG91dHB1dFtvcDErK10gPSBvdXRwdXRbb3AyKytdID0gIGZpbGVuYW1lTGVuZ3RoICAgICAgICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChmaWxlbmFtZUxlbmd0aCA+PiA4KSAmIDB4ZmY7XG5cbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9ICBleHRyYUZpZWxkTGVuZ3RoICAgICAgICYgMHhmZjtcbiAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IChleHRyYUZpZWxkTGVuZ3RoID4+IDgpICYgMHhmZjtcblxuICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICBvdXRwdXRbb3AyKytdID0gIGNvbW1lbnRMZW5ndGggICAgICAgJiAweGZmO1xuICAgIG91dHB1dFtvcDIrK10gPSAoY29tbWVudExlbmd0aCA+PiA4KSAmIDB4ZmY7XG5cbiAgICAvLyBkaXNrIG51bWJlciBzdGFydFxuICAgIG91dHB1dFtvcDIrK10gPSAwO1xuICAgIG91dHB1dFtvcDIrK10gPSAwO1xuXG4gICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgb3V0cHV0W29wMisrXSA9IDA7XG4gICAgb3V0cHV0W29wMisrXSA9IDA7XG5cbiAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICBvdXRwdXRbb3AyKytdID0gMDtcbiAgICBvdXRwdXRbb3AyKytdID0gMDtcbiAgICBvdXRwdXRbb3AyKytdID0gMDtcbiAgICBvdXRwdXRbb3AyKytdID0gMDtcblxuICAgIC8vIHJlbGF0aXZlIG9mZnNldCBvZiBsb2NhbCBoZWFkZXJcbiAgICBvdXRwdXRbb3AyKytdID0gIG9mZnNldCAgICAgICAgJiAweGZmO1xuICAgIG91dHB1dFtvcDIrK10gPSAob2Zmc2V0ID4+ICA4KSAmIDB4ZmY7XG4gICAgb3V0cHV0W29wMisrXSA9IChvZmZzZXQgPj4gMTYpICYgMHhmZjtcbiAgICBvdXRwdXRbb3AyKytdID0gKG9mZnNldCA+PiAyNCkgJiAweGZmO1xuXG4gICAgLy8gZmlsZW5hbWVcbiAgICBmaWxlbmFtZSA9IGZpbGUub3B0aW9uWydmaWxlbmFtZSddO1xuICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICAgIG91dHB1dC5zZXQoZmlsZW5hbWUsIG9wMSk7XG4gICAgICAgIG91dHB1dC5zZXQoZmlsZW5hbWUsIG9wMik7XG4gICAgICAgIG9wMSArPSBmaWxlbmFtZUxlbmd0aDtcbiAgICAgICAgb3AyICs9IGZpbGVuYW1lTGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGZpbGVuYW1lTGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBvdXRwdXRbb3AxKytdID0gb3V0cHV0W29wMisrXSA9IGZpbGVuYW1lW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXh0cmEgZmllbGRcbiAgICBleHRyYUZpZWxkID0gZmlsZS5vcHRpb25bJ2V4dHJhRmllbGQnXTtcbiAgICBpZiAoZXh0cmFGaWVsZCkge1xuICAgICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICAgIG91dHB1dC5zZXQoZXh0cmFGaWVsZCwgb3AxKTtcbiAgICAgICAgb3V0cHV0LnNldChleHRyYUZpZWxkLCBvcDIpO1xuICAgICAgICBvcDEgKz0gZXh0cmFGaWVsZExlbmd0aDtcbiAgICAgICAgb3AyICs9IGV4dHJhRmllbGRMZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29tbWVudExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgb3V0cHV0W29wMSsrXSA9IG91dHB1dFtvcDIrK10gPSBleHRyYUZpZWxkW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tbWVudFxuICAgIGNvbW1lbnQgPSBmaWxlLm9wdGlvblsnY29tbWVudCddO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICAgICAgb3V0cHV0LnNldChjb21tZW50LCBvcDIpO1xuICAgICAgICBvcDIgKz0gY29tbWVudExlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb21tZW50TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBvdXRwdXRbb3AyKytdID0gY29tbWVudFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGZpbGUgZGF0YVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICBvdXRwdXQuc2V0KGZpbGUuYnVmZmVyLCBvcDEpO1xuICAgICAgb3AxICs9IGZpbGUuYnVmZmVyLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqID0gMCwgamwgPSBmaWxlLmJ1ZmZlci5sZW5ndGg7IGogPCBqbDsgKytqKSB7XG4gICAgICAgIG91dHB1dFtvcDErK10gPSBmaWxlLmJ1ZmZlcltqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIHNpZ25hdHVyZVxuICBvdXRwdXRbb3AzKytdID0gWmxpYi5aaXAuQ2VudHJhbERpcmVjdG9yeVNpZ25hdHVyZVswXTtcbiAgb3V0cHV0W29wMysrXSA9IFpsaWIuWmlwLkNlbnRyYWxEaXJlY3RvcnlTaWduYXR1cmVbMV07XG4gIG91dHB1dFtvcDMrK10gPSBabGliLlppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzJdO1xuICBvdXRwdXRbb3AzKytdID0gWmxpYi5aaXAuQ2VudHJhbERpcmVjdG9yeVNpZ25hdHVyZVszXTtcblxuICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gIG91dHB1dFtvcDMrK10gPSAwO1xuICBvdXRwdXRbb3AzKytdID0gMDtcblxuICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gIG91dHB1dFtvcDMrK10gPSAwO1xuICBvdXRwdXRbb3AzKytdID0gMDtcblxuICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3Rvcnkgb24gdGhpcyBkaXNrXG4gIG91dHB1dFtvcDMrK10gPSAgaWwgICAgICAgJiAweGZmO1xuICBvdXRwdXRbb3AzKytdID0gKGlsID4+IDgpICYgMHhmZjtcblxuICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgb3V0cHV0W29wMysrXSA9ICBpbCAgICAgICAmIDB4ZmY7XG4gIG91dHB1dFtvcDMrK10gPSAoaWwgPj4gOCkgJiAweGZmO1xuXG4gIC8vIHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gIG91dHB1dFtvcDMrK10gPSAgY2VudHJhbERpcmVjdG9yeVNpemUgICAgICAgICYgMHhmZjtcbiAgb3V0cHV0W29wMysrXSA9IChjZW50cmFsRGlyZWN0b3J5U2l6ZSA+PiAgOCkgJiAweGZmO1xuICBvdXRwdXRbb3AzKytdID0gKGNlbnRyYWxEaXJlY3RvcnlTaXplID4+IDE2KSAmIDB4ZmY7XG4gIG91dHB1dFtvcDMrK10gPSAoY2VudHJhbERpcmVjdG9yeVNpemUgPj4gMjQpICYgMHhmZjtcblxuICAvLyBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlclxuICBvdXRwdXRbb3AzKytdID0gIGxvY2FsRmlsZVNpemUgICAgICAgICYgMHhmZjtcbiAgb3V0cHV0W29wMysrXSA9IChsb2NhbEZpbGVTaXplID4+ICA4KSAmIDB4ZmY7XG4gIG91dHB1dFtvcDMrK10gPSAobG9jYWxGaWxlU2l6ZSA+PiAxNikgJiAweGZmO1xuICBvdXRwdXRbb3AzKytdID0gKGxvY2FsRmlsZVNpemUgPj4gMjQpICYgMHhmZjtcblxuICAvLyAuWklQIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgY29tbWVudExlbmd0aCA9IHRoaXMuY29tbWVudCA/IHRoaXMuY29tbWVudC5sZW5ndGggOiAwO1xuICBvdXRwdXRbb3AzKytdID0gIGNvbW1lbnRMZW5ndGggICAgICAgJiAweGZmO1xuICBvdXRwdXRbb3AzKytdID0gKGNvbW1lbnRMZW5ndGggPj4gOCkgJiAweGZmO1xuXG4gIC8vIC5aSVAgZmlsZSBjb21tZW50XG4gIGlmICh0aGlzLmNvbW1lbnQpIHtcbiAgICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICAgIG91dHB1dC5zZXQodGhpcy5jb21tZW50LCBvcDMpO1xuICAgICAgb3AzICs9IGNvbW1lbnRMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsID0gY29tbWVudExlbmd0aDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgb3V0cHV0W29wMysrXSA9IHRoaXMuY29tbWVudFtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9wYXJhbXMgb3B0aW9ucy5cbiAqIEByZXR1cm4geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9XG4gKi9cblpsaWIuWmlwLnByb3RvdHlwZS5kZWZsYXRlV2l0aE9wdGlvbiA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdEZWZsYXRlfSAqL1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgWmxpYi5SYXdEZWZsYXRlKGlucHV0LCBvcHRfcGFyYW1zWydkZWZsYXRlT3B0aW9uJ10pO1xuXG4gIHJldHVybiBkZWZsYXRvci5jb21wcmVzcygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyhBcnJheS48bnVtYmVyPnxVaW50MzJBcnJheSl9IGtleVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5abGliLlppcC5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHRtcCA9ICgoa2V5WzJdICYgMHhmZmZmKSB8IDIpO1xuXG4gIHJldHVybiAoKHRtcCAqICh0bXAgXiAxKSkgPj4gOCkgJiAweGZmO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyhBcnJheS48bnVtYmVyPnxVaW50MzJBcnJheXxPYmplY3QpfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblpsaWIuWmlwLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihrZXksIG4pIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciB0bXAgPSB0aGlzLmdldEJ5dGUoLyoqIEB0eXBlIHsoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqLyhrZXkpKTtcblxuICB0aGlzLnVwZGF0ZUtleXMoLyoqIEB0eXBlIHsoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqLyhrZXkpLCBuKTtcblxuICByZXR1cm4gdG1wIF4gbjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKi9cblpsaWIuWmlwLnByb3RvdHlwZS51cGRhdGVLZXlzID0gZnVuY3Rpb24oa2V5LCBuKSB7XG4gIGtleVswXSA9IFpsaWIuQ1JDMzIuc2luZ2xlKGtleVswXSwgbik7XG4gIGtleVsxXSA9XG4gICAgICAoKCgoKGtleVsxXSArIChrZXlbMF0gJiAweGZmKSkgKiAyMDE3MyA+Pj4gMCkgKiA2NjgxKSA+Pj4gMCkgKyAxKSA+Pj4gMDtcbiAga2V5WzJdID0gWmxpYi5DUkMzMi5zaW5nbGUoa2V5WzJdLCBrZXlbMV0gPj4+IDI0KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IHBhc3N3b3JkXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5fE9iamVjdCl9XG4gKi9cblpsaWIuWmlwLnByb3RvdHlwZS5jcmVhdGVFbmNyeXB0aW9uS2V5ID0gZnVuY3Rpb24ocGFzc3dvcmQpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KX0gKi9cbiAgdmFyIGtleSA9IFszMDU0MTk4OTYsIDU5MTc1MTA0OSwgODc4MDgyMTkyXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlsO1xuXG4gIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgIGtleSA9IG5ldyBVaW50MzJBcnJheShrZXkpO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWwgPSBwYXNzd29yZC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdGhpcy51cGRhdGVLZXlzKGtleSwgcGFzc3dvcmRbaV0gJiAweGZmKTtcbiAgfVxuXG4gIHJldHVybiBrZXk7XG59O1xuXG5cblxuLyoqXG4gKiBidWlsZCBodWZmbWFuIHRhYmxlIGZyb20gbGVuZ3RoIGxpc3QuXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGxlbmd0aHMgbGVuZ3RoIGxpc3QuXG4gKiBAcmV0dXJuIHshQXJyYXl9IGh1ZmZtYW4gdGFibGUuXG4gKi9cblpsaWIuSHVmZm1hbi5idWlsZEh1ZmZtYW5UYWJsZSA9IGZ1bmN0aW9uKGxlbmd0aHMpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxlbmd0aCBsaXN0IHNpemUuICovXG4gIHZhciBsaXN0U2l6ZSA9IGxlbmd0aHMubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gbWF4IGNvZGUgbGVuZ3RoIGZvciB0YWJsZSBzaXplLiAqL1xuICB2YXIgbWF4Q29kZUxlbmd0aCA9IDA7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBtaW4gY29kZSBsZW5ndGggZm9yIHRhYmxlIHNpemUuICovXG4gIHZhciBtaW5Db2RlTGVuZ3RoID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAvKiogQHR5cGUge251bWJlcn0gdGFibGUgc2l6ZS4gKi9cbiAgdmFyIHNpemU7XG4gIC8qKiBAdHlwZSB7IShBcnJheXxVaW50OEFycmF5KX0gaHVmZm1hbiBjb2RlIHRhYmxlLiAqL1xuICB2YXIgdGFibGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBiaXQgbGVuZ3RoLiAqL1xuICB2YXIgYml0TGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlLiAqL1xuICB2YXIgY29kZTtcbiAgLyoqXG4gICAqIOOCteOCpOOCuuOBjCAyXm1heGxlbmd0aCDlgIvjga7jg4bjg7zjg5bjg6vjgpLln4vjgoHjgovjgZ/jgoHjga7jgrnjgq3jg4Pjg5fplbcuXG4gICAqIEB0eXBlIHtudW1iZXJ9IHNraXAgbGVuZ3RoIGZvciB0YWJsZSBmaWxsaW5nLlxuICAgKi9cbiAgdmFyIHNraXA7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSByZXZlcnNlZCBjb2RlLiAqL1xuICB2YXIgcmV2ZXJzZWQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSByZXZlcnNlIHRlbXAuICovXG4gIHZhciBydGVtcDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0LiAqL1xuICB2YXIgaWw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGNvdW50ZXIuICovXG4gIHZhciBqO1xuICAvKiogQHR5cGUge251bWJlcn0gdGFibGUgdmFsdWUuICovXG4gIHZhciB2YWx1ZTtcblxuICAvLyBNYXRoLm1heCDjga/pgYXjgYTjga7jgafmnIDplbfjga7lgKTjga8gZm9yLWxvb3Ag44Gn5Y+W5b6X44GZ44KLXG4gIGZvciAoaSA9IDAsIGlsID0gbGlzdFNpemU7IGkgPCBpbDsgKytpKSB7XG4gICAgaWYgKGxlbmd0aHNbaV0gPiBtYXhDb2RlTGVuZ3RoKSB7XG4gICAgICBtYXhDb2RlTGVuZ3RoID0gbGVuZ3Roc1tpXTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aHNbaV0gPCBtaW5Db2RlTGVuZ3RoKSB7XG4gICAgICBtaW5Db2RlTGVuZ3RoID0gbGVuZ3Roc1tpXTtcbiAgICB9XG4gIH1cblxuICBzaXplID0gMSA8PCBtYXhDb2RlTGVuZ3RoO1xuICB0YWJsZSA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50MzJBcnJheSA6IEFycmF5KShzaXplKTtcblxuICAvLyDjg5Pjg4Pjg4jplbfjga7nn63jgYTpoIbjgYvjgonjg4/jg5Xjg57jg7PnrKblj7fjgpLlibLjgorlvZPjgabjgotcbiAgZm9yIChiaXRMZW5ndGggPSAxLCBjb2RlID0gMCwgc2tpcCA9IDI7IGJpdExlbmd0aCA8PSBtYXhDb2RlTGVuZ3RoOykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0U2l6ZTsgKytpKSB7XG4gICAgICBpZiAobGVuZ3Roc1tpXSA9PT0gYml0TGVuZ3RoKSB7XG4gICAgICAgIC8vIOODk+ODg+ODiOOCquODvOODgOODvOOBjOmAhuOBq+OBquOCi+OBn+OCgeODk+ODg+ODiOmVt+WIhuS4puOBs+OCkuWPjei7ouOBmeOCi1xuICAgICAgICBmb3IgKHJldmVyc2VkID0gMCwgcnRlbXAgPSBjb2RlLCBqID0gMDsgaiA8IGJpdExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgcmV2ZXJzZWQgPSAocmV2ZXJzZWQgPDwgMSkgfCAocnRlbXAgJiAxKTtcbiAgICAgICAgICBydGVtcCA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacgOWkp+ODk+ODg+ODiOmVt+OCkuOCguOBqOOBq+ODhuODvOODluODq+OCkuS9nOOCi+OBn+OCgeOAgVxuICAgICAgICAvLyDmnIDlpKfjg5Pjg4Pjg4jplbfku6XlpJbjgafjga8gMCAvIDEg44Gp44Gh44KJ44Gn44KC6Imv44GE566H5omA44GM44Gn44GN44KLXG4gICAgICAgIC8vIOOBneOBruOBqeOBoeOCieOBp+OCguiJr+OBhOWgtOaJgOOBr+WQjOOBmOWApOOBp+Wfi+OCgeOCi+OBk+OBqOOBp1xuICAgICAgICAvLyDmnKzmnaXjga7jg5Pjg4Pjg4jplbfku6XkuIrjga7jg5Pjg4Pjg4jmlbDlj5blvpfjgZfjgabjgoLllY/poYzjgYzotbfjgZPjgonjgarjgYTjgojjgYbjgavjgZnjgotcbiAgICAgICAgdmFsdWUgPSAoYml0TGVuZ3RoIDw8IDE2KSB8IGk7XG4gICAgICAgIGZvciAoaiA9IHJldmVyc2VkOyBqIDwgc2l6ZTsgaiArPSBza2lwKSB7XG4gICAgICAgICAgdGFibGVbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgICsrY29kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmrKHjga7jg5Pjg4Pjg4jplbfjgbhcbiAgICArK2JpdExlbmd0aDtcbiAgICBjb2RlIDw8PSAxO1xuICAgIHNraXAgPDw9IDE7XG4gIH1cblxuICByZXR1cm4gW3RhYmxlLCBtYXhDb2RlTGVuZ3RoLCBtaW5Db2RlTGVuZ3RoXTtcbn07XG5cblxuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqIEBkZWZpbmUge251bWJlcn0gYnVmZmVyIGJsb2NrIHNpemUuICovXG52YXIgWkxJQl9SQVdfSU5GTEFURV9CVUZGRVJfU0laRSA9IDB4ODAwMDsgLy8gWyAweDgwMDAgPj0gWkxJQl9CVUZGRVJfQkxPQ0tfU0laRSBdXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG52YXIgYnVpbGRIdWZmbWFuVGFibGUgPSBabGliLkh1ZmZtYW4uYnVpbGRIdWZmbWFuVGFibGU7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyEoVWludDhBcnJheXxBcnJheS48bnVtYmVyPil9IGlucHV0IGlucHV0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRfcGFyYW1zIG9wdGlvbiBwYXJhbWV0ZXIuXG4gKlxuICogb3B0X3BhcmFtcyDjga/ku6XkuIvjga7jg5fjg63jg5Hjg4bjgqPjgpLmjIflrprjgZnjgovkuovjgYzjgafjgY3jgb7jgZnjgIJcbiAqICAgLSBpbmRleDogaW5wdXQgYnVmZmVyIOOBriBkZWZsYXRlIOOCs+ODs+ODhuODiuOBrumWi+Wni+S9jee9ri5cbiAqICAgLSBibG9ja1NpemU6IOODkOODg+ODleOCoeOBruODluODreODg+OCr+OCteOCpOOCui5cbiAqICAgLSBidWZmZXJUeXBlOiBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZSDjga7lgKTjgavjgojjgaPjgabjg5Djg4Pjg5XjgqHjga7nrqHnkIbmlrnms5XjgpLmjIflrprjgZnjgosuXG4gKiAgIC0gcmVzaXplOiDnorrkv53jgZfjgZ/jg5Djg4Pjg5XjgqHjgYzlrp/pmpvjga7lpKfjgY3jgZXjgojjgorlpKfjgY3jgYvjgaPjgZ/loLTlkIjjgavliIfjgoroqbDjgoHjgosuXG4gKi9cblpsaWIuUmF3SW5mbGF0ZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gaW5mbGF0ZWQgYnVmZmVyICovXG4gIHRoaXMuYnVmZmVyO1xuICAvKiogQHR5cGUgeyFBcnJheS48KEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpPn0gKi9cbiAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGJsb2NrIHNpemUuICovXG4gIHRoaXMuYnVmZmVyU2l6ZSA9IFpMSUJfUkFXX0lORkxBVEVfQlVGRkVSX1NJWkU7XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gdG90YWwgb3V0cHV0IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB0aGlzLnRvdGFscG9zID0gMDtcbiAgLyoqIEB0eXBlIHshbnVtYmVyfSBpbnB1dCBidWZmZXIgcG9pbnRlci4gKi9cbiAgdGhpcy5pcCA9IDA7XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gYml0IHN0cmVhbSByZWFkZXIgYnVmZmVyLiAqL1xuICB0aGlzLmJpdHNidWYgPSAwO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9IGJpdCBzdHJlYW0gcmVhZGVyIGJ1ZmZlciBzaXplLiAqL1xuICB0aGlzLmJpdHNidWZsZW4gPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5pbnB1dCA9IFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpIDogaW5wdXQ7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5vdXRwdXQ7XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gb3V0cHV0IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB0aGlzLm9wO1xuICAvKiogQHR5cGUge2Jvb2xlYW59IGlzIGZpbmFsIGJsb2NrIGZsYWcuICovXG4gIHRoaXMuYmZpbmFsID0gZmFsc2U7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdJbmZsYXRlLkJ1ZmZlclR5cGV9IGJ1ZmZlciBtYW5hZ2VtZW50LiAqL1xuICB0aGlzLmJ1ZmZlclR5cGUgPSBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZS5BREFQVElWRTtcbiAgLyoqIEB0eXBlIHtib29sZWFufSByZXNpemUgZmxhZyBmb3IgbWVtb3J5IHNpemUgb3B0aW1pemF0aW9uLiAqL1xuICB0aGlzLnJlc2l6ZSA9IGZhbHNlO1xuXG4gIC8vIG9wdGlvbiBwYXJhbWV0ZXJzXG4gIGlmIChvcHRfcGFyYW1zIHx8ICEob3B0X3BhcmFtcyA9IHt9KSkge1xuICAgIGlmIChvcHRfcGFyYW1zWydpbmRleCddKSB7XG4gICAgICB0aGlzLmlwID0gb3B0X3BhcmFtc1snaW5kZXgnXTtcbiAgICB9XG4gICAgaWYgKG9wdF9wYXJhbXNbJ2J1ZmZlclNpemUnXSkge1xuICAgICAgdGhpcy5idWZmZXJTaXplID0gb3B0X3BhcmFtc1snYnVmZmVyU2l6ZSddO1xuICAgIH1cbiAgICBpZiAob3B0X3BhcmFtc1snYnVmZmVyVHlwZSddKSB7XG4gICAgICB0aGlzLmJ1ZmZlclR5cGUgPSBvcHRfcGFyYW1zWydidWZmZXJUeXBlJ107XG4gICAgfVxuICAgIGlmIChvcHRfcGFyYW1zWydyZXNpemUnXSkge1xuICAgICAgdGhpcy5yZXNpemUgPSBvcHRfcGFyYW1zWydyZXNpemUnXTtcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWFsaXplXG4gIHN3aXRjaCAodGhpcy5idWZmZXJUeXBlKSB7XG4gICAgY2FzZSBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZS5CTE9DSzpcbiAgICAgIHRoaXMub3AgPSBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGg7XG4gICAgICB0aGlzLm91dHB1dCA9XG4gICAgICAgICAgbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoXG4gICAgICAgICAgICAgIFpsaWIuUmF3SW5mbGF0ZS5NYXhCYWNrd2FyZExlbmd0aCArXG4gICAgICAgICAgICAgIHRoaXMuYnVmZmVyU2l6ZSArXG4gICAgICAgICAgICAgIFpsaWIuUmF3SW5mbGF0ZS5NYXhDb3B5TGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWmxpYi5SYXdJbmZsYXRlLkJ1ZmZlclR5cGUuQURBUFRJVkU6XG4gICAgICB0aGlzLm9wID0gMDtcbiAgICAgIHRoaXMub3V0cHV0ID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkodGhpcy5idWZmZXJTaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5mbGF0ZSBtb2RlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLkJ1ZmZlclR5cGUgPSB7XG4gIEJMT0NLOiAwLFxuICBBREFQVElWRTogMVxufTtcblxuLyoqXG4gKiBkZWNvbXByZXNzLlxuICogQHJldHVybiB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gaW5mbGF0ZWQgYnVmZmVyLlxuICovXG5abGliLlJhd0luZmxhdGUucHJvdG90eXBlLmRlY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKCF0aGlzLmJmaW5hbCkge1xuICAgIHRoaXMucGFyc2VCbG9jaygpO1xuICB9XG5cbiAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkJMT0NLOlxuICAgICAgcmV0dXJuIHRoaXMuY29uY2F0QnVmZmVyQmxvY2soKTtcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkFEQVBUSVZFOlxuICAgICAgcmV0dXJuIHRoaXMuY29uY2F0QnVmZmVyRHluYW1pYygpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5mbGF0ZSBtb2RlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfSBtYXggYmFja3dhcmQgbGVuZ3RoIGZvciBMWjc3LlxuICovXG5abGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGggPSAzMjc2ODtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9IG1heCBjb3B5IGxlbmd0aCBmb3IgTFo3Ny5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLk1heENvcHlMZW5ndGggPSAyNTg7XG5cbi8qKlxuICogaHVmZm1hbiBvcmRlclxuICogQGNvbnN0XG4gKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX1cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLk9yZGVyID0gKGZ1bmN0aW9uKHRhYmxlKSB7XG4gIHJldHVybiBVU0VfVFlQRURBUlJBWSA/IG5ldyBVaW50MTZBcnJheSh0YWJsZSkgOiB0YWJsZTtcbn0pKFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSk7XG5cbi8qKlxuICogaHVmZm1hbiBsZW5ndGggY29kZSB0YWJsZS5cbiAqIEBjb25zdFxuICogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDE2QXJyYXkpfVxuICovXG5abGliLlJhd0luZmxhdGUuTGVuZ3RoQ29kZVRhYmxlID0gKGZ1bmN0aW9uKHRhYmxlKSB7XG4gIHJldHVybiBVU0VfVFlQRURBUlJBWSA/IG5ldyBVaW50MTZBcnJheSh0YWJsZSkgOiB0YWJsZTtcbn0pKFtcbiAgMHgwMDAzLCAweDAwMDQsIDB4MDAwNSwgMHgwMDA2LCAweDAwMDcsIDB4MDAwOCwgMHgwMDA5LCAweDAwMGEsIDB4MDAwYixcbiAgMHgwMDBkLCAweDAwMGYsIDB4MDAxMSwgMHgwMDEzLCAweDAwMTcsIDB4MDAxYiwgMHgwMDFmLCAweDAwMjMsIDB4MDAyYixcbiAgMHgwMDMzLCAweDAwM2IsIDB4MDA0MywgMHgwMDUzLCAweDAwNjMsIDB4MDA3MywgMHgwMDgzLCAweDAwYTMsIDB4MDBjMyxcbiAgMHgwMGUzLCAweDAxMDIsIDB4MDEwMiwgMHgwMTAyXG5dKTtcblxuLyoqXG4gKiBodWZmbWFuIGxlbmd0aCBleHRyYS1iaXRzIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX1cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLkxlbmd0aEV4dHJhVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQ4QXJyYXkodGFibGUpIDogdGFibGU7XG59KShbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsXG4gIDUsIDUsIDAsIDAsIDBcbl0pO1xuXG4vKipcbiAqIGh1ZmZtYW4gZGlzdCBjb2RlIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZS5EaXN0Q29kZVRhYmxlID0gKGZ1bmN0aW9uKHRhYmxlKSB7XG4gIHJldHVybiBVU0VfVFlQRURBUlJBWSA/IG5ldyBVaW50MTZBcnJheSh0YWJsZSkgOiB0YWJsZTtcbn0pKFtcbiAgMHgwMDAxLCAweDAwMDIsIDB4MDAwMywgMHgwMDA0LCAweDAwMDUsIDB4MDAwNywgMHgwMDA5LCAweDAwMGQsIDB4MDAxMSxcbiAgMHgwMDE5LCAweDAwMjEsIDB4MDAzMSwgMHgwMDQxLCAweDAwNjEsIDB4MDA4MSwgMHgwMGMxLCAweDAxMDEsIDB4MDE4MSxcbiAgMHgwMjAxLCAweDAzMDEsIDB4MDQwMSwgMHgwNjAxLCAweDA4MDEsIDB4MGMwMSwgMHgxMDAxLCAweDE4MDEsIDB4MjAwMSxcbiAgMHgzMDAxLCAweDQwMDEsIDB4NjAwMVxuXSk7XG5cbi8qKlxuICogaHVmZm1hbiBkaXN0IGV4dHJhLWJpdHMgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfVxuICovXG5abGliLlJhd0luZmxhdGUuRGlzdEV4dHJhVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQ4QXJyYXkodGFibGUpIDogdGFibGU7XG59KShbXG4gIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsXG4gIDExLCAxMiwgMTIsIDEzLCAxM1xuXSk7XG5cbi8qKlxuICogZml4ZWQgaHVmZm1hbiBsZW5ndGggY29kZSB0YWJsZVxuICogQGNvbnN0XG4gKiBAdHlwZSB7IUFycmF5fVxuICovXG5abGliLlJhd0luZmxhdGUuRml4ZWRMaXRlcmFsTGVuZ3RoVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIHRhYmxlO1xufSkoKGZ1bmN0aW9uKCkge1xuICB2YXIgbGVuZ3RocyA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKDI4OCk7XG4gIHZhciBpLCBpbDtcblxuICBmb3IgKGkgPSAwLCBpbCA9IGxlbmd0aHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIGxlbmd0aHNbaV0gPVxuICAgICAgICAoaSA8PSAxNDMpID8gOCA6XG4gICAgICAgICAgICAoaSA8PSAyNTUpID8gOSA6XG4gICAgICAgICAgICAgICAgKGkgPD0gMjc5KSA/IDcgOlxuICAgICAgICAgICAgICAgICAgICA4O1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkSHVmZm1hblRhYmxlKGxlbmd0aHMpO1xufSkoKSk7XG5cbi8qKlxuICogZml4ZWQgaHVmZm1hbiBkaXN0YW5jZSBjb2RlIHRhYmxlXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshQXJyYXl9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZS5GaXhlZERpc3RhbmNlVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIHRhYmxlO1xufSkoKGZ1bmN0aW9uKCkge1xuICB2YXIgbGVuZ3RocyA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKDMwKTtcbiAgdmFyIGksIGlsO1xuXG4gIGZvciAoaSA9IDAsIGlsID0gbGVuZ3Rocy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgbGVuZ3Roc1tpXSA9IDU7XG4gIH1cblxuICByZXR1cm4gYnVpbGRIdWZmbWFuVGFibGUobGVuZ3Rocyk7XG59KSgpKTtcblxuLyoqXG4gKiBwYXJzZSBkZWZsYXRlZCBibG9jay5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBoZWFkZXIgKi9cbiAgdmFyIGhkciA9IHRoaXMucmVhZEJpdHMoMyk7XG5cbiAgLy8gQkZJTkFMXG4gIGlmIChoZHIgJiAweDEpIHtcbiAgICB0aGlzLmJmaW5hbCA9IHRydWU7XG4gIH1cblxuICAvLyBCVFlQRVxuICBoZHIgPj4+PSAxO1xuICBzd2l0Y2ggKGhkcikge1xuICAgICAgLy8gdW5jb21wcmVzc2VkXG4gICAgY2FzZSAwOlxuICAgICAgdGhpcy5wYXJzZVVuY29tcHJlc3NlZEJsb2NrKCk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIGZpeGVkIGh1ZmZtYW5cbiAgICBjYXNlIDE6XG4gICAgICB0aGlzLnBhcnNlRml4ZWRIdWZmbWFuQmxvY2soKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gZHluYW1pYyBodWZmbWFuXG4gICAgY2FzZSAyOlxuICAgICAgdGhpcy5wYXJzZUR5bmFtaWNIdWZmbWFuQmxvY2soKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gcmVzZXJ2ZWQgb3Igb3RoZXJcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIEJUWVBFOiAnICsgaGRyKTtcbiAgfVxufTtcblxuLyoqXG4gKiByZWFkIGluZmxhdGUgYml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBiaXRzIGxlbmd0aC5cbiAqIEByZXR1cm4ge251bWJlcn0gcmVhZCBiaXRzLlxuICovXG5abGliLlJhd0luZmxhdGUucHJvdG90eXBlLnJlYWRCaXRzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHZhciBiaXRzYnVmID0gdGhpcy5iaXRzYnVmO1xuICB2YXIgYml0c2J1ZmxlbiA9IHRoaXMuYml0c2J1ZmxlbjtcbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgdmFyIGlwID0gdGhpcy5pcDtcblxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gaW5wdXQgYW5kIG91dHB1dCBieXRlLiAqL1xuICB2YXIgb2N0ZXQ7XG5cbiAgLy8gaW5wdXQgYnl0ZVxuICBpZiAoaXAgKyAoKGxlbmd0aCAtIGJpdHNidWZsZW4gKyA3KSA+PiAzKSA+PSBpbnB1dExlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgYnVmZmVyIGlzIGJyb2tlbicpO1xuICB9XG5cbiAgLy8gbm90IGVub3VnaCBidWZmZXJcbiAgd2hpbGUgKGJpdHNidWZsZW4gPCBsZW5ndGgpIHtcbiAgICBiaXRzYnVmIHw9IGlucHV0W2lwKytdIDw8IGJpdHNidWZsZW47XG4gICAgYml0c2J1ZmxlbiArPSA4O1xuICB9XG5cbiAgLy8gb3V0cHV0IGJ5dGVcbiAgb2N0ZXQgPSBiaXRzYnVmICYgLyogTUFTSyAqLyAoKDEgPDwgbGVuZ3RoKSAtIDEpO1xuICBiaXRzYnVmID4+Pj0gbGVuZ3RoO1xuICBiaXRzYnVmbGVuIC09IGxlbmd0aDtcblxuICB0aGlzLmJpdHNidWYgPSBiaXRzYnVmO1xuICB0aGlzLmJpdHNidWZsZW4gPSBiaXRzYnVmbGVuO1xuICB0aGlzLmlwID0gaXA7XG5cbiAgcmV0dXJuIG9jdGV0O1xufTtcblxuLyoqXG4gKiByZWFkIGh1ZmZtYW4gY29kZSB1c2luZyB0YWJsZVxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXl8VWludDE2QXJyYXkpfSB0YWJsZSBodWZmbWFuIGNvZGUgdGFibGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGh1ZmZtYW4gY29kZS5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5yZWFkQ29kZUJ5VGFibGUgPSBmdW5jdGlvbih0YWJsZSkge1xuICB2YXIgYml0c2J1ZiA9IHRoaXMuYml0c2J1ZjtcbiAgdmFyIGJpdHNidWZsZW4gPSB0aGlzLmJpdHNidWZsZW47XG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG5cbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBodWZmbWFuIGNvZGUgdGFibGUgKi9cbiAgdmFyIGNvZGVUYWJsZSA9IHRhYmxlWzBdO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIG1heENvZGVMZW5ndGggPSB0YWJsZVsxXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNvZGUgbGVuZ3RoICYgY29kZSAoMTZiaXQsIDE2Yml0KSAqL1xuICB2YXIgY29kZVdpdGhMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBjb2RlIGJpdHMgbGVuZ3RoICovXG4gIHZhciBjb2RlTGVuZ3RoO1xuXG4gIC8vIG5vdCBlbm91Z2ggYnVmZmVyXG4gIHdoaWxlIChiaXRzYnVmbGVuIDwgbWF4Q29kZUxlbmd0aCkge1xuICAgIGlmIChpcCA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJpdHNidWYgfD0gaW5wdXRbaXArK10gPDwgYml0c2J1ZmxlbjtcbiAgICBiaXRzYnVmbGVuICs9IDg7XG4gIH1cblxuICAvLyByZWFkIG1heCBsZW5ndGhcbiAgY29kZVdpdGhMZW5ndGggPSBjb2RlVGFibGVbYml0c2J1ZiAmICgoMSA8PCBtYXhDb2RlTGVuZ3RoKSAtIDEpXTtcbiAgY29kZUxlbmd0aCA9IGNvZGVXaXRoTGVuZ3RoID4+PiAxNjtcblxuICBpZiAoY29kZUxlbmd0aCA+IGJpdHNidWZsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29kZSBsZW5ndGg6ICcgKyBjb2RlTGVuZ3RoKTtcbiAgfVxuXG4gIHRoaXMuYml0c2J1ZiA9IGJpdHNidWYgPj4gY29kZUxlbmd0aDtcbiAgdGhpcy5iaXRzYnVmbGVuID0gYml0c2J1ZmxlbiAtIGNvZGVMZW5ndGg7XG4gIHRoaXMuaXAgPSBpcDtcblxuICByZXR1cm4gY29kZVdpdGhMZW5ndGggJiAweGZmZmY7XG59O1xuXG4vKipcbiAqIHBhcnNlIHVuY29tcHJlc3NlZCBibG9jay5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5wYXJzZVVuY29tcHJlc3NlZEJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG4gIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dDtcbiAgdmFyIG9wID0gdGhpcy5vcDtcblxuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gYmxvY2sgbGVuZ3RoICovXG4gIHZhciBsZW47XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgZm9yIGNoZWNrIGJsb2NrIGxlbmd0aCAqL1xuICB2YXIgbmxlbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG91dHB1dCBidWZmZXIgbGVuZ3RoICovXG4gIHZhciBvbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNvcHkgY291bnRlciAqL1xuICB2YXIgcHJlQ29weTtcblxuICAvLyBza2lwIGJ1ZmZlcmVkIGhlYWRlciBiaXRzXG4gIHRoaXMuYml0c2J1ZiA9IDA7XG4gIHRoaXMuYml0c2J1ZmxlbiA9IDA7XG5cbiAgLy8gbGVuXG4gIGlmIChpcCArIDEgPj0gaW5wdXRMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOJyk7XG4gIH1cbiAgbGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gbmxlblxuICBpZiAoaXAgKyAxID49IGlucHV0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4nKTtcbiAgfVxuICBubGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gY2hlY2sgbGVuICYgbmxlblxuICBpZiAobGVuID09PSB+bmxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1bmNvbXByZXNzZWQgYmxvY2sgaGVhZGVyOiBsZW5ndGggdmVyaWZ5Jyk7XG4gIH1cblxuICAvLyBjaGVjayBzaXplXG4gIGlmIChpcCArIGxlbiA+IGlucHV0Lmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGJ1ZmZlciBpcyBicm9rZW4nKTsgfVxuXG4gIC8vIGV4cGFuZCBidWZmZXJcbiAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkJMT0NLOlxuICAgICAgLy8gcHJlIGNvcHlcbiAgICAgIHdoaWxlIChvcCArIGxlbiA+IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgcHJlQ29weSA9IG9sZW5ndGggLSBvcDtcbiAgICAgICAgbGVuIC09IHByZUNvcHk7XG4gICAgICAgIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgICAgICAgIG91dHB1dC5zZXQoaW5wdXQuc3ViYXJyYXkoaXAsIGlwICsgcHJlQ29weSksIG9wKTtcbiAgICAgICAgICBvcCArPSBwcmVDb3B5O1xuICAgICAgICAgIGlwICs9IHByZUNvcHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKHByZUNvcHktLSkge1xuICAgICAgICAgICAgb3V0cHV0W29wKytdID0gaW5wdXRbaXArK107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgICAgb3V0cHV0ID0gdGhpcy5leHBhbmRCdWZmZXJCbG9jaygpO1xuICAgICAgICBvcCA9IHRoaXMub3A7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkFEQVBUSVZFOlxuICAgICAgd2hpbGUgKG9wICsgbGVuID4gb3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlckFkYXB0aXZlKHtmaXhSYXRpbzogMn0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmZsYXRlIG1vZGUnKTtcbiAgfVxuXG4gIC8vIGNvcHlcbiAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgb3V0cHV0LnNldChpbnB1dC5zdWJhcnJheShpcCwgaXAgKyBsZW4pLCBvcCk7XG4gICAgb3AgKz0gbGVuO1xuICAgIGlwICs9IGxlbjtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIG91dHB1dFtvcCsrXSA9IGlucHV0W2lwKytdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXAgPSBpcDtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbn07XG5cbi8qKlxuICogcGFyc2UgZml4ZWQgaHVmZm1hbiBibG9jay5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5wYXJzZUZpeGVkSHVmZm1hbkJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy5idWZmZXJUeXBlKSB7XG4gICAgY2FzZSBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZS5BREFQVElWRTpcbiAgICAgIHRoaXMuZGVjb2RlSHVmZm1hbkFkYXB0aXZlKFxuICAgICAgICAgIFpsaWIuUmF3SW5mbGF0ZS5GaXhlZExpdGVyYWxMZW5ndGhUYWJsZSxcbiAgICAgICAgICBabGliLlJhd0luZmxhdGUuRml4ZWREaXN0YW5jZVRhYmxlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZS5CTE9DSzpcbiAgICAgIHRoaXMuZGVjb2RlSHVmZm1hbkJsb2NrKFxuICAgICAgICAgIFpsaWIuUmF3SW5mbGF0ZS5GaXhlZExpdGVyYWxMZW5ndGhUYWJsZSxcbiAgICAgICAgICBabGliLlJhd0luZmxhdGUuRml4ZWREaXN0YW5jZVRhYmxlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmZsYXRlIG1vZGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwYXJzZSBkeW5hbWljIGh1ZmZtYW4gYmxvY2suXG4gKi9cblpsaWIuUmF3SW5mbGF0ZS5wcm90b3R5cGUucGFyc2VEeW5hbWljSHVmZm1hbkJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgbGl0ZXJhbCBhbmQgbGVuZ3RoIGNvZGVzLiAqL1xuICB2YXIgaGxpdCA9IHRoaXMucmVhZEJpdHMoNSkgKyAyNTc7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMuICovXG4gIHZhciBoZGlzdCA9IHRoaXMucmVhZEJpdHMoNSkgKyAxO1xuICAvKiogQHR5cGUge251bWJlcn0gbnVtYmVyIG9mIGNvZGUgbGVuZ3Rocy4gKi9cbiAgdmFyIGhjbGVuID0gdGhpcy5yZWFkQml0cyg0KSArIDQ7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gY29kZSBsZW5ndGhzLiAqL1xuICB2YXIgY29kZUxlbmd0aHMgPVxuICAgICAgbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoWmxpYi5SYXdJbmZsYXRlLk9yZGVyLmxlbmd0aCk7XG4gIC8qKiBAdHlwZSB7IUFycmF5fSBjb2RlIGxlbmd0aHMgdGFibGUuICovXG4gIHZhciBjb2RlTGVuZ3Roc1RhYmxlO1xuICAvKiogQHR5cGUgeyEoVWludDhBcnJheXxBcnJheS48bnVtYmVyPil9IGxpdGVyYWwgYW5kIGxlbmd0aCBjb2RlIHRhYmxlLiAqL1xuICB2YXIgbGl0bGVuVGFibGU7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gZGlzdGFuY2UgY29kZSB0YWJsZS4gKi9cbiAgdmFyIGRpc3RUYWJsZTtcbiAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkuPG51bWJlcj4pfSBjb2RlIGxlbmd0aCB0YWJsZS4gKi9cbiAgdmFyIGxlbmd0aFRhYmxlO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGNvZGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgcHJldjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciByZXBlYXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGNvdW50ZXIuICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsaW1pdC4gKi9cbiAgdmFyIGlsO1xuXG4gIC8vIGRlY29kZSBjb2RlIGxlbmd0aHNcbiAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyArK2kpIHtcbiAgICBjb2RlTGVuZ3Roc1tabGliLlJhd0luZmxhdGUuT3JkZXJbaV1dID0gdGhpcy5yZWFkQml0cygzKTtcbiAgfVxuICBpZiAoIVVTRV9UWVBFREFSUkFZKSB7XG4gICAgZm9yIChpID0gaGNsZW4sIGhjbGVuID0gY29kZUxlbmd0aHMubGVuZ3RoOyBpIDwgaGNsZW47ICsraSkge1xuICAgICAgY29kZUxlbmd0aHNbWmxpYi5SYXdJbmZsYXRlLk9yZGVyW2ldXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVjb2RlIGxlbmd0aCB0YWJsZVxuICBjb2RlTGVuZ3Roc1RhYmxlID0gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMpO1xuICBsZW5ndGhUYWJsZSA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKGhsaXQgKyBoZGlzdCk7XG4gIGZvciAoaSA9IDAsIGlsID0gaGxpdCArIGhkaXN0OyBpIDwgaWw7KSB7XG4gICAgY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGNvZGVMZW5ndGhzVGFibGUpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAxNjpcbiAgICAgICAgcmVwZWF0ID0gMyArIHRoaXMucmVhZEJpdHMoMik7XG4gICAgICAgIHdoaWxlIChyZXBlYXQtLSkgeyBsZW5ndGhUYWJsZVtpKytdID0gcHJldjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIHJlcGVhdCA9IDMgKyB0aGlzLnJlYWRCaXRzKDMpO1xuICAgICAgICB3aGlsZSAocmVwZWF0LS0pIHsgbGVuZ3RoVGFibGVbaSsrXSA9IDA7IH1cbiAgICAgICAgcHJldiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODpcbiAgICAgICAgcmVwZWF0ID0gMTEgKyB0aGlzLnJlYWRCaXRzKDcpO1xuICAgICAgICB3aGlsZSAocmVwZWF0LS0pIHsgbGVuZ3RoVGFibGVbaSsrXSA9IDA7IH1cbiAgICAgICAgcHJldiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuZ3RoVGFibGVbaSsrXSA9IGNvZGU7XG4gICAgICAgIHByZXYgPSBjb2RlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBsaXRsZW5UYWJsZSA9IFVTRV9UWVBFREFSUkFZXG4gICAgICA/IGJ1aWxkSHVmZm1hblRhYmxlKGxlbmd0aFRhYmxlLnN1YmFycmF5KDAsIGhsaXQpKVxuICAgICAgOiBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhUYWJsZS5zbGljZSgwLCBobGl0KSk7XG4gIGRpc3RUYWJsZSA9IFVTRV9UWVBFREFSUkFZXG4gICAgICA/IGJ1aWxkSHVmZm1hblRhYmxlKGxlbmd0aFRhYmxlLnN1YmFycmF5KGhsaXQpKVxuICAgICAgOiBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhUYWJsZS5zbGljZShobGl0KSk7XG5cbiAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkFEQVBUSVZFOlxuICAgICAgdGhpcy5kZWNvZGVIdWZmbWFuQWRhcHRpdmUobGl0bGVuVGFibGUsIGRpc3RUYWJsZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZS5CdWZmZXJUeXBlLkJMT0NLOlxuICAgICAgdGhpcy5kZWNvZGVIdWZmbWFuQmxvY2sobGl0bGVuVGFibGUsIGRpc3RUYWJsZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluZmxhdGUgbW9kZScpO1xuICB9XG59O1xuXG4vKipcbiAqIGRlY29kZSBodWZmbWFuIGNvZGVcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9IGxpdGxlbiBsaXRlcmFsIGFuZCBsZW5ndGggY29kZSB0YWJsZS5cbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gZGlzdCBkaXN0aW5hdGlvbiBjb2RlIHRhYmxlLlxuICovXG5abGliLlJhd0luZmxhdGUucHJvdG90eXBlLmRlY29kZUh1ZmZtYW5CbG9jayA9IGZ1bmN0aW9uKGxpdGxlbiwgZGlzdCkge1xuICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gIHZhciBvcCA9IHRoaXMub3A7XG5cbiAgdGhpcy5jdXJyZW50TGl0bGVuVGFibGUgPSBsaXRsZW47XG5cbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG91dHB1dCBwb3NpdGlvbiBsaW1pdC4gKi9cbiAgdmFyIG9sZW5ndGggPSBvdXRwdXQubGVuZ3RoIC0gWmxpYi5SYXdJbmZsYXRlLk1heENvcHlMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBodWZmbWFuIGNvZGUuICovXG4gIHZhciBjb2RlO1xuICAvKiogQHR5cGUge251bWJlcn0gdGFibGUgaW5kZXguICovXG4gIHZhciB0aTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZSBkaXN0aW5hdGlvbi4gKi9cbiAgdmFyIGNvZGVEaXN0O1xuICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlIGxlbmd0aC4gKi9cbiAgdmFyIGNvZGVMZW5ndGg7XG5cbiAgdmFyIGxlbmd0aENvZGVUYWJsZSA9IFpsaWIuUmF3SW5mbGF0ZS5MZW5ndGhDb2RlVGFibGU7XG4gIHZhciBsZW5ndGhFeHRyYVRhYmxlID0gWmxpYi5SYXdJbmZsYXRlLkxlbmd0aEV4dHJhVGFibGU7XG4gIHZhciBkaXN0Q29kZVRhYmxlID0gWmxpYi5SYXdJbmZsYXRlLkRpc3RDb2RlVGFibGU7XG4gIHZhciBkaXN0RXh0cmFUYWJsZSA9IFpsaWIuUmF3SW5mbGF0ZS5EaXN0RXh0cmFUYWJsZTtcblxuICB3aGlsZSAoKGNvZGUgPSB0aGlzLnJlYWRDb2RlQnlUYWJsZShsaXRsZW4pKSAhPT0gMjU2KSB7XG4gICAgLy8gbGl0ZXJhbFxuICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICBpZiAob3AgPj0gb2xlbmd0aCkge1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIG91dHB1dCA9IHRoaXMuZXhwYW5kQnVmZmVyQmxvY2soKTtcbiAgICAgICAgb3AgPSB0aGlzLm9wO1xuICAgICAgfVxuICAgICAgb3V0cHV0W29wKytdID0gY29kZTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGVuZ3RoIGNvZGVcbiAgICB0aSA9IGNvZGUgLSAyNTc7XG4gICAgY29kZUxlbmd0aCA9IGxlbmd0aENvZGVUYWJsZVt0aV07XG4gICAgaWYgKGxlbmd0aEV4dHJhVGFibGVbdGldID4gMCkge1xuICAgICAgY29kZUxlbmd0aCArPSB0aGlzLnJlYWRCaXRzKGxlbmd0aEV4dHJhVGFibGVbdGldKTtcbiAgICB9XG5cbiAgICAvLyBkaXN0IGNvZGVcbiAgICBjb2RlID0gdGhpcy5yZWFkQ29kZUJ5VGFibGUoZGlzdCk7XG4gICAgY29kZURpc3QgPSBkaXN0Q29kZVRhYmxlW2NvZGVdO1xuICAgIGlmIChkaXN0RXh0cmFUYWJsZVtjb2RlXSA+IDApIHtcbiAgICAgIGNvZGVEaXN0ICs9IHRoaXMucmVhZEJpdHMoZGlzdEV4dHJhVGFibGVbY29kZV0pO1xuICAgIH1cblxuICAgIC8vIGx6NzcgZGVjb2RlXG4gICAgaWYgKG9wID49IG9sZW5ndGgpIHtcbiAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgIG91dHB1dCA9IHRoaXMuZXhwYW5kQnVmZmVyQmxvY2soKTtcbiAgICAgIG9wID0gdGhpcy5vcDtcbiAgICB9XG4gICAgd2hpbGUgKGNvZGVMZW5ndGgtLSkge1xuICAgICAgb3V0cHV0W29wXSA9IG91dHB1dFsob3ArKykgLSBjb2RlRGlzdF07XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaXMuYml0c2J1ZmxlbiA+PSA4KSB7XG4gICAgdGhpcy5iaXRzYnVmbGVuIC09IDg7XG4gICAgdGhpcy5pcC0tO1xuICB9XG4gIHRoaXMub3AgPSBvcDtcbn07XG5cbi8qKlxuICogZGVjb2RlIGh1ZmZtYW4gY29kZSAoYWRhcHRpdmUpXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDE2QXJyYXkpfSBsaXRsZW4gbGl0ZXJhbCBhbmQgbGVuZ3RoIGNvZGUgdGFibGUuXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGRpc3QgZGlzdGluYXRpb24gY29kZSB0YWJsZS5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5kZWNvZGVIdWZmbWFuQWRhcHRpdmUgPSBmdW5jdGlvbihsaXRsZW4sIGRpc3QpIHtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICB2YXIgb3AgPSB0aGlzLm9wO1xuXG4gIHRoaXMuY3VycmVudExpdGxlblRhYmxlID0gbGl0bGVuO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBvdXRwdXQgcG9zaXRpb24gbGltaXQuICovXG4gIHZhciBvbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZS4gKi9cbiAgdmFyIGNvZGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSB0YWJsZSBpbmRleC4gKi9cbiAgdmFyIHRpO1xuICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlIGRpc3RpbmF0aW9uLiAqL1xuICB2YXIgY29kZURpc3Q7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBodWZmbWFuIGNvZGUgbGVuZ3RoLiAqL1xuICB2YXIgY29kZUxlbmd0aDtcblxuICB2YXIgbGVuZ3RoQ29kZVRhYmxlID0gWmxpYi5SYXdJbmZsYXRlLkxlbmd0aENvZGVUYWJsZTtcbiAgdmFyIGxlbmd0aEV4dHJhVGFibGUgPSBabGliLlJhd0luZmxhdGUuTGVuZ3RoRXh0cmFUYWJsZTtcbiAgdmFyIGRpc3RDb2RlVGFibGUgPSBabGliLlJhd0luZmxhdGUuRGlzdENvZGVUYWJsZTtcbiAgdmFyIGRpc3RFeHRyYVRhYmxlID0gWmxpYi5SYXdJbmZsYXRlLkRpc3RFeHRyYVRhYmxlO1xuXG4gIHdoaWxlICgoY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGxpdGxlbikpICE9PSAyNTYpIHtcbiAgICAvLyBsaXRlcmFsXG4gICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgIGlmIChvcCA+PSBvbGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dCA9IHRoaXMuZXhwYW5kQnVmZmVyQWRhcHRpdmUoKTtcbiAgICAgICAgb2xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBvdXRwdXRbb3ArK10gPSBjb2RlO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsZW5ndGggY29kZVxuICAgIHRpID0gY29kZSAtIDI1NztcbiAgICBjb2RlTGVuZ3RoID0gbGVuZ3RoQ29kZVRhYmxlW3RpXTtcbiAgICBpZiAobGVuZ3RoRXh0cmFUYWJsZVt0aV0gPiAwKSB7XG4gICAgICBjb2RlTGVuZ3RoICs9IHRoaXMucmVhZEJpdHMobGVuZ3RoRXh0cmFUYWJsZVt0aV0pO1xuICAgIH1cblxuICAgIC8vIGRpc3QgY29kZVxuICAgIGNvZGUgPSB0aGlzLnJlYWRDb2RlQnlUYWJsZShkaXN0KTtcbiAgICBjb2RlRGlzdCA9IGRpc3RDb2RlVGFibGVbY29kZV07XG4gICAgaWYgKGRpc3RFeHRyYVRhYmxlW2NvZGVdID4gMCkge1xuICAgICAgY29kZURpc3QgKz0gdGhpcy5yZWFkQml0cyhkaXN0RXh0cmFUYWJsZVtjb2RlXSk7XG4gICAgfVxuXG4gICAgLy8gbHo3NyBkZWNvZGVcbiAgICBpZiAob3AgKyBjb2RlTGVuZ3RoID4gb2xlbmd0aCkge1xuICAgICAgb3V0cHV0ID0gdGhpcy5leHBhbmRCdWZmZXJBZGFwdGl2ZSgpO1xuICAgICAgb2xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChjb2RlTGVuZ3RoLS0pIHtcbiAgICAgIG91dHB1dFtvcF0gPSBvdXRwdXRbKG9wKyspIC0gY29kZURpc3RdO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0aGlzLmJpdHNidWZsZW4gPj0gOCkge1xuICAgIHRoaXMuYml0c2J1ZmxlbiAtPSA4O1xuICAgIHRoaXMuaXAtLTtcbiAgfVxuICB0aGlzLm9wID0gb3A7XG59O1xuXG4vKipcbiAqIGV4cGFuZCBvdXRwdXQgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW0gb3B0aW9uIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBvdXRwdXQgYnVmZmVyLlxuICovXG5abGliLlJhd0luZmxhdGUucHJvdG90eXBlLmV4cGFuZEJ1ZmZlckJsb2NrID0gZnVuY3Rpb24ob3B0X3BhcmFtKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gc3RvcmUgYnVmZmVyLiAqL1xuICB2YXIgYnVmZmVyID1cbiAgICAgIG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKFxuICAgICAgICAgIHRoaXMub3AgLSBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGhcbiAgICAgICk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBiYWNrd2FyZCBiYXNlIHBvaW50ICovXG4gIHZhciBiYWNrd2FyZCA9IHRoaXMub3AgLSBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBjb3B5IGluZGV4LiAqL1xuICB2YXIgaTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNvcHkgbGltaXQgKi9cbiAgdmFyIGlsO1xuXG4gIHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dDtcblxuICAvLyBjb3B5IHRvIG91dHB1dCBidWZmZXJcbiAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgYnVmZmVyLnNldChvdXRwdXQuc3ViYXJyYXkoWmxpYi5SYXdJbmZsYXRlLk1heEJhY2t3YXJkTGVuZ3RoLCBidWZmZXIubGVuZ3RoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMCwgaWwgPSBidWZmZXIubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgYnVmZmVyW2ldID0gb3V0cHV0W2kgKyBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGhdO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuYmxvY2tzLnB1c2goYnVmZmVyKTtcbiAgdGhpcy50b3RhbHBvcyArPSBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIGNvcHkgdG8gYmFja3dhcmQgYnVmZmVyXG4gIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgIG91dHB1dC5zZXQoXG4gICAgICAgIG91dHB1dC5zdWJhcnJheShiYWNrd2FyZCwgYmFja3dhcmQgKyBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGgpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgWmxpYi5SYXdJbmZsYXRlLk1heEJhY2t3YXJkTGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IG91dHB1dFtiYWNrd2FyZCArIGldO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3AgPSBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGg7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogZXhwYW5kIG91dHB1dCBidWZmZXIuIChhZGFwdGl2ZSlcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtIG9wdGlvbiBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gb3V0cHV0IGJ1ZmZlciBwb2ludGVyLlxuICovXG5abGliLlJhd0luZmxhdGUucHJvdG90eXBlLmV4cGFuZEJ1ZmZlckFkYXB0aXZlID0gZnVuY3Rpb24ob3B0X3BhcmFtKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gc3RvcmUgYnVmZmVyLiAqL1xuICB2YXIgYnVmZmVyO1xuICAvKiogQHR5cGUge251bWJlcn0gZXhwYW50aW9uIHJhdGlvLiAqL1xuICB2YXIgcmF0aW8gPSAodGhpcy5pbnB1dC5sZW5ndGggLyB0aGlzLmlwICsgMSkgfCAwO1xuICAvKiogQHR5cGUge251bWJlcn0gbWF4aW11bSBudW1iZXIgb2YgaHVmZm1hbiBjb2RlLiAqL1xuICB2YXIgbWF4SHVmZkNvZGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBuZXcgb3V0cHV0IGJ1ZmZlciBzaXplLiAqL1xuICB2YXIgbmV3U2l6ZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG1heCBpbmZsYXRlIHNpemUuICovXG4gIHZhciBtYXhJbmZsYXRlU2l6ZTtcblxuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG5cbiAgaWYgKG9wdF9wYXJhbSkge1xuICAgIGlmICh0eXBlb2Ygb3B0X3BhcmFtLmZpeFJhdGlvID09PSAnbnVtYmVyJykge1xuICAgICAgcmF0aW8gPSBvcHRfcGFyYW0uZml4UmF0aW87XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0X3BhcmFtLmFkZFJhdGlvID09PSAnbnVtYmVyJykge1xuICAgICAgcmF0aW8gKz0gb3B0X3BhcmFtLmFkZFJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBuZXcgYnVmZmVyIHNpemVcbiAgaWYgKHJhdGlvIDwgMikge1xuICAgIG1heEh1ZmZDb2RlID1cbiAgICAgICAgKGlucHV0Lmxlbmd0aCAtIHRoaXMuaXApIC8gdGhpcy5jdXJyZW50TGl0bGVuVGFibGVbMl07XG4gICAgbWF4SW5mbGF0ZVNpemUgPSAobWF4SHVmZkNvZGUgLyAyICogMjU4KSB8IDA7XG4gICAgbmV3U2l6ZSA9IG1heEluZmxhdGVTaXplIDwgb3V0cHV0Lmxlbmd0aCA/XG4gICAgICAgIG91dHB1dC5sZW5ndGggKyBtYXhJbmZsYXRlU2l6ZSA6XG4gICAgICAgIG91dHB1dC5sZW5ndGggPDwgMTtcbiAgfSBlbHNlIHtcbiAgICBuZXdTaXplID0gb3V0cHV0Lmxlbmd0aCAqIHJhdGlvO1xuICB9XG5cbiAgLy8gYnVmZmVyIGV4cGFudGlvblxuICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTtcbiAgICBidWZmZXIuc2V0KG91dHB1dCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gb3V0cHV0O1xuICB9XG5cbiAgdGhpcy5vdXRwdXQgPSBidWZmZXI7XG5cbiAgcmV0dXJuIHRoaXMub3V0cHV0O1xufTtcblxuLyoqXG4gKiBjb25jYXQgb3V0cHV0IGJ1ZmZlci5cbiAqIEByZXR1cm4geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBidWZmZXIuXG4gKi9cblpsaWIuUmF3SW5mbGF0ZS5wcm90b3R5cGUuY29uY2F0QnVmZmVyQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB2YXIgcG9zID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB2YXIgbGltaXQgPSB0aGlzLnRvdGFscG9zICsgKHRoaXMub3AgLSBabGliLlJhd0luZmxhdGUuTWF4QmFja3dhcmRMZW5ndGgpO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBibG9jayBhcnJheS4gKi9cbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICAvKiogQHR5cGUgeyFBcnJheX0gYmxvY2tzIGFycmF5LiAqL1xuICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gb3V0cHV0IGJsb2NrIGFycmF5LiAqL1xuICB2YXIgYmxvY2s7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgdmFyIGJ1ZmZlciA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKGxpbWl0KTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0ZXIuICovXG4gIHZhciBpbDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgdmFyIGo7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0ZXIuICovXG4gIHZhciBqbDtcblxuICAvLyBzaW5nbGUgYnVmZmVyXG4gIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID9cbiAgICAgICAgdGhpcy5vdXRwdXQuc3ViYXJyYXkoWmxpYi5SYXdJbmZsYXRlLk1heEJhY2t3YXJkTGVuZ3RoLCB0aGlzLm9wKSA6XG4gICAgICAgIHRoaXMub3V0cHV0LnNsaWNlKFpsaWIuUmF3SW5mbGF0ZS5NYXhCYWNrd2FyZExlbmd0aCwgdGhpcy5vcCk7XG4gIH1cblxuICAvLyBjb3B5IHRvIGJ1ZmZlclxuICBmb3IgKGkgPSAwLCBpbCA9IGJsb2Nrcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgZm9yIChqID0gMCwgamwgPSBibG9jay5sZW5ndGg7IGogPCBqbDsgKytqKSB7XG4gICAgICBidWZmZXJbcG9zKytdID0gYmxvY2tbal07XG4gICAgfVxuICB9XG5cbiAgLy8gY3VycmVudCBidWZmZXJcbiAgZm9yIChpID0gWmxpYi5SYXdJbmZsYXRlLk1heEJhY2t3YXJkTGVuZ3RoLCBpbCA9IHRoaXMub3A7IGkgPCBpbDsgKytpKSB7XG4gICAgYnVmZmVyW3BvcysrXSA9IG91dHB1dFtpXTtcbiAgfVxuXG4gIHRoaXMuYmxvY2tzID0gW107XG4gIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXG4gIHJldHVybiB0aGlzLmJ1ZmZlcjtcbn07XG5cbi8qKlxuICogY29uY2F0IG91dHB1dCBidWZmZXIuIChkeW5hbWljKVxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gb3V0cHV0IGJ1ZmZlci5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlLnByb3RvdHlwZS5jb25jYXRCdWZmZXJEeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj58VWludDhBcnJheX0gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgdmFyIGJ1ZmZlcjtcbiAgdmFyIG9wID0gdGhpcy5vcDtcblxuICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICBpZiAodGhpcy5yZXNpemUpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG9wKTtcbiAgICAgIGJ1ZmZlci5zZXQodGhpcy5vdXRwdXQuc3ViYXJyYXkoMCwgb3ApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gdGhpcy5vdXRwdXQuc3ViYXJyYXkoMCwgb3ApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoID4gb3ApIHtcbiAgICAgIHRoaXMub3V0cHV0Lmxlbmd0aCA9IG9wO1xuICAgIH1cbiAgICBidWZmZXIgPSB0aGlzLm91dHB1dDtcbiAgfVxuXG4gIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXG4gIHJldHVybiB0aGlzLmJ1ZmZlcjtcbn07XG5cblxuXG5cbnZhciBidWlsZEh1ZmZtYW5UYWJsZSA9IFpsaWIuSHVmZm1hbi5idWlsZEh1ZmZtYW5UYWJsZTtcblxuLyoqXG4gKiBAcGFyYW0geyEoVWludDhBcnJheXxBcnJheS48bnVtYmVyPil9IGlucHV0IGlucHV0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpcCBpbnB1dCBidWZmZXIgcG9pbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2J1ZmZlcnNpemUgYnVmZmVyIGJsb2NrIHNpemUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtID0gZnVuY3Rpb24oaW5wdXQsIGlwLCBvcHRfYnVmZmVyc2l6ZSkge1xuICAvKiogQHR5cGUgeyFBcnJheS48KEFycmF5fFVpbnQ4QXJyYXkpPn0gKi9cbiAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGJsb2NrIHNpemUuICovXG4gIHRoaXMuYnVmZmVyU2l6ZSA9XG4gICAgICBvcHRfYnVmZmVyc2l6ZSA/IG9wdF9idWZmZXJzaXplIDogWkxJQl9TVFJFQU1fUkFXX0lORkxBVEVfQlVGRkVSX1NJWkU7XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gdG90YWwgb3V0cHV0IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB0aGlzLnRvdGFscG9zID0gMDtcbiAgLyoqIEB0eXBlIHshbnVtYmVyfSBpbnB1dCBidWZmZXIgcG9pbnRlci4gKi9cbiAgdGhpcy5pcCA9IGlwID09PSB2b2lkIDAgPyAwIDogaXA7XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gYml0IHN0cmVhbSByZWFkZXIgYnVmZmVyLiAqL1xuICB0aGlzLmJpdHNidWYgPSAwO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9IGJpdCBzdHJlYW0gcmVhZGVyIGJ1ZmZlciBzaXplLiAqL1xuICB0aGlzLmJpdHNidWZsZW4gPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9IGlucHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5pbnB1dCA9IFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpIDogaW5wdXQ7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5KX0gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5vdXRwdXQgPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KSh0aGlzLmJ1ZmZlclNpemUpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9IG91dHB1dCBidWZmZXIgcG9pbnRlci4gKi9cbiAgdGhpcy5vcCA9IDA7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gaXMgZmluYWwgYmxvY2sgZmxhZy4gKi9cbiAgdGhpcy5iZmluYWwgPSBmYWxzZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IHVuY29tcHJlc3NlZCBibG9jayBsZW5ndGguICovXG4gIHRoaXMuYmxvY2tMZW5ndGg7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gcmVzaXplIGZsYWcgZm9yIG1lbW9yeSBzaXplIG9wdGltaXphdGlvbi4gKi9cbiAgdGhpcy5yZXNpemUgPSBmYWxzZTtcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgdGhpcy5saXRsZW5UYWJsZTtcbiAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgdGhpcy5kaXN0VGFibGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnNwID0gMDsgLy8gc3RyZWFtIHBvaW50ZXJcbiAgLyoqIEB0eXBlIHtabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzfSAqL1xuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuSU5JVElBTElaRUQ7XG5cbiAgLy9cbiAgLy8gYmFja3VwXG4gIC8vXG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gKi9cbiAgdGhpcy5pcF87XG4gIC8qKiBAdHlwZSB7IW51bWJlcn0gKi9cbiAgdGhpcy5iaXRzYnVmbGVuXztcbiAgLyoqIEB0eXBlIHshbnVtYmVyfSAqL1xuICB0aGlzLmJpdHNidWZfO1xufTtcblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0uQmxvY2tUeXBlID0ge1xuICBVTkNPTVBSRVNTRUQ6IDAsXG4gIEZJWEVEOiAxLFxuICBEWU5BTUlDOiAyXG59O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMgPSB7XG4gIElOSVRJQUxJWkVEOiAwLFxuICBCTE9DS19IRUFERVJfU1RBUlQ6IDEsXG4gIEJMT0NLX0hFQURFUl9FTkQ6IDIsXG4gIEJMT0NLX0JPRFlfU1RBUlQ6IDMsXG4gIEJMT0NLX0JPRFlfRU5EOiA0LFxuICBERUNPREVfQkxPQ0tfU1RBUlQ6IDUsXG4gIERFQ09ERV9CTE9DS19FTkQ6IDZcbn07XG5cbi8qKlxuICogZGVjb21wcmVzcy5cbiAqIEByZXR1cm4geyEoVWludDhBcnJheXxBcnJheSl9IGluZmxhdGVkIGJ1ZmZlci5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLnByb3RvdHlwZS5kZWNvbXByZXNzID0gZnVuY3Rpb24obmV3SW5wdXQsIGlwKSB7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdmFyIHN0b3AgPSBmYWxzZTtcblxuICBpZiAobmV3SW5wdXQgIT09IHZvaWQgMCkge1xuICAgIHRoaXMuaW5wdXQgPSBuZXdJbnB1dDtcbiAgfVxuXG4gIGlmIChpcCAhPT0gdm9pZCAwKSB7XG4gICAgdGhpcy5pcCA9IGlwO1xuICB9XG5cbiAgLy8gZGVjb21wcmVzc1xuICB3aGlsZSAoIXN0b3ApIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgIC8vIGJsb2NrIGhlYWRlclxuICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLklOSVRJQUxJWkVEOlxuICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLkJMT0NLX0hFQURFUl9TVEFSVDpcbiAgICAgICAgaWYgKHRoaXMucmVhZEJsb2NrSGVhZGVyKCkgPCAwKSB7XG4gICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGJsb2NrIGJvZHlcbiAgICAgIGNhc2UgWmxpYi5SYXdJbmZsYXRlU3RyZWFtLlN0YXR1cy5CTE9DS19IRUFERVJfRU5EOiAvKiBGQUxMVEhST1VHSCAqL1xuICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLkJMT0NLX0JPRFlfU1RBUlQ6XG4gICAgICAgIHN3aXRjaCh0aGlzLmN1cnJlbnRCbG9ja1R5cGUpIHtcbiAgICAgICAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5CbG9ja1R5cGUuVU5DT01QUkVTU0VEOlxuICAgICAgICAgICAgaWYgKHRoaXMucmVhZFVuY29tcHJlc3NlZEJsb2NrSGVhZGVyKCkgPCAwKSB7XG4gICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uQmxvY2tUeXBlLkZJWEVEOlxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VGaXhlZEh1ZmZtYW5CbG9jaygpIDwgMCkge1xuICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkJsb2NrVHlwZS5EWU5BTUlDOlxuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VEeW5hbWljSHVmZm1hbkJsb2NrKCkgPCAwKSB7XG4gICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGRlY29kZSBkYXRhXG4gICAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuQkxPQ0tfQk9EWV9FTkQ6XG4gICAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuREVDT0RFX0JMT0NLX1NUQVJUOlxuICAgICAgICBzd2l0Y2godGhpcy5jdXJyZW50QmxvY2tUeXBlKSB7XG4gICAgICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uQmxvY2tUeXBlLlVOQ09NUFJFU1NFRDpcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlVW5jb21wcmVzc2VkQmxvY2soKSA8IDApIHtcbiAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5CbG9ja1R5cGUuRklYRUQ6IC8qIEZBTExUSFJPVUdIICovXG4gICAgICAgICAgY2FzZSBabGliLlJhd0luZmxhdGVTdHJlYW0uQmxvY2tUeXBlLkRZTkFNSUM6XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVIdWZmbWFuKCkgPCAwKSB7XG4gICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuREVDT0RFX0JMT0NLX0VORDpcbiAgICAgICAgaWYgKHRoaXMuYmZpbmFsKSB7XG4gICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLklOSVRJQUxJWkVEO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmNvbmNhdEJ1ZmZlcigpO1xufTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9IG1heCBiYWNrd2FyZCBsZW5ndGggZm9yIExaNzcuXG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5NYXhCYWNrd2FyZExlbmd0aCA9IDMyNzY4O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn0gbWF4IGNvcHkgbGVuZ3RoIGZvciBMWjc3LlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0uTWF4Q29weUxlbmd0aCA9IDI1ODtcblxuLyoqXG4gKiBodWZmbWFuIG9yZGVyXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfVxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0uT3JkZXIgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQxNkFycmF5KHRhYmxlKSA6IHRhYmxlO1xufSkoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcblxuLyoqXG4gKiBodWZmbWFuIGxlbmd0aCBjb2RlIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5MZW5ndGhDb2RlVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQxNkFycmF5KHRhYmxlKSA6IHRhYmxlO1xufSkoW1xuICAweDAwMDMsIDB4MDAwNCwgMHgwMDA1LCAweDAwMDYsIDB4MDAwNywgMHgwMDA4LCAweDAwMDksIDB4MDAwYSwgMHgwMDBiLFxuICAweDAwMGQsIDB4MDAwZiwgMHgwMDExLCAweDAwMTMsIDB4MDAxNywgMHgwMDFiLCAweDAwMWYsIDB4MDAyMywgMHgwMDJiLFxuICAweDAwMzMsIDB4MDAzYiwgMHgwMDQzLCAweDAwNTMsIDB4MDA2MywgMHgwMDczLCAweDAwODMsIDB4MDBhMywgMHgwMGMzLFxuICAweDAwZTMsIDB4MDEwMiwgMHgwMTAyLCAweDAxMDJcbl0pO1xuXG4vKipcbiAqIGh1ZmZtYW4gbGVuZ3RoIGV4dHJhLWJpdHMgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfVxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0uTGVuZ3RoRXh0cmFUYWJsZSA9IChmdW5jdGlvbih0YWJsZSkge1xuICByZXR1cm4gVVNFX1RZUEVEQVJSQVkgPyBuZXcgVWludDhBcnJheSh0YWJsZSkgOiB0YWJsZTtcbn0pKFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSxcbiAgNSwgNSwgMCwgMCwgMFxuXSk7XG5cbi8qKlxuICogaHVmZm1hbiBkaXN0IGNvZGUgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX1cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkRpc3RDb2RlVGFibGUgPSAoZnVuY3Rpb24odGFibGUpIHtcbiAgcmV0dXJuIFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQxNkFycmF5KHRhYmxlKSA6IHRhYmxlO1xufSkoW1xuICAweDAwMDEsIDB4MDAwMiwgMHgwMDAzLCAweDAwMDQsIDB4MDAwNSwgMHgwMDA3LCAweDAwMDksIDB4MDAwZCwgMHgwMDExLFxuICAweDAwMTksIDB4MDAyMSwgMHgwMDMxLCAweDAwNDEsIDB4MDA2MSwgMHgwMDgxLCAweDAwYzEsIDB4MDEwMSwgMHgwMTgxLFxuICAweDAyMDEsIDB4MDMwMSwgMHgwNDAxLCAweDA2MDEsIDB4MDgwMSwgMHgwYzAxLCAweDEwMDEsIDB4MTgwMSwgMHgyMDAxLFxuICAweDMwMDEsIDB4NDAwMSwgMHg2MDAxXG5dKTtcblxuLyoqXG4gKiBodWZmbWFuIGRpc3QgZXh0cmEtYml0cyB0YWJsZS5cbiAqIEBjb25zdFxuICogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5EaXN0RXh0cmFUYWJsZSA9IChmdW5jdGlvbih0YWJsZSkge1xuICByZXR1cm4gVVNFX1RZUEVEQVJSQVkgPyBuZXcgVWludDhBcnJheSh0YWJsZSkgOiB0YWJsZTtcbn0pKFtcbiAgMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSxcbiAgMTEsIDEyLCAxMiwgMTMsIDEzXG5dKTtcblxuLyoqXG4gKiBmaXhlZCBodWZmbWFuIGxlbmd0aCBjb2RlIHRhYmxlXG4gKiBAY29uc3RcbiAqIEB0eXBlIHshQXJyYXl9XG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5GaXhlZExpdGVyYWxMZW5ndGhUYWJsZSA9IChmdW5jdGlvbih0YWJsZSkge1xuICByZXR1cm4gdGFibGU7XG59KSgoZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGhzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoMjg4KTtcbiAgdmFyIGksIGlsO1xuXG4gIGZvciAoaSA9IDAsIGlsID0gbGVuZ3Rocy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgbGVuZ3Roc1tpXSA9XG4gICAgICAgIChpIDw9IDE0MykgPyA4IDpcbiAgICAgICAgICAgIChpIDw9IDI1NSkgPyA5IDpcbiAgICAgICAgICAgICAgICAoaSA8PSAyNzkpID8gNyA6XG4gICAgICAgICAgICAgICAgICAgIDg7XG4gIH1cblxuICByZXR1cm4gYnVpbGRIdWZmbWFuVGFibGUobGVuZ3Rocyk7XG59KSgpKTtcblxuLyoqXG4gKiBmaXhlZCBodWZmbWFuIGRpc3RhbmNlIGNvZGUgdGFibGVcbiAqIEBjb25zdFxuICogQHR5cGUgeyFBcnJheX1cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkZpeGVkRGlzdGFuY2VUYWJsZSA9IChmdW5jdGlvbih0YWJsZSkge1xuICByZXR1cm4gdGFibGU7XG59KSgoZnVuY3Rpb24oKSB7XG4gIHZhciBsZW5ndGhzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoMzApO1xuICB2YXIgaSwgaWw7XG5cbiAgZm9yIChpID0gMCwgaWwgPSBsZW5ndGhzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICBsZW5ndGhzW2ldID0gNTtcbiAgfVxuXG4gIHJldHVybiBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhzKTtcbn0pKCkpO1xuXG4vKipcbiAqIHBhcnNlIGRlZmxhdGVkIGJsb2NrLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLnJlYWRCbG9ja0hlYWRlciA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge251bWJlcn0gaGVhZGVyICovXG4gIHZhciBoZHI7XG5cbiAgdGhpcy5zdGF0dXMgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLkJMT0NLX0hFQURFUl9TVEFSVDtcblxuICB0aGlzLnNhdmVfKCk7XG4gIGlmICgoaGRyID0gdGhpcy5yZWFkQml0cygzKSkgPCAwKSB7XG4gICAgdGhpcy5yZXN0b3JlXygpO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIEJGSU5BTFxuICBpZiAoaGRyICYgMHgxKSB7XG4gICAgdGhpcy5iZmluYWwgPSB0cnVlO1xuICB9XG5cbiAgLy8gQlRZUEVcbiAgaGRyID4+Pj0gMTtcbiAgc3dpdGNoIChoZHIpIHtcbiAgICBjYXNlIDA6IC8vIHVuY29tcHJlc3NlZFxuICAgICAgdGhpcy5jdXJyZW50QmxvY2tUeXBlID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkJsb2NrVHlwZS5VTkNPTVBSRVNTRUQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6IC8vIGZpeGVkIGh1ZmZtYW5cbiAgICAgIHRoaXMuY3VycmVudEJsb2NrVHlwZSA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5CbG9ja1R5cGUuRklYRUQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6IC8vIGR5bmFtaWMgaHVmZm1hblxuICAgICAgdGhpcy5jdXJyZW50QmxvY2tUeXBlID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkJsb2NrVHlwZS5EWU5BTUlDO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gcmVzZXJ2ZWQgb3Igb3RoZXJcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBCVFlQRTogJyArIGhkcik7XG4gIH1cblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuQkxPQ0tfSEVBREVSX0VORDtcbn07XG5cbi8qKlxuICogcmVhZCBpbmZsYXRlIGJpdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggYml0cyBsZW5ndGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJlYWQgYml0cy5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkQml0cyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICB2YXIgYml0c2J1ZiA9IHRoaXMuYml0c2J1ZjtcbiAgdmFyIGJpdHNidWZsZW4gPSB0aGlzLmJpdHNidWZsZW47XG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG5cbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IGFuZCBvdXRwdXQgYnl0ZS4gKi9cbiAgdmFyIG9jdGV0O1xuXG4gIC8vIG5vdCBlbm91Z2ggYnVmZmVyXG4gIHdoaWxlIChiaXRzYnVmbGVuIDwgbGVuZ3RoKSB7XG4gICAgLy8gaW5wdXQgYnl0ZVxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gaXApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgb2N0ZXQgPSBpbnB1dFtpcCsrXTtcblxuICAgIC8vIGNvbmNhdCBvY3RldFxuICAgIGJpdHNidWYgfD0gb2N0ZXQgPDwgYml0c2J1ZmxlbjtcbiAgICBiaXRzYnVmbGVuICs9IDg7XG4gIH1cblxuICAvLyBvdXRwdXQgYnl0ZVxuICBvY3RldCA9IGJpdHNidWYgJiAvKiBNQVNLICovICgoMSA8PCBsZW5ndGgpIC0gMSk7XG4gIGJpdHNidWYgPj4+PSBsZW5ndGg7XG4gIGJpdHNidWZsZW4gLT0gbGVuZ3RoO1xuXG4gIHRoaXMuYml0c2J1ZiA9IGJpdHNidWY7XG4gIHRoaXMuYml0c2J1ZmxlbiA9IGJpdHNidWZsZW47XG4gIHRoaXMuaXAgPSBpcDtcblxuICByZXR1cm4gb2N0ZXQ7XG59O1xuXG4vKipcbiAqIHJlYWQgaHVmZm1hbiBjb2RlIHVzaW5nIHRhYmxlXG4gKiBAcGFyYW0ge0FycmF5fSB0YWJsZSBodWZmbWFuIGNvZGUgdGFibGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGh1ZmZtYW4gY29kZS5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkQ29kZUJ5VGFibGUgPSBmdW5jdGlvbih0YWJsZSkge1xuICB2YXIgYml0c2J1ZiA9IHRoaXMuYml0c2J1ZjtcbiAgdmFyIGJpdHNidWZsZW4gPSB0aGlzLmJpdHNidWZsZW47XG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG5cbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBodWZmbWFuIGNvZGUgdGFibGUgKi9cbiAgdmFyIGNvZGVUYWJsZSA9IHRhYmxlWzBdO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIG1heENvZGVMZW5ndGggPSB0YWJsZVsxXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IGJ5dGUgKi9cbiAgdmFyIG9jdGV0O1xuICAvKiogQHR5cGUge251bWJlcn0gY29kZSBsZW5ndGggJiBjb2RlICgxNmJpdCwgMTZiaXQpICovXG4gIHZhciBjb2RlV2l0aExlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNvZGUgYml0cyBsZW5ndGggKi9cbiAgdmFyIGNvZGVMZW5ndGg7XG5cbiAgLy8gbm90IGVub3VnaCBidWZmZXJcbiAgd2hpbGUgKGJpdHNidWZsZW4gPCBtYXhDb2RlTGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSBpcCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBvY3RldCA9IGlucHV0W2lwKytdO1xuICAgIGJpdHNidWYgfD0gb2N0ZXQgPDwgYml0c2J1ZmxlbjtcbiAgICBiaXRzYnVmbGVuICs9IDg7XG4gIH1cblxuICAvLyByZWFkIG1heCBsZW5ndGhcbiAgY29kZVdpdGhMZW5ndGggPSBjb2RlVGFibGVbYml0c2J1ZiAmICgoMSA8PCBtYXhDb2RlTGVuZ3RoKSAtIDEpXTtcbiAgY29kZUxlbmd0aCA9IGNvZGVXaXRoTGVuZ3RoID4+PiAxNjtcblxuICBpZiAoY29kZUxlbmd0aCA+IGJpdHNidWZsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29kZSBsZW5ndGg6ICcgKyBjb2RlTGVuZ3RoKTtcbiAgfVxuXG4gIHRoaXMuYml0c2J1ZiA9IGJpdHNidWYgPj4gY29kZUxlbmd0aDtcbiAgdGhpcy5iaXRzYnVmbGVuID0gYml0c2J1ZmxlbiAtIGNvZGVMZW5ndGg7XG4gIHRoaXMuaXAgPSBpcDtcblxuICByZXR1cm4gY29kZVdpdGhMZW5ndGggJiAweGZmZmY7XG59O1xuXG4vKipcbiAqIHJlYWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlclxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLnJlYWRVbmNvbXByZXNzZWRCbG9ja0hlYWRlciA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge251bWJlcn0gYmxvY2sgbGVuZ3RoICovXG4gIHZhciBsZW47XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgZm9yIGNoZWNrIGJsb2NrIGxlbmd0aCAqL1xuICB2YXIgbmxlbjtcblxuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICB2YXIgaXAgPSB0aGlzLmlwO1xuXG4gIHRoaXMuc3RhdHVzID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLlN0YXR1cy5CTE9DS19CT0RZX1NUQVJUO1xuXG4gIGlmIChpcCArIDQgPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgbGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG4gIG5sZW4gPSBpbnB1dFtpcCsrXSB8IChpbnB1dFtpcCsrXSA8PCA4KTtcblxuICAvLyBjaGVjayBsZW4gJiBubGVuXG4gIGlmIChsZW4gPT09IH5ubGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IGxlbmd0aCB2ZXJpZnknKTtcbiAgfVxuXG4gIC8vIHNraXAgYnVmZmVyZWQgaGVhZGVyIGJpdHNcbiAgdGhpcy5iaXRzYnVmID0gMDtcbiAgdGhpcy5iaXRzYnVmbGVuID0gMDtcblxuICB0aGlzLmlwID0gaXA7XG4gIHRoaXMuYmxvY2tMZW5ndGggPSBsZW47XG4gIHRoaXMuc3RhdHVzID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLlN0YXR1cy5CTE9DS19CT0RZX0VORDtcbn07XG5cbi8qKlxuICogcGFyc2UgdW5jb21wcmVzc2VkIGJsb2NrLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLnBhcnNlVW5jb21wcmVzc2VkQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgdmFyIGlwID0gdGhpcy5pcDtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICB2YXIgb3AgPSB0aGlzLm9wO1xuICB2YXIgbGVuID0gdGhpcy5ibG9ja0xlbmd0aDtcblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuREVDT0RFX0JMT0NLX1NUQVJUO1xuXG4gIC8vIGNvcHlcbiAgLy8gWFhYOiDjgajjgorjgYLjgYjjgZrntKDnm7TjgavjgrPjg5Tjg7xcbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaWYgKG9wID09PSBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICBvdXRwdXQgPSB0aGlzLmV4cGFuZEJ1ZmZlcih7Zml4UmF0aW86IDJ9KTtcbiAgICB9XG5cbiAgICAvLyBub3QgZW5vdWdoIGlucHV0IGJ1ZmZlclxuICAgIGlmIChpcCA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaXAgPSBpcDtcbiAgICAgIHRoaXMub3AgPSBvcDtcbiAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBsZW4gKyAxOyAvLyDjgrPjg5Tjg7zjgZfjgabjgarjgYTjga7jgafmiLvjgZlcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBvdXRwdXRbb3ArK10gPSBpbnB1dFtpcCsrXTtcbiAgfVxuXG4gIGlmIChsZW4gPCAwKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLkRFQ09ERV9CTE9DS19FTkQ7XG4gIH1cblxuICB0aGlzLmlwID0gaXA7XG4gIHRoaXMub3AgPSBvcDtcblxuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogcGFyc2UgZml4ZWQgaHVmZm1hbiBibG9jay5cbiAqL1xuWmxpYi5SYXdJbmZsYXRlU3RyZWFtLnByb3RvdHlwZS5wYXJzZUZpeGVkSHVmZm1hbkJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdHVzID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLlN0YXR1cy5CTE9DS19CT0RZX1NUQVJUO1xuXG4gIHRoaXMubGl0bGVuVGFibGUgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uRml4ZWRMaXRlcmFsTGVuZ3RoVGFibGU7XG4gIHRoaXMuZGlzdFRhYmxlID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkZpeGVkRGlzdGFuY2VUYWJsZTtcblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuQkxPQ0tfQk9EWV9FTkQ7XG5cbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIOOCquODluOCuOOCp+OCr+ODiOOBruOCs+ODs+ODhuOCreOCueODiOOCkuWIpeOBruODl+ODreODkeODhuOCo+OBq+mAgOmBv+OBmeOCiy5cbiAqIEBwcml2YXRlXG4gKi9cblpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5wcm90b3R5cGUuc2F2ZV8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pcF8gPSB0aGlzLmlwO1xuICB0aGlzLmJpdHNidWZsZW5fID0gdGhpcy5iaXRzYnVmbGVuO1xuICB0aGlzLmJpdHNidWZfID0gdGhpcy5iaXRzYnVmO1xufTtcblxuLyoqXG4gKiDliKXjga7jg5fjg63jg5Hjg4bjgqPjgavpgIDpgb/jgZfjgZ/jgrPjg7Pjg4bjgq3jgrnjg4jjgpLlvqnlhYPjgZnjgosuXG4gKiBAcHJpdmF0ZVxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLnJlc3RvcmVfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXAgPSB0aGlzLmlwXztcbiAgdGhpcy5iaXRzYnVmbGVuID0gdGhpcy5iaXRzYnVmbGVuXztcbiAgdGhpcy5iaXRzYnVmID0gdGhpcy5iaXRzYnVmXztcbn07XG5cbi8qKlxuICogcGFyc2UgZHluYW1pYyBodWZmbWFuIGJsb2NrLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLnBhcnNlRHluYW1pY0h1ZmZtYW5CbG9jayA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge251bWJlcn0gbnVtYmVyIG9mIGxpdGVyYWwgYW5kIGxlbmd0aCBjb2Rlcy4gKi9cbiAgdmFyIGhsaXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMuICovXG4gIHZhciBoZGlzdDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG51bWJlciBvZiBjb2RlIGxlbmd0aHMuICovXG4gIHZhciBoY2xlbjtcbiAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkpfSBjb2RlIGxlbmd0aHMuICovXG4gIHZhciBjb2RlTGVuZ3RocyA9XG4gICAgICBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KShabGliLlJhd0luZmxhdGVTdHJlYW0uT3JkZXIubGVuZ3RoKTtcbiAgLyoqIEB0eXBlIHshQXJyYXl9IGNvZGUgbGVuZ3RocyB0YWJsZS4gKi9cbiAgdmFyIGNvZGVMZW5ndGhzVGFibGU7XG4gIC8qKiBAdHlwZSB7IShVaW50MzJBcnJheXxBcnJheSl9IGxpdGVyYWwgYW5kIGxlbmd0aCBjb2RlIGxlbmd0aHMuICovXG4gIHZhciBsaXRsZW5MZW5ndGhzO1xuICAvKiogQHR5cGUgeyEoVWludDMyQXJyYXl8QXJyYXkpfSBkaXN0YW5jZSBjb2RlIGxlbmd0aHMuICovXG4gIHZhciBkaXN0TGVuZ3RocztcblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuQkxPQ0tfQk9EWV9TVEFSVDtcblxuICB0aGlzLnNhdmVfKCk7XG4gIGhsaXQgPSB0aGlzLnJlYWRCaXRzKDUpICsgMjU3O1xuICBoZGlzdCA9IHRoaXMucmVhZEJpdHMoNSkgKyAxO1xuICBoY2xlbiA9IHRoaXMucmVhZEJpdHMoNCkgKyA0O1xuICBpZiAoaGxpdCA8IDAgfHwgaGRpc3QgPCAwIHx8IGhjbGVuIDwgMCkge1xuICAgIHRoaXMucmVzdG9yZV8oKTtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB0cnkge1xuICAgIHBhcnNlRHluYW1pY0h1ZmZtYW5CbG9ja0ltcGwuY2FsbCh0aGlzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgdGhpcy5yZXN0b3JlXygpO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRHluYW1pY0h1ZmZtYW5CbG9ja0ltcGwoKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGJpdHM7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIHByZXYgPSAwO1xuICAgIHZhciByZXBlYXQ7XG4gICAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkuPG51bWJlcj4pfSBjb2RlIGxlbmd0aCB0YWJsZS4gKi9cbiAgICB2YXIgbGVuZ3RoVGFibGU7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgICB2YXIgaTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsaW1pdC4gKi9cbiAgICB2YXIgaWw7XG5cbiAgICAvLyBkZWNvZGUgY29kZSBsZW5ndGhzXG4gICAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyArK2kpIHtcbiAgICAgIGlmICgoYml0cyA9IHRoaXMucmVhZEJpdHMoMykpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBlbm91Z2ggaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIGNvZGVMZW5ndGhzW1psaWIuUmF3SW5mbGF0ZVN0cmVhbS5PcmRlcltpXV0gPSBiaXRzO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBsZW5ndGggdGFibGVcbiAgICBjb2RlTGVuZ3Roc1RhYmxlID0gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMpO1xuICAgIGxlbmd0aFRhYmxlID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoaGxpdCArIGhkaXN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbCA9IGhsaXQgKyBoZGlzdDsgaSA8IGlsOykge1xuICAgICAgY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGNvZGVMZW5ndGhzVGFibGUpO1xuICAgICAgaWYgKGNvZGUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGVub3VnaCBpbnB1dCcpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgaWYgKChiaXRzID0gdGhpcy5yZWFkQml0cygyKSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBlbm91Z2ggaW5wdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwZWF0ID0gMyArIGJpdHM7XG4gICAgICAgICAgd2hpbGUgKHJlcGVhdC0tKSB7IGxlbmd0aFRhYmxlW2krK10gPSBwcmV2OyB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgaWYgKChiaXRzID0gdGhpcy5yZWFkQml0cygzKSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBlbm91Z2ggaW5wdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwZWF0ID0gMyArIGJpdHM7XG4gICAgICAgICAgd2hpbGUgKHJlcGVhdC0tKSB7IGxlbmd0aFRhYmxlW2krK10gPSAwOyB9XG4gICAgICAgICAgcHJldiA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgaWYgKChiaXRzID0gdGhpcy5yZWFkQml0cyg3KSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBlbm91Z2ggaW5wdXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwZWF0ID0gMTEgKyBiaXRzO1xuICAgICAgICAgIHdoaWxlIChyZXBlYXQtLSkgeyBsZW5ndGhUYWJsZVtpKytdID0gMDsgfVxuICAgICAgICAgIHByZXYgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxlbmd0aFRhYmxlW2krK10gPSBjb2RlO1xuICAgICAgICAgIHByZXYgPSBjb2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpdGVyYWwgYW5kIGxlbmd0aCBjb2RlXG4gICAgbGl0bGVuTGVuZ3RocyA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKGhsaXQpO1xuXG4gICAgLy8gZGlzdGFuY2UgY29kZVxuICAgIGRpc3RMZW5ndGhzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoaGRpc3QpO1xuXG4gICAgdGhpcy5saXRsZW5UYWJsZSA9IFVTRV9UWVBFREFSUkFZXG4gICAgICAgID8gYnVpbGRIdWZmbWFuVGFibGUobGVuZ3RoVGFibGUuc3ViYXJyYXkoMCwgaGxpdCkpXG4gICAgICAgIDogYnVpbGRIdWZmbWFuVGFibGUobGVuZ3RoVGFibGUuc2xpY2UoMCwgaGxpdCkpO1xuICAgIHRoaXMuZGlzdFRhYmxlID0gVVNFX1RZUEVEQVJSQVlcbiAgICAgICAgPyBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhUYWJsZS5zdWJhcnJheShobGl0KSlcbiAgICAgICAgOiBidWlsZEh1ZmZtYW5UYWJsZShsZW5ndGhUYWJsZS5zbGljZShobGl0KSk7XG4gIH1cblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuQkxPQ0tfQk9EWV9FTkQ7XG5cbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIGRlY29kZSBodWZmbWFuIGNvZGUgKGR5bmFtaWMpXG4gKiBAcmV0dXJuIHsobnVtYmVyfHVuZGVmaW5lZCl9IC0xIGlzIGVycm9yLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLmRlY29kZUh1ZmZtYW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICB2YXIgb3AgPSB0aGlzLm9wO1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBodWZmbWFuIGNvZGUuICovXG4gIHZhciBjb2RlO1xuICAvKiogQHR5cGUge251bWJlcn0gdGFibGUgaW5kZXguICovXG4gIHZhciB0aTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGh1ZmZtYW4gY29kZSBkaXN0aW5hdGlvbi4gKi9cbiAgdmFyIGNvZGVEaXN0O1xuICAvKiogQHR5cGUge251bWJlcn0gaHVmZm1hbiBjb2RlIGxlbmd0aC4gKi9cbiAgdmFyIGNvZGVMZW5ndGg7XG5cbiAgdmFyIGxpdGxlbiA9IHRoaXMubGl0bGVuVGFibGU7XG4gIHZhciBkaXN0ID0gdGhpcy5kaXN0VGFibGU7XG5cbiAgdmFyIG9sZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICB2YXIgYml0cztcblxuICB0aGlzLnN0YXR1cyA9IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5TdGF0dXMuREVDT0RFX0JMT0NLX1NUQVJUO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdGhpcy5zYXZlXygpO1xuXG4gICAgY29kZSA9IHRoaXMucmVhZENvZGVCeVRhYmxlKGxpdGxlbik7XG4gICAgaWYgKGNvZGUgPCAwKSB7XG4gICAgICB0aGlzLm9wID0gb3A7XG4gICAgICB0aGlzLnJlc3RvcmVfKCk7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDI1Nikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gbGl0ZXJhbFxuICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICBpZiAob3AgPT09IG9sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0ID0gdGhpcy5leHBhbmRCdWZmZXIoKTtcbiAgICAgICAgb2xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBvdXRwdXRbb3ArK10gPSBjb2RlO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsZW5ndGggY29kZVxuICAgIHRpID0gY29kZSAtIDI1NztcbiAgICBjb2RlTGVuZ3RoID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkxlbmd0aENvZGVUYWJsZVt0aV07XG4gICAgaWYgKFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5MZW5ndGhFeHRyYVRhYmxlW3RpXSA+IDApIHtcbiAgICAgIGJpdHMgPSB0aGlzLnJlYWRCaXRzKFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5MZW5ndGhFeHRyYVRhYmxlW3RpXSk7XG4gICAgICBpZiAoYml0cyA8IDApIHtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLnJlc3RvcmVfKCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvZGVMZW5ndGggKz0gYml0cztcbiAgICB9XG5cbiAgICAvLyBkaXN0IGNvZGVcbiAgICBjb2RlID0gdGhpcy5yZWFkQ29kZUJ5VGFibGUoZGlzdCk7XG4gICAgaWYgKGNvZGUgPCAwKSB7XG4gICAgICB0aGlzLm9wID0gb3A7XG4gICAgICB0aGlzLnJlc3RvcmVfKCk7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvZGVEaXN0ID0gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLkRpc3RDb2RlVGFibGVbY29kZV07XG4gICAgaWYgKFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5EaXN0RXh0cmFUYWJsZVtjb2RlXSA+IDApIHtcbiAgICAgIGJpdHMgPSB0aGlzLnJlYWRCaXRzKFpsaWIuUmF3SW5mbGF0ZVN0cmVhbS5EaXN0RXh0cmFUYWJsZVtjb2RlXSk7XG4gICAgICBpZiAoYml0cyA8IDApIHtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLnJlc3RvcmVfKCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvZGVEaXN0ICs9IGJpdHM7XG4gICAgfVxuXG4gICAgLy8gbHo3NyBkZWNvZGVcbiAgICBpZiAob3AgKyBjb2RlTGVuZ3RoID49IG9sZW5ndGgpIHtcbiAgICAgIG91dHB1dCA9IHRoaXMuZXhwYW5kQnVmZmVyKCk7XG4gICAgICBvbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICB3aGlsZSAoY29kZUxlbmd0aC0tKSB7XG4gICAgICBvdXRwdXRbb3BdID0gb3V0cHV0WyhvcCsrKSAtIGNvZGVEaXN0XTtcbiAgICB9XG5cbiAgICAvLyBicmVha1xuICAgIGlmICh0aGlzLmlwID09PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0aGlzLmJpdHNidWZsZW4gPj0gOCkge1xuICAgIHRoaXMuYml0c2J1ZmxlbiAtPSA4O1xuICAgIHRoaXMuaXAtLTtcbiAgfVxuXG4gIHRoaXMub3AgPSBvcDtcbiAgdGhpcy5zdGF0dXMgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uU3RhdHVzLkRFQ09ERV9CTE9DS19FTkQ7XG59O1xuXG4vKipcbiAqIGV4cGFuZCBvdXRwdXQgYnVmZmVyLiAoZHluYW1pYylcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtIG9wdGlvbiBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7IShBcnJheXxVaW50OEFycmF5KX0gb3V0cHV0IGJ1ZmZlciBwb2ludGVyLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLmV4cGFuZEJ1ZmZlciA9IGZ1bmN0aW9uKG9wdF9wYXJhbSkge1xuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9IHN0b3JlIGJ1ZmZlci4gKi9cbiAgdmFyIGJ1ZmZlcjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGV4cGFudGlvbiByYXRpby4gKi9cbiAgdmFyIHJhdGlvID0gKHRoaXMuaW5wdXQubGVuZ3RoIC8gdGhpcy5pcCArIDEpIHwgMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG1heGltdW0gbnVtYmVyIG9mIGh1ZmZtYW4gY29kZS4gKi9cbiAgdmFyIG1heEh1ZmZDb2RlO1xuICAvKiogQHR5cGUge251bWJlcn0gbmV3IG91dHB1dCBidWZmZXIgc2l6ZS4gKi9cbiAgdmFyIG5ld1NpemU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBtYXggaW5mbGF0ZSBzaXplLiAqL1xuICB2YXIgbWF4SW5mbGF0ZVNpemU7XG5cbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuXG4gIGlmIChvcHRfcGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIG9wdF9wYXJhbS5maXhSYXRpbyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJhdGlvID0gb3B0X3BhcmFtLmZpeFJhdGlvO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdF9wYXJhbS5hZGRSYXRpbyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJhdGlvICs9IG9wdF9wYXJhbS5hZGRSYXRpbztcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgbmV3IGJ1ZmZlciBzaXplXG4gIGlmIChyYXRpbyA8IDIpIHtcbiAgICBtYXhIdWZmQ29kZSA9XG4gICAgICAgIChpbnB1dC5sZW5ndGggLSB0aGlzLmlwKSAvIHRoaXMubGl0bGVuVGFibGVbMl07XG4gICAgbWF4SW5mbGF0ZVNpemUgPSAobWF4SHVmZkNvZGUgLyAyICogMjU4KSB8IDA7XG4gICAgbmV3U2l6ZSA9IG1heEluZmxhdGVTaXplIDwgb3V0cHV0Lmxlbmd0aCA/XG4gICAgICAgIG91dHB1dC5sZW5ndGggKyBtYXhJbmZsYXRlU2l6ZSA6XG4gICAgICAgIG91dHB1dC5sZW5ndGggPDwgMTtcbiAgfSBlbHNlIHtcbiAgICBuZXdTaXplID0gb3V0cHV0Lmxlbmd0aCAqIHJhdGlvO1xuICB9XG5cbiAgLy8gYnVmZmVyIGV4cGFudGlvblxuICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTtcbiAgICBidWZmZXIuc2V0KG91dHB1dCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gb3V0cHV0O1xuICB9XG5cbiAgdGhpcy5vdXRwdXQgPSBidWZmZXI7XG5cbiAgcmV0dXJuIHRoaXMub3V0cHV0O1xufTtcblxuLyoqXG4gKiBjb25jYXQgb3V0cHV0IGJ1ZmZlci4gKGR5bmFtaWMpXG4gKiBAcmV0dXJuIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBvdXRwdXQgYnVmZmVyLlxuICovXG5abGliLlJhd0luZmxhdGVTdHJlYW0ucHJvdG90eXBlLmNvbmNhdEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9IG91dHB1dCBidWZmZXIuICovXG4gIHZhciBidWZmZXI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgb3AgPSB0aGlzLm9wO1xuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIHZhciB0bXA7XG5cbiAgaWYgKHRoaXMucmVzaXplKSB7XG4gICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dC5zdWJhcnJheSh0aGlzLnNwLCBvcCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSB0aGlzLm91dHB1dC5zbGljZSh0aGlzLnNwLCBvcCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9XG4gICAgICAgIFVTRV9UWVBFREFSUkFZID8gdGhpcy5vdXRwdXQuc3ViYXJyYXkodGhpcy5zcCwgb3ApIDogdGhpcy5vdXRwdXQuc2xpY2UodGhpcy5zcCwgb3ApO1xuICB9XG5cbiAgdGhpcy5zcCA9IG9wO1xuXG4gIC8vIGNvbXBhY3Rpb25cbiAgaWYgKG9wID4gWmxpYi5SYXdJbmZsYXRlU3RyZWFtLk1heEJhY2t3YXJkTGVuZ3RoICsgdGhpcy5idWZmZXJTaXplKSB7XG4gICAgdGhpcy5vcCA9IHRoaXMuc3AgPSBabGliLlJhd0luZmxhdGVTdHJlYW0uTWF4QmFja3dhcmRMZW5ndGg7XG4gICAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgICB0bXAgPSAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovKHRoaXMub3V0cHV0KTtcbiAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJTaXplICsgWmxpYi5SYXdJbmZsYXRlU3RyZWFtLk1heEJhY2t3YXJkTGVuZ3RoKTtcbiAgICAgIHRoaXMub3V0cHV0LnNldCh0bXAuc3ViYXJyYXkob3AgLSBabGliLlJhd0luZmxhdGVTdHJlYW0uTWF4QmFja3dhcmRMZW5ndGgsIG9wKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQuc2xpY2Uob3AgLSBabGliLlJhd0luZmxhdGVTdHJlYW0uTWF4QmFja3dhcmRMZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyEoVWludDhBcnJheXxBcnJheSl9IGlucHV0IGRlZmxhdGVkIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBvcHRpb24gcGFyYW1ldGVycy5cbiAqXG4gKiBvcHRfcGFyYW1zIOOBr+S7peS4i+OBruODl+ODreODkeODhuOCo+OCkuaMh+WumuOBmeOCi+S6i+OBjOOBp+OBjeOBvuOBmeOAglxuICogICAtIGluZGV4OiBpbnB1dCBidWZmZXIg44GuIGRlZmxhdGUg44Kz44Oz44OG44OK44Gu6ZaL5aeL5L2N572uLlxuICogICAtIGJsb2NrU2l6ZTog44OQ44OD44OV44Kh44Gu44OW44Ot44OD44Kv44K144Kk44K6LlxuICogICAtIHZlcmlmeTog5Ly45by144GM57WC44KP44Gj44Gf5b6MIGFkbGVyLTMyIGNoZWNrc3VtIOOBruaknOiovOOCkuihjOOBhuOBiy5cbiAqICAgLSBidWZmZXJUeXBlOiBabGliLkluZmxhdGUuQnVmZmVyVHlwZSDjga7lgKTjgavjgojjgaPjgabjg5Djg4Pjg5XjgqHjga7nrqHnkIbmlrnms5XjgpLmjIflrprjgZnjgosuXG4gKiAgICAgICBabGliLkluZmxhdGUuQnVmZmVyVHlwZSDjga8gWmxpYi5SYXdJbmZsYXRlLkJ1ZmZlclR5cGUg44Gu44Ko44Kk44Oq44Ki44K5LlxuICovXG5abGliLkluZmxhdGUgPSBmdW5jdGlvbihpbnB1dCwgb3B0X3BhcmFtcykge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGJ1ZmZlclNpemU7XG4gIC8qKiBAdHlwZSB7WmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGV9ICovXG4gIHZhciBidWZmZXJUeXBlO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGNtZjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBmbGc7XG5cbiAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkpfSAqL1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmlwID0gMDtcbiAgLyoqIEB0eXBlIHtabGliLlJhd0luZmxhdGV9ICovXG4gIHRoaXMucmF3aW5mbGF0ZTtcbiAgLyoqIEB0eXBlIHsoYm9vbGVhbnx1bmRlZmluZWQpfSB2ZXJpZnkgZmxhZy4gKi9cbiAgdGhpcy52ZXJpZnk7XG5cbiAgLy8gb3B0aW9uIHBhcmFtZXRlcnNcbiAgaWYgKG9wdF9wYXJhbXMgfHwgIShvcHRfcGFyYW1zID0ge30pKSB7XG4gICAgaWYgKG9wdF9wYXJhbXNbJ2luZGV4J10pIHtcbiAgICAgIHRoaXMuaXAgPSBvcHRfcGFyYW1zWydpbmRleCddO1xuICAgIH1cbiAgICBpZiAob3B0X3BhcmFtc1sndmVyaWZ5J10pIHtcbiAgICAgIHRoaXMudmVyaWZ5ID0gb3B0X3BhcmFtc1sndmVyaWZ5J107XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHJlc3Npb24gTWV0aG9kIGFuZCBGbGFnc1xuICBjbWYgPSBpbnB1dFt0aGlzLmlwKytdO1xuICBmbGcgPSBpbnB1dFt0aGlzLmlwKytdO1xuXG4gIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICBzd2l0Y2ggKGNtZiAmIDB4MGYpIHtcbiAgICBjYXNlIFpsaWIuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURTpcbiAgICAgIHRoaXMubWV0aG9kID0gWmxpYi5Db21wcmVzc2lvbk1ldGhvZC5ERUZMQVRFO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kJyk7XG4gIH1cblxuICAvLyBmY2hlY2tcbiAgaWYgKCgoY21mIDw8IDgpICsgZmxnKSAlIDMxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZjaGVjayBmbGFnOicgKyAoKGNtZiA8PCA4KSArIGZsZykgJSAzMSk7XG4gIH1cblxuICAvLyBmZGljdCAobm90IHN1cHBvcnRlZClcbiAgaWYgKGZsZyAmIDB4MjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZkaWN0IGZsYWcgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgLy8gUmF3SW5mbGF0ZVxuICB0aGlzLnJhd2luZmxhdGUgPSBuZXcgWmxpYi5SYXdJbmZsYXRlKGlucHV0LCB7XG4gICAgJ2luZGV4JzogdGhpcy5pcCxcbiAgICAnYnVmZmVyU2l6ZSc6IG9wdF9wYXJhbXNbJ2J1ZmZlclNpemUnXSxcbiAgICAnYnVmZmVyVHlwZSc6IG9wdF9wYXJhbXNbJ2J1ZmZlclR5cGUnXSxcbiAgICAncmVzaXplJzogb3B0X3BhcmFtc1sncmVzaXplJ11cbiAgfSk7XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuWmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGUgPSBabGliLlJhd0luZmxhdGUuQnVmZmVyVHlwZTtcblxuLyoqXG4gKiBkZWNvbXByZXNzLlxuICogQHJldHVybiB7IShVaW50OEFycmF5fEFycmF5KX0gaW5mbGF0ZWQgYnVmZmVyLlxuICovXG5abGliLkluZmxhdGUucHJvdG90eXBlLmRlY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBpbnB1dCBidWZmZXIuICovXG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5KX0gaW5mbGF0ZWQgYnVmZmVyLiAqL1xuICB2YXIgYnVmZmVyO1xuICAvKiogQHR5cGUge251bWJlcn0gYWRsZXItMzIgY2hlY2tzdW0gKi9cbiAgdmFyIGFkbGVyMzI7XG5cbiAgYnVmZmVyID0gdGhpcy5yYXdpbmZsYXRlLmRlY29tcHJlc3MoKTtcbiAgdGhpcy5pcCA9IHRoaXMucmF3aW5mbGF0ZS5pcDtcblxuICAvLyB2ZXJpZnkgYWRsZXItMzJcbiAgaWYgKHRoaXMudmVyaWZ5KSB7XG4gICAgYWRsZXIzMiA9IChcbiAgICAgICAgaW5wdXRbdGhpcy5pcCsrXSA8PCAyNCB8IGlucHV0W3RoaXMuaXArK10gPDwgMTYgfFxuICAgICAgICBpbnB1dFt0aGlzLmlwKytdIDw8IDggfCBpbnB1dFt0aGlzLmlwKytdXG4gICAgKSA+Pj4gMDtcblxuICAgIGlmIChhZGxlcjMyICE9PSBabGliLkFkbGVyMzIoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkbGVyLTMyIGNoZWNrc3VtJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuLyogdmltOnNldCBleHBhbmR0YWIgdHM9MiBzdz0yIHR3PTgwOiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHshKFVpbnQ4QXJyYXl8QXJyYXkpfSBpbnB1dCBkZWZsYXRlZCBidWZmZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuWmxpYi5JbmZsYXRlU3RyZWFtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLyoqIEB0eXBlIHshKFVpbnQ4QXJyYXl8QXJyYXkpfSAqL1xuICB0aGlzLmlucHV0ID0gaW5wdXQgPT09IHZvaWQgMCA/IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKCkgOiBpbnB1dDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuaXAgPSAwO1xuICAvKiogQHR5cGUge1psaWIuUmF3SW5mbGF0ZVN0cmVhbX0gKi9cbiAgdGhpcy5yYXdpbmZsYXRlID0gbmV3IFpsaWIuUmF3SW5mbGF0ZVN0cmVhbSh0aGlzLmlucHV0LCB0aGlzLmlwKTtcbiAgLyoqIEB0eXBlIHtabGliLkNvbXByZXNzaW9uTWV0aG9kfSAqL1xuICB0aGlzLm1ldGhvZDtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSAqL1xuICB0aGlzLm91dHB1dCA9IHRoaXMucmF3aW5mbGF0ZS5vdXRwdXQ7XG59O1xuXG4vKipcbiAqIGRlY29tcHJlc3MuXG4gKiBAcmV0dXJuIHshKFVpbnQ4QXJyYXl8QXJyYXkpfSBpbmZsYXRlZCBidWZmZXIuXG4gKi9cblpsaWIuSW5mbGF0ZVN0cmVhbS5wcm90b3R5cGUuZGVjb21wcmVzcyA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5KX0gaW5mbGF0ZWQgYnVmZmVyLiAqL1xuICB2YXIgYnVmZmVyO1xuICAvKiogQHR5cGUge251bWJlcn0gYWRsZXItMzIgY2hlY2tzdW0gKi9cbiAgdmFyIGFkbGVyMzI7XG5cbiAgLy8g5paw44GX44GE5YWl5Yqb44KS5YWl5Yqb44OQ44OD44OV44Kh44Gr57WQ5ZCI44GZ44KLXG4gIC8vIFhYWCBBcnJheSwgVWludDhBcnJheSDjga7jg4Hjgqfjg4Pjgq/jgpLooYzjgYbjgYvnorroqo3jgZnjgotcbiAgaWYgKGlucHV0ICE9PSB2b2lkIDApIHtcbiAgICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheSh0aGlzLmlucHV0Lmxlbmd0aCArIGlucHV0Lmxlbmd0aCk7XG4gICAgICB0bXAuc2V0KHRoaXMuaW5wdXQsIDApO1xuICAgICAgdG1wLnNldChpbnB1dCwgdGhpcy5pbnB1dC5sZW5ndGgpO1xuICAgICAgdGhpcy5pbnB1dCA9IHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuaW5wdXQuY29uY2F0KGlucHV0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5tZXRob2QgPT09IHZvaWQgMCkge1xuICAgIGlmKHRoaXMucmVhZEhlYWRlcigpIDwgMCkge1xuICAgICAgcmV0dXJuIG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKCk7XG4gICAgfVxuICB9XG5cbiAgYnVmZmVyID0gdGhpcy5yYXdpbmZsYXRlLmRlY29tcHJlc3ModGhpcy5pbnB1dCwgdGhpcy5pcCk7XG4gIGlmICh0aGlzLnJhd2luZmxhdGUuaXAgIT09IDApIHtcbiAgICB0aGlzLmlucHV0ID0gVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgICB0aGlzLmlucHV0LnN1YmFycmF5KHRoaXMucmF3aW5mbGF0ZS5pcCkgOlxuICAgICAgICB0aGlzLmlucHV0LnNsaWNlKHRoaXMucmF3aW5mbGF0ZS5pcCk7XG4gICAgdGhpcy5pcCA9IDA7XG4gIH1cblxuICAvLyB2ZXJpZnkgYWRsZXItMzJcbiAgLypcbiAgaWYgKHRoaXMudmVyaWZ5KSB7XG4gICAgYWRsZXIzMiA9XG4gICAgICBpbnB1dFt0aGlzLmlwKytdIDw8IDI0IHwgaW5wdXRbdGhpcy5pcCsrXSA8PCAxNiB8XG4gICAgICBpbnB1dFt0aGlzLmlwKytdIDw8IDggfCBpbnB1dFt0aGlzLmlwKytdO1xuXG4gICAgaWYgKGFkbGVyMzIgIT09IFpsaWIuQWRsZXIzMihidWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRsZXItMzIgY2hlY2tzdW0nKTtcbiAgICB9XG4gIH1cbiAgKi9cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuWmxpYi5JbmZsYXRlU3RyZWFtLnByb3RvdHlwZS5yZWFkSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG5cbiAgLy8gQ29tcHJlc3Npb24gTWV0aG9kIGFuZCBGbGFnc1xuICB2YXIgY21mID0gaW5wdXRbaXArK107XG4gIHZhciBmbGcgPSBpbnB1dFtpcCsrXTtcblxuICBpZiAoY21mID09PSB2b2lkIDAgfHwgZmxnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgc3dpdGNoIChjbWYgJiAweDBmKSB7XG4gICAgY2FzZSBabGliLkNvbXByZXNzaW9uTWV0aG9kLkRFRkxBVEU6XG4gICAgICB0aGlzLm1ldGhvZCA9IFpsaWIuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCcpO1xuICB9XG5cbiAgLy8gZmNoZWNrXG4gIGlmICgoKGNtZiA8PCA4KSArIGZsZykgJSAzMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmY2hlY2sgZmxhZzonICsgKChjbWYgPDwgOCkgKyBmbGcpICUgMzEpO1xuICB9XG5cbiAgLy8gZmRpY3QgKG5vdCBzdXBwb3J0ZWQpXG4gIGlmIChmbGcgJiAweDIwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZGljdCBmbGFnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHRoaXMuaXAgPSBpcDtcbn07XG5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdaSVAgKFJGQzE5NTIpIOWxlemWi+OCs+ODs+ODhuODiuWun+ijhS5cbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBpbnB1dCBpbnB1dCBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9wYXJhbXMgb3B0aW9uIHBhcmFtZXRlcnMuXG4gKi9cblpsaWIuR3VuemlwID0gZnVuY3Rpb24oaW5wdXQsIG9wdF9wYXJhbXMpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBpbnB1dCBidWZmZXIuICovXG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IGJ1ZmZlciBwb2ludGVyLiAqL1xuICB0aGlzLmlwID0gMDtcbiAgLyoqIEB0eXBlIHtBcnJheS48WmxpYi5HdW56aXBNZW1iZXI+fSAqL1xuICB0aGlzLm1lbWJlciA9IFtdO1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuZGVjb21wcmVzc2VkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5LjxabGliLkd1bnppcE1lbWJlcj59XG4gKi9cblpsaWIuR3VuemlwLnByb3RvdHlwZS5nZXRNZW1iZXJzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kZWNvbXByZXNzZWQpIHtcbiAgICB0aGlzLmRlY29tcHJlc3MoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm1lbWJlci5zbGljZSgpO1xufTtcblxuLyoqXG4gKiBpbmZsYXRlIGd6aXAgZGF0YS5cbiAqIEByZXR1cm4geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGluZmxhdGVkIGJ1ZmZlci5cbiAqL1xuWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IGxlbmd0aC4gKi9cbiAgdmFyIGlsID0gdGhpcy5pbnB1dC5sZW5ndGg7XG5cbiAgd2hpbGUgKHRoaXMuaXAgPCBpbCkge1xuICAgIHRoaXMuZGVjb2RlTWVtYmVyKCk7XG4gIH1cblxuICB0aGlzLmRlY29tcHJlc3NlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXMuY29uY2F0TWVtYmVyKCk7XG59O1xuXG4vKipcbiAqIGRlY29kZSBnemlwIG1lbWJlci5cbiAqL1xuWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29kZU1lbWJlciA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge1psaWIuR3VuemlwTWVtYmVyfSAqL1xuICB2YXIgbWVtYmVyID0gbmV3IFpsaWIuR3VuemlwTWVtYmVyKCk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaXNpemU7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdJbmZsYXRlfSBSYXdJbmZsYXRlIGltcGxlbWVudGF0aW9uLiAqL1xuICB2YXIgcmF3aW5mbGF0ZTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBpbmZsYXRlZCBkYXRhLiAqL1xuICB2YXIgaW5mbGF0ZWQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBpbmZsYXRlIHNpemUgKi9cbiAgdmFyIGluZmxlbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNoYXJhY3RlciBjb2RlICovXG4gIHZhciBjO1xuICAvKiogQHR5cGUge251bWJlcn0gY2hhcmFjdGVyIGluZGV4IGluIHN0cmluZy4gKi9cbiAgdmFyIGNpO1xuICAvKiogQHR5cGUge0FycmF5LjxzdHJpbmc+fSBjaGFyYWN0ZXIgYXJyYXkuICovXG4gIHZhciBzdHI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBtb2RpZmljYXRpb24gdGltZS4gKi9cbiAgdmFyIG10aW1lO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGNyYzMyO1xuXG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIHZhciBpcCA9IHRoaXMuaXA7XG5cbiAgbWVtYmVyLmlkMSA9IGlucHV0W2lwKytdO1xuICBtZW1iZXIuaWQyID0gaW5wdXRbaXArK107XG5cbiAgLy8gY2hlY2sgc2lnbmF0dXJlXG4gIGlmIChtZW1iZXIuaWQxICE9PSAweDFmIHx8IG1lbWJlci5pZDIgIT09IDB4OGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmlsZSBzaWduYXR1cmU6JyArIG1lbWJlci5pZDEgKyAnLCcgKyBtZW1iZXIuaWQyKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGNvbXByZXNzaW9uIG1ldGhvZFxuICBtZW1iZXIuY20gPSBpbnB1dFtpcCsrXTtcbiAgc3dpdGNoIChtZW1iZXIuY20pIHtcbiAgICBjYXNlIDg6IC8qIFhYWDogdXNlIFpsaWIgY29uc3QgKi9cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kOiAnICsgbWVtYmVyLmNtKTtcbiAgfVxuXG4gIC8vIGZsYWdzXG4gIG1lbWJlci5mbGcgPSBpbnB1dFtpcCsrXTtcblxuICAvLyBtb2RpZmljYXRpb24gdGltZVxuICBtdGltZSA9IChpbnB1dFtpcCsrXSkgICAgICAgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDgpICB8XG4gICAgICAoaW5wdXRbaXArK10gPDwgMTYpIHxcbiAgICAgIChpbnB1dFtpcCsrXSA8PCAyNCk7XG4gIG1lbWJlci5tdGltZSA9IG5ldyBEYXRlKG10aW1lICogMTAwMCk7XG5cbiAgLy8gZXh0cmEgZmxhZ3NcbiAgbWVtYmVyLnhmbCA9IGlucHV0W2lwKytdO1xuXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1cbiAgbWVtYmVyLm9zID0gaW5wdXRbaXArK107XG5cbiAgLy8gZXh0cmFcbiAgaWYgKChtZW1iZXIuZmxnICYgWmxpYi5HemlwLkZsYWdzTWFzay5GRVhUUkEpID4gMCkge1xuICAgIG1lbWJlci54bGVuID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG4gICAgaXAgPSB0aGlzLmRlY29kZVN1YkZpZWxkKGlwLCBtZW1iZXIueGxlbik7XG4gIH1cblxuICAvLyBmbmFtZVxuICBpZiAoKG1lbWJlci5mbGcgJiBabGliLkd6aXAuRmxhZ3NNYXNrLkZOQU1FKSA+IDApIHtcbiAgICBmb3Ioc3RyID0gW10sIGNpID0gMDsgKGMgPSBpbnB1dFtpcCsrXSkgPiAwOykge1xuICAgICAgc3RyW2NpKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICB9XG4gICAgbWVtYmVyLm5hbWUgPSBzdHIuam9pbignJyk7XG4gIH1cblxuICAvLyBmY29tbWVudFxuICBpZiAoKG1lbWJlci5mbGcgJiBabGliLkd6aXAuRmxhZ3NNYXNrLkZDT01NRU5UKSA+IDApIHtcbiAgICBmb3Ioc3RyID0gW10sIGNpID0gMDsgKGMgPSBpbnB1dFtpcCsrXSkgPiAwOykge1xuICAgICAgc3RyW2NpKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICB9XG4gICAgbWVtYmVyLmNvbW1lbnQgPSBzdHIuam9pbignJyk7XG4gIH1cblxuICAvLyBmaGNyY1xuICBpZiAoKG1lbWJlci5mbGcgJiBabGliLkd6aXAuRmxhZ3NNYXNrLkZIQ1JDKSA+IDApIHtcbiAgICBtZW1iZXIuY3JjMTYgPSBabGliLkNSQzMyLmNhbGMoaW5wdXQsIDAsIGlwKSAmIDB4ZmZmZjtcbiAgICBpZiAobWVtYmVyLmNyYzE2ICE9PSAoaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGVhZGVyIGNyYzE2Jyk7XG4gICAgfVxuICB9XG5cbiAgLy8gaXNpemUg44KS5LqL5YmN44Gr5Y+W5b6X44GZ44KL44Go5bGV6ZaL5b6M44Gu44K144Kk44K644GM5YiG44GL44KL44Gf44KB44CBXG4gIC8vIGluZmxhdGXlh6bnkIbjga7jg5Djg4Pjg5XjgqHjgrXjgqTjgrrjgYzkuovliY3jgavliIbjgYvjgorjgIHpq5jpgJ/jgavjgarjgotcbiAgaXNpemUgPSAoaW5wdXRbaW5wdXQubGVuZ3RoIC0gNF0pICAgICAgIHwgKGlucHV0W2lucHV0Lmxlbmd0aCAtIDNdIDw8IDgpIHxcbiAgICAgIChpbnB1dFtpbnB1dC5sZW5ndGggLSAyXSA8PCAxNikgfCAoaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV0gPDwgMjQpO1xuXG4gIC8vIGlzaXplIOOBruWmpeW9k+aAp+ODgeOCp+ODg+OCr1xuICAvLyDjg4/jg5Xjg57jg7PnrKblj7fjgafjga/mnIDlsI8gMi1iaXQg44Gu44Gf44KB44CB5pyA5aSn44GnIDEvNCDjgavjgarjgotcbiAgLy8gTFo3NyDnrKblj7fjgafjga8g6ZW344GV44Go6Led6ZuiIDItQnl0ZSDjgafmnIDlpKcgMjU4LUJ5dGUg44KS6KGo54++44Gn44GN44KL44Gf44KB44CBXG4gIC8vIDEvMTI4IOOBq+OBquOCi+OBqOOBmeOCi1xuICAvLyDjgZPjgZPjgYvjgonlhaXlipvjg5Djg4Pjg5XjgqHjga7mrovjgorjgYwgaXNpemUg44GuIDUxMiDlgI3ku6XkuIrjgaDjgaPjgZ/jgolcbiAgLy8g44K144Kk44K65oyH5a6a44Gu44OQ44OD44OV44Kh56K65L+d44Gv6KGM44KP44Gq44GE5LqL44Go44GZ44KLXG4gIGlmIChpbnB1dC5sZW5ndGggLSBpcCAtIC8qIENSQy0zMiAqLzQgLSAvKiBJU0laRSAqLzQgPCBpc2l6ZSAqIDUxMikge1xuICAgIGluZmxlbiA9IGlzaXplO1xuICB9XG5cbiAgLy8gY29tcHJlc3NlZCBibG9ja1xuICByYXdpbmZsYXRlID0gbmV3IFpsaWIuUmF3SW5mbGF0ZShpbnB1dCwgeydpbmRleCc6IGlwLCAnYnVmZmVyU2l6ZSc6IGluZmxlbn0pO1xuICBtZW1iZXIuZGF0YSA9IGluZmxhdGVkID0gcmF3aW5mbGF0ZS5kZWNvbXByZXNzKCk7XG4gIGlwID0gcmF3aW5mbGF0ZS5pcDtcblxuICAvLyBjcmMzMlxuICBtZW1iZXIuY3JjMzIgPSBjcmMzMiA9XG4gICAgICAoKGlucHV0W2lwKytdKSAgICAgICB8IChpbnB1dFtpcCsrXSA8PCA4KSB8XG4gICAgICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNCkpID4+PiAwO1xuICBpZiAoWmxpYi5DUkMzMi5jYWxjKGluZmxhdGVkKSAhPT0gY3JjMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQ1JDLTMyIGNoZWNrc3VtOiAweCcgK1xuICAgICAgICBabGliLkNSQzMyLmNhbGMoaW5mbGF0ZWQpLnRvU3RyaW5nKDE2KSArICcgLyAweCcgKyBjcmMzMi50b1N0cmluZygxNikpO1xuICB9XG5cbiAgLy8gaW5wdXQgc2l6ZVxuICBtZW1iZXIuaXNpemUgPSBpc2l6ZSA9XG4gICAgICAoKGlucHV0W2lwKytdKSAgICAgICB8IChpbnB1dFtpcCsrXSA8PCA4KSB8XG4gICAgICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNCkpID4+PiAwO1xuICBpZiAoKGluZmxhdGVkLmxlbmd0aCAmIDB4ZmZmZmZmZmYpICE9PSBpc2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCBzaXplOiAnICtcbiAgICAgICAgKGluZmxhdGVkLmxlbmd0aCAmIDB4ZmZmZmZmZmYpICsgJyAvICcgKyBpc2l6ZSk7XG4gIH1cblxuICB0aGlzLm1lbWJlci5wdXNoKG1lbWJlcik7XG4gIHRoaXMuaXAgPSBpcDtcbn07XG5cbi8qKlxuICog44K144OW44OV44Kj44O844Or44OJ44Gu44OH44Kz44O844OJXG4gKiBYWFg6IOePvuWcqOOBr+S9leOCguOBm+OBmuOCueOCreODg+ODl+OBmeOCi1xuICovXG5abGliLkd1bnppcC5wcm90b3R5cGUuZGVjb2RlU3ViRmllbGQgPSBmdW5jdGlvbihpcCwgbGVuZ3RoKSB7XG4gIHJldHVybiBpcCArIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX1cbiAqL1xuWmxpYi5HdW56aXAucHJvdG90eXBlLmNvbmNhdE1lbWJlciA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge0FycmF5LjxabGliLkd1bnppcE1lbWJlcj59ICovXG4gIHZhciBtZW1iZXIgPSB0aGlzLm1lbWJlcjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHAgPSAwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHNpemUgPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBidWZmZXI7XG5cbiAgZm9yIChpID0gMCwgaWwgPSBtZW1iZXIubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHNpemUgKz0gbWVtYmVyW2ldLmRhdGEubGVuZ3RoO1xuICB9XG5cbiAgaWYgKFVTRV9UWVBFREFSUkFZKSB7XG4gICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIGJ1ZmZlci5zZXQobWVtYmVyW2ldLmRhdGEsIHApO1xuICAgICAgcCArPSBtZW1iZXJbaV0uZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbDsgKytpKSB7XG4gICAgICBidWZmZXJbaV0gPSBtZW1iZXJbaV0uZGF0YTtcbiAgICB9XG4gICAgYnVmZmVyID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYnVmZmVyKTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuWmxpYi5HdW56aXBNZW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IHNpZ25hdHVyZSBmaXJzdCBieXRlLiAqL1xuICB0aGlzLmlkMTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IHNpZ25hdHVyZSBzZWNvbmQgYnl0ZS4gKi9cbiAgdGhpcy5pZDI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBjb21wcmVzc2lvbiBtZXRob2QuICovXG4gIHRoaXMuY207XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBmbGFncy4gKi9cbiAgdGhpcy5mbGc7XG4gIC8qKiBAdHlwZSB7RGF0ZX0gbW9kaWZpY2F0aW9uIHRpbWUuICovXG4gIHRoaXMubXRpbWU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBleHRyYSBmbGFncy4gKi9cbiAgdGhpcy54Zmw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBvcGVyYXRpbmcgc3lzdGVtIG51bWJlci4gKi9cbiAgdGhpcy5vcztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IENSQy0xNiB2YWx1ZSBmb3IgRkhDUkMgZmxhZy4gKi9cbiAgdGhpcy5jcmMxNjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGV4dHJhIGxlbmd0aC4gKi9cbiAgdGhpcy54bGVuO1xuICAvKiogQHR5cGUge251bWJlcn0gQ1JDLTMyIHZhbHVlIGZvciB2ZXJpZmljYXRpb24uICovXG4gIHRoaXMuY3JjMzI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBpbnB1dCBzaXplIG1vZHVsbyAzMiB2YWx1ZS4gKi9cbiAgdGhpcy5pc2l6ZTtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IGZpbGVuYW1lLiAqL1xuICB0aGlzLm5hbWU7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBjb21tZW50LiAqL1xuICB0aGlzLmNvbW1lbnQ7XG4gIC8qKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX0gKi9cbiAgdGhpcy5kYXRhO1xufTtcblxuWmxpYi5HdW56aXBNZW1iZXIucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmFtZTtcbn07XG5cblpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGE7XG59O1xuXG5abGliLkd1bnppcE1lbWJlci5wcm90b3R5cGUuZ2V0TXRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubXRpbWU7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBHWklQIChSRkMxOTUyKSDlrp/oo4UuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IShBcnJheXxVaW50OEFycmF5KX0gaW5wdXQgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIG9wdGlvbiBwYXJhbWV0ZXJzLlxuICovXG5abGliLkd6aXAgPSBmdW5jdGlvbihpbnB1dCwgb3B0X3BhcmFtcykge1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAvKiogQHR5cGUge251bWJlcn0gaW5wdXQgYnVmZmVyIHBvaW50ZXIuICovXG4gIHRoaXMuaXAgPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBidWZmZXIuICovXG4gIHRoaXMub3V0cHV0O1xuICAvKiogQHR5cGUge251bWJlcn0gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgdGhpcy5vcCA9IDA7XG4gIC8qKiBAdHlwZSB7IU9iamVjdH0gZmxhZ3Mgb3B0aW9uIGZsYWdzLiAqL1xuICB0aGlzLmZsYWdzID0ge307XG4gIC8qKiBAdHlwZSB7IXN0cmluZ30gZmlsZW5hbWUuICovXG4gIHRoaXMuZmlsZW5hbWU7XG4gIC8qKiBAdHlwZSB7IXN0cmluZ30gY29tbWVudC4gKi9cbiAgdGhpcy5jb21tZW50O1xuICAvKiogQHR5cGUgeyFPYmplY3R9IGRlZmxhdGUgb3B0aW9ucy4gKi9cbiAgdGhpcy5kZWZsYXRlT3B0aW9ucztcblxuICAvLyBvcHRpb24gcGFyYW1ldGVyc1xuICBpZiAob3B0X3BhcmFtcykge1xuICAgIGlmIChvcHRfcGFyYW1zWydmbGFncyddKSB7XG4gICAgICB0aGlzLmZsYWdzID0gb3B0X3BhcmFtc1snZmxhZ3MnXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRfcGFyYW1zWydmaWxlbmFtZSddID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5maWxlbmFtZSA9IG9wdF9wYXJhbXNbJ2ZpbGVuYW1lJ107XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0X3BhcmFtc1snY29tbWVudCddID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jb21tZW50ID0gb3B0X3BhcmFtc1snY29tbWVudCddO1xuICAgIH1cbiAgICBpZiAob3B0X3BhcmFtc1snZGVmbGF0ZU9wdGlvbnMnXSkge1xuICAgICAgdGhpcy5kZWZsYXRlT3B0aW9ucyA9IG9wdF9wYXJhbXNbJ2RlZmxhdGVPcHRpb25zJ107XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLmRlZmxhdGVPcHRpb25zKSB7XG4gICAgdGhpcy5kZWZsYXRlT3B0aW9ucyA9IHt9O1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuWmxpYi5HemlwLkRlZmF1bHRCdWZmZXJTaXplID0gMHg4MDAwO1xuXG4vKipcbiAqIGVuY29kZSBnemlwIG1lbWJlcnMuXG4gKiBAcmV0dXJuIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBnemlwIGJpbmFyeSBhcnJheS5cbiAqL1xuWmxpYi5HemlwLnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge251bWJlcn0gZmxhZ3MuICovXG4gIHZhciBmbGc7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBtb2RpZmljYXRpb24gdGltZS4gKi9cbiAgdmFyIG10aW1lO1xuICAvKiogQHR5cGUge251bWJlcn0gQ1JDLTE2IHZhbHVlIGZvciBGSENSQyBmbGFnLiAqL1xuICB2YXIgY3JjMTY7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBDUkMtMzIgdmFsdWUgZm9yIHZlcmlmaWNhdGlvbi4gKi9cbiAgdmFyIGNyYzMyO1xuICAvKiogQHR5cGUgeyFabGliLlJhd0RlZmxhdGV9IHJhdyBkZWZsYXRlIG9iamVjdC4gKi9cbiAgdmFyIHJhd2RlZmxhdGU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBjaGFyYWN0ZXIgY29kZSAqL1xuICB2YXIgYztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgY291bnRlci4gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGxpbWl0ZXIuICovXG4gIHZhciBpbDtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBvdXRwdXQgYnVmZmVyLiAqL1xuICB2YXIgb3V0cHV0ID1cbiAgICAgIG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKFpsaWIuR3ppcC5EZWZhdWx0QnVmZmVyU2l6ZSk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBvdXRwdXQgYnVmZmVyIHBvaW50ZXIuICovXG4gIHZhciBvcCA9IDA7XG5cbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgdmFyIGlwID0gdGhpcy5pcDtcbiAgdmFyIGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgdmFyIGNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG5cbiAgLy8gY2hlY2sgc2lnbmF0dXJlXG4gIG91dHB1dFtvcCsrXSA9IDB4MWY7XG4gIG91dHB1dFtvcCsrXSA9IDB4OGI7XG5cbiAgLy8gY2hlY2sgY29tcHJlc3Npb24gbWV0aG9kXG4gIG91dHB1dFtvcCsrXSA9IDg7IC8qIFhYWDogdXNlIFpsaWIgY29uc3QgKi9cblxuICAvLyBmbGFnc1xuICBmbGcgPSAwO1xuICBpZiAodGhpcy5mbGFnc1snZm5hbWUnXSkgICAgZmxnIHw9IFpsaWIuR3ppcC5GbGFnc01hc2suRk5BTUU7XG4gIGlmICh0aGlzLmZsYWdzWydmY29tbWVudCddKSBmbGcgfD0gWmxpYi5HemlwLkZsYWdzTWFzay5GQ09NTUVOVDtcbiAgaWYgKHRoaXMuZmxhZ3NbJ2ZoY3JjJ10pICAgIGZsZyB8PSBabGliLkd6aXAuRmxhZ3NNYXNrLkZIQ1JDO1xuICAvLyBYWFg6IEZURVhUXG4gIC8vIFhYWDogRkVYVFJBXG4gIG91dHB1dFtvcCsrXSA9IGZsZztcblxuICAvLyBtb2RpZmljYXRpb24gdGltZVxuICBtdGltZSA9IChEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKSkgLyAxMDAwIHwgMDtcbiAgb3V0cHV0W29wKytdID0gbXRpbWUgICAgICAgICYgMHhmZjtcbiAgb3V0cHV0W29wKytdID0gbXRpbWUgPj4+ICA4ICYgMHhmZjtcbiAgb3V0cHV0W29wKytdID0gbXRpbWUgPj4+IDE2ICYgMHhmZjtcbiAgb3V0cHV0W29wKytdID0gbXRpbWUgPj4+IDI0ICYgMHhmZjtcblxuICAvLyBleHRyYSBmbGFnc1xuICBvdXRwdXRbb3ArK10gPSAwO1xuXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1cbiAgb3V0cHV0W29wKytdID0gWmxpYi5HemlwLk9wZXJhdGluZ1N5c3RlbS5VTktOT1dOO1xuXG4gIC8vIGV4dHJhXG4gIC8qIE5PUCAqL1xuXG4gIC8vIGZuYW1lXG4gIGlmICh0aGlzLmZsYWdzWydmbmFtZSddICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGkgPSAwLCBpbCA9IGZpbGVuYW1lLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIGMgPSBmaWxlbmFtZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGMgPiAweGZmKSB7IG91dHB1dFtvcCsrXSA9IChjID4+PiA4KSAmIDB4ZmY7IH1cbiAgICAgIG91dHB1dFtvcCsrXSA9IGMgJiAweGZmO1xuICAgIH1cbiAgICBvdXRwdXRbb3ArK10gPSAwOyAvLyBudWxsIHRlcm1pbmF0aW9uXG4gIH1cblxuICAvLyBmY29tbWVudFxuICBpZiAodGhpcy5mbGFnc1snY29tbWVudCddKSB7XG4gICAgZm9yIChpID0gMCwgaWwgPSBjb21tZW50Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIGMgPSBjb21tZW50LmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoYyA+IDB4ZmYpIHsgb3V0cHV0W29wKytdID0gKGMgPj4+IDgpICYgMHhmZjsgfVxuICAgICAgb3V0cHV0W29wKytdID0gYyAmIDB4ZmY7XG4gICAgfVxuICAgIG91dHB1dFtvcCsrXSA9IDA7IC8vIG51bGwgdGVybWluYXRpb25cbiAgfVxuXG4gIC8vIGZoY3JjXG4gIGlmICh0aGlzLmZsYWdzWydmaGNyYyddKSB7XG4gICAgY3JjMTYgPSBabGliLkNSQzMyLmNhbGMob3V0cHV0LCAwLCBvcCkgJiAweGZmZmY7XG4gICAgb3V0cHV0W29wKytdID0gKGNyYzE2ICAgICAgKSAmIDB4ZmY7XG4gICAgb3V0cHV0W29wKytdID0gKGNyYzE2ID4+PiA4KSAmIDB4ZmY7XG4gIH1cblxuICAvLyBhZGQgY29tcHJlc3Mgb3B0aW9uXG4gIHRoaXMuZGVmbGF0ZU9wdGlvbnNbJ291dHB1dEJ1ZmZlciddID0gb3V0cHV0O1xuICB0aGlzLmRlZmxhdGVPcHRpb25zWydvdXRwdXRJbmRleCddID0gb3A7XG5cbiAgLy8gY29tcHJlc3NcbiAgcmF3ZGVmbGF0ZSA9IG5ldyBabGliLlJhd0RlZmxhdGUoaW5wdXQsIHRoaXMuZGVmbGF0ZU9wdGlvbnMpO1xuICBvdXRwdXQgPSByYXdkZWZsYXRlLmNvbXByZXNzKCk7XG4gIG9wID0gcmF3ZGVmbGF0ZS5vcDtcblxuICAvLyBleHBhbmQgYnVmZmVyXG4gIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgIGlmIChvcCArIDggPiBvdXRwdXQuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkob3AgKyA4KTtcbiAgICAgIHRoaXMub3V0cHV0LnNldChuZXcgVWludDhBcnJheShvdXRwdXQuYnVmZmVyKSk7XG4gICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0LmJ1ZmZlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gY3JjMzJcbiAgY3JjMzIgPSBabGliLkNSQzMyLmNhbGMoaW5wdXQpO1xuICBvdXRwdXRbb3ArK10gPSAoY3JjMzIgICAgICAgKSAmIDB4ZmY7XG4gIG91dHB1dFtvcCsrXSA9IChjcmMzMiA+Pj4gIDgpICYgMHhmZjtcbiAgb3V0cHV0W29wKytdID0gKGNyYzMyID4+PiAxNikgJiAweGZmO1xuICBvdXRwdXRbb3ArK10gPSAoY3JjMzIgPj4+IDI0KSAmIDB4ZmY7XG5cbiAgLy8gaW5wdXQgc2l6ZVxuICBpbCA9IGlucHV0Lmxlbmd0aDtcbiAgb3V0cHV0W29wKytdID0gKGlsICAgICAgICkgJiAweGZmO1xuICBvdXRwdXRbb3ArK10gPSAoaWwgPj4+ICA4KSAmIDB4ZmY7XG4gIG91dHB1dFtvcCsrXSA9IChpbCA+Pj4gMTYpICYgMHhmZjtcbiAgb3V0cHV0W29wKytdID0gKGlsID4+PiAyNCkgJiAweGZmO1xuXG4gIHRoaXMuaXAgPSBpcDtcblxuICBpZiAoVVNFX1RZUEVEQVJSQVkgJiYgb3AgPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQgPSBvdXRwdXQuc3ViYXJyYXkoMCwgb3ApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuWmxpYi5HemlwLk9wZXJhdGluZ1N5c3RlbSA9IHtcbiAgRkFUOiAwLFxuICBBTUlHQTogMSxcbiAgVk1TOiAyLFxuICBVTklYOiAzLFxuICBWTV9DTVM6IDQsXG4gIEFUQVJJX1RPUzogNSxcbiAgSFBGUzogNixcbiAgTUFDSU5UT1NIOiA3LFxuICBaX1NZU1RFTTogOCxcbiAgQ1BfTTogOSxcbiAgVE9QU18yMDogMTAsXG4gIE5URlM6IDExLFxuICBRRE9TOiAxMixcbiAgQUNPUk5fUklTQ09TOiAxMyxcbiAgVU5LTk9XTjogMjU1XG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cblpsaWIuR3ppcC5GbGFnc01hc2sgPSB7XG4gIEZURVhUOiAweDAxLFxuICBGSENSQzogMHgwMixcbiAgRkVYVFJBOiAweDA0LFxuICBGTkFNRTogMHgwOCxcbiAgRkNPTU1FTlQ6IDB4MTBcbn07XG5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEhlYXAgU29ydCDlrp/oo4UuIOODj+ODleODnuODs+espuWPt+WMluOBp+S9v+eUqOOBmeOCiy5cbiAqL1xuXG4vKipcbiAqIOOCq+OCueOCv+ODoOODj+ODleODnuODs+espuWPt+OBp+S9v+eUqOOBmeOCi+ODkuODvOODl+Wun+ijhVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCDjg5Ljg7zjg5fjgrXjgqTjgrouXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuWmxpYi5IZWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHRoaXMuYnVmZmVyID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQxNkFycmF5IDogQXJyYXkpKGxlbmd0aCAqIDIpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIOimquODjuODvOODieOBriBpbmRleCDlj5blvpdcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDlrZDjg47jg7zjg4njga4gaW5kZXguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOimquODjuODvOODieOBriBpbmRleC5cbiAqXG4gKi9cblpsaWIuSGVhcC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgcmV0dXJuICgoaW5kZXggLSAyKSAvIDQgfCAwKSAqIDI7XG59O1xuXG4vKipcbiAqIOWtkOODjuODvOODieOBriBpbmRleCDlj5blvpdcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDopqrjg47jg7zjg4njga4gaW5kZXguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOWtkOODjuODvOODieOBriBpbmRleC5cbiAqL1xuWmxpYi5IZWFwLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHJldHVybiAyICogaW5kZXggKyAyO1xufTtcblxuLyoqXG4gKiBIZWFwIOOBq+WApOOCkui/veWKoOOBmeOCi1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOOCreODvCBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSDlgKQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOePvuWcqOOBruODkuODvOODl+mVty5cbiAqL1xuWmxpYi5IZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBjdXJyZW50LCBwYXJlbnQsXG4gICAgICBoZWFwID0gdGhpcy5idWZmZXIsXG4gICAgICBzd2FwO1xuXG4gIGN1cnJlbnQgPSB0aGlzLmxlbmd0aDtcbiAgaGVhcFt0aGlzLmxlbmd0aCsrXSA9IHZhbHVlO1xuICBoZWFwW3RoaXMubGVuZ3RoKytdID0gaW5kZXg7XG5cbiAgLy8g44Or44O844OI44OO44O844OJ44Gr44Gf44Gp44KK552A44GP44G+44Gn5YWl44KM5pu/44GI44KS6Kmm44G/44KLXG4gIHdoaWxlIChjdXJyZW50ID4gMCkge1xuICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KGN1cnJlbnQpO1xuXG4gICAgLy8g6Kaq44OO44O844OJ44Go5q+U6LyD44GX44Gm6Kaq44Gu5pa544GM5bCP44GV44GR44KM44Gw5YWl44KM5pu/44GI44KLXG4gICAgaWYgKGhlYXBbY3VycmVudF0gPiBoZWFwW3BhcmVudF0pIHtcbiAgICAgIHN3YXAgPSBoZWFwW2N1cnJlbnRdO1xuICAgICAgaGVhcFtjdXJyZW50XSA9IGhlYXBbcGFyZW50XTtcbiAgICAgIGhlYXBbcGFyZW50XSA9IHN3YXA7XG5cbiAgICAgIHN3YXAgPSBoZWFwW2N1cnJlbnQgKyAxXTtcbiAgICAgIGhlYXBbY3VycmVudCArIDFdID0gaGVhcFtwYXJlbnQgKyAxXTtcbiAgICAgIGhlYXBbcGFyZW50ICsgMV0gPSBzd2FwO1xuXG4gICAgICBjdXJyZW50ID0gcGFyZW50O1xuICAgICAgLy8g5YWl44KM5pu/44GI44GM5b+F6KaB44Gq44GP44Gq44Gj44Gf44KJ44Gd44GT44Gn5oqc44GR44KLXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogSGVhcOOBi+OCieS4gOeVquWkp+OBjeOBhOWApOOCkui/lOOBmVxuICogQHJldHVybiB7e2luZGV4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyfX0ge2luZGV4OiDjgq3jg7xpbmRleCxcbiAqICAgICB2YWx1ZTog5YCkLCBsZW5ndGg6IOODkuODvOODl+mVt30g44GuIE9iamVjdC5cbiAqL1xuWmxpYi5IZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluZGV4LCB2YWx1ZSxcbiAgICAgIGhlYXAgPSB0aGlzLmJ1ZmZlciwgc3dhcCxcbiAgICAgIGN1cnJlbnQsIHBhcmVudDtcblxuICB2YWx1ZSA9IGhlYXBbMF07XG4gIGluZGV4ID0gaGVhcFsxXTtcblxuICAvLyDlvozjgo3jgYvjgonlgKTjgpLlj5bjgotcbiAgdGhpcy5sZW5ndGggLT0gMjtcbiAgaGVhcFswXSA9IGhlYXBbdGhpcy5sZW5ndGhdO1xuICBoZWFwWzFdID0gaGVhcFt0aGlzLmxlbmd0aCArIDFdO1xuXG4gIHBhcmVudCA9IDA7XG4gIC8vIOODq+ODvOODiOODjuODvOODieOBi+OCieS4i+OBjOOBo+OBpuOBhOOBj1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGN1cnJlbnQgPSB0aGlzLmdldENoaWxkKHBhcmVudCk7XG5cbiAgICAvLyDnr4Tlm7Ljg4Hjgqfjg4Pjgq9cbiAgICBpZiAoY3VycmVudCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8g6Zqj44Gu44OO44O844OJ44Go5q+U6LyD44GX44Gm44CB6Zqj44Gu5pa544GM5YCk44GM5aSn44GN44GR44KM44Gw6Zqj44KS54++5Zyo44OO44O844OJ44Go44GX44Gm6YG45oqeXG4gICAgaWYgKGN1cnJlbnQgKyAyIDwgdGhpcy5sZW5ndGggJiYgaGVhcFtjdXJyZW50ICsgMl0gPiBoZWFwW2N1cnJlbnRdKSB7XG4gICAgICBjdXJyZW50ICs9IDI7XG4gICAgfVxuXG4gICAgLy8g6Kaq44OO44O844OJ44Go5q+U6LyD44GX44Gm6Kaq44Gu5pa544GM5bCP44GV44GE5aC05ZCI44Gv5YWl44KM5pu/44GI44KLXG4gICAgaWYgKGhlYXBbY3VycmVudF0gPiBoZWFwW3BhcmVudF0pIHtcbiAgICAgIHN3YXAgPSBoZWFwW3BhcmVudF07XG4gICAgICBoZWFwW3BhcmVudF0gPSBoZWFwW2N1cnJlbnRdO1xuICAgICAgaGVhcFtjdXJyZW50XSA9IHN3YXA7XG5cbiAgICAgIHN3YXAgPSBoZWFwW3BhcmVudCArIDFdO1xuICAgICAgaGVhcFtwYXJlbnQgKyAxXSA9IGhlYXBbY3VycmVudCArIDFdO1xuICAgICAgaGVhcFtjdXJyZW50ICsgMV0gPSBzd2FwO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHtpbmRleDogaW5kZXgsIHZhbHVlOiB2YWx1ZSwgbGVuZ3RoOiB0aGlzLmxlbmd0aH07XG59O1xuXG5cbi8qIHZpbTpzZXQgZXhwYW5kdGFiIHRzPTIgc3c9MiB0dz04MDogKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlZmxhdGUgKFJGQzE5NTEpIOespuWPt+WMluOCouODq+OCtOODquOCuuODoOWun+ijhS5cbiAqL1xuXG5cbi8qKlxuICogUmF3IERlZmxhdGUg5a6f6KOFXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0IOespuWPt+WMluOBmeOCi+WvvuixoeOBruODkOODg+ODleOCoS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBvcHRpb24gcGFyYW1ldGVycy5cbiAqXG4gKiB0eXBlZCBhcnJheSDjgYzkvb/nlKjlj6/og73jgarjgajjgY3jgIFvdXRwdXRCdWZmZXIg44GMIEFycmF5IOOBr+iHquWLleeahOOBqyBVaW50OEFycmF5IOOBq1xuICog5aSJ5o+b44GV44KM44G+44GZLlxuICog5Yil44Gu44Kq44OW44K444Kn44Kv44OI44Gr44Gq44KL44Gf44KB5Ye65Yqb44OQ44OD44OV44Kh44KS5Y+C54Wn44GX44Gm44GE44KL5aSJ5pWw44Gq44Gp44GvXG4gKiDmm7TmlrDjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZkuXG4gKi9cblpsaWIuUmF3RGVmbGF0ZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdEZWZsYXRlLkNvbXByZXNzaW9uVHlwZX0gKi9cbiAgdGhpcy5jb21wcmVzc2lvblR5cGUgPSBabGliLlJhd0RlZmxhdGUuQ29tcHJlc3Npb25UeXBlLkRZTkFNSUM7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmxhenkgPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqL1xuICB0aGlzLmZyZXFzTGl0TGVuO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqL1xuICB0aGlzLmZyZXFzRGlzdDtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB0aGlzLmlucHV0ID1cbiAgICAgIChVU0VfVFlQRURBUlJBWSAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSA/IG5ldyBVaW50OEFycmF5KGlucHV0KSA6IGlucHV0O1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IG91dHB1dCBvdXRwdXQgYnVmZmVyLiAqL1xuICB0aGlzLm91dHB1dDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IHBvcyBvdXRwdXQgYnVmZmVyIHBvc2l0aW9uLiAqL1xuICB0aGlzLm9wID0gMDtcblxuICAvLyBvcHRpb24gcGFyYW1ldGVyc1xuICBpZiAob3B0X3BhcmFtcykge1xuICAgIGlmIChvcHRfcGFyYW1zWydsYXp5J10pIHtcbiAgICAgIHRoaXMubGF6eSA9IG9wdF9wYXJhbXNbJ2xhenknXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRfcGFyYW1zWydjb21wcmVzc2lvblR5cGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Npb25UeXBlID0gb3B0X3BhcmFtc1snY29tcHJlc3Npb25UeXBlJ107XG4gICAgfVxuICAgIGlmIChvcHRfcGFyYW1zWydvdXRwdXRCdWZmZXInXSkge1xuICAgICAgdGhpcy5vdXRwdXQgPVxuICAgICAgICAgIChVU0VfVFlQRURBUlJBWSAmJiBvcHRfcGFyYW1zWydvdXRwdXRCdWZmZXInXSBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KG9wdF9wYXJhbXNbJ291dHB1dEJ1ZmZlciddKSA6IG9wdF9wYXJhbXNbJ291dHB1dEJ1ZmZlciddO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdF9wYXJhbXNbJ291dHB1dEluZGV4J10gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm9wID0gb3B0X3BhcmFtc1snb3V0cHV0SW5kZXgnXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMub3V0cHV0KSB7XG4gICAgdGhpcy5vdXRwdXQgPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KSgweDgwMDApO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGUgPSB7XG4gIE5PTkU6IDAsXG4gIEZJWEVEOiAxLFxuICBEWU5BTUlDOiAyLFxuICBSRVNFUlZFRDogM1xufTtcblxuXG4vKipcbiAqIExaNzcg44Gu5pyA5bCP44Oe44OD44OB6ZW3XG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5Mejc3TWluTGVuZ3RoID0gMztcblxuLyoqXG4gKiBMWjc3IOOBruacgOWkp+ODnuODg+ODgemVt1xuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5abGliLlJhd0RlZmxhdGUuTHo3N01heExlbmd0aCA9IDI1ODtcblxuLyoqXG4gKiBMWjc3IOOBruOCpuOCo+ODs+ODieOCpuOCteOCpOOCulxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5abGliLlJhd0RlZmxhdGUuV2luZG93U2l6ZSA9IDB4ODAwMDtcblxuLyoqXG4gKiDmnIDplbfjga7nrKblj7fplbdcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLk1heENvZGVMZW5ndGggPSAxNjtcblxuLyoqXG4gKiDjg4/jg5Xjg57jg7PnrKblj7fjga7mnIDlpKfmlbDlgKRcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLkhVRk1BWCA9IDI4NjtcblxuLyoqXG4gKiDlm7rlrprjg4/jg5Xjg57jg7PnrKblj7fjga7nrKblj7fljJbjg4bjg7zjg5bjg6tcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5LjxBcnJheS48bnVtYmVyLCBudW1iZXI+Pn1cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLkZpeGVkSHVmZm1hblRhYmxlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdGFibGUgPSBbXSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMjg4OyBpKyspIHtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgKGkgPD0gMTQzKTogdGFibGUucHVzaChbaSAgICAgICArIDB4MDMwLCA4XSk7IGJyZWFrO1xuICAgICAgY2FzZSAoaSA8PSAyNTUpOiB0YWJsZS5wdXNoKFtpIC0gMTQ0ICsgMHgxOTAsIDldKTsgYnJlYWs7XG4gICAgICBjYXNlIChpIDw9IDI3OSk6IHRhYmxlLnB1c2goW2kgLSAyNTYgKyAweDAwMCwgN10pOyBicmVhaztcbiAgICAgIGNhc2UgKGkgPD0gMjg3KTogdGFibGUucHVzaChbaSAtIDI4MCArIDB4MEMwLCA4XSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgbGl0ZXJhbDogJyArIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufSkoKTtcblxuLyoqXG4gKiBERUZMQVRFIOODluODreODg+OCr+OBruS9nOaIkFxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0g5Zyn57iu5riI44G/IGJ5dGUgYXJyYXkuXG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgYmxvY2tBcnJheTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBwb3NpdGlvbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBsZW5ndGg7XG5cbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcblxuICAvLyBjb21wcmVzc2lvblxuICBzd2l0Y2ggKHRoaXMuY29tcHJlc3Npb25UeXBlKSB7XG4gICAgY2FzZSBabGliLlJhd0RlZmxhdGUuQ29tcHJlc3Npb25UeXBlLk5PTkU6XG4gICAgICAvLyBlYWNoIDY1NTM1LUJ5dGUgKGxlbmd0aCBoZWFkZXI6IDE2LWJpdClcbiAgICAgIGZvciAocG9zaXRpb24gPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7IHBvc2l0aW9uIDwgbGVuZ3RoOykge1xuICAgICAgICBibG9ja0FycmF5ID0gVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgICAgICAgaW5wdXQuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgMHhmZmZmKSA6XG4gICAgICAgICAgICBpbnB1dC5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAweGZmZmYpO1xuICAgICAgICBwb3NpdGlvbiArPSBibG9ja0FycmF5Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5tYWtlTm9jb21wcmVzc0Jsb2NrKGJsb2NrQXJyYXksIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpsaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGUuRklYRUQ6XG4gICAgICB0aGlzLm91dHB1dCA9IHRoaXMubWFrZUZpeGVkSHVmZm1hbkJsb2NrKGlucHV0LCB0cnVlKTtcbiAgICAgIHRoaXMub3AgPSB0aGlzLm91dHB1dC5sZW5ndGg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpsaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGUuRFlOQU1JQzpcbiAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5tYWtlRHluYW1pY0h1ZmZtYW5CbG9jayhpbnB1dCwgdHJ1ZSk7XG4gICAgICB0aGlzLm9wID0gdGhpcy5vdXRwdXQubGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93ICdpbnZhbGlkIGNvbXByZXNzaW9uIHR5cGUnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3V0cHV0O1xufTtcblxuLyoqXG4gKiDpnZ7lnKfnuK7jg5bjg63jg4Pjgq/jga7kvZzmiJBcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gYmxvY2tBcnJheSDjg5bjg63jg4Pjgq/jg4fjg7zjgr8gYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7IWJvb2xlYW59IGlzRmluYWxCbG9jayDmnIDlvozjga7jg5bjg63jg4Pjgq/jgarjgonjgbB0cnVlLlxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0g6Z2e5Zyn57iu44OW44Ot44OD44KvIGJ5dGUgYXJyYXkuXG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5wcm90b3R5cGUubWFrZU5vY29tcHJlc3NCbG9jayA9XG4gICAgZnVuY3Rpb24oYmxvY2tBcnJheSwgaXNGaW5hbEJsb2NrKSB7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBiZmluYWw7XG4gICAgICAvKiogQHR5cGUge1psaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGV9ICovXG4gICAgICB2YXIgYnR5cGU7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBsZW47XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBubGVuO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB2YXIgaTtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGlsO1xuXG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXQ7XG4gICAgICB2YXIgb3AgPSB0aGlzLm9wO1xuXG4gICAgICAvLyBleHBhbmQgYnVmZmVyXG4gICAgICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXQuYnVmZmVyKTtcbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPD0gb3AgKyBibG9ja0FycmF5Lmxlbmd0aCArIDUpIHtcbiAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShvdXRwdXQubGVuZ3RoIDw8IDEpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zZXQodGhpcy5vdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGJmaW5hbCA9IGlzRmluYWxCbG9jayA/IDEgOiAwO1xuICAgICAgYnR5cGUgPSBabGliLlJhd0RlZmxhdGUuQ29tcHJlc3Npb25UeXBlLk5PTkU7XG4gICAgICBvdXRwdXRbb3ArK10gPSAoYmZpbmFsKSB8IChidHlwZSA8PCAxKTtcblxuICAgICAgLy8gbGVuZ3RoXG4gICAgICBsZW4gPSBibG9ja0FycmF5Lmxlbmd0aDtcbiAgICAgIG5sZW4gPSAofmxlbiArIDB4MTAwMDApICYgMHhmZmZmO1xuICAgICAgb3V0cHV0W29wKytdID0gICAgICAgICAgbGVuICYgMHhmZjtcbiAgICAgIG91dHB1dFtvcCsrXSA9ICAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgICBvdXRwdXRbb3ArK10gPSAgICAgICAgIG5sZW4gJiAweGZmO1xuICAgICAgb3V0cHV0W29wKytdID0gKG5sZW4gPj4+IDgpICYgMHhmZjtcblxuICAgICAgLy8gY29weSBidWZmZXJcbiAgICAgIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgICAgICBvdXRwdXQuc2V0KGJsb2NrQXJyYXksIG9wKTtcbiAgICAgICAgb3AgKz0gYmxvY2tBcnJheS5sZW5ndGg7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5zdWJhcnJheSgwLCBvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IGJsb2NrQXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgIG91dHB1dFtvcCsrXSA9IGJsb2NrQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0Lmxlbmd0aCA9IG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wID0gb3A7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4vKipcbiAqIOWbuuWumuODj+ODleODnuODs+ODluODreODg+OCr+OBruS9nOaIkFxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBibG9ja0FycmF5IOODluODreODg+OCr+ODh+ODvOOCvyBieXRlIGFycmF5LlxuICogQHBhcmFtIHshYm9vbGVhbn0gaXNGaW5hbEJsb2NrIOacgOW+jOOBruODluODreODg+OCr+OBquOCieOBsHRydWUuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSDlm7rlrprjg4/jg5Xjg57jg7PnrKblj7fljJbjg5bjg63jg4Pjgq8gYnl0ZSBhcnJheS5cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLnByb3RvdHlwZS5tYWtlRml4ZWRIdWZmbWFuQmxvY2sgPVxuICAgIGZ1bmN0aW9uKGJsb2NrQXJyYXksIGlzRmluYWxCbG9jaykge1xuICAgICAgLyoqIEB0eXBlIHtabGliLkJpdFN0cmVhbX0gKi9cbiAgICAgIHZhciBzdHJlYW0gPSBuZXcgWmxpYi5CaXRTdHJlYW0oVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0LmJ1ZmZlcikgOiB0aGlzLm91dHB1dCwgdGhpcy5vcCk7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBiZmluYWw7XG4gICAgICAvKiogQHR5cGUge1psaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGV9ICovXG4gICAgICB2YXIgYnR5cGU7XG4gICAgICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDE2QXJyYXkpfSAqL1xuICAgICAgdmFyIGRhdGE7XG5cbiAgICAgIC8vIGhlYWRlclxuICAgICAgYmZpbmFsID0gaXNGaW5hbEJsb2NrID8gMSA6IDA7XG4gICAgICBidHlwZSA9IFpsaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGUuRklYRUQ7XG5cbiAgICAgIHN0cmVhbS53cml0ZUJpdHMoYmZpbmFsLCAxLCB0cnVlKTtcbiAgICAgIHN0cmVhbS53cml0ZUJpdHMoYnR5cGUsIDIsIHRydWUpO1xuXG4gICAgICBkYXRhID0gdGhpcy5sejc3KGJsb2NrQXJyYXkpO1xuICAgICAgdGhpcy5maXhlZEh1ZmZtYW4oZGF0YSwgc3RyZWFtKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbS5maW5pc2goKTtcbiAgICB9O1xuXG4vKipcbiAqIOWLleeahOODj+ODleODnuODs+ODluODreODg+OCr+OBruS9nOaIkFxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBibG9ja0FycmF5IOODluODreODg+OCr+ODh+ODvOOCvyBieXRlIGFycmF5LlxuICogQHBhcmFtIHshYm9vbGVhbn0gaXNGaW5hbEJsb2NrIOacgOW+jOOBruODluODreODg+OCr+OBquOCieOBsHRydWUuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSDli5XnmoTjg4/jg5Xjg57jg7PnrKblj7fjg5bjg63jg4Pjgq8gYnl0ZSBhcnJheS5cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLnByb3RvdHlwZS5tYWtlRHluYW1pY0h1ZmZtYW5CbG9jayA9XG4gICAgZnVuY3Rpb24oYmxvY2tBcnJheSwgaXNGaW5hbEJsb2NrKSB7XG4gICAgICAvKiogQHR5cGUge1psaWIuQml0U3RyZWFtfSAqL1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBabGliLkJpdFN0cmVhbShVU0VfVFlQRURBUlJBWSA/XG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXQuYnVmZmVyKSA6IHRoaXMub3V0cHV0LCB0aGlzLm9wKTtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGJmaW5hbDtcbiAgICAgIC8qKiBAdHlwZSB7WmxpYi5SYXdEZWZsYXRlLkNvbXByZXNzaW9uVHlwZX0gKi9cbiAgICAgIHZhciBidHlwZTtcbiAgICAgIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9ICovXG4gICAgICB2YXIgZGF0YTtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGhsaXQ7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBoZGlzdDtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGhjbGVuO1xuICAgICAgLyoqIEBjb25zdCBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgICB2YXIgaGNsZW5PcmRlciA9XG4gICAgICAgICAgWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdO1xuICAgICAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICAgICAgdmFyIGxpdExlbkxlbmd0aHM7XG4gICAgICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDE2QXJyYXkpfSAqL1xuICAgICAgdmFyIGxpdExlbkNvZGVzO1xuICAgICAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICAgICAgdmFyIGRpc3RMZW5ndGhzO1xuICAgICAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX0gKi9cbiAgICAgIHZhciBkaXN0Q29kZXM7XG4gICAgICAvKiogQHR5cGUge3tcbiAgICAgICAqICAgY29kZXM6ICEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpLFxuICAgICAgICogICBmcmVxczogIShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KVxuICAgICAgICogfX0gKi9cbiAgICAgIHZhciB0cmVlU3ltYm9scztcbiAgICAgIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgICAgIHZhciB0cmVlTGVuZ3RocztcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgICB2YXIgdHJhbnNMZW5ndGhzID0gbmV3IEFycmF5KDE5KTtcbiAgICAgIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9ICovXG4gICAgICB2YXIgdHJlZUNvZGVzO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB2YXIgY29kZTtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGJpdGxlbjtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGk7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBpbDtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBiZmluYWwgPSBpc0ZpbmFsQmxvY2sgPyAxIDogMDtcbiAgICAgIGJ0eXBlID0gWmxpYi5SYXdEZWZsYXRlLkNvbXByZXNzaW9uVHlwZS5EWU5BTUlDO1xuXG4gICAgICBzdHJlYW0ud3JpdGVCaXRzKGJmaW5hbCwgMSwgdHJ1ZSk7XG4gICAgICBzdHJlYW0ud3JpdGVCaXRzKGJ0eXBlLCAyLCB0cnVlKTtcblxuICAgICAgZGF0YSA9IHRoaXMubHo3NyhibG9ja0FycmF5KTtcblxuICAgICAgLy8g44Oq44OG44Op44Or44O76ZW344GVLCDot53pm6Ljga7jg4/jg5Xjg57jg7PnrKblj7fjgajnrKblj7fplbfjga7nrpflh7pcbiAgICAgIGxpdExlbkxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHNfKHRoaXMuZnJlcXNMaXRMZW4sIDE1KTtcbiAgICAgIGxpdExlbkNvZGVzID0gdGhpcy5nZXRDb2Rlc0Zyb21MZW5ndGhzXyhsaXRMZW5MZW5ndGhzKTtcbiAgICAgIGRpc3RMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzXyh0aGlzLmZyZXFzRGlzdCwgNyk7XG4gICAgICBkaXN0Q29kZXMgPSB0aGlzLmdldENvZGVzRnJvbUxlbmd0aHNfKGRpc3RMZW5ndGhzKTtcblxuICAgICAgLy8gSExJVCwgSERJU1Qg44Gu5rG65a6aXG4gICAgICBmb3IgKGhsaXQgPSAyODY7IGhsaXQgPiAyNTcgJiYgbGl0TGVuTGVuZ3Roc1tobGl0IC0gMV0gPT09IDA7IGhsaXQtLSkge31cbiAgICAgIGZvciAoaGRpc3QgPSAzMDsgaGRpc3QgPiAxICYmIGRpc3RMZW5ndGhzW2hkaXN0IC0gMV0gPT09IDA7IGhkaXN0LS0pIHt9XG5cbiAgICAgIC8vIEhDTEVOXG4gICAgICB0cmVlU3ltYm9scyA9XG4gICAgICAgICAgdGhpcy5nZXRUcmVlU3ltYm9sc18oaGxpdCwgbGl0TGVuTGVuZ3RocywgaGRpc3QsIGRpc3RMZW5ndGhzKTtcbiAgICAgIHRyZWVMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzXyh0cmVlU3ltYm9scy5mcmVxcywgNyk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMTk7IGkrKykge1xuICAgICAgICB0cmFuc0xlbmd0aHNbaV0gPSB0cmVlTGVuZ3Roc1toY2xlbk9yZGVyW2ldXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaGNsZW4gPSAxOTsgaGNsZW4gPiA0ICYmIHRyYW5zTGVuZ3Roc1toY2xlbiAtIDFdID09PSAwOyBoY2xlbi0tKSB7fVxuXG4gICAgICB0cmVlQ29kZXMgPSB0aGlzLmdldENvZGVzRnJvbUxlbmd0aHNfKHRyZWVMZW5ndGhzKTtcblxuICAgICAgLy8g5Ye65YqbXG4gICAgICBzdHJlYW0ud3JpdGVCaXRzKGhsaXQgLSAyNTcsIDUsIHRydWUpO1xuICAgICAgc3RyZWFtLndyaXRlQml0cyhoZGlzdCAtIDEsIDUsIHRydWUpO1xuICAgICAgc3RyZWFtLndyaXRlQml0cyhoY2xlbiAtIDQsIDQsIHRydWUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyBpKyspIHtcbiAgICAgICAgc3RyZWFtLndyaXRlQml0cyh0cmFuc0xlbmd0aHNbaV0sIDMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyDjg4Tjg6rjg7zjga7lh7rliptcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gdHJlZVN5bWJvbHMuY29kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb2RlID0gdHJlZVN5bWJvbHMuY29kZXNbaV07XG5cbiAgICAgICAgc3RyZWFtLndyaXRlQml0cyh0cmVlQ29kZXNbY29kZV0sIHRyZWVMZW5ndGhzW2NvZGVdLCB0cnVlKTtcblxuICAgICAgICAvLyBleHRyYSBiaXRzXG4gICAgICAgIGlmIChjb2RlID49IDE2KSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAxNjogYml0bGVuID0gMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE3OiBiaXRsZW4gPSAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTg6IGJpdGxlbiA9IDc7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgY29kZTogJyArIGNvZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyZWFtLndyaXRlQml0cyh0cmVlU3ltYm9scy5jb2Rlc1tpXSwgYml0bGVuLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmR5bmFtaWNIdWZmbWFuKFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgW2xpdExlbkNvZGVzLCBsaXRMZW5MZW5ndGhzXSxcbiAgICAgICAgICBbZGlzdENvZGVzLCBkaXN0TGVuZ3Roc10sXG4gICAgICAgICAgc3RyZWFtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gc3RyZWFtLmZpbmlzaCgpO1xuICAgIH07XG5cblxuLyoqXG4gKiDli5XnmoTjg4/jg5Xjg57jg7PnrKblj7fljJYo44Kr44K544K/44Og44OP44OV44Oe44Oz44OG44O844OW44OrKVxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX0gZGF0YUFycmF5IExaNzcg56ym5Y+35YyW5riI44G/IGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0geyFabGliLkJpdFN0cmVhbX0gc3RyZWFtIOabuOOBjei+vOOBv+eUqOODk+ODg+ODiOOCueODiOODquODvOODoC5cbiAqIEByZXR1cm4geyFabGliLkJpdFN0cmVhbX0g44OP44OV44Oe44Oz56ym5Y+35YyW5riI44G/44OT44OD44OI44K544OI44Oq44O844Og44Kq44OW44K444Kn44Kv44OILlxuICovXG5abGliLlJhd0RlZmxhdGUucHJvdG90eXBlLmR5bmFtaWNIdWZmbWFuID1cbiAgICBmdW5jdGlvbihkYXRhQXJyYXksIGxpdExlbiwgZGlzdCwgc3RyZWFtKSB7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBpbmRleDtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGxlbmd0aDtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdmFyIGxpdGVyYWw7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBjb2RlO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB2YXIgbGl0TGVuQ29kZXM7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHZhciBsaXRMZW5MZW5ndGhzO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB2YXIgZGlzdENvZGVzO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB2YXIgZGlzdExlbmd0aHM7XG5cbiAgICAgIGxpdExlbkNvZGVzID0gbGl0TGVuWzBdO1xuICAgICAgbGl0TGVuTGVuZ3RocyA9IGxpdExlblsxXTtcbiAgICAgIGRpc3RDb2RlcyA9IGRpc3RbMF07XG4gICAgICBkaXN0TGVuZ3RocyA9IGRpc3RbMV07XG5cbiAgICAgIC8vIOespuWPt+OCkiBCaXRTdHJlYW0g44Gr5pu444GN6L6844KT44Gn44GE44GPXG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZGF0YUFycmF5Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgbGl0ZXJhbCA9IGRhdGFBcnJheVtpbmRleF07XG5cbiAgICAgICAgLy8gbGl0ZXJhbCBvciBsZW5ndGhcbiAgICAgICAgc3RyZWFtLndyaXRlQml0cyhsaXRMZW5Db2Rlc1tsaXRlcmFsXSwgbGl0TGVuTGVuZ3Roc1tsaXRlcmFsXSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8g6ZW344GV44O76Led6Zui56ym5Y+3XG4gICAgICAgIGlmIChsaXRlcmFsID4gMjU2KSB7XG4gICAgICAgICAgLy8gbGVuZ3RoIGV4dHJhXG4gICAgICAgICAgc3RyZWFtLndyaXRlQml0cyhkYXRhQXJyYXlbKytpbmRleF0sIGRhdGFBcnJheVsrK2luZGV4XSwgdHJ1ZSk7XG4gICAgICAgICAgLy8gZGlzdGFuY2VcbiAgICAgICAgICBjb2RlID0gZGF0YUFycmF5WysraW5kZXhdO1xuICAgICAgICAgIHN0cmVhbS53cml0ZUJpdHMoZGlzdENvZGVzW2NvZGVdLCBkaXN0TGVuZ3Roc1tjb2RlXSwgdHJ1ZSk7XG4gICAgICAgICAgLy8gZGlzdGFuY2UgZXh0cmFcbiAgICAgICAgICBzdHJlYW0ud3JpdGVCaXRzKGRhdGFBcnJheVsrK2luZGV4XSwgZGF0YUFycmF5WysraW5kZXhdLCB0cnVlKTtcbiAgICAgICAgICAvLyDntYLnq69cbiAgICAgICAgfSBlbHNlIGlmIChsaXRlcmFsID09PSAyNTYpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH07XG5cbi8qKlxuICog5Zu65a6a44OP44OV44Oe44Oz56ym5Y+35YyWXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDE2QXJyYXkpfSBkYXRhQXJyYXkgTFo3NyDnrKblj7fljJbmuIjjgb8gYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7IVpsaWIuQml0U3RyZWFtfSBzdHJlYW0g5pu444GN6L6844G/55So44OT44OD44OI44K544OI44Oq44O844OgLlxuICogQHJldHVybiB7IVpsaWIuQml0U3RyZWFtfSDjg4/jg5Xjg57jg7PnrKblj7fljJbmuIjjgb/jg5Pjg4Pjg4jjgrnjg4jjg6rjg7zjg6Djgqrjg5bjgrjjgqfjgq/jg4guXG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5wcm90b3R5cGUuZml4ZWRIdWZmbWFuID0gZnVuY3Rpb24oZGF0YUFycmF5LCBzdHJlYW0pIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpbmRleDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBsZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgbGl0ZXJhbDtcblxuICAvLyDnrKblj7fjgpIgQml0U3RyZWFtIOOBq+abuOOBjei+vOOCk+OBp+OBhOOBj1xuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZGF0YUFycmF5Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBsaXRlcmFsID0gZGF0YUFycmF5W2luZGV4XTtcblxuICAgIC8vIOespuWPt+OBruabuOOBjei+vOOBv1xuICAgIFpsaWIuQml0U3RyZWFtLnByb3RvdHlwZS53cml0ZUJpdHMuYXBwbHkoXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgWmxpYi5SYXdEZWZsYXRlLkZpeGVkSHVmZm1hblRhYmxlW2xpdGVyYWxdXG4gICAgKTtcblxuICAgIC8vIOmVt+OBleODu+i3nembouespuWPt1xuICAgIGlmIChsaXRlcmFsID4gMHgxMDApIHtcbiAgICAgIC8vIGxlbmd0aCBleHRyYVxuICAgICAgc3RyZWFtLndyaXRlQml0cyhkYXRhQXJyYXlbKytpbmRleF0sIGRhdGFBcnJheVsrK2luZGV4XSwgdHJ1ZSk7XG4gICAgICAvLyBkaXN0YW5jZVxuICAgICAgc3RyZWFtLndyaXRlQml0cyhkYXRhQXJyYXlbKytpbmRleF0sIDUpO1xuICAgICAgLy8gZGlzdGFuY2UgZXh0cmFcbiAgICAgIHN0cmVhbS53cml0ZUJpdHMoZGF0YUFycmF5WysraW5kZXhdLCBkYXRhQXJyYXlbKytpbmRleF0sIHRydWUpO1xuICAgICAgLy8g57WC56uvXG4gICAgfSBlbHNlIGlmIChsaXRlcmFsID09PSAweDEwMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn07XG5cbi8qKlxuICog44Oe44OD44OB5oOF5aCxXG4gKiBAcGFyYW0geyFudW1iZXJ9IGxlbmd0aCDjg57jg4Pjg4HjgZfjgZ/plbfjgZUuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGJhY2t3YXJkRGlzdGFuY2Ug44Oe44OD44OB5L2N572u44Go44Gu6Led6ZuiLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5Mejc3TWF0Y2ggPSBmdW5jdGlvbihsZW5ndGgsIGJhY2t3YXJkRGlzdGFuY2UpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IG1hdGNoIGxlbmd0aC4gKi9cbiAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBiYWNrd2FyZCBkaXN0YW5jZS4gKi9cbiAgdGhpcy5iYWNrd2FyZERpc3RhbmNlID0gYmFja3dhcmREaXN0YW5jZTtcbn07XG5cbi8qKlxuICog6ZW344GV56ym5Y+344OG44O844OW44OrLlxuICogW+OCs+ODvOODiSwg5ouh5by144OT44OD44OILCDmi6HlvLXjg5Pjg4Pjg4jplbddIOOBrumFjeWIl+OBqOOBquOBo+OBpuOBhOOCiy5cbiAqIEBjb25zdFxuICogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfVxuICovXG5abGliLlJhd0RlZmxhdGUuTHo3N01hdGNoLkxlbmd0aENvZGVUYWJsZSA9IChmdW5jdGlvbih0YWJsZSkge1xuICByZXR1cm4gVVNFX1RZUEVEQVJSQVkgPyBuZXcgVWludDMyQXJyYXkodGFibGUpIDogdGFibGU7XG59KSgoZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7IUFycmF5fSAqL1xuICB2YXIgdGFibGUgPSBbXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUgeyFBcnJheS48bnVtYmVyPn0gKi9cbiAgdmFyIGM7XG5cbiAgZm9yIChpID0gMzsgaSA8PSAyNTg7IGkrKykge1xuICAgIGMgPSBjb2RlKGkpO1xuICAgIHRhYmxlW2ldID0gKGNbMl0gPDwgMjQpIHwgKGNbMV0gPDwgMTYpIHwgY1swXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIGx6NzcgbGVuZ3RoLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPG51bWJlcj59IGx6NzcgY29kZXMuXG4gICAqL1xuICBmdW5jdGlvbiBjb2RlKGxlbmd0aCkge1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSAobGVuZ3RoID09PSAzKTogcmV0dXJuIFsyNTcsIGxlbmd0aCAtIDMsIDBdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA9PT0gNCk6IHJldHVybiBbMjU4LCBsZW5ndGggLSA0LCAwXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPT09IDUpOiByZXR1cm4gWzI1OSwgbGVuZ3RoIC0gNSwgMF07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoID09PSA2KTogcmV0dXJuIFsyNjAsIGxlbmd0aCAtIDYsIDBdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA9PT0gNyk6IHJldHVybiBbMjYxLCBsZW5ndGggLSA3LCAwXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPT09IDgpOiByZXR1cm4gWzI2MiwgbGVuZ3RoIC0gOCwgMF07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoID09PSA5KTogcmV0dXJuIFsyNjMsIGxlbmd0aCAtIDksIDBdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA9PT0gMTApOiByZXR1cm4gWzI2NCwgbGVuZ3RoIC0gMTAsIDBdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSAxMik6IHJldHVybiBbMjY1LCBsZW5ndGggLSAxMSwgMV07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDE0KTogcmV0dXJuIFsyNjYsIGxlbmd0aCAtIDEzLCAxXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gMTYpOiByZXR1cm4gWzI2NywgbGVuZ3RoIC0gMTUsIDFdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSAxOCk6IHJldHVybiBbMjY4LCBsZW5ndGggLSAxNywgMV07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDIyKTogcmV0dXJuIFsyNjksIGxlbmd0aCAtIDE5LCAyXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gMjYpOiByZXR1cm4gWzI3MCwgbGVuZ3RoIC0gMjMsIDJdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSAzMCk6IHJldHVybiBbMjcxLCBsZW5ndGggLSAyNywgMl07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDM0KTogcmV0dXJuIFsyNzIsIGxlbmd0aCAtIDMxLCAyXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gNDIpOiByZXR1cm4gWzI3MywgbGVuZ3RoIC0gMzUsIDNdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSA1MCk6IHJldHVybiBbMjc0LCBsZW5ndGggLSA0MywgM107IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDU4KTogcmV0dXJuIFsyNzUsIGxlbmd0aCAtIDUxLCAzXTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gNjYpOiByZXR1cm4gWzI3NiwgbGVuZ3RoIC0gNTksIDNdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSA4Mik6IHJldHVybiBbMjc3LCBsZW5ndGggLSA2NywgNF07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDk4KTogcmV0dXJuIFsyNzgsIGxlbmd0aCAtIDgzLCA0XTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gMTE0KTogcmV0dXJuIFsyNzksIGxlbmd0aCAtIDk5LCA0XTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gMTMwKTogcmV0dXJuIFsyODAsIGxlbmd0aCAtIDExNSwgNF07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDE2Mik6IHJldHVybiBbMjgxLCBsZW5ndGggLSAxMzEsIDVdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA8PSAxOTQpOiByZXR1cm4gWzI4MiwgbGVuZ3RoIC0gMTYzLCA1XTsgYnJlYWs7XG4gICAgICBjYXNlIChsZW5ndGggPD0gMjI2KTogcmV0dXJuIFsyODMsIGxlbmd0aCAtIDE5NSwgNV07IGJyZWFrO1xuICAgICAgY2FzZSAobGVuZ3RoIDw9IDI1Nyk6IHJldHVybiBbMjg0LCBsZW5ndGggLSAyMjcsIDVdOyBicmVhaztcbiAgICAgIGNhc2UgKGxlbmd0aCA9PT0gMjU4KTogcmV0dXJuIFsyODUsIGxlbmd0aCAtIDI1OCwgMF07IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgJ2ludmFsaWQgbGVuZ3RoOiAnICsgbGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn0pKCkpO1xuXG4vKipcbiAqIOi3nembouespuWPt+ODhuODvOODluODq1xuICogQHBhcmFtIHshbnVtYmVyfSBkaXN0IOi3nemboi5cbiAqIEByZXR1cm4geyFBcnJheS48bnVtYmVyPn0g44Kz44O844OJ44CB5ouh5by144OT44OD44OI44CB5ouh5by144OT44OD44OI6ZW344Gu6YWN5YiXLlxuICogQHByaXZhdGVcbiAqL1xuWmxpYi5SYXdEZWZsYXRlLkx6NzdNYXRjaC5wcm90b3R5cGUuZ2V0RGlzdGFuY2VDb2RlXyA9IGZ1bmN0aW9uKGRpc3QpIHtcbiAgLyoqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59IGRpc3RhbmNlIGNvZGUgdGFibGUuICovXG4gIHZhciByO1xuXG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgKGRpc3QgPT09IDEpOiByID0gWzAsIGRpc3QgLSAxLCAwXTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA9PT0gMik6IHIgPSBbMSwgZGlzdCAtIDIsIDBdOyBicmVhaztcbiAgICBjYXNlIChkaXN0ID09PSAzKTogciA9IFsyLCBkaXN0IC0gMywgMF07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPT09IDQpOiByID0gWzMsIGRpc3QgLSA0LCAwXTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSA2KTogciA9IFs0LCBkaXN0IC0gNSwgMV07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gOCk6IHIgPSBbNSwgZGlzdCAtIDcsIDFdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDEyKTogciA9IFs2LCBkaXN0IC0gOSwgMl07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMTYpOiByID0gWzcsIGRpc3QgLSAxMywgMl07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMjQpOiByID0gWzgsIGRpc3QgLSAxNywgM107IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMzIpOiByID0gWzksIGRpc3QgLSAyNSwgM107IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gNDgpOiByID0gWzEwLCBkaXN0IC0gMzMsIDRdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDY0KTogciA9IFsxMSwgZGlzdCAtIDQ5LCA0XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSA5Nik6IHIgPSBbMTIsIGRpc3QgLSA2NSwgNV07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMTI4KTogciA9IFsxMywgZGlzdCAtIDk3LCA1XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAxOTIpOiByID0gWzE0LCBkaXN0IC0gMTI5LCA2XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAyNTYpOiByID0gWzE1LCBkaXN0IC0gMTkzLCA2XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAzODQpOiByID0gWzE2LCBkaXN0IC0gMjU3LCA3XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSA1MTIpOiByID0gWzE3LCBkaXN0IC0gMzg1LCA3XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSA3NjgpOiByID0gWzE4LCBkaXN0IC0gNTEzLCA4XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAxMDI0KTogciA9IFsxOSwgZGlzdCAtIDc2OSwgOF07IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMTUzNik6IHIgPSBbMjAsIGRpc3QgLSAxMDI1LCA5XTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAyMDQ4KTogciA9IFsyMSwgZGlzdCAtIDE1MzcsIDldOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDMwNzIpOiByID0gWzIyLCBkaXN0IC0gMjA0OSwgMTBdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDQwOTYpOiByID0gWzIzLCBkaXN0IC0gMzA3MywgMTBdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDYxNDQpOiByID0gWzI0LCBkaXN0IC0gNDA5NywgMTFdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDgxOTIpOiByID0gWzI1LCBkaXN0IC0gNjE0NSwgMTFdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDEyMjg4KTogciA9IFsyNiwgZGlzdCAtIDgxOTMsIDEyXTsgYnJlYWs7XG4gICAgY2FzZSAoZGlzdCA8PSAxNjM4NCk6IHIgPSBbMjcsIGRpc3QgLSAxMjI4OSwgMTJdOyBicmVhaztcbiAgICBjYXNlIChkaXN0IDw9IDI0NTc2KTogciA9IFsyOCwgZGlzdCAtIDE2Mzg1LCAxM107IGJyZWFrO1xuICAgIGNhc2UgKGRpc3QgPD0gMzI3NjgpOiByID0gWzI5LCBkaXN0IC0gMjQ1NzcsIDEzXTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgJ2ludmFsaWQgZGlzdGFuY2UnO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIOODnuODg+ODgeaDheWgseOCkiBMWjc3IOespuWPt+WMlumFjeWIl+OBp+i/lOOBmS5cbiAqIOOBquOBiuOAgeOBk+OBk+OBp+OBr+S7peS4i+OBruWGhemDqOS7leanmOOBp+espuWPt+WMluOBl+OBpuOBhOOCi1xuICogWyBDT0RFLCBFWFRSQS1CSVQtTEVOLCBFWFRSQSwgQ09ERSwgRVhUUkEtQklULUxFTiwgRVhUUkEgXVxuICogQHJldHVybiB7IUFycmF5LjxudW1iZXI+fSBMWjc3IOespuWPt+WMliBieXRlIGFycmF5LlxuICovXG5abGliLlJhd0RlZmxhdGUuTHo3N01hdGNoLnByb3RvdHlwZS50b0x6NzdBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGRpc3QgPSB0aGlzLmJhY2t3YXJkRGlzdGFuY2U7XG4gIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gIHZhciBjb2RlQXJyYXkgPSBbXTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBwb3MgPSAwO1xuICAvKiogQHR5cGUgeyFBcnJheS48bnVtYmVyPn0gKi9cbiAgdmFyIGNvZGU7XG5cbiAgLy8gbGVuZ3RoXG4gIGNvZGUgPSBabGliLlJhd0RlZmxhdGUuTHo3N01hdGNoLkxlbmd0aENvZGVUYWJsZVtsZW5ndGhdO1xuICBjb2RlQXJyYXlbcG9zKytdID0gY29kZSAmIDB4ZmZmZjtcbiAgY29kZUFycmF5W3BvcysrXSA9IChjb2RlID4+IDE2KSAmIDB4ZmY7XG4gIGNvZGVBcnJheVtwb3MrK10gPSBjb2RlID4+IDI0O1xuXG4gIC8vIGRpc3RhbmNlXG4gIGNvZGUgPSB0aGlzLmdldERpc3RhbmNlQ29kZV8oZGlzdCk7XG4gIGNvZGVBcnJheVtwb3MrK10gPSBjb2RlWzBdO1xuICBjb2RlQXJyYXlbcG9zKytdID0gY29kZVsxXTtcbiAgY29kZUFycmF5W3BvcysrXSA9IGNvZGVbMl07XG5cbiAgcmV0dXJuIGNvZGVBcnJheTtcbn07XG5cbi8qKlxuICogTFo3NyDlrp/oo4VcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gZGF0YUFycmF5IExaNzcg56ym5Y+35YyW44GZ44KL44OQ44Kk44OI6YWN5YiXLlxuICogQHJldHVybiB7IShBcnJheS48bnVtYmVyPnxVaW50MTZBcnJheSl9IExaNzcg56ym5Y+35YyW44GX44Gf6YWN5YiXLlxuICovXG5abGliLlJhd0RlZmxhdGUucHJvdG90eXBlLmx6NzcgPSBmdW5jdGlvbihkYXRhQXJyYXkpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IHBvc2l0aW9uICovXG4gIHZhciBwb3NpdGlvbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGlucHV0IGxlbmd0aCAqL1xuICB2YXIgbGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBjb3VudGVyICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsaW1pdGVyICovXG4gIHZhciBpbDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGNoYWluZWQtaGFzaC10YWJsZSBrZXkgKi9cbiAgdmFyIG1hdGNoS2V5O1xuICAvKiogQHR5cGUge09iamVjdC48bnVtYmVyLCBBcnJheS48bnVtYmVyPj59IGNoYWluZWQtaGFzaC10YWJsZSAqL1xuICB2YXIgdGFibGUgPSB7fTtcbiAgLyoqIEBjb25zdCBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgd2luZG93U2l6ZSA9IFpsaWIuUmF3RGVmbGF0ZS5XaW5kb3dTaXplO1xuICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSBtYXRjaCBsaXN0ICovXG4gIHZhciBtYXRjaExpc3Q7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdEZWZsYXRlLkx6NzdNYXRjaH0gbG9uZ2VzdCBtYXRjaCAqL1xuICB2YXIgbG9uZ2VzdE1hdGNoO1xuICAvKiogQHR5cGUge1psaWIuUmF3RGVmbGF0ZS5Mejc3TWF0Y2h9IHByZXZpb3VzIGxvbmdlc3QgbWF0Y2ggKi9cbiAgdmFyIHByZXZNYXRjaDtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX0gbHo3NyBidWZmZXIgKi9cbiAgdmFyIGx6NzdidWYgPSBVU0VfVFlQRURBUlJBWSA/XG4gICAgICBuZXcgVWludDE2QXJyYXkoZGF0YUFycmF5Lmxlbmd0aCAqIDIpIDogW107XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsejc3IG91dHB1dCBidWZmZXIgcG9pbnRlciAqL1xuICB2YXIgcG9zID0gMDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGx6Nzcgc2tpcCBsZW5ndGggKi9cbiAgdmFyIHNraXBMZW5ndGggPSAwO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqL1xuICB2YXIgZnJlcXNMaXRMZW4gPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDMyQXJyYXkgOiBBcnJheSkoMjg2KTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KX0gKi9cbiAgdmFyIGZyZXFzRGlzdCA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50MzJBcnJheSA6IEFycmF5KSgzMCk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgbGF6eSA9IHRoaXMubGF6eTtcbiAgLyoqIEB0eXBlIHsqfSB0ZW1wb3JhcnkgdmFyaWFibGUgKi9cbiAgdmFyIHRtcDtcblxuICAvLyDliJ3mnJ/ljJZcbiAgaWYgKCFVU0VfVFlQRURBUlJBWSkge1xuICAgIGZvciAoaSA9IDA7IGkgPD0gMjg1OykgeyBmcmVxc0xpdExlbltpKytdID0gMDsgfVxuICAgIGZvciAoaSA9IDA7IGkgPD0gMjk7KSB7IGZyZXFzRGlzdFtpKytdID0gMDsgfVxuICB9XG4gIGZyZXFzTGl0TGVuWzI1Nl0gPSAxOyAvLyBFT0Ig44Gu5pyA5L2O5Ye654++5Zue5pWw44GvIDFcblxuICAvKipcbiAgICog44Oe44OD44OB44OH44O844K/44Gu5pu444GN6L6844G/XG4gICAqIEBwYXJhbSB7WmxpYi5SYXdEZWZsYXRlLkx6NzdNYXRjaH0gbWF0Y2ggTFo3NyBNYXRjaCBkYXRhLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IG9mZnNldCDjgrnjgq3jg4Pjg5fplovlp4vkvY3nva4o55u45a++5oyH5a6aKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlTWF0Y2gobWF0Y2gsIG9mZnNldCkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgdmFyIGx6NzdBcnJheSA9IG1hdGNoLnRvTHo3N0FycmF5KCk7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGk7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGlsO1xuXG4gICAgZm9yIChpID0gMCwgaWwgPSBsejc3QXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgbHo3N2J1Zltwb3MrK10gPSBsejc3QXJyYXlbaV07XG4gICAgfVxuICAgIGZyZXFzTGl0TGVuW2x6NzdBcnJheVswXV0rKztcbiAgICBmcmVxc0Rpc3RbbHo3N0FycmF5WzNdXSsrO1xuICAgIHNraXBMZW5ndGggPSBtYXRjaC5sZW5ndGggKyBvZmZzZXQgLSAxO1xuICAgIHByZXZNYXRjaCA9IG51bGw7XG4gIH1cblxuICAvLyBMWjc3IOespuWPt+WMllxuICBmb3IgKHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gZGF0YUFycmF5Lmxlbmd0aDsgcG9zaXRpb24gPCBsZW5ndGg7ICsrcG9zaXRpb24pIHtcbiAgICAvLyDjg4/jg4Pjgrfjg6Xjgq3jg7zjga7kvZzmiJBcbiAgICBmb3IgKG1hdGNoS2V5ID0gMCwgaSA9IDAsIGlsID0gWmxpYi5SYXdEZWZsYXRlLkx6NzdNaW5MZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICBpZiAocG9zaXRpb24gKyBpID09PSBsZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXRjaEtleSA9IChtYXRjaEtleSA8PCA4KSB8IGRhdGFBcnJheVtwb3NpdGlvbiArIGldO1xuICAgIH1cblxuICAgIC8vIOODhuODvOODluODq+OBjOacquWumue+qeOBoOOBo+OBn+OCieS9nOaIkOOBmeOCi1xuICAgIGlmICh0YWJsZVttYXRjaEtleV0gPT09IHZvaWQgMCkgeyB0YWJsZVttYXRjaEtleV0gPSBbXTsgfVxuICAgIG1hdGNoTGlzdCA9IHRhYmxlW21hdGNoS2V5XTtcblxuICAgIC8vIHNraXBcbiAgICBpZiAoc2tpcExlbmd0aC0tID4gMCkge1xuICAgICAgbWF0Y2hMaXN0LnB1c2gocG9zaXRpb24pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8g44Oe44OD44OB44OG44O844OW44Or44Gu5pu05pawICjmnIDlpKfmiLvjgorot53pm6LjgpLotoXjgYjjgabjgYTjgovjgoLjga7jgpLliYrpmaTjgZnjgospXG4gICAgd2hpbGUgKG1hdGNoTGlzdC5sZW5ndGggPiAwICYmIHBvc2l0aW9uIC0gbWF0Y2hMaXN0WzBdID4gd2luZG93U2l6ZSkge1xuICAgICAgbWF0Y2hMaXN0LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8g44OH44O844K/5pyr5bC+44Gn44Oe44OD44OB44GX44KI44GG44GM44Gq44GE5aC05ZCI44Gv44Gd44Gu44G+44G+5rWB44GX44GT44KAXG4gICAgaWYgKHBvc2l0aW9uICsgWmxpYi5SYXdEZWZsYXRlLkx6NzdNaW5MZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICBpZiAocHJldk1hdGNoKSB7XG4gICAgICAgIHdyaXRlTWF0Y2gocHJldk1hdGNoLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlsID0gbGVuZ3RoIC0gcG9zaXRpb247IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHRtcCA9IGRhdGFBcnJheVtwb3NpdGlvbiArIGldO1xuICAgICAgICBsejc3YnVmW3BvcysrXSA9IHRtcDtcbiAgICAgICAgKytmcmVxc0xpdExlblt0bXBdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8g44Oe44OD44OB5YCZ6KOc44GL44KJ5pyA6ZW344Gu44KC44Gu44KS5o6i44GZXG4gICAgaWYgKG1hdGNoTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICBsb25nZXN0TWF0Y2ggPSB0aGlzLnNlYXJjaExvbmdlc3RNYXRjaF8oZGF0YUFycmF5LCBwb3NpdGlvbiwgbWF0Y2hMaXN0KTtcblxuICAgICAgaWYgKHByZXZNYXRjaCkge1xuICAgICAgICAvLyDnj77lnKjjga7jg57jg4Pjg4Hjga7mlrnjgYzliY3lm57jga7jg57jg4Pjg4HjgojjgorjgoLplbfjgYRcbiAgICAgICAgaWYgKHByZXZNYXRjaC5sZW5ndGggPCBsb25nZXN0TWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gd3JpdGUgcHJldmlvdXMgbGl0ZXJhbFxuICAgICAgICAgIHRtcCA9IGRhdGFBcnJheVtwb3NpdGlvbiAtIDFdO1xuICAgICAgICAgIGx6NzdidWZbcG9zKytdID0gdG1wO1xuICAgICAgICAgICsrZnJlcXNMaXRMZW5bdG1wXTtcblxuICAgICAgICAgIC8vIHdyaXRlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAgICB3cml0ZU1hdGNoKGxvbmdlc3RNYXRjaCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd3JpdGUgcHJldmlvdXMgbWF0Y2hcbiAgICAgICAgICB3cml0ZU1hdGNoKHByZXZNYXRjaCwgLTEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvbmdlc3RNYXRjaC5sZW5ndGggPCBsYXp5KSB7XG4gICAgICAgIHByZXZNYXRjaCA9IGxvbmdlc3RNYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlTWF0Y2gobG9uZ2VzdE1hdGNoLCAwKTtcbiAgICAgIH1cbiAgICAgIC8vIOWJjeWbnuODnuODg+ODgeOBl+OBpuOBhOOBpuS7iuWbnuODnuODg+ODgeOBjOOBquOBi+OBo+OBn+OCieWJjeWbnuOBruOCkuaOoeeUqFxuICAgIH0gZWxzZSBpZiAocHJldk1hdGNoKSB7XG4gICAgICB3cml0ZU1hdGNoKHByZXZNYXRjaCwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgPSBkYXRhQXJyYXlbcG9zaXRpb25dO1xuICAgICAgbHo3N2J1Zltwb3MrK10gPSB0bXA7XG4gICAgICArK2ZyZXFzTGl0TGVuW3RtcF07XG4gICAgfVxuXG4gICAgbWF0Y2hMaXN0LnB1c2gocG9zaXRpb24pOyAvLyDjg57jg4Pjg4Hjg4bjg7zjg5bjg6vjgavnj77lnKjjga7kvY3nva7jgpLkv53lrZhcbiAgfVxuXG4gIC8vIOe1guerr+WHpueQhlxuICBsejc3YnVmW3BvcysrXSA9IDI1NjtcbiAgZnJlcXNMaXRMZW5bMjU2XSsrO1xuICB0aGlzLmZyZXFzTGl0TGVuID0gZnJlcXNMaXRMZW47XG4gIHRoaXMuZnJlcXNEaXN0ID0gZnJlcXNEaXN0O1xuXG4gIHJldHVybiAvKiogQHR5cGUgeyEoVWludDE2QXJyYXl8QXJyYXkuPG51bWJlcj4pfSAqLyAoXG4gICAgICBVU0VfVFlQRURBUlJBWSA/ICBsejc3YnVmLnN1YmFycmF5KDAsIHBvcykgOiBsejc3YnVmXG4gICk7XG59O1xuXG4vKipcbiAqIOODnuODg+ODgeOBl+OBn+WAmeijnOOBruS4reOBi+OCieacgOmVt+S4gOiHtOOCkuaOouOBmVxuICogQHBhcmFtIHshT2JqZWN0fSBkYXRhIHBsYWluIGRhdGEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zaXRpb24gcGxhaW4gZGF0YSBieXRlIGFycmF5IHBvc2l0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IG1hdGNoTGlzdCDlgJnoo5zjgajjgarjgovkvY3nva7jga7phY3liJcuXG4gKiBAcmV0dXJuIHshWmxpYi5SYXdEZWZsYXRlLkx6NzdNYXRjaH0g5pyA6ZW344GL44Gk5pyA55+t6Led6Zui44Gu44Oe44OD44OB44Kq44OW44K444Kn44Kv44OILlxuICogQHByaXZhdGVcbiAqL1xuWmxpYi5SYXdEZWZsYXRlLnByb3RvdHlwZS5zZWFyY2hMb25nZXN0TWF0Y2hfID1cbiAgICBmdW5jdGlvbihkYXRhLCBwb3NpdGlvbiwgbWF0Y2hMaXN0KSB7XG4gICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgY3VycmVudE1hdGNoLFxuICAgICAgICAgIG1hdGNoTWF4ID0gMCwgbWF0Y2hMZW5ndGgsXG4gICAgICAgICAgaSwgaiwgbCwgZGwgPSBkYXRhLmxlbmd0aDtcblxuICAgICAgLy8g5YCZ6KOc44KS5b6M44KN44GL44KJIDEg44Gk44Ga44Gk57We44KK6L6844KT44Gn44KG44GPXG4gICAgICBwZXJtYXRjaDpcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWF0Y2hMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaExpc3RbbCAtIGkgLSAxXTtcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gWmxpYi5SYXdEZWZsYXRlLkx6NzdNaW5MZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIOWJjeWbnuOBvuOBp+OBruacgOmVt+S4gOiHtOOCkuacq+WwvuOBi+OCieS4gOiHtOaknOe0ouOBmeOCi1xuICAgICAgICAgICAgaWYgKG1hdGNoTWF4ID4gWmxpYi5SYXdEZWZsYXRlLkx6NzdNaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gbWF0Y2hNYXg7IGogPiBabGliLlJhd0RlZmxhdGUuTHo3N01pbkxlbmd0aDsgai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbbWF0Y2ggKyBqIC0gMV0gIT09IGRhdGFbcG9zaXRpb24gKyBqIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHBlcm1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXRjaExlbmd0aCA9IG1hdGNoTWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDmnIDplbfkuIDoh7TmjqLntKJcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaExlbmd0aCA8IFpsaWIuUmF3RGVmbGF0ZS5Mejc3TWF4TGVuZ3RoICYmXG4gICAgICAgICAgICBwb3NpdGlvbiArIG1hdGNoTGVuZ3RoIDwgZGwgJiZcbiAgICAgICAgICAgIGRhdGFbbWF0Y2ggKyBtYXRjaExlbmd0aF0gPT09IGRhdGFbcG9zaXRpb24gKyBtYXRjaExlbmd0aF0pIHtcbiAgICAgICAgICAgICAgKyttYXRjaExlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g44Oe44OD44OB6ZW344GM5ZCM44GY5aC05ZCI44Gv5b6M5pa544KS5YSq5YWIXG4gICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGggPiBtYXRjaE1heCkge1xuICAgICAgICAgICAgICBjdXJyZW50TWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgICAgICAgbWF0Y2hNYXggPSBtYXRjaExlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5pyA6ZW344GM56K65a6a44GX44Gf44KJ5b6M44Gu5Yem55CG44Gv55yB55WlXG4gICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGggPT09IFpsaWIuUmF3RGVmbGF0ZS5Mejc3TWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBabGliLlJhd0RlZmxhdGUuTHo3N01hdGNoKG1hdGNoTWF4LCBwb3NpdGlvbiAtIGN1cnJlbnRNYXRjaCk7XG4gICAgfTtcblxuLyoqXG4gKiBUcmVlLVRyYW5zbWl0IFN5bWJvbHMg44Gu566X5Ye6XG4gKiByZWZlcmVuY2U6IFB1VFRZIERlZmxhdGUgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBobGl0IEhMSVQuXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGxpdGxlbkxlbmd0aHMg44Oq44OG44Op44Or44Go6ZW344GV56ym5Y+344Gu56ym5Y+36ZW36YWN5YiXLlxuICogQHBhcmFtIHtudW1iZXJ9IGhkaXN0IEhESVNULlxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBkaXN0TGVuZ3RocyDot53pm6LnrKblj7fjga7nrKblj7fplbfphY3liJcuXG4gKiBAcmV0dXJuIHt7XG4gKiAgIGNvZGVzOiAhKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KSxcbiAqICAgZnJlcXM6ICEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSlcbiAqIH19IFRyZWUtVHJhbnNtaXQgU3ltYm9scy5cbiAqL1xuWmxpYi5SYXdEZWZsYXRlLnByb3RvdHlwZS5nZXRUcmVlU3ltYm9sc18gPVxuICAgIGZ1bmN0aW9uKGhsaXQsIGxpdGxlbkxlbmd0aHMsIGhkaXN0LCBkaXN0TGVuZ3Rocykge1xuICAgICAgdmFyIHNyYyA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50MzJBcnJheSA6IEFycmF5KShobGl0ICsgaGRpc3QpLFxuICAgICAgICAgIGksIGosIHJ1bkxlbmd0aCwgbCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDMyQXJyYXkgOiBBcnJheSkoMjg2ICsgMzApLFxuICAgICAgICAgIG5SZXN1bHQsXG4gICAgICAgICAgcnB0LFxuICAgICAgICAgIGZyZXFzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoMTkpO1xuXG4gICAgICBqID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBobGl0OyBpKyspIHtcbiAgICAgICAgc3JjW2orK10gPSBsaXRsZW5MZW5ndGhzW2ldO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGhkaXN0OyBpKyspIHtcbiAgICAgICAgc3JjW2orK10gPSBkaXN0TGVuZ3Roc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8g5Yid5pyf5YyWXG4gICAgICBpZiAoIVVTRV9UWVBFREFSUkFZKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBmcmVxcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBmcmVxc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8g56ym5Y+35YyWXG4gICAgICBuUmVzdWx0ID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmMubGVuZ3RoOyBpIDwgbDsgaSArPSBqKSB7XG4gICAgICAgIC8vIFJ1biBMZW5ndGggRW5jb2RpbmdcbiAgICAgICAgZm9yIChqID0gMTsgaSArIGogPCBsICYmIHNyY1tpICsgal0gPT09IHNyY1tpXTsgKytqKSB7fVxuXG4gICAgICAgIHJ1bkxlbmd0aCA9IGo7XG5cbiAgICAgICAgaWYgKHNyY1tpXSA9PT0gMCkge1xuICAgICAgICAgIC8vIDAg44Gu57mw44KK6L+U44GX44GMIDMg5Zue5pyq5rqA44Gq44KJ44Gw44Gd44Gu44G+44G+XG4gICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5MZW5ndGgtLSA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0W25SZXN1bHQrK10gPSAwO1xuICAgICAgICAgICAgICBmcmVxc1swXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyDnubDjgorov5TjgZfjga/mnIDlpKcgMTM4IOOBvuOBp+OBquOBruOBp+WIh+OCiuipsOOCgeOCi1xuICAgICAgICAgICAgICBycHQgPSAocnVuTGVuZ3RoIDwgMTM4ID8gcnVuTGVuZ3RoIDogMTM4KTtcblxuICAgICAgICAgICAgICBpZiAocnB0ID4gcnVuTGVuZ3RoIC0gMyAmJiBycHQgPCBydW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBycHQgPSBydW5MZW5ndGggLSAzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMy0xMCDlm54gLT4gMTdcbiAgICAgICAgICAgICAgaWYgKHJwdCA8PSAxMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtuUmVzdWx0KytdID0gMTc7XG4gICAgICAgICAgICAgICAgcmVzdWx0W25SZXN1bHQrK10gPSBycHQgLSAzO1xuICAgICAgICAgICAgICAgIGZyZXFzWzE3XSsrO1xuICAgICAgICAgICAgICAgIC8vIDExLTEzOCDlm54gLT4gMThcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbblJlc3VsdCsrXSA9IDE4O1xuICAgICAgICAgICAgICAgIHJlc3VsdFtuUmVzdWx0KytdID0gcnB0IC0gMTE7XG4gICAgICAgICAgICAgICAgZnJlcXNbMThdKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBydW5MZW5ndGggLT0gcnB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbblJlc3VsdCsrXSA9IHNyY1tpXTtcbiAgICAgICAgICBmcmVxc1tzcmNbaV1dKys7XG4gICAgICAgICAgcnVuTGVuZ3RoLS07XG5cbiAgICAgICAgICAvLyDnubDjgorov5TjgZflm57mlbDjgYwz5Zue5pyq5rqA44Gq44KJ44Gw44Op44Oz44Os44Oz44Kw44K556ym5Y+344Gv6KaB44KJ44Gq44GEXG4gICAgICAgICAgaWYgKHJ1bkxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5MZW5ndGgtLSA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0W25SZXN1bHQrK10gPSBzcmNbaV07XG4gICAgICAgICAgICAgIGZyZXFzW3NyY1tpXV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMg5Zue5Lul5LiK44Gq44KJ44Gw44Op44Oz44Os44Oz44Kw44K556ym5Y+35YyWXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5MZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIHJ1bkxlbmd0aOOCkiAzLTYg44Gn5YiG5YmyXG4gICAgICAgICAgICAgIHJwdCA9IChydW5MZW5ndGggPCA2ID8gcnVuTGVuZ3RoIDogNik7XG5cbiAgICAgICAgICAgICAgaWYgKHJwdCA+IHJ1bkxlbmd0aCAtIDMgJiYgcnB0IDwgcnVuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcnB0ID0gcnVuTGVuZ3RoIC0gMztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdFtuUmVzdWx0KytdID0gMTY7XG4gICAgICAgICAgICAgIHJlc3VsdFtuUmVzdWx0KytdID0gcnB0IC0gMztcbiAgICAgICAgICAgICAgZnJlcXNbMTZdKys7XG5cbiAgICAgICAgICAgICAgcnVuTGVuZ3RoIC09IHJwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZXM6XG4gICAgICAgICAgICBVU0VfVFlQRURBUlJBWSA/IHJlc3VsdC5zdWJhcnJheSgwLCBuUmVzdWx0KSA6IHJlc3VsdC5zbGljZSgwLCBuUmVzdWx0KSxcbiAgICAgICAgZnJlcXM6IGZyZXFzXG4gICAgICB9O1xuICAgIH07XG5cbi8qKlxuICog44OP44OV44Oe44Oz56ym5Y+344Gu6ZW344GV44KS5Y+W5b6X44GZ44KLXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheXxVaW50MzJBcnJheSl9IGZyZXFzIOWHuuePvuOCq+OCpuODs+ODiC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCDnrKblj7fplbfjga7liLbpmZAuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSDnrKblj7fplbfphY3liJcuXG4gKiBAcHJpdmF0ZVxuICovXG5abGliLlJhd0RlZmxhdGUucHJvdG90eXBlLmdldExlbmd0aHNfID0gZnVuY3Rpb24oZnJlcXMsIGxpbWl0KSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgblN5bWJvbHMgPSBmcmVxcy5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7WmxpYi5IZWFwfSAqL1xuICB2YXIgaGVhcCA9IG5ldyBabGliLkhlYXAoMiAqIFpsaWIuUmF3RGVmbGF0ZS5IVUZNQVgpO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBsZW5ndGggPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KShuU3ltYm9scyk7XG4gIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gIHZhciBub2RlcztcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KX0gKi9cbiAgdmFyIHZhbHVlcztcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgY29kZUxlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlsO1xuXG4gIC8vIOmFjeWIl+OBruWIneacn+WMllxuICBpZiAoIVVTRV9UWVBFREFSUkFZKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5TeW1ib2xzOyBpKyspIHtcbiAgICAgIGxlbmd0aFtpXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8g44OS44O844OX44Gu5qeL56+JXG4gIGZvciAoaSA9IDA7IGkgPCBuU3ltYm9sczsgKytpKSB7XG4gICAgaWYgKGZyZXFzW2ldID4gMCkge1xuICAgICAgaGVhcC5wdXNoKGksIGZyZXFzW2ldKTtcbiAgICB9XG4gIH1cbiAgbm9kZXMgPSBuZXcgQXJyYXkoaGVhcC5sZW5ndGggLyAyKTtcbiAgdmFsdWVzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQzMkFycmF5IDogQXJyYXkpKGhlYXAubGVuZ3RoIC8gMik7XG5cbiAgLy8g6Z2eIDAg44Gu6KaB57Sg44GM5LiA44Gk44Gg44GR44Gg44Gj44Gf5aC05ZCI44Gv44CB44Gd44Gu44K344Oz44Oc44Or44Gr56ym5Y+36ZW3IDEg44KS5Ymy44KK5b2T44Gm44Gm57WC5LqGXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBsZW5ndGhbaGVhcC5wb3AoKS5pbmRleF0gPSAxO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICAvLyBSZXZlcnNlIFBhY2thZ2UgTWVyZ2UgQWxnb3JpdGhtIOOBq+OCiOOCiyBDYW5vbmljYWwgSHVmZm1hbiBDb2RlIOOBruespuWPt+mVt+axuuWumlxuICBmb3IgKGkgPSAwLCBpbCA9IGhlYXAubGVuZ3RoIC8gMjsgaSA8IGlsOyArK2kpIHtcbiAgICBub2Rlc1tpXSA9IGhlYXAucG9wKCk7XG4gICAgdmFsdWVzW2ldID0gbm9kZXNbaV0udmFsdWU7XG4gIH1cbiAgY29kZUxlbmd0aCA9IHRoaXMucmV2ZXJzZVBhY2thZ2VNZXJnZV8odmFsdWVzLCB2YWx1ZXMubGVuZ3RoLCBsaW1pdCk7XG5cbiAgZm9yIChpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgbGVuZ3RoW25vZGVzW2ldLmluZGV4XSA9IGNvZGVMZW5ndGhbaV07XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXZlcnNlIFBhY2thZ2UgTWVyZ2UgQWxnb3JpdGhtLlxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KX0gZnJlcXMgc29ydGVkIHByb2JhYmlsaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN5bWJvbHMgbnVtYmVyIG9mIHN5bWJvbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgY29kZSBsZW5ndGggbGltaXQuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBjb2RlIGxlbmd0aHMuXG4gKi9cblpsaWIuUmF3RGVmbGF0ZS5wcm90b3R5cGUucmV2ZXJzZVBhY2thZ2VNZXJnZV8gPSBmdW5jdGlvbihmcmVxcywgc3ltYm9scywgbGltaXQpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX0gKi9cbiAgdmFyIG1pbmltdW1Db3N0ID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQxNkFycmF5IDogQXJyYXkpKGxpbWl0KTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgZmxhZyA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKGxpbWl0KTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgY29kZUxlbmd0aCA9IG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKHN5bWJvbHMpO1xuICAvKiogQHR5cGUge0FycmF5fSAqL1xuICB2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGltaXQpO1xuICAvKiogQHR5cGUge0FycmF5fSAqL1xuICB2YXIgdHlwZSAgPSBuZXcgQXJyYXkobGltaXQpO1xuICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICB2YXIgY3VycmVudFBvc2l0aW9uID0gbmV3IEFycmF5KGxpbWl0KTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBleGNlc3MgPSAoMSA8PCBsaW1pdCkgLSBzeW1ib2xzO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGhhbGYgPSAoMSA8PCAobGltaXQgLSAxKSk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBqO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgd2VpZ2h0O1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIG5leHQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gICAqL1xuICBmdW5jdGlvbiB0YWtlUGFja2FnZShqKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIHggPSB0eXBlW2pdW2N1cnJlbnRQb3NpdGlvbltqXV07XG5cbiAgICBpZiAoeCA9PT0gc3ltYm9scykge1xuICAgICAgdGFrZVBhY2thZ2UoaisxKTtcbiAgICAgIHRha2VQYWNrYWdlKGorMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC0tY29kZUxlbmd0aFt4XTtcbiAgICB9XG5cbiAgICArK2N1cnJlbnRQb3NpdGlvbltqXTtcbiAgfVxuXG4gIG1pbmltdW1Db3N0W2xpbWl0LTFdID0gc3ltYm9scztcblxuICBmb3IgKGogPSAwOyBqIDwgbGltaXQ7ICsraikge1xuICAgIGlmIChleGNlc3MgPCBoYWxmKSB7XG4gICAgICBmbGFnW2pdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ1tqXSA9IDE7XG4gICAgICBleGNlc3MgLT0gaGFsZjtcbiAgICB9XG4gICAgZXhjZXNzIDw8PSAxO1xuICAgIG1pbmltdW1Db3N0W2xpbWl0LTItal0gPSAobWluaW11bUNvc3RbbGltaXQtMS1qXSAvIDIgfCAwKSArIHN5bWJvbHM7XG4gIH1cbiAgbWluaW11bUNvc3RbMF0gPSBmbGFnWzBdO1xuXG4gIHZhbHVlWzBdID0gbmV3IEFycmF5KG1pbmltdW1Db3N0WzBdKTtcbiAgdHlwZVswXSAgPSBuZXcgQXJyYXkobWluaW11bUNvc3RbMF0pO1xuICBmb3IgKGogPSAxOyBqIDwgbGltaXQ7ICsraikge1xuICAgIGlmIChtaW5pbXVtQ29zdFtqXSA+IDIgKiBtaW5pbXVtQ29zdFtqLTFdICsgZmxhZ1tqXSkge1xuICAgICAgbWluaW11bUNvc3Rbal0gPSAyICogbWluaW11bUNvc3Rbai0xXSArIGZsYWdbal07XG4gICAgfVxuICAgIHZhbHVlW2pdID0gbmV3IEFycmF5KG1pbmltdW1Db3N0W2pdKTtcbiAgICB0eXBlW2pdICA9IG5ldyBBcnJheShtaW5pbXVtQ29zdFtqXSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sczsgKytpKSB7XG4gICAgY29kZUxlbmd0aFtpXSA9IGxpbWl0O1xuICB9XG5cbiAgZm9yICh0ID0gMDsgdCA8IG1pbmltdW1Db3N0W2xpbWl0LTFdOyArK3QpIHtcbiAgICB2YWx1ZVtsaW1pdC0xXVt0XSA9IGZyZXFzW3RdO1xuICAgIHR5cGVbbGltaXQtMV1bdF0gID0gdDtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW1pdDsgKytpKSB7XG4gICAgY3VycmVudFBvc2l0aW9uW2ldID0gMDtcbiAgfVxuICBpZiAoZmxhZ1tsaW1pdC0xXSA9PT0gMSkge1xuICAgIC0tY29kZUxlbmd0aFswXTtcbiAgICArK2N1cnJlbnRQb3NpdGlvbltsaW1pdC0xXTtcbiAgfVxuXG4gIGZvciAoaiA9IGxpbWl0LTI7IGogPj0gMDsgLS1qKSB7XG4gICAgaSA9IDA7XG4gICAgd2VpZ2h0ID0gMDtcbiAgICBuZXh0ID0gY3VycmVudFBvc2l0aW9uW2orMV07XG5cbiAgICBmb3IgKHQgPSAwOyB0IDwgbWluaW11bUNvc3Rbal07IHQrKykge1xuICAgICAgd2VpZ2h0ID0gdmFsdWVbaisxXVtuZXh0XSArIHZhbHVlW2orMV1bbmV4dCsxXTtcblxuICAgICAgaWYgKHdlaWdodCA+IGZyZXFzW2ldKSB7XG4gICAgICAgIHZhbHVlW2pdW3RdID0gd2VpZ2h0O1xuICAgICAgICB0eXBlW2pdW3RdID0gc3ltYm9scztcbiAgICAgICAgbmV4dCArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVbal1bdF0gPSBmcmVxc1tpXTtcbiAgICAgICAgdHlwZVtqXVt0XSA9IGk7XG4gICAgICAgICsraTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50UG9zaXRpb25bal0gPSAwO1xuICAgIGlmIChmbGFnW2pdID09PSAxKSB7XG4gICAgICB0YWtlUGFja2FnZShqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29kZUxlbmd0aDtcbn07XG5cbi8qKlxuICog56ym5Y+36ZW36YWN5YiX44GL44KJ44OP44OV44Oe44Oz56ym5Y+344KS5Y+W5b6X44GZ44KLXG4gKiByZWZlcmVuY2U6IFB1VFRZIERlZmxhdGUgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gbGVuZ3RocyDnrKblj7fplbfphY3liJcuXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQxNkFycmF5KX0g44OP44OV44Oe44Oz56ym5Y+36YWN5YiXLlxuICogQHByaXZhdGVcbiAqL1xuWmxpYi5SYXdEZWZsYXRlLnByb3RvdHlwZS5nZXRDb2Rlc0Zyb21MZW5ndGhzXyA9IGZ1bmN0aW9uKGxlbmd0aHMpIHtcbiAgdmFyIGNvZGVzID0gbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQxNkFycmF5IDogQXJyYXkpKGxlbmd0aHMubGVuZ3RoKSxcbiAgICAgIGNvdW50ID0gW10sXG4gICAgICBzdGFydENvZGUgPSBbXSxcbiAgICAgIGNvZGUgPSAwLCBpLCBpbCwgaiwgbTtcblxuICAvLyBDb3VudCB0aGUgY29kZXMgb2YgZWFjaCBsZW5ndGguXG4gIGZvciAoaSA9IDAsIGlsID0gbGVuZ3Rocy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY291bnRbbGVuZ3Roc1tpXV0gPSAoY291bnRbbGVuZ3Roc1tpXV0gfCAwKSArIDE7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIHN0YXJ0aW5nIGNvZGUgZm9yIGVhY2ggbGVuZ3RoIGJsb2NrLlxuICBmb3IgKGkgPSAxLCBpbCA9IFpsaWIuUmF3RGVmbGF0ZS5NYXhDb2RlTGVuZ3RoOyBpIDw9IGlsOyBpKyspIHtcbiAgICBzdGFydENvZGVbaV0gPSBjb2RlO1xuICAgIGNvZGUgKz0gY291bnRbaV0gfCAwO1xuICAgIGNvZGUgPDw9IDE7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIGNvZGUgZm9yIGVhY2ggc3ltYm9sLiBNaXJyb3JlZCwgb2YgY291cnNlLlxuICBmb3IgKGkgPSAwLCBpbCA9IGxlbmd0aHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvZGUgPSBzdGFydENvZGVbbGVuZ3Roc1tpXV07XG4gICAgc3RhcnRDb2RlW2xlbmd0aHNbaV1dICs9IDE7XG4gICAgY29kZXNbaV0gPSAwO1xuXG4gICAgZm9yIChqID0gMCwgbSA9IGxlbmd0aHNbaV07IGogPCBtOyBqKyspIHtcbiAgICAgIGNvZGVzW2ldID0gKGNvZGVzW2ldIDw8IDEpIHwgKGNvZGUgJiAxKTtcbiAgICAgIGNvZGUgPj4+PSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2Rlcztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0IGlucHV0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3BhcmFtcyBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblpsaWIuVW56aXAgPSBmdW5jdGlvbihpbnB1dCwgb3B0X3BhcmFtcykge1xuICBvcHRfcGFyYW1zID0gb3B0X3BhcmFtcyB8fCB7fTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB0aGlzLmlucHV0ID1cbiAgICAgIChVU0VfVFlQRURBUlJBWSAmJiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkpID9cbiAgICAgICAgICBuZXcgVWludDhBcnJheShpbnB1dCkgOiBpbnB1dDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuaXAgPSAwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5lb2Nkck9mZnNldDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubnVtYmVyT2ZUaGlzRGlzaztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuc3RhcnREaXNrO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy50b3RhbEVudHJpZXNUaGlzRGlzaztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMudG90YWxFbnRyaWVzO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5jZW50cmFsRGlyZWN0b3J5U2l6ZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuY2VudHJhbERpcmVjdG9yeU9mZnNldDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuY29tbWVudExlbmd0aDtcbiAgLyoqIEB0eXBlIHsoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHRoaXMuY29tbWVudDtcbiAgLyoqIEB0eXBlIHtBcnJheS48WmxpYi5VbnppcC5GaWxlSGVhZGVyPn0gKi9cbiAgdGhpcy5maWxlSGVhZGVyTGlzdDtcbiAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgdGhpcy5maWxlbmFtZVRvSW5kZXg7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy52ZXJpZnkgPSBvcHRfcGFyYW1zWyd2ZXJpZnknXSB8fCBmYWxzZTtcbiAgLyoqIEB0eXBlIHsoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHRoaXMucGFzc3dvcmQgPSBvcHRfcGFyYW1zWydwYXNzd29yZCddO1xufTtcblxuWmxpYi5VbnppcC5Db21wcmVzc2lvbk1ldGhvZCA9IFpsaWIuWmlwLkNvbXByZXNzaW9uTWV0aG9kO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqIEBjb25zdFxuICovXG5abGliLlVuemlwLkZpbGVIZWFkZXJTaWduYXR1cmUgPSBabGliLlppcC5GaWxlSGVhZGVyU2lnbmF0dXJlO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqIEBjb25zdFxuICovXG5abGliLlVuemlwLkxvY2FsRmlsZUhlYWRlclNpZ25hdHVyZSA9IFpsaWIuWmlwLkxvY2FsRmlsZUhlYWRlclNpZ25hdHVyZTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gKiBAY29uc3RcbiAqL1xuWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlID0gWmxpYi5aaXAuQ2VudHJhbERpcmVjdG9yeVNpZ25hdHVyZTtcblxuLyoqXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IGlucHV0IGlucHV0IGJ1ZmZlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpcCBpbnB1dCBwb3NpdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5abGliLlVuemlwLkZpbGVIZWFkZXIgPSBmdW5jdGlvbihpbnB1dCwgaXApIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLm9mZnNldCA9IGlwO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnZlcnNpb247XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLm9zO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5uZWVkVmVyc2lvbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuZmxhZ3M7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmNvbXByZXNzaW9uO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy50aW1lO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5kYXRlO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5jcmMzMjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuY29tcHJlc3NlZFNpemU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnBsYWluU2l6ZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuZmlsZU5hbWVMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmV4dHJhRmllbGRMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5kaXNrTnVtYmVyU3RhcnQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXM7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXM7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdGhpcy5maWxlbmFtZTtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB0aGlzLmV4dHJhRmllbGQ7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdGhpcy5jb21tZW50O1xufTtcblxuWmxpYi5VbnppcC5GaWxlSGVhZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaXAgPSB0aGlzLm9mZnNldDtcblxuICAvLyBjZW50cmFsIGZpbGUgaGVhZGVyIHNpZ25hdHVyZVxuICBpZiAoaW5wdXRbaXArK10gIT09IFpsaWIuVW56aXAuRmlsZUhlYWRlclNpZ25hdHVyZVswXSB8fFxuICAgICAgaW5wdXRbaXArK10gIT09IFpsaWIuVW56aXAuRmlsZUhlYWRlclNpZ25hdHVyZVsxXSB8fFxuICAgICAgaW5wdXRbaXArK10gIT09IFpsaWIuVW56aXAuRmlsZUhlYWRlclNpZ25hdHVyZVsyXSB8fFxuICAgICAgaW5wdXRbaXArK10gIT09IFpsaWIuVW56aXAuRmlsZUhlYWRlclNpZ25hdHVyZVszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWxlIGhlYWRlciBzaWduYXR1cmUnKTtcbiAgfVxuXG4gIC8vIHZlcnNpb24gbWFkZSBieVxuICB0aGlzLnZlcnNpb24gPSBpbnB1dFtpcCsrXTtcbiAgdGhpcy5vcyA9IGlucHV0W2lwKytdO1xuXG4gIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgdGhpcy5uZWVkVmVyc2lvbiA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICB0aGlzLmZsYWdzID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gIHRoaXMuY29tcHJlc3Npb24gPSBpbnB1dFtpcCsrXSB8IChpbnB1dFtpcCsrXSA8PCA4KTtcblxuICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgdGhpcy50aW1lID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy9sYXN0IG1vZCBmaWxlIGRhdGVcbiAgdGhpcy5kYXRlID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gY3JjLTMyXG4gIHRoaXMuY3JjMzIgPSAoXG4gICAgICAoaW5wdXRbaXArK10gICAgICApIHwgKGlucHV0W2lwKytdIDw8ICA4KSB8XG4gICAgICAoaW5wdXRbaXArK10gPDwgMTYpIHwgKGlucHV0W2lwKytdIDw8IDI0KVxuICApID4+PiAwO1xuXG4gIC8vIGNvbXByZXNzZWQgc2l6ZVxuICB0aGlzLmNvbXByZXNzZWRTaXplID0gKFxuICAgICAgKGlucHV0W2lwKytdICAgICAgKSB8IChpbnB1dFtpcCsrXSA8PCAgOCkgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNClcbiAgKSA+Pj4gMDtcblxuICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICB0aGlzLnBsYWluU2l6ZSA9IChcbiAgICAgIChpbnB1dFtpcCsrXSAgICAgICkgfCAoaW5wdXRbaXArK10gPDwgIDgpIHxcbiAgICAgIChpbnB1dFtpcCsrXSA8PCAxNikgfCAoaW5wdXRbaXArK10gPDwgMjQpXG4gICkgPj4+IDA7XG5cbiAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICB0aGlzLmZpbGVOYW1lTGVuZ3RoID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gIHRoaXMuZXh0cmFGaWVsZExlbmd0aCA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gIHRoaXMuZGlza051bWJlclN0YXJ0ID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPVxuICAgICAgKGlucHV0W2lwKytdICAgICAgKSB8IChpbnB1dFtpcCsrXSA8PCAgOCkgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNCk7XG5cbiAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gKFxuICAgICAgKGlucHV0W2lwKytdICAgICAgKSB8IChpbnB1dFtpcCsrXSA8PCAgOCkgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNClcbiAgKSA+Pj4gMDtcblxuICAvLyBmaWxlIG5hbWVcbiAgdGhpcy5maWxlbmFtZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgaW5wdXQuc3ViYXJyYXkoaXAsIGlwICs9IHRoaXMuZmlsZU5hbWVMZW5ndGgpIDpcbiAgICAgIGlucHV0LnNsaWNlKGlwLCBpcCArPSB0aGlzLmZpbGVOYW1lTGVuZ3RoKVxuICApO1xuXG4gIC8vIGV4dHJhIGZpZWxkXG4gIHRoaXMuZXh0cmFGaWVsZCA9IFVTRV9UWVBFREFSUkFZID9cbiAgICAgIGlucHV0LnN1YmFycmF5KGlwLCBpcCArPSB0aGlzLmV4dHJhRmllbGRMZW5ndGgpIDpcbiAgICAgIGlucHV0LnNsaWNlKGlwLCBpcCArPSB0aGlzLmV4dHJhRmllbGRMZW5ndGgpO1xuXG4gIC8vIGZpbGUgY29tbWVudFxuICB0aGlzLmNvbW1lbnQgPSBVU0VfVFlQRURBUlJBWSA/XG4gICAgICBpbnB1dC5zdWJhcnJheShpcCwgaXAgKyB0aGlzLmZpbGVDb21tZW50TGVuZ3RoKSA6XG4gICAgICBpbnB1dC5zbGljZShpcCwgaXAgKyB0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcblxuICB0aGlzLmxlbmd0aCA9IGlwIC0gdGhpcy5vZmZzZXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gaW5wdXQgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGlwIGlucHV0IHBvc2l0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblpsaWIuVW56aXAuTG9jYWxGaWxlSGVhZGVyID0gZnVuY3Rpb24oaW5wdXQsIGlwKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5vZmZzZXQgPSBpcDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5uZWVkVmVyc2lvbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuZmxhZ3M7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmNvbXByZXNzaW9uO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy50aW1lO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5kYXRlO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdGhpcy5jcmMzMjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuY29tcHJlc3NlZFNpemU7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLnBsYWluU2l6ZTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHRoaXMuZmlsZU5hbWVMZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB0aGlzLmV4dHJhRmllbGRMZW5ndGg7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB0aGlzLmZpbGVuYW1lO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHRoaXMuZXh0cmFGaWVsZDtcbn07XG5cblpsaWIuVW56aXAuTG9jYWxGaWxlSGVhZGVyLkZsYWdzID0gWmxpYi5aaXAuRmxhZ3M7XG5cblpsaWIuVW56aXAuTG9jYWxGaWxlSGVhZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaXAgPSB0aGlzLm9mZnNldDtcblxuICAvLyBsb2NhbCBmaWxlIGhlYWRlciBzaWduYXR1cmVcbiAgaWYgKGlucHV0W2lwKytdICE9PSBabGliLlVuemlwLkxvY2FsRmlsZUhlYWRlclNpZ25hdHVyZVswXSB8fFxuICAgICAgaW5wdXRbaXArK10gIT09IFpsaWIuVW56aXAuTG9jYWxGaWxlSGVhZGVyU2lnbmF0dXJlWzFdIHx8XG4gICAgICBpbnB1dFtpcCsrXSAhPT0gWmxpYi5VbnppcC5Mb2NhbEZpbGVIZWFkZXJTaWduYXR1cmVbMl0gfHxcbiAgICAgIGlucHV0W2lwKytdICE9PSBabGliLlVuemlwLkxvY2FsRmlsZUhlYWRlclNpZ25hdHVyZVszXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsb2NhbCBmaWxlIGhlYWRlciBzaWduYXR1cmUnKTtcbiAgfVxuXG4gIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgdGhpcy5uZWVkVmVyc2lvbiA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICB0aGlzLmZsYWdzID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gIHRoaXMuY29tcHJlc3Npb24gPSBpbnB1dFtpcCsrXSB8IChpbnB1dFtpcCsrXSA8PCA4KTtcblxuICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgdGhpcy50aW1lID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy9sYXN0IG1vZCBmaWxlIGRhdGVcbiAgdGhpcy5kYXRlID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gY3JjLTMyXG4gIHRoaXMuY3JjMzIgPSAoXG4gICAgICAoaW5wdXRbaXArK10gICAgICApIHwgKGlucHV0W2lwKytdIDw8ICA4KSB8XG4gICAgICAoaW5wdXRbaXArK10gPDwgMTYpIHwgKGlucHV0W2lwKytdIDw8IDI0KVxuICApID4+PiAwO1xuXG4gIC8vIGNvbXByZXNzZWQgc2l6ZVxuICB0aGlzLmNvbXByZXNzZWRTaXplID0gKFxuICAgICAgKGlucHV0W2lwKytdICAgICAgKSB8IChpbnB1dFtpcCsrXSA8PCAgOCkgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNClcbiAgKSA+Pj4gMDtcblxuICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICB0aGlzLnBsYWluU2l6ZSA9IChcbiAgICAgIChpbnB1dFtpcCsrXSAgICAgICkgfCAoaW5wdXRbaXArK10gPDwgIDgpIHxcbiAgICAgIChpbnB1dFtpcCsrXSA8PCAxNikgfCAoaW5wdXRbaXArK10gPDwgMjQpXG4gICkgPj4+IDA7XG5cbiAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICB0aGlzLmZpbGVOYW1lTGVuZ3RoID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gIHRoaXMuZXh0cmFGaWVsZExlbmd0aCA9IGlucHV0W2lwKytdIHwgKGlucHV0W2lwKytdIDw8IDgpO1xuXG4gIC8vIGZpbGUgbmFtZVxuICB0aGlzLmZpbGVuYW1lID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBVU0VfVFlQRURBUlJBWSA/XG4gICAgICBpbnB1dC5zdWJhcnJheShpcCwgaXAgKz0gdGhpcy5maWxlTmFtZUxlbmd0aCkgOlxuICAgICAgaW5wdXQuc2xpY2UoaXAsIGlwICs9IHRoaXMuZmlsZU5hbWVMZW5ndGgpXG4gICk7XG5cbiAgLy8gZXh0cmEgZmllbGRcbiAgdGhpcy5leHRyYUZpZWxkID0gVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgaW5wdXQuc3ViYXJyYXkoaXAsIGlwICs9IHRoaXMuZXh0cmFGaWVsZExlbmd0aCkgOlxuICAgICAgaW5wdXQuc2xpY2UoaXAsIGlwICs9IHRoaXMuZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgdGhpcy5sZW5ndGggPSBpcCAtIHRoaXMub2Zmc2V0O1xufTtcblxuXG5abGliLlVuemlwLnByb3RvdHlwZS5zZWFyY2hFbmRPZkNlbnRyYWxEaXJlY3RvcnlSZWNvcmQgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSAqL1xuICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlwO1xuXG4gIGZvciAoaXAgPSBpbnB1dC5sZW5ndGggLSAxMjsgaXAgPiAwOyAtLWlwKSB7XG4gICAgaWYgKGlucHV0W2lwICBdID09PSBabGliLlVuemlwLkNlbnRyYWxEaXJlY3RvcnlTaWduYXR1cmVbMF0gJiZcbiAgICAgICAgaW5wdXRbaXArMV0gPT09IFpsaWIuVW56aXAuQ2VudHJhbERpcmVjdG9yeVNpZ25hdHVyZVsxXSAmJlxuICAgICAgICBpbnB1dFtpcCsyXSA9PT0gWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzJdICYmXG4gICAgICAgIGlucHV0W2lwKzNdID09PSBabGliLlVuemlwLkNlbnRyYWxEaXJlY3RvcnlTaWduYXR1cmVbM10pIHtcbiAgICAgIHRoaXMuZW9jZHJPZmZzZXQgPSBpcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0VuZCBvZiBDZW50cmFsIERpcmVjdG9yeSBSZWNvcmQgbm90IGZvdW5kJyk7XG59O1xuXG5abGliLlVuemlwLnByb3RvdHlwZS5wYXJzZUVuZE9mQ2VudHJhbERpcmVjdG9yeVJlY29yZCA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaXA7XG5cbiAgaWYgKCF0aGlzLmVvY2RyT2Zmc2V0KSB7XG4gICAgdGhpcy5zZWFyY2hFbmRPZkNlbnRyYWxEaXJlY3RvcnlSZWNvcmQoKTtcbiAgfVxuICBpcCA9IHRoaXMuZW9jZHJPZmZzZXQ7XG5cbiAgLy8gc2lnbmF0dXJlXG4gIGlmIChpbnB1dFtpcCsrXSAhPT0gWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzBdIHx8XG4gICAgICBpbnB1dFtpcCsrXSAhPT0gWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzFdIHx8XG4gICAgICBpbnB1dFtpcCsrXSAhPT0gWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzJdIHx8XG4gICAgICBpbnB1dFtpcCsrXSAhPT0gWmxpYi5VbnppcC5DZW50cmFsRGlyZWN0b3J5U2lnbmF0dXJlWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZScpO1xuICB9XG5cbiAgLy8gbnVtYmVyIG9mIHRoaXMgZGlza1xuICB0aGlzLm51bWJlck9mVGhpc0Rpc2sgPSBpbnB1dFtpcCsrXSB8IChpbnB1dFtpcCsrXSA8PCA4KTtcblxuICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gIHRoaXMuc3RhcnREaXNrID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IG9uIHRoaXMgZGlza1xuICB0aGlzLnRvdGFsRW50cmllc1RoaXNEaXNrID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gIHRoaXMudG90YWxFbnRyaWVzID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgdGhpcy5jZW50cmFsRGlyZWN0b3J5U2l6ZSA9IChcbiAgICAgIChpbnB1dFtpcCsrXSAgICAgICkgfCAoaW5wdXRbaXArK10gPDwgIDgpIHxcbiAgICAgIChpbnB1dFtpcCsrXSA8PCAxNikgfCAoaW5wdXRbaXArK10gPDwgMjQpXG4gICkgPj4+IDA7XG5cbiAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgdGhpcy5jZW50cmFsRGlyZWN0b3J5T2Zmc2V0ID0gKFxuICAgICAgKGlucHV0W2lwKytdICAgICAgKSB8IChpbnB1dFtpcCsrXSA8PCAgOCkgfFxuICAgICAgKGlucHV0W2lwKytdIDw8IDE2KSB8IChpbnB1dFtpcCsrXSA8PCAyNClcbiAgKSA+Pj4gMDtcblxuICAvLyAuWklQIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgdGhpcy5jb21tZW50TGVuZ3RoID0gaW5wdXRbaXArK10gfCAoaW5wdXRbaXArK10gPDwgOCk7XG5cbiAgLy8gLlpJUCBmaWxlIGNvbW1lbnRcbiAgdGhpcy5jb21tZW50ID0gVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgaW5wdXQuc3ViYXJyYXkoaXAsIGlwICsgdGhpcy5jb21tZW50TGVuZ3RoKSA6XG4gICAgICBpbnB1dC5zbGljZShpcCwgaXAgKyB0aGlzLmNvbW1lbnRMZW5ndGgpO1xufTtcblxuWmxpYi5VbnppcC5wcm90b3R5cGUucGFyc2VGaWxlSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPFpsaWIuVW56aXAuRmlsZUhlYWRlcj59ICovXG4gIHZhciBmaWxlbGlzdCA9IFtdO1xuICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSAqL1xuICB2YXIgZmlsZXRhYmxlID0ge307XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaXA7XG4gIC8qKiBAdHlwZSB7WmxpYi5VbnppcC5GaWxlSGVhZGVyfSAqL1xuICB2YXIgZmlsZUhlYWRlcjtcbiAgLyo6IEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKjogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlsO1xuXG4gIGlmICh0aGlzLmZpbGVIZWFkZXJMaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuY2VudHJhbERpcmVjdG9yeU9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgdGhpcy5wYXJzZUVuZE9mQ2VudHJhbERpcmVjdG9yeVJlY29yZCgpO1xuICB9XG4gIGlwID0gdGhpcy5jZW50cmFsRGlyZWN0b3J5T2Zmc2V0O1xuXG4gIGZvciAoaSA9IDAsIGlsID0gdGhpcy50b3RhbEVudHJpZXM7IGkgPCBpbDsgKytpKSB7XG4gICAgZmlsZUhlYWRlciA9IG5ldyBabGliLlVuemlwLkZpbGVIZWFkZXIodGhpcy5pbnB1dCwgaXApO1xuICAgIGZpbGVIZWFkZXIucGFyc2UoKTtcbiAgICBpcCArPSBmaWxlSGVhZGVyLmxlbmd0aDtcbiAgICBmaWxlbGlzdFtpXSA9IGZpbGVIZWFkZXI7XG4gICAgZmlsZXRhYmxlW2ZpbGVIZWFkZXIuZmlsZW5hbWVdID0gaTtcbiAgfVxuXG4gIGlmICh0aGlzLmNlbnRyYWxEaXJlY3RvcnlTaXplIDwgaXAgLSB0aGlzLmNlbnRyYWxEaXJlY3RvcnlPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmlsZSBoZWFkZXIgc2l6ZScpO1xuICB9XG5cbiAgdGhpcy5maWxlSGVhZGVyTGlzdCA9IGZpbGVsaXN0O1xuICB0aGlzLmZpbGVuYW1lVG9JbmRleCA9IGZpbGV0YWJsZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGZpbGUgaGVhZGVyIGluZGV4LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBmaWxlIGRhdGEuXG4gKi9cblpsaWIuVW56aXAucHJvdG90eXBlLmdldEZpbGVEYXRhID0gZnVuY3Rpb24oaW5kZXgsIG9wdF9wYXJhbXMpIHtcbiAgb3B0X3BhcmFtcyA9IG9wdF9wYXJhbXMgfHwge307XG4gIC8qKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gKi9cbiAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgLyoqIEB0eXBlIHtBcnJheS48WmxpYi5VbnppcC5GaWxlSGVhZGVyPn0gKi9cbiAgdmFyIGZpbGVIZWFkZXJMaXN0ID0gdGhpcy5maWxlSGVhZGVyTGlzdDtcbiAgLyoqIEB0eXBlIHtabGliLlVuemlwLkxvY2FsRmlsZUhlYWRlcn0gKi9cbiAgdmFyIGxvY2FsRmlsZUhlYWRlcjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBvZmZzZXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgbGVuZ3RoO1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9ICovXG4gIHZhciBidWZmZXI7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgY3JjMzI7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj58VWludDMyQXJyYXl8T2JqZWN0fSAqL1xuICB2YXIga2V5O1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaWw7XG5cbiAgaWYgKCFmaWxlSGVhZGVyTGlzdCkge1xuICAgIHRoaXMucGFyc2VGaWxlSGVhZGVyKCk7XG4gIH1cblxuICBpZiAoZmlsZUhlYWRlckxpc3RbaW5kZXhdID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIGluZGV4Jyk7XG4gIH1cblxuICBvZmZzZXQgPSBmaWxlSGVhZGVyTGlzdFtpbmRleF0ucmVsYXRpdmVPZmZzZXQ7XG4gIGxvY2FsRmlsZUhlYWRlciA9IG5ldyBabGliLlVuemlwLkxvY2FsRmlsZUhlYWRlcih0aGlzLmlucHV0LCBvZmZzZXQpO1xuICBsb2NhbEZpbGVIZWFkZXIucGFyc2UoKTtcbiAgb2Zmc2V0ICs9IGxvY2FsRmlsZUhlYWRlci5sZW5ndGg7XG4gIGxlbmd0aCA9IGxvY2FsRmlsZUhlYWRlci5jb21wcmVzc2VkU2l6ZTtcblxuICAvLyBkZWNyeXB0aW9uXG4gIGlmICgobG9jYWxGaWxlSGVhZGVyLmZsYWdzICYgWmxpYi5VbnppcC5Mb2NhbEZpbGVIZWFkZXIuRmxhZ3MuRU5DUllQVCkgIT09IDApIHtcbiAgICBpZiAoIShvcHRfcGFyYW1zWydwYXNzd29yZCddIHx8IHRoaXMucGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSBzZXQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAga2V5ID0gIHRoaXMuY3JlYXRlRGVjcnlwdGlvbktleShvcHRfcGFyYW1zWydwYXNzd29yZCddIHx8IHRoaXMucGFzc3dvcmQpO1xuXG4gICAgLy8gZW5jcnlwdGlvbiBoZWFkZXJcbiAgICBmb3IoaSA9IG9mZnNldCwgaWwgPSBvZmZzZXQgKyAxMjsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHRoaXMuZGVjb2RlKGtleSwgaW5wdXRbaV0pO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTI7XG4gICAgbGVuZ3RoIC09IDEyO1xuXG4gICAgLy8gZGVjcnlwdGlvblxuICAgIGZvciAoaSA9IG9mZnNldCwgaWwgPSBvZmZzZXQgKyBsZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICBpbnB1dFtpXSA9IHRoaXMuZGVjb2RlKGtleSwgaW5wdXRbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAobG9jYWxGaWxlSGVhZGVyLmNvbXByZXNzaW9uKSB7XG4gICAgY2FzZSBabGliLlVuemlwLkNvbXByZXNzaW9uTWV0aG9kLlNUT1JFOlxuICAgICAgYnVmZmVyID0gVVNFX1RZUEVEQVJSQVkgP1xuICAgICAgICAgIHRoaXMuaW5wdXQuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpIDpcbiAgICAgICAgICB0aGlzLmlucHV0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWmxpYi5VbnppcC5Db21wcmVzc2lvbk1ldGhvZC5ERUZMQVRFOlxuICAgICAgYnVmZmVyID0gbmV3IFpsaWIuUmF3SW5mbGF0ZSh0aGlzLmlucHV0LCB7XG4gICAgICAgICdpbmRleCc6IG9mZnNldCxcbiAgICAgICAgJ2J1ZmZlclNpemUnOiBsb2NhbEZpbGVIZWFkZXIucGxhaW5TaXplXG4gICAgICB9KS5kZWNvbXByZXNzKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUnKTtcbiAgfVxuXG4gIGlmICh0aGlzLnZlcmlmeSkge1xuICAgIGNyYzMyID0gWmxpYi5DUkMzMi5jYWxjKGJ1ZmZlcik7XG4gICAgaWYgKGxvY2FsRmlsZUhlYWRlci5jcmMzMiAhPT0gY3JjMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnd3JvbmcgY3JjOiBmaWxlPTB4JyArIGxvY2FsRmlsZUhlYWRlci5jcmMzMi50b1N0cmluZygxNikgK1xuICAgICAgICAgICcsIGRhdGE9MHgnICsgY3JjMzIudG9TdHJpbmcoMTYpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICovXG5abGliLlVuemlwLnByb3RvdHlwZS5nZXRGaWxlbmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48c3RyaW5nPn0gKi9cbiAgdmFyIGZpbGVuYW1lTGlzdCA9IFtdO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaWw7XG4gIC8qKiBAdHlwZSB7QXJyYXkuPFpsaWIuVW56aXAuRmlsZUhlYWRlcj59ICovXG4gIHZhciBmaWxlSGVhZGVyTGlzdDtcblxuICBpZiAoIXRoaXMuZmlsZUhlYWRlckxpc3QpIHtcbiAgICB0aGlzLnBhcnNlRmlsZUhlYWRlcigpO1xuICB9XG4gIGZpbGVIZWFkZXJMaXN0ID0gdGhpcy5maWxlSGVhZGVyTGlzdDtcblxuICBmb3IgKGkgPSAwLCBpbCA9IGZpbGVIZWFkZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICBmaWxlbmFtZUxpc3RbaV0gPSBmaWxlSGVhZGVyTGlzdFtpXS5maWxlbmFtZTtcbiAgfVxuXG4gIHJldHVybiBmaWxlbmFtZUxpc3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSBleHRyYWN0IGZpbGVuYW1lLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zXG4gKiBAcmV0dXJuIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBkZWNvbXByZXNzZWQgZGF0YS5cbiAqL1xuWmxpYi5VbnppcC5wcm90b3R5cGUuZGVjb21wcmVzcyA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBvcHRfcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgaW5kZXg7XG5cbiAgaWYgKCF0aGlzLmZpbGVuYW1lVG9JbmRleCkge1xuICAgIHRoaXMucGFyc2VGaWxlSGVhZGVyKCk7XG4gIH1cbiAgaW5kZXggPSB0aGlzLmZpbGVuYW1lVG9JbmRleFtmaWxlbmFtZV07XG5cbiAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmlsZW5hbWUgKyAnIG5vdCBmb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0RmlsZURhdGEoaW5kZXgsIG9wdF9wYXJhbXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyhBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gcGFzc3dvcmRcbiAqL1xuWmxpYi5VbnppcC5wcm90b3R5cGUuc2V0UGFzc3dvcmQgPSBmdW5jdGlvbihwYXNzd29yZCkge1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7KEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5fE9iamVjdCl9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuWmxpYi5VbnppcC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oa2V5LCBuKSB7XG4gIG4gXj0gdGhpcy5nZXRCeXRlKC8qKiBAdHlwZSB7KEFycmF5LjxudW1iZXI+fFVpbnQzMkFycmF5KX0gKi8oa2V5KSk7XG4gIHRoaXMudXBkYXRlS2V5cygvKiogQHR5cGUgeyhBcnJheS48bnVtYmVyPnxVaW50MzJBcnJheSl9ICovKGtleSksIG4pO1xuXG4gIHJldHVybiBuO1xufTtcblxuLy8gY29tbW9uIG1ldGhvZFxuWmxpYi5VbnppcC5wcm90b3R5cGUudXBkYXRlS2V5cyA9IFpsaWIuWmlwLnByb3RvdHlwZS51cGRhdGVLZXlzO1xuWmxpYi5VbnppcC5wcm90b3R5cGUuY3JlYXRlRGVjcnlwdGlvbktleSA9IFpsaWIuWmlwLnByb3RvdHlwZS5jcmVhdGVFbmNyeXB0aW9uS2V5O1xuWmxpYi5VbnppcC5wcm90b3R5cGUuZ2V0Qnl0ZSA9IFpsaWIuWmlwLnByb3RvdHlwZS5nZXRCeXRlO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcg6ZuR5aSa44Gq6Zai5pWw576k44KS44G+44Go44KB44Gf44Oi44K444Ol44O844Or5a6f6KOFLlxuICovXG5cblxuLyoqXG4gKiBCeXRlIFN0cmluZyDjgYvjgokgQnl0ZSBBcnJheSDjgavlpInmj5suXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0ciBieXRlIHN0cmluZy5cbiAqIEByZXR1cm4geyFBcnJheS48bnVtYmVyPn0gYnl0ZSBhcnJheS5cbiAqL1xuWmxpYi5VdGlsLnN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24oc3RyKSB7XG4gIC8qKiBAdHlwZSB7IUFycmF5Ljwoc3RyaW5nfG51bWJlcik+fSAqL1xuICB2YXIgdG1wID0gc3RyLnNwbGl0KCcnKTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBpO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGlsO1xuXG4gIGZvciAoaSA9IDAsIGlsID0gdG1wLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICB0bXBbaV0gPSAodG1wW2ldLmNoYXJDb2RlQXQoMCkgJiAweGZmKSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiB0bXA7XG59O1xuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBZGxlcjMyIGNoZWNrc3VtIOWun+ijhS5cbiAqL1xuXG5cbi8qKlxuICogQWRsZXIzMiDjg4/jg4Pjgrfjg6XlgKTjga7kvZzmiJBcbiAqIEBwYXJhbSB7IShBcnJheXxVaW50OEFycmF5fHN0cmluZyl9IGFycmF5IOeul+WHuuOBq+S9v+eUqOOBmeOCiyBieXRlIGFycmF5LlxuICogQHJldHVybiB7bnVtYmVyfSBBZGxlcjMyIOODj+ODg+OCt+ODpeWApC5cbiAqL1xuWmxpYi5BZGxlcjMyID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgaWYgKHR5cGVvZihhcnJheSkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyYXkgPSBabGliLlV0aWwuc3RyaW5nVG9CeXRlQXJyYXkoYXJyYXkpO1xuICB9XG4gIHJldHVybiBabGliLkFkbGVyMzIudXBkYXRlKDEsIGFycmF5KTtcbn07XG5cbi8qKlxuICogQWRsZXIzMiDjg4/jg4Pjgrfjg6XlgKTjga7mm7TmlrBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZGxlciDnj77lnKjjga7jg4/jg4Pjgrfjg6XlgKQuXG4gKiBAcGFyYW0geyEoQXJyYXl8VWludDhBcnJheSl9IGFycmF5IOabtOaWsOOBq+S9v+eUqOOBmeOCiyBieXRlIGFycmF5LlxuICogQHJldHVybiB7bnVtYmVyfSBBZGxlcjMyIOODj+ODg+OCt+ODpeWApC5cbiAqL1xuWmxpYi5BZGxlcjMyLnVwZGF0ZSA9IGZ1bmN0aW9uKGFkbGVyLCBhcnJheSkge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIHMxID0gYWRsZXIgJiAweGZmZmY7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgczIgPSAoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGFycmF5IGxlbmd0aCAqL1xuICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBsZW5ndGggKGRvbid0IG92ZXJmbG93KSAqL1xuICB2YXIgdGxlbjtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGFycmF5IGluZGV4ICovXG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAobGVuID4gMCkge1xuICAgIHRsZW4gPSBsZW4gPiBabGliLkFkbGVyMzIuT3B0aW1pemF0aW9uUGFyYW1ldGVyID9cbiAgICAgICAgWmxpYi5BZGxlcjMyLk9wdGltaXphdGlvblBhcmFtZXRlciA6IGxlbjtcbiAgICBsZW4gLT0gdGxlbjtcbiAgICBkbyB7XG4gICAgICBzMSArPSBhcnJheVtpKytdO1xuICAgICAgczIgKz0gczE7XG4gICAgfSB3aGlsZSAoLS10bGVuKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuICgoczIgPDwgMTYpIHwgczEpID4+PiAwO1xufTtcblxuLyoqXG4gKiBBZGxlcjMyIOacgOmBqeWMluODkeODqeODoeODvOOCv1xuICog54++54q244Gn44GvIDEwMjQg56iL5bqm44GM5pyA6YGpLlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9hZGxlci0zMi1zaW1wbGUtdnMtb3B0aW1pemVkLzNcbiAqIEBkZWZpbmUge251bWJlcn1cbiAqL1xuWmxpYi5BZGxlcjMyLk9wdGltaXphdGlvblBhcmFtZXRlciA9IDEwMjQ7XG5cblxuXG5cbi8qKlxuICog44OT44OD44OI44K544OI44Oq44O844OgXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IShBcnJheXxVaW50OEFycmF5KT19IGJ1ZmZlciBvdXRwdXQgYnVmZmVyLlxuICogQHBhcmFtIHtudW1iZXI9fSBidWZmZXJQb3NpdGlvbiBzdGFydCBidWZmZXIgcG9pbnRlci5cbiAqL1xuWmxpYi5CaXRTdHJlYW0gPSBmdW5jdGlvbihidWZmZXIsIGJ1ZmZlclBvc2l0aW9uKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBidWZmZXIgaW5kZXguICovXG4gIHRoaXMuaW5kZXggPSB0eXBlb2YgYnVmZmVyUG9zaXRpb24gPT09ICdudW1iZXInID8gYnVmZmVyUG9zaXRpb24gOiAwO1xuICAvKiogQHR5cGUge251bWJlcn0gYml0IGluZGV4LiAqL1xuICB0aGlzLmJpdGluZGV4ID0gMDtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBiaXQtc3RyZWFtIG91dHB1dCBidWZmZXIuICovXG4gIHRoaXMuYnVmZmVyID0gYnVmZmVyIGluc3RhbmNlb2YgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KSA/XG4gICAgICBidWZmZXIgOlxuICAgICAgbmV3IChVU0VfVFlQRURBUlJBWSA/IFVpbnQ4QXJyYXkgOiBBcnJheSkoWmxpYi5CaXRTdHJlYW0uRGVmYXVsdEJsb2NrU2l6ZSk7XG5cbiAgLy8g5YWl5Yqb44GV44KM44GfIGluZGV4IOOBjOi2s+OCiuOBquOBi+OBo+OBn+OCieaLoeW8teOBmeOCi+OBjOOAgeWAjeOBq+OBl+OBpuOCguODgOODoeOBquOCieS4jeato+OBqOOBmeOCi1xuICBpZiAodGhpcy5idWZmZXIubGVuZ3RoICogMiA8PSB0aGlzLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleFwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPD0gdGhpcy5pbmRleCkge1xuICAgIHRoaXMuZXhwYW5kQnVmZmVyKCk7XG4gIH1cbn07XG5cbi8qKlxuICog44OH44OV44Kp44Or44OI44OW44Ot44OD44Kv44K144Kk44K6LlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5abGliLkJpdFN0cmVhbS5EZWZhdWx0QmxvY2tTaXplID0gMHg4MDAwO1xuXG4vKipcbiAqIGV4cGFuZCBidWZmZXIuXG4gKiBAcmV0dXJuIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBuZXcgYnVmZmVyLlxuICovXG5abGliLkJpdFN0cmVhbS5wcm90b3R5cGUuZXhwYW5kQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheXxVaW50OEFycmF5KX0gb2xkIGJ1ZmZlci4gKi9cbiAgdmFyIG9sZGJ1ZiA9IHRoaXMuYnVmZmVyO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBjb3VudGVyLiAqL1xuICB2YXIgaTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IGxvb3AgbGltaXRlci4gKi9cbiAgdmFyIGlsID0gb2xkYnVmLmxlbmd0aDtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBuZXcgYnVmZmVyLiAqL1xuICB2YXIgYnVmZmVyID1cbiAgICAgIG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKGlsIDw8IDEpO1xuXG4gIC8vIGNvcHkgYnVmZmVyXG4gIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgIGJ1ZmZlci5zZXQob2xkYnVmKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBYWFg6IGxvb3AgdW5yb2xsaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIGJ1ZmZlcltpXSA9IG9sZGJ1ZltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKHRoaXMuYnVmZmVyID0gYnVmZmVyKTtcbn07XG5cblxuLyoqXG4gKiDmlbDlgKTjgpLjg5Pjg4Pjg4jjgafmjIflrprjgZfjgZ/mlbDjgaDjgZHmm7jjgY3ovrzjgoAuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIOabuOOBjei+vOOCgOaVsOWApC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIOabuOOBjei+vOOCgOODk+ODg+ODiOaVsC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHJldmVyc2Ug6YCG6aCG44Gr5pu444GN6L6844KA44Gq44KJ44GwIHRydWUuXG4gKi9cblpsaWIuQml0U3RyZWFtLnByb3RvdHlwZS53cml0ZUJpdHMgPSBmdW5jdGlvbihudW1iZXIsIG4sIHJldmVyc2UpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICB2YXIgYml0aW5kZXggPSB0aGlzLmJpdGluZGV4O1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBjdXJyZW50IG9jdGV0LiAqL1xuICB2YXIgY3VycmVudCA9IGJ1ZmZlcltpbmRleF07XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBsb29wIGNvdW50ZXIuICovXG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiAzMi1iaXQg5pW05pWw44Gu44OT44OD44OI6aCG44KS6YCG44Gr44GZ44KLXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIDMyLWJpdCBpbnRlZ2VyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJldmVyc2VkIDMyLWJpdCBpbnRlZ2VyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmV2MzJfKG4pIHtcbiAgICByZXR1cm4gKFpsaWIuQml0U3RyZWFtLlJldmVyc2VUYWJsZVtuICYgMHhGRl0gPDwgMjQpIHxcbiAgICAgICAgKFpsaWIuQml0U3RyZWFtLlJldmVyc2VUYWJsZVtuID4+PiA4ICYgMHhGRl0gPDwgMTYpIHxcbiAgICAgICAgKFpsaWIuQml0U3RyZWFtLlJldmVyc2VUYWJsZVtuID4+PiAxNiAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgWmxpYi5CaXRTdHJlYW0uUmV2ZXJzZVRhYmxlW24gPj4+IDI0ICYgMHhGRl07XG4gIH1cblxuICBpZiAocmV2ZXJzZSAmJiBuID4gMSkge1xuICAgIG51bWJlciA9IG4gPiA4ID9cbiAgICAgICAgcmV2MzJfKG51bWJlcikgPj4gKDMyIC0gbikgOlxuICAgICAgICBabGliLkJpdFN0cmVhbS5SZXZlcnNlVGFibGVbbnVtYmVyXSA+PiAoOCAtIG4pO1xuICB9XG5cbiAgLy8gQnl0ZSDlooPnlYzjgpLotoXjgYjjgarjgYTjgajjgY1cbiAgaWYgKG4gKyBiaXRpbmRleCA8IDgpIHtcbiAgICBjdXJyZW50ID0gKGN1cnJlbnQgPDwgbikgfCBudW1iZXI7XG4gICAgYml0aW5kZXggKz0gbjtcbiAgICAvLyBCeXRlIOWig+eVjOOCkui2heOBiOOCi+OBqOOBjVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGN1cnJlbnQgPSAoY3VycmVudCA8PCAxKSB8ICgobnVtYmVyID4+IG4gLSBpIC0gMSkgJiAxKTtcblxuICAgICAgLy8gbmV4dCBieXRlXG4gICAgICBpZiAoKytiaXRpbmRleCA9PT0gOCkge1xuICAgICAgICBiaXRpbmRleCA9IDA7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IFpsaWIuQml0U3RyZWFtLlJldmVyc2VUYWJsZVtjdXJyZW50XTtcbiAgICAgICAgY3VycmVudCA9IDA7XG5cbiAgICAgICAgLy8gZXhwYW5kXG4gICAgICAgIGlmIChpbmRleCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuZXhwYW5kQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYnVmZmVyW2luZGV4XSA9IGN1cnJlbnQ7XG5cbiAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIHRoaXMuYml0aW5kZXggPSBiaXRpbmRleDtcbiAgdGhpcy5pbmRleCA9IGluZGV4O1xufTtcblxuXG4vKipcbiAqIOOCueODiOODquODvOODoOOBrue1guerr+WHpueQhuOCkuihjOOBhlxuICogQHJldHVybiB7IShBcnJheXxVaW50OEFycmF5KX0g57WC56uv5Yem55CG5b6M44Gu44OQ44OD44OV44Kh44KSIGJ5dGUgYXJyYXkg44Gn6L+U44GZLlxuICovXG5abGliLkJpdFN0cmVhbS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9IG91dHB1dCBidWZmZXIuICovXG4gIHZhciBvdXRwdXQ7XG5cbiAgLy8gYml0aW5kZXgg44GMIDAg44Gu5pmC44Gv5L2Z5YiG44GrIGluZGV4IOOBjOmAsuOCk+OBp+OBhOOCi+eKtuaFi1xuICBpZiAodGhpcy5iaXRpbmRleCA+IDApIHtcbiAgICBidWZmZXJbaW5kZXhdIDw8PSA4IC0gdGhpcy5iaXRpbmRleDtcbiAgICBidWZmZXJbaW5kZXhdID0gWmxpYi5CaXRTdHJlYW0uUmV2ZXJzZVRhYmxlW2J1ZmZlcltpbmRleF1dO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICAvLyBhcnJheSB0cnVuY2F0aW9uXG4gIGlmIChVU0VfVFlQRURBUlJBWSkge1xuICAgIG91dHB1dCA9IGJ1ZmZlci5zdWJhcnJheSgwLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLmxlbmd0aCA9IGluZGV4O1xuICAgIG91dHB1dCA9IGJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIDAtMjU1IOOBruODk+ODg+ODiOmghuOCkuWPjei7ouOBl+OBn+ODhuODvOODluODq1xuICogQGNvbnN0XG4gKiBAdHlwZSB7IShVaW50OEFycmF5fEFycmF5LjxudW1iZXI+KX1cbiAqL1xuWmxpYi5CaXRTdHJlYW0uUmV2ZXJzZVRhYmxlID0gKGZ1bmN0aW9uKHRhYmxlKSB7XG4gIHJldHVybiB0YWJsZTtcbn0pKChmdW5jdGlvbigpIHtcbiAgLyoqIEB0eXBlIHshKEFycmF5fFVpbnQ4QXJyYXkpfSByZXZlcnNlIHRhYmxlLiAqL1xuICB2YXIgdGFibGUgPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDhBcnJheSA6IEFycmF5KSgyNTYpO1xuICAvKiogQHR5cGUge251bWJlcn0gbG9vcCBjb3VudGVyLiAqL1xuICB2YXIgaTtcblxuICAvLyBnZW5lcmF0ZVxuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICB0YWJsZVtpXSA9IChmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgciA9IG47XG4gICAgICB2YXIgcyA9IDc7XG5cbiAgICAgIGZvciAobiA+Pj49IDE7IG47IG4gPj4+PSAxKSB7XG4gICAgICAgIHIgPDw9IDE7XG4gICAgICAgIHIgfD0gbiAmIDE7XG4gICAgICAgIC0tcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChyIDw8IHMgJiAweGZmKSA+Pj4gMDtcbiAgICB9KShpKTtcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn0pKCkpO1xuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDUkMzMiDlrp/oo4UuXG4gKi9cblxuXG4vKiogQGRlZmluZSB7Ym9vbGVhbn0gKi9cbnZhciBaTElCX0NSQzMyX0NPTVBBQ1QgPSBmYWxzZTtcblxuLyoqXG4gKiBDUkMzMiDjg4/jg4Pjgrfjg6XlgKTjgpLlj5blvpdcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gZGF0YSBkYXRhIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcj19IHBvcyBkYXRhIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBsZW5ndGggZGF0YSBsZW5ndGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENSQzMyLlxuICovXG5abGliLkNSQzMyLmNhbGMgPSBmdW5jdGlvbihkYXRhLCBwb3MsIGxlbmd0aCkge1xuICByZXR1cm4gWmxpYi5DUkMzMi51cGRhdGUoZGF0YSwgMCwgcG9zLCBsZW5ndGgpO1xufTtcblxuLyoqXG4gKiBDUkMzMuODj+ODg+OCt+ODpeWApOOCkuabtOaWsFxuICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSBkYXRhIGRhdGEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjcmMgQ1JDMzIuXG4gKiBAcGFyYW0ge251bWJlcj19IHBvcyBkYXRhIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBsZW5ndGggZGF0YSBsZW5ndGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENSQzMyLlxuICovXG5abGliLkNSQzMyLnVwZGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNyYywgcG9zLCBsZW5ndGgpIHtcbiAgdmFyIHRhYmxlID0gWmxpYi5DUkMzMi5UYWJsZTtcbiAgdmFyIGkgPSAodHlwZW9mIHBvcyA9PT0gJ251bWJlcicpID8gcG9zIDogKHBvcyA9IDApO1xuICB2YXIgaWwgPSAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gbGVuZ3RoIDogZGF0YS5sZW5ndGg7XG5cbiAgY3JjIF49IDB4ZmZmZmZmZmY7XG5cbiAgLy8gbG9vcCB1bnJvbGxpbmcgZm9yIHBlcmZvcm1hbmNlXG4gIGZvciAoaSA9IGlsICYgNzsgaS0tOyArK3Bvcykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbcG9zXSkgJiAweGZmXTtcbiAgfVxuICBmb3IgKGkgPSBpbCA+PiAzOyBpLS07IHBvcyArPSA4KSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtwb3MgICAgXSkgJiAweGZmXTtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlWyhjcmMgXiBkYXRhW3BvcyArIDFdKSAmIDB4ZmZdO1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbcG9zICsgMl0pICYgMHhmZl07XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtwb3MgKyAzXSkgJiAweGZmXTtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlWyhjcmMgXiBkYXRhW3BvcyArIDRdKSAmIDB4ZmZdO1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFibGVbKGNyYyBeIGRhdGFbcG9zICsgNV0pICYgMHhmZl07XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtwb3MgKyA2XSkgJiAweGZmXTtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlWyhjcmMgXiBkYXRhW3BvcyArIDddKSAmIDB4ZmZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAweGZmZmZmZmZmKSA+Pj4gMDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHBhcmFtIHtudW1iZXJ9IGNyY1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuWmxpYi5DUkMzMi5zaW5nbGUgPSBmdW5jdGlvbihudW0sIGNyYykge1xuICByZXR1cm4gKFpsaWIuQ1JDMzIuVGFibGVbKG51bSBeIGNyYykgJiAweGZmXSBeIChudW0gPj4+IDgpKSA+Pj4gMDtcbn07XG5cbi8qKlxuICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5abGliLkNSQzMyLlRhYmxlXyA9IFtcbiAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhlZTBlNjEyYywgMHg5OTA5NTFiYSwgMHgwNzZkYzQxOSwgMHg3MDZhZjQ4ZixcbiAgMHhlOTYzYTUzNSwgMHg5ZTY0OTVhMywgMHgwZWRiODgzMiwgMHg3OWRjYjhhNCwgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCxcbiAgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNywgMHg5MGJmMWQ5MSwgMHgxZGI3MTA2NCwgMHg2YWIwMjBmMixcbiAgMHhmM2I5NzE0OCwgMHg4NGJlNDFkZSwgMHgxYWRhZDQ3ZCwgMHg2ZGRkZTRlYiwgMHhmNGQ0YjU1MSwgMHg4M2QzODVjNyxcbiAgMHgxMzZjOTg1NiwgMHg2NDZiYThjMCwgMHhmZDYyZjk3YSwgMHg4YTY1YzllYywgMHgxNDAxNWM0ZiwgMHg2MzA2NmNkOSxcbiAgMHhmYTBmM2Q2MywgMHg4ZDA4MGRmNSwgMHgzYjZlMjBjOCwgMHg0YzY5MTA1ZSwgMHhkNTYwNDFlNCwgMHhhMjY3NzE3MixcbiAgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YiwgMHgzNWI1YThmYSwgMHg0MmIyOTg2YyxcbiAgMHhkYmJiYzlkNiwgMHhhY2JjZjk0MCwgMHgzMmQ4NmNlMywgMHg0NWRmNWM3NSwgMHhkY2Q2MGRjZiwgMHhhYmQxM2Q1OSxcbiAgMHgyNmQ5MzBhYywgMHg1MWRlMDAzYSwgMHhjOGQ3NTE4MCwgMHhiZmQwNjExNiwgMHgyMWI0ZjRiNSwgMHg1NmIzYzQyMyxcbiAgMHhjZmJhOTU5OSwgMHhiOGJkYTUwZiwgMHgyODAyYjg5ZSwgMHg1ZjA1ODgwOCwgMHhjNjBjZDliMiwgMHhiMTBiZTkyNCxcbiAgMHgyZjZmN2M4NywgMHg1ODY4NGMxMSwgMHhjMTYxMWRhYiwgMHhiNjY2MmQzZCwgMHg3NmRjNDE5MCwgMHgwMWRiNzEwNixcbiAgMHg5OGQyMjBiYywgMHhlZmQ1MTAyYSwgMHg3MWIxODU4OSwgMHgwNmI2YjUxZiwgMHg5ZmJmZTRhNSwgMHhlOGI4ZDQzMyxcbiAgMHg3ODA3YzlhMiwgMHgwZjAwZjkzNCwgMHg5NjA5YTg4ZSwgMHhlMTBlOTgxOCwgMHg3ZjZhMGRiYiwgMHgwODZkM2QyZCxcbiAgMHg5MTY0NmM5NywgMHhlNjYzNWMwMSwgMHg2YjZiNTFmNCwgMHgxYzZjNjE2MiwgMHg4NTY1MzBkOCwgMHhmMjYyMDA0ZSxcbiAgMHg2YzA2OTVlZCwgMHgxYjAxYTU3YiwgMHg4MjA4ZjRjMSwgMHhmNTBmYzQ1NywgMHg2NWIwZDljNiwgMHgxMmI3ZTk1MCxcbiAgMHg4YmJlYjhlYSwgMHhmY2I5ODg3YywgMHg2MmRkMWRkZiwgMHgxNWRhMmQ0OSwgMHg4Y2QzN2NmMywgMHhmYmQ0NGM2NSxcbiAgMHg0ZGIyNjE1OCwgMHgzYWI1NTFjZSwgMHhhM2JjMDA3NCwgMHhkNGJiMzBlMiwgMHg0YWRmYTU0MSwgMHgzZGQ4OTVkNyxcbiAgMHhhNGQxYzQ2ZCwgMHhkM2Q2ZjRmYiwgMHg0MzY5ZTk2YSwgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCxcbiAgMHg0NDA0MmQ3MywgMHgzMzAzMWRlNSwgMHhhYTBhNGM1ZiwgMHhkZDBkN2NjOSwgMHg1MDA1NzEzYywgMHgyNzAyNDFhYSxcbiAgMHhiZTBiMTAxMCwgMHhjOTBjMjA4NiwgMHg1NzY4YjUyNSwgMHgyMDZmODViMywgMHhiOTY2ZDQwOSwgMHhjZTYxZTQ5ZixcbiAgMHg1ZWRlZjkwZSwgMHgyOWQ5Yzk5OCwgMHhiMGQwOTgyMiwgMHhjN2Q3YThiNCwgMHg1OWIzM2QxNywgMHgyZWI0MGQ4MSxcbiAgMHhiN2JkNWMzYiwgMHhjMGJhNmNhZCwgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNiwgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSxcbiAgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSwgMHg3M2RjMTY4MywgMHhlMzYzMGIxMiwgMHg5NDY0M2I4NCxcbiAgMHgwZDZkNmEzZSwgMHg3YTZhNWFhOCwgMHhlNDBlY2YwYiwgMHg5MzA5ZmY5ZCwgMHgwYTAwYWUyNywgMHg3ZDA3OWViMSxcbiAgMHhmMDBmOTM0NCwgMHg4NzA4YTNkMiwgMHgxZTAxZjI2OCwgMHg2OTA2YzJmZSwgMHhmNzYyNTc1ZCwgMHg4MDY1NjdjYixcbiAgMHgxOTZjMzY3MSwgMHg2ZTZiMDZlNywgMHhmZWQ0MWI3NiwgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSwgMHg2N2RkNGFjYyxcbiAgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSwgMHhkNmQ2YTNlOCwgMHhhMWQxOTM3ZSxcbiAgMHgzOGQ4YzJjNCwgMHg0ZmRmZjI1MiwgMHhkMWJiNjdmMSwgMHhhNmJjNTc2NywgMHgzZmI1MDZkZCwgMHg0OGIyMzY0YixcbiAgMHhkODBkMmJkYSwgMHhhZjBhMWI0YywgMHgzNjAzNGFmNiwgMHg0MTA0N2E2MCwgMHhkZjYwZWZjMywgMHhhODY3ZGY1NSxcbiAgMHgzMTZlOGVlZiwgMHg0NjY5YmU3OSwgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNixcbiAgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZiwgMHhjNWJhM2JiZSwgMHhiMmJkMGIyOCxcbiAgMHgyYmI0NWE5MiwgMHg1Y2IzNmEwNCwgMHhjMmQ3ZmZhNywgMHhiNWQwY2YzMSwgMHgyY2Q5OWU4YiwgMHg1YmRlYWUxZCxcbiAgMHg5YjY0YzJiMCwgMHhlYzYzZjIyNiwgMHg3NTZhYTM5YywgMHgwMjZkOTMwYSwgMHg5YzA5MDZhOSwgMHhlYjBlMzYzZixcbiAgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMywgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCxcbiAgMHg5MmQyOGU5YiwgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNywgMHgwYmRiZGYyMSwgMHg4NmQzZDJkNCwgMHhmMWQ0ZTI0MixcbiAgMHg2OGRkYjNmOCwgMHgxZmRhODM2ZSwgMHg4MWJlMTZjZCwgMHhmNmI5MjY1YiwgMHg2ZmIwNzdlMSwgMHgxOGI3NDc3NyxcbiAgMHg4ODA4NWFlNiwgMHhmZjBmNmE3MCwgMHg2NjA2M2JjYSwgMHgxMTAxMGI1YywgMHg4ZjY1OWVmZiwgMHhmODYyYWU2OSxcbiAgMHg2MTZiZmZkMywgMHgxNjZjY2Y0NSwgMHhhMDBhZTI3OCwgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMixcbiAgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNywgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYiwgMHhhZWQxNmE0YSwgMHhkOWQ2NWFkYyxcbiAgMHg0MGRmMGI2NiwgMHgzN2Q4M2JmMCwgMHhhOWJjYWU1MywgMHhkZWJiOWVjNSwgMHg0N2IyY2Y3ZiwgMHgzMGI1ZmZlOSxcbiAgMHhiZGJkZjIxYywgMHhjYWJhYzI4YSwgMHg1M2IzOTMzMCwgMHgyNGI0YTNhNiwgMHhiYWQwMzYwNSwgMHhjZGQ3MDY5MyxcbiAgMHg1NGRlNTcyOSwgMHgyM2Q5NjdiZiwgMHhiMzY2N2EyZSwgMHhjNDYxNGFiOCwgMHg1ZDY4MWIwMiwgMHgyYTZmMmI5NCxcbiAgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYiwgMHgyZDAyZWY4ZFxuXTtcblxuLyoqXG4gKiBAdHlwZSB7IShBcnJheS48bnVtYmVyPnxVaW50MzJBcnJheSl9IENSQy0zMiBUYWJsZS5cbiAqIEBjb25zdFxuICovXG5abGliLkNSQzMyLlRhYmxlID0gWkxJQl9DUkMzMl9DT01QQUNUID8gKGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUgeyEoQXJyYXkuPG51bWJlcj58VWludDMyQXJyYXkpfSAqL1xuICB2YXIgdGFibGUgPSBuZXcgKFVTRV9UWVBFREFSUkFZID8gVWludDMyQXJyYXkgOiBBcnJheSkoMjU2KTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBjO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGk7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgajtcblxuICBmb3IgKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICBjID0gaTtcbiAgICBmb3IgKGogPSAwOyBqIDwgODsgKytqKSB7XG4gICAgICBjID0gKGMgJiAxKSA/ICgweGVkQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKTtcbiAgICB9XG4gICAgdGFibGVbaV0gPSBjID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufSkoKSA6IFVTRV9UWVBFREFSUkFZID8gbmV3IFVpbnQzMkFycmF5KFpsaWIuQ1JDMzIuVGFibGVfKSA6IFpsaWIuQ1JDMzIuVGFibGVfO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmbGF0ZSAoUkZDMTk1MSkg5a6f6KOFLlxuICogRGVmbGF0ZeOCouODq+OCtOODquOCuuODoOacrOS9k+OBryBabGliLlJhd0RlZmxhdGUg44Gn5a6f6KOF44GV44KM44Gm44GE44KLLlxuICovXG5cbi8qKlxuICogWmxpYiBEZWZsYXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IShBcnJheXxVaW50OEFycmF5KX0gaW5wdXQg56ym5Y+35YyW44GZ44KL5a++6LGh44GuIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9wYXJhbXMgb3B0aW9uIHBhcmFtZXRlcnMuXG4gKi9cblpsaWIuRGVmbGF0ZSA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7IShBcnJheXxVaW50OEFycmF5KX0gKi9cbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9ICovXG4gIHRoaXMub3V0cHV0ID1cbiAgICAgIG5ldyAoVVNFX1RZUEVEQVJSQVkgPyBVaW50OEFycmF5IDogQXJyYXkpKFpsaWIuRGVmbGF0ZS5EZWZhdWx0QnVmZmVyU2l6ZSk7XG4gIC8qKiBAdHlwZSB7WmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZX0gKi9cbiAgdGhpcy5jb21wcmVzc2lvblR5cGUgPSBabGliLkRlZmxhdGUuQ29tcHJlc3Npb25UeXBlLkRZTkFNSUM7XG4gIC8qKiBAdHlwZSB7WmxpYi5SYXdEZWZsYXRlfSAqL1xuICB0aGlzLnJhd0RlZmxhdGU7XG4gIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICB2YXIgcmF3RGVmbGF0ZU9wdGlvbiA9IHt9O1xuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgdmFyIHByb3A7XG5cbiAgLy8gb3B0aW9uIHBhcmFtZXRlcnNcbiAgaWYgKG9wdF9wYXJhbXMgfHwgIShvcHRfcGFyYW1zID0ge30pKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRfcGFyYW1zWydjb21wcmVzc2lvblR5cGUnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Npb25UeXBlID0gb3B0X3BhcmFtc1snY29tcHJlc3Npb25UeXBlJ107XG4gICAgfVxuICB9XG5cbiAgLy8gY29weSBvcHRpb25zXG4gIGZvciAocHJvcCBpbiBvcHRfcGFyYW1zKSB7XG4gICAgcmF3RGVmbGF0ZU9wdGlvbltwcm9wXSA9IG9wdF9wYXJhbXNbcHJvcF07XG4gIH1cblxuICAvLyBzZXQgcmF3LWRlZmxhdGUgb3V0cHV0IGJ1ZmZlclxuICByYXdEZWZsYXRlT3B0aW9uWydvdXRwdXRCdWZmZXInXSA9IHRoaXMub3V0cHV0O1xuXG4gIHRoaXMucmF3RGVmbGF0ZSA9IG5ldyBabGliLlJhd0RlZmxhdGUodGhpcy5pbnB1dCwgcmF3RGVmbGF0ZU9wdGlvbik7XG59O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn0g44OH44OV44Kp44Or44OI44OQ44OD44OV44Kh44K144Kk44K6LlxuICovXG5abGliLkRlZmxhdGUuRGVmYXVsdEJ1ZmZlclNpemUgPSAweDgwMDA7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuWmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZSA9IFpsaWIuUmF3RGVmbGF0ZS5Db21wcmVzc2lvblR5cGU7XG5cbi8qKlxuICog55u05o6l5Zyn57iu44Gr5o6b44GR44KLLlxuICogQHBhcmFtIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBpbnB1dCB0YXJnZXQgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIG9wdGlvbiBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7IShBcnJheXxVaW50OEFycmF5KX0gY29tcHJlc3NlZCBkYXRhIGJ5dGUgYXJyYXkuXG4gKi9cblpsaWIuRGVmbGF0ZS5jb21wcmVzcyA9IGZ1bmN0aW9uKGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gIHJldHVybiAobmV3IFpsaWIuRGVmbGF0ZShpbnB1dCwgb3B0X3BhcmFtcykpLmNvbXByZXNzKCk7XG59O1xuXG4vKipcbiAqIERlZmxhdGUgQ29tcHJlc3Npb24uXG4gKiBAcmV0dXJuIHshKEFycmF5fFVpbnQ4QXJyYXkpfSBjb21wcmVzc2VkIGRhdGEgYnl0ZSBhcnJheS5cbiAqL1xuWmxpYi5EZWZsYXRlLnByb3RvdHlwZS5jb21wcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAvKiogQHR5cGUge1psaWIuQ29tcHJlc3Npb25NZXRob2R9ICovXG4gIHZhciBjbTtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBjaW5mbztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBjbWY7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgZmxnO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGZjaGVjaztcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBmZGljdDtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIHZhciBmbGV2ZWw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgY2xldmVsO1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgdmFyIGFkbGVyO1xuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHZhciBlcnJvciA9IGZhbHNlO1xuICAvKiogQHR5cGUgeyEoQXJyYXl8VWludDhBcnJheSl9ICovXG4gIHZhciBvdXRwdXQ7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICB2YXIgcG9zID0gMDtcblxuICBvdXRwdXQgPSB0aGlzLm91dHB1dDtcblxuICAvLyBDb21wcmVzc2lvbiBNZXRob2QgYW5kIEZsYWdzXG4gIGNtID0gWmxpYi5Db21wcmVzc2lvbk1ldGhvZC5ERUZMQVRFO1xuICBzd2l0Y2ggKGNtKSB7XG4gICAgY2FzZSBabGliLkNvbXByZXNzaW9uTWV0aG9kLkRFRkxBVEU6XG4gICAgICBjaW5mbyA9IE1hdGguTE9HMkUgKiBNYXRoLmxvZyhabGliLlJhd0RlZmxhdGUuV2luZG93U2l6ZSkgLSA4O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb21wcmVzc2lvbiBtZXRob2QnKTtcbiAgfVxuICBjbWYgPSAoY2luZm8gPDwgNCkgfCBjbTtcbiAgb3V0cHV0W3BvcysrXSA9IGNtZjtcblxuICAvLyBGbGFnc1xuICBmZGljdCA9IDA7XG4gIHN3aXRjaCAoY20pIHtcbiAgICBjYXNlIFpsaWIuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURTpcbiAgICAgIHN3aXRjaCAodGhpcy5jb21wcmVzc2lvblR5cGUpIHtcbiAgICAgICAgY2FzZSBabGliLkRlZmxhdGUuQ29tcHJlc3Npb25UeXBlLk5PTkU6IGZsZXZlbCA9IDA7IGJyZWFrO1xuICAgICAgICBjYXNlIFpsaWIuRGVmbGF0ZS5Db21wcmVzc2lvblR5cGUuRklYRUQ6IGZsZXZlbCA9IDE7IGJyZWFrO1xuICAgICAgICBjYXNlIFpsaWIuRGVmbGF0ZS5Db21wcmVzc2lvblR5cGUuRFlOQU1JQzogZmxldmVsID0gMjsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb21wcmVzc2lvbiBtZXRob2QnKTtcbiAgfVxuICBmbGcgPSAoZmxldmVsIDw8IDYpIHwgKGZkaWN0IDw8IDUpO1xuICBmY2hlY2sgPSAzMSAtIChjbWYgKiAyNTYgKyBmbGcpICUgMzE7XG4gIGZsZyB8PSBmY2hlY2s7XG4gIG91dHB1dFtwb3MrK10gPSBmbGc7XG5cbiAgLy8gQWRsZXItMzIgY2hlY2tzdW1cbiAgYWRsZXIgPSBabGliLkFkbGVyMzIodGhpcy5pbnB1dCk7XG5cbiAgdGhpcy5yYXdEZWZsYXRlLm9wID0gcG9zO1xuICBvdXRwdXQgPSB0aGlzLnJhd0RlZmxhdGUuY29tcHJlc3MoKTtcbiAgcG9zID0gb3V0cHV0Lmxlbmd0aDtcblxuICBpZiAoVVNFX1RZUEVEQVJSQVkpIHtcbiAgICAvLyBzdWJhcnJheSDliIbjgpLlhYPjgavjgoLjganjgZlcbiAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShvdXRwdXQuYnVmZmVyKTtcbiAgICAvLyBleHBhbmQgYnVmZmVyXG4gICAgaWYgKG91dHB1dC5sZW5ndGggPD0gcG9zICsgNCkge1xuICAgICAgdGhpcy5vdXRwdXQgPSBuZXcgVWludDhBcnJheShvdXRwdXQubGVuZ3RoICsgNCk7XG4gICAgICB0aGlzLm91dHB1dC5zZXQob3V0cHV0KTtcbiAgICAgIG91dHB1dCA9IHRoaXMub3V0cHV0O1xuICAgIH1cbiAgICBvdXRwdXQgPSBvdXRwdXQuc3ViYXJyYXkoMCwgcG9zICsgNCk7XG4gIH1cblxuICAvLyBhZGxlcjMyXG4gIG91dHB1dFtwb3MrK10gPSAoYWRsZXIgPj4gMjQpICYgMHhmZjtcbiAgb3V0cHV0W3BvcysrXSA9IChhZGxlciA+PiAxNikgJiAweGZmO1xuICBvdXRwdXRbcG9zKytdID0gKGFkbGVyID4+ICA4KSAmIDB4ZmY7XG4gIG91dHB1dFtwb3MrK10gPSAoYWRsZXIgICAgICApICYgMHhmZjtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG5leHBvcnR7WmxpYn07XG5cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFPQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQUNBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBEQTtBQXNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQU1BOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVhBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFRQTs7OztBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFLQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBL0JBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUtBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBSUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQTZDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../MLVPanel/src/vendor/zlib_and_gzip.js\n");

/***/ }),

/***/ "./lanceotron/src/capture_compare_track.js":
/*!*************************************************!*\
  !*** ./lanceotron/src/capture_compare_track.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CaptureCompareTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getDecodeFunction(sample_size) {\n\tvar max = sample_size * 2;\n\treturn function (tokens, feature) {\n\t\tfeature.data = [];\n\t\tfor (var i = 0; i < max; i += 2) {\n\t\t\tfeature.data.push([parseFloat(tokens[i]), parseFloat(tokens[i + 1])]);\n\t\t}\n\t};\n}\n\nvar CaptureCompareTrack = function (_MLVBedTrack) {\n\t_inherits(CaptureCompareTrack, _MLVBedTrack);\n\n\tfunction CaptureCompareTrack(config) {\n\t\t_classCallCheck(this, CaptureCompareTrack);\n\n\t\tconfig.format = \"feature\";\n\t\tif (!config.colors) {\n\t\t\tconfig.colors = [\"#FF0000\", \"#0000FF\", \"#008000\"];\n\t\t}\n\t\treturn _possibleConstructorReturn(this, (CaptureCompareTrack.__proto__ || Object.getPrototypeOf(CaptureCompareTrack)).call(this, config));\n\t}\n\n\t_createClass(CaptureCompareTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tif (this.config.url && this.config.url.endsWith(\".gz\")) {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, getDecodeFunction(this.config.conditions.length));\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, getDecodeFunction(this.config.conditions.length));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\t\t\tvar max = this.config.initial_y_max * 4;\n\t\t\tvar min = this.config.initial_y_max / 6;\n\t\t\tvar val = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tvar feature_div = $(\"<div>\");\n\t\t\tdialog.fixed_scale_check = $(\"<input>\").attr({ type: \"checkbox\" }).prop(\"checked\", !dialog.config.dynamic_scale).click(function (e) {\n\t\t\t\tvar dyn = true;\n\t\t\t\tif ($(this).prop(\"checked\")) {\n\t\t\t\t\tdyn = false;\n\t\t\t\t}\n\t\t\t\tdialog.config.dynamic_scale = dyn;\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"dynamic_scale\", dyn);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t\tdialog.scale_slider.slider(dyn ? \"disable\" : \"enable\");\n\t\t\t\tdialog.max_y_input.attr(\"disabled\", dyn);\n\t\t\t});\n\n\t\t\tfeature_div.append(dialog.fixed_scale_check).append(\"<label>Fixed Scale</label><br>\");\n\t\t\tdialog.scale_slider = $(\"<div>\").slider({\n\t\t\t\tmax: max,\n\t\t\t\tmin: min,\n\t\t\t\tstep: (max - min) / 100,\n\t\t\t\tvalue: val,\n\t\t\t\tslide: function slide(e, ui) {\n\t\t\t\t\tdialog.config.y_max = ui.value;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"y_max\", ui.value);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t\tdialog.max_y_input.val(ui.value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tdialog.max_y_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar y = dialog.max_y_input.val();\n\t\t\t\ty = parseFloat(y);\n\t\t\t\tvar s = dialog.scale_slider;\n\t\t\t\tvar max = s.slider(\"option\", \"max\");\n\t\t\t\tvar min = s.slider(\"option\", \"min\");\n\t\t\t\tif (y > max) {\n\t\t\t\t\ts.slider(\"option\", \"max\", y);\n\t\t\t\t} else if (y < min) {\n\t\t\t\t\ts.slider(\"option\", \"min\", y);\n\t\t\t\t}\n\n\t\t\t\ts.slider(\"option\", \"step\", (max - min) / 100);\n\t\t\t\ts.slider(\"option\", \"value\", y);\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"y_max\", y);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).width(50).val(val);\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>Track Height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tfeature_div.append(dialog.scale_slider.css(\"margin-bottom\", \"4px\")).append(\"<span>Max Y:</span>\").append(dialog.max_y_input).appendTo(dialog.div);\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tvar sd_name = \"sd-ra-name-\" + dialog.id;\n\t\t\tvar sd_div = $(\"<div>\").append(\"<label>Display SD as:</label><br>\");\n\t\t\tvar is_box = false;\n\t\t\tif (!this.config.display_sd || this.config.display_sd == \"box\") {\n\t\t\t\tis_box = true;\n\t\t\t}\n\t\t\tsd_div.append($(\"<input>\").attr({ type: \"radio\", value: \"box\", checked: is_box, name: sd_name }));\n\t\t\tsd_div.append($(\"<span>\").text(\"Box\"));\n\t\t\tsd_div.append($(\"<input>\").attr({ type: \"radio\", value: \"bar\", checked: this.config.display_sd === \"bar\", name: sd_name }));\n\t\t\tsd_div.append($(\"<span>\").text(\"Bar\"));\n\t\t\tsd_div.appendTo(dialog.div);\n\n\t\t\t$(\"input[name='\" + sd_name + \"']\").click(function (e) {\n\t\t\t\tvar display_sd = $(\"input[name='\" + sd_name + \"']:checked\").val();\n\t\t\t\tdialog.config.display_sd = display_sd;\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"display_sd\", display_sd);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t});\n\t\t\tdialog.div.append(\"<hr>\");\n\t\t\tvar color_div = $(\"<div class='t-d-div'></div>\").appendTo(dialog.div);\n\t\t\tcolor_div.append(\"<label>Sample Colors</label><br>\");\n\n\t\t\tfor (var x = 0; x < this.config.conditions.length; x++) {\n\t\t\t\tvar d = $(\"<div>\");\n\t\t\t\tvar color_input = $(\"<input>\").attr({ type: \"color\" }).data(\"index\", x).val(this.config.colors[x]).height(20).width(20).css({ \"margin-right\": \"3px\", \"padding\": \"0px\" }).change(function (e) {\n\t\t\t\t\tvar color = $(this).val();\n\t\t\t\t\tdialog.config.colors[$(this).data(\"index\")] = color;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(self.config.track_id, \"colors\", dialog.config.colors);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\td.append(color_input).append($(\"<span>\").text(this.config.conditions[x])).appendTo(color_div);\n\t\t\t}\n\n\t\t\tif (dialog.config.dynamic_scale) {\n\t\t\t\tdialog.scale_slider.slider(\"disable\");\n\t\t\t\tdialog.max_y_input.slider(\"disable\");\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"calculateMaxY\",\n\t\tvalue: function calculateMaxY(options) {\n\t\t\tvar count = 0;\n\t\t\tvar y_max = 0;\n\t\t\tvar s_s = this.config.conditions.length;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = options.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\tif (x_pos > count) {\n\t\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\t\t\tvar y = feature.data[i][0] + feature.data[i][1];\n\t\t\t\t\t\t\tif (y > y_max) {\n\t\t\t\t\t\t\t\ty_max = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn y_max;\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar features = options.features;\n\t\t\tvar sparse = false;\n\t\t\tvar interval = 1;\n\t\t\t/*if (features.length> 1.5*options.pixelWidth){\r\n   \tinterval += Math.floor(features.length/options.pixelWidth)\r\n   }*/\n\n\t\t\tvar top = this.config.discrete ? options.top : 0;\n\t\t\tvar bot = this.config.discrete ? parseInt(top) + parseInt(this.config.height) : options.pixelHeight;\n\t\t\tif (this.config.display_difference) {}\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bot;\n\t\t\tvar ctx = options.context;\n\t\t\tvar prev_x = null;\n\t\t\tvar prev_y = [];\n\t\t\tvar colors = this.config.colors;\n\t\t\tvar y_max = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tif (this.config.dynamic_scale) {\n\t\t\t\ty_max = this.calculateMaxY(options);\n\t\t\t}\n\t\t\tvar wig_height = this.config.discrete ? this.config.height : options.pixelHeight;\n\t\t\tvar s_s = this.config.conditions.length;\n\t\t\tvar display_bar = false;\n\t\t\tvar display_box = true;\n\t\t\tif (this.config.display_sd === \"bar\") {\n\t\t\t\tdisplay_box = false;\n\t\t\t\tif (options.bpPerPixel < 100) {\n\t\t\t\t\tdisplay_bar = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0;\n\t\t\tvar drawn = 0;\n\n\t\t\tfor (var x = 0; x < features.length; x += interval) {\n\n\t\t\t\tvar feature = features[x];\n\n\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\tif (x_pos > count) {\n\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\tdrawn++;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlen = len / options.bpPerPixel;\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tvar t_y = [];\n\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\tvar y_pos = wig_height - feature.data[i][0] / y_max * wig_height + top;\n\t\t\t\t\ty_pos = y_pos;\n\t\t\t\t\tif (this.config.asline && prev_x != null) {\n\t\t\t\t\t\tctx.strokeStyle = colors[i];\n\t\t\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(prev_x, prev_y[i]);\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.lineTo(x_pos, y_pos);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\t\t\tctx.strokeStyle = colors[i];\n\t\t\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\t\t\tctx.fillRect(x_pos - len / 2, y_pos, len, this.bottom - y_pos);\n\n\t\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tvar sd = feature.data[i][1] / y_max * wig_height;\n\n\t\t\t\t\tif (display_box) {\n\t\t\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\t\t\tctx.fillRect(x_pos - len / 2, y_pos - sd, len, 2 * sd);\n\t\t\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\t\t} else if (display_bar) {\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(x_pos - 4, y_pos - sd);\n\t\t\t\t\t\tctx.lineTo(x_pos + 4, y_pos - sd);\n\t\t\t\t\t\tctx.moveTo(x_pos, y_pos - sd);\n\t\t\t\t\t\tctx.lineTo(x_pos, y_pos + sd);\n\t\t\t\t\t\tctx.moveTo(x_pos - 4, y_pos + sd);\n\t\t\t\t\t\tctx.lineTo(x_pos + 4, y_pos + sd);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\tt_y.push(y_pos);\n\t\t\t\t}\n\t\t\t\tprev_y = t_y;\n\t\t\t\tprev_x = x_pos;\n\t\t\t}\n\n\t\t\tif (this.config.exclusion_zone) {\n\t\t\t\tvar bpStart = options.bpStart;\n\t\t\t\tvar bpEnd = options.bpStart + options.bpPerPixel * options.pixelWidth;\n\t\t\t\tvar ex = this.config.exclusion_zone;\n\n\t\t\t\tif (ex[0] > bpStart && ex[0] < bpEnd || ex[1] > bpStart && ex[1] < bpEnd) {\n\t\t\t\t\tvar ex_st = (ex[0] - bpStart) / options.bpPerPixel;\n\t\t\t\t\tex_st = ex_st < 0 ? 0 : ex_st;\n\t\t\t\t\tvar ex_en = (ex[1] - bpStart) / options.bpPerPixel;\n\t\t\t\t\tex_en = ex_en > options.pixelWidth ? options.pixelWidth : ex_en;\n\t\t\t\t\tctx.fillStyle = \"white\";\n\t\t\t\t\tctx.strokeStyle = \"grey\";\n\n\t\t\t\t\tctx.rect(ex_st, this.top + 1, ex_en - ex_st, this.config.height - 1);\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tex = this.config.viewpoint;\n\t\t\t\tif (ex) {\n\t\t\t\t\tif (ex[0] > bpStart && ex[0] < bpEnd || ex[1] > bpStart && ex[1] < bpEnd) {\n\t\t\t\t\t\tvar _ex_st = (ex[0] - bpStart) / options.bpPerPixel;\n\t\t\t\t\t\t_ex_st = _ex_st < 0 ? 0 : _ex_st;\n\t\t\t\t\t\tvar _ex_en = (ex[1] - bpStart) / options.bpPerPixel;\n\t\t\t\t\t\t_ex_en = _ex_en > options.pixelWidth ? options.pixelWidth : _ex_en;\n\t\t\t\t\t\tctx.fillStyle = \"grey\";\n\t\t\t\t\t\tctx.fillRect(_ex_st, this.top + 1, _ex_en - _ex_st, this.config.height - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.max_y = y_max;\n\n\t\t\treturn this.config.discrete ? bot : null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tvar bot = this.bottom;\n\t\t\tvar top = this.top;\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\t\t\tvar max_y = this.max_y;\n\t\t\tvar min_y = 0;\n\t\t\tvar range = max_y - min_y;\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(20, top);\n\t\t\tctx.moveTo(0, bot);\n\t\t\tctx.lineTo(20, bot);\n\t\t\tctx.font = \"12px Arial\";\n\t\t\tctx.stroke();\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(max_y.toFixed(2), 20, top);\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(min_y, 20, bot);\n\t\t\tctx.font = \"14px Arial\";\n\t\t\tvar text = this.config.legend_label ? this.config.legend_label : \"Condition\";\n\t\t\tctx.fillText(text, 10, top + 30);\n\t\t\tctx.font = \"12px Arial\";\n\t\t\tvar colors = this.config.colors;\n\t\t\tfor (var i = 0; i < this.config.conditions.length; i++) {\n\t\t\t\tctx.fillStyle = colors[i];\n\t\t\t\tctx.globalAlpha = 0.4;\n\t\t\t\tctx.fillRect(10, top + 40 + i * 30, 20, 20);\n\t\t\t\tctx.globalAlpha = 1.0;\n\t\t\t\tctx.fillRect(10, top + 49 + i * 30, 20, 2);\n\t\t\t\tctx.fillStyle = \"black\";\n\t\t\t\tctx.fillText(this.config.conditions[i], 31, top + 55 + i * 30);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}]);\n\n\treturn CaptureCompareTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"capture_compare\"] = CaptureCompareTrack;\n_tracks.MLVTrack.track_types[\"capture_compare\"] = {\n\t\"class\": CaptureCompareTrack\n};\n\nexports.CaptureCompareTrack = CaptureCompareTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9jYXB0dXJlX2NvbXBhcmVfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvY2FwdHVyZV9jb21wYXJlX3RyYWNrLmpzP2QzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERlY29kZUZ1bmN0aW9uKHNhbXBsZV9zaXplKXtcclxuXHRsZXQgbWF4ID0gc2FtcGxlX3NpemUqMlxyXG5cdHJldHVybiBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0XHRmZWF0dXJlLmRhdGE9W107XHJcblx0XHRmb3IgKGxldCBpPTA7aTxtYXg7aSs9Mil7XHJcblx0XHRcdGZlYXR1cmUuZGF0YS5wdXNoKFtwYXJzZUZsb2F0KHRva2Vuc1tpXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsxXSldKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgQ2FwdHVyZUNvbXBhcmVUcmFjayBleHRlbmRzIE1MVkJlZFRyYWNre1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcclxuICAgIFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuICAgIFx0aWYgKCFjb25maWcuY29sb3JzKXtcclxuICAgIFx0XHRjb25maWcuY29sb3JzPVtcIiNGRjAwMDBcIixcIiMwMDAwRkZcIixcIiMwMDgwMDBcIl1cclxuICAgIFx0fVxyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcudXJsICYmIHRoaXMuY29uZmlnLnVybC5lbmRzV2l0aChcIi5nelwiKSl7XHJcblx0XHRcdHRoaXMuZmVhdHVyZV9zb3VyY2UgPSBuZXcgVGFiaXhCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGdldERlY29kZUZ1bmN0aW9uKHRoaXMuY29uZmlnLmNvbmRpdGlvbnMubGVuZ3RoKSk7XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZ2V0RGVjb2RlRnVuY3Rpb24odGhpcy5jb25maWcuY29uZGl0aW9ucy5sZW5ndGgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGlhbG9nKXtcclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGRpYWxvZy5kaXYuZW1wdHkoKTtcclxuXHRcdGxldCBtYXg9dGhpcy5jb25maWcuaW5pdGlhbF95X21heCo0O1xyXG5cdFx0bGV0IG1pbiA9dGhpcy5jb25maWcuaW5pdGlhbF95X21heC82O1xyXG5cdFx0bGV0IHZhbCA9IHRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRsZXQgZmVhdHVyZV9kaXY9ICAkKFwiPGRpdj5cIik7XHJcblx0XHRkaWFsb2cuZml4ZWRfc2NhbGVfY2hlY2sgPSAkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwiY2hlY2tib3hcIn0pXHJcblx0XHRcdFx0LnByb3AoXCJjaGVja2VkXCIsIWRpYWxvZy5jb25maWcuZHluYW1pY19zY2FsZSlcclxuXHRcdFx0XHQuY2xpY2soZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRsZXQgZHluPXRydWU7XHJcblx0XHRcdFx0XHRpZiAoJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiKSl7XHJcblx0XHRcdFx0XHRcdGR5bj1mYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGRpYWxvZy5jb25maWcuZHluYW1pY19zY2FsZT1keW47XHJcbiAgICAgICAgICAgXHRcdFx0aWYgKGRpYWxvZy5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBcdFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJkeW5hbWljX3NjYWxlXCIsZHluKTtcclxuICAgICAgICAgICAgICAgIFx0XHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgICAgIFx0XHRcdGRpYWxvZy5zY2FsZV9zbGlkZXIuc2xpZGVyKGR5bj9cImRpc2FibGVcIjpcImVuYWJsZVwiKTtcclxuICAgICAgICAgICAgXHRcdGRpYWxvZy5tYXhfeV9pbnB1dC5hdHRyKFwiZGlzYWJsZWRcIixkeW4pO1xyXG5cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRmZWF0dXJlX2Rpdi5hcHBlbmQoZGlhbG9nLmZpeGVkX3NjYWxlX2NoZWNrKS5hcHBlbmQoXCI8bGFiZWw+Rml4ZWQgU2NhbGU8L2xhYmVsPjxicj5cIik7XHJcbiAgICBcdGRpYWxvZy5zY2FsZV9zbGlkZXI9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICBcdFx0bWF4Om1heCxcclxuICAgICAgIFx0XHRtaW46bWluLFxyXG4gICAgICAgXHRcdHN0ZXA6KG1heC1taW4pLzEwMCxcclxuICAgICAgIFx0XHR2YWx1ZTp2YWwsXHJcbiAgICAgICBcdFx0c2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgXHRcdGRpYWxvZy5jb25maWcueV9tYXg9dWkudmFsdWVcclxuICAgICAgICAgICBcdFx0aWYgKGRpYWxvZy5wYW5lbCl7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwieV9tYXhcIix1aS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgIFx0XHRkaWFsb2cubWF4X3lfaW5wdXQudmFsKHVpLnZhbHVlKVxyXG4gICAgICAgXHRcdH0gXHJcbiAgICBcdH0pO1xyXG4gICAgXHRkaWFsb2cubWF4X3lfaW5wdXQ9JChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1kaWFsb2cubWF4X3lfaW5wdXQudmFsKCk7XHJcbiAgICAgICAgICAgICAgICB5PXBhcnNlRmxvYXQoeSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcyA9IGRpYWxvZy5zY2FsZV9zbGlkZXI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4ID0gcy5zbGlkZXIoXCJvcHRpb25cIixcIm1heFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBzLnNsaWRlcihcIm9wdGlvblwiLFwibWluXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoeT5tYXgpe1xyXG4gICAgICAgICAgICAgICAgXHRzLnNsaWRlcihcIm9wdGlvblwiLFwibWF4XCIseSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlICBpZih5PG1pbil7XHJcbiAgICAgICAgICAgICAgICBcdHMuc2xpZGVyKFwib3B0aW9uXCIsXCJtaW5cIix5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHMuc2xpZGVyKFwib3B0aW9uXCIsXCJzdGVwXCIsKG1heC1taW4pLzEwMCk7XHJcbiAgICAgICAgICAgICAgICBzLnNsaWRlcihcIm9wdGlvblwiLFwidmFsdWVcIix5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcInlfbWF4XCIseSk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICBcdFx0fVxyXG4gICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9KS53aWR0aCg1MCkudmFsKHZhbCk7XHJcbiAgICAgICAgICBcclxuXHJcblxyXG4gICAgXHRcdGxldCBoZWlnaHRfZGl2PSQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIik7XHJcbiAgICAgICAgXHRcclxuXHRcdFx0aGVpZ2h0X2Rpdi5hcHBlbmQoXCI8bGFiZWw+VHJhY2sgSGVpZ2h0OjwvbGFiZWw+XCIpLmFwcGVuZFRvKGRpYWxvZy5kaXYpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGhlaWdodF9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG4gICAgICAgICAgICAgICAgbWluOiAxMCxcclxuICAgICAgICAgICAgICAgIG1heDogNTAwLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ZGlhbG9nLmNvbmZpZy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29uZmlnLmhlaWdodD0gdWkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJoZWlnaHRcIixkaWFsb2cuY29uZmlnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY3NzKHtcIm1hcmdpblwiOlwiNXB4IDNweFwifSk7XHJcblxyXG5cclxuICAgICAgICAgICAgaGVpZ2h0X3NsaWRlci5hcHBlbmRUbyhoZWlnaHRfZGl2KTtcclxuICAgICAgICBcclxuXHJcbiAgIFx0XHRkaWFsb2cuZGl2LmFwcGVuZChcIjxocj5cIik7XHJcbiAgICBcdGZlYXR1cmVfZGl2LmFwcGVuZChkaWFsb2cuc2NhbGVfc2xpZGVyLmNzcyhcIm1hcmdpbi1ib3R0b21cIixcIjRweFwiKSkuYXBwZW5kKFwiPHNwYW4+TWF4IFk6PC9zcGFuPlwiKS5hcHBlbmQoZGlhbG9nLm1heF95X2lucHV0KS5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuXHRcdGRpYWxvZy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgIFx0bGV0IHNkX25hbWU9IFwic2QtcmEtbmFtZS1cIitkaWFsb2cuaWQ7XHJcbiAgICBcdGxldCBzZF9kaXY9ICAkKFwiPGRpdj5cIikuYXBwZW5kKFwiPGxhYmVsPkRpc3BsYXkgU0QgYXM6PC9sYWJlbD48YnI+XCIpO1xyXG4gICAgXHRsZXQgaXNfYm94PWZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZGlzcGxheV9zZCB8fCB0aGlzLmNvbmZpZy5kaXNwbGF5X3NkPT1cImJveFwiKXtcclxuXHRcdFx0aXNfYm94PXRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNkX2Rpdi5hcHBlbmQoJChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcInJhZGlvXCIsdmFsdWU6XCJib3hcIixjaGVja2VkOmlzX2JveCxuYW1lOnNkX25hbWV9KSlcclxuICAgICAgICBzZF9kaXYuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dChcIkJveFwiKSk7XHJcbiAgICAgICAgc2RfZGl2LmFwcGVuZCgkKFwiPGlucHV0PlwiKS5hdHRyKHt0eXBlOlwicmFkaW9cIix2YWx1ZTpcImJhclwiLGNoZWNrZWQ6dGhpcy5jb25maWcuZGlzcGxheV9zZD09PVwiYmFyXCIsbmFtZTpzZF9uYW1lfSkpXHJcbiAgICAgICAgc2RfZGl2LmFwcGVuZCgkKFwiPHNwYW4+XCIpLnRleHQoXCJCYXJcIikpO1xyXG4gICAgICAgIHNkX2Rpdi5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAkKFwiaW5wdXRbbmFtZT0nXCIrc2RfbmFtZStcIiddXCIpLmNsaWNrKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlfc2Q9JChcImlucHV0W25hbWU9J1wiK3NkX25hbWUrXCInXTpjaGVja2VkXCIpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgZGlhbG9nLmNvbmZpZy5kaXNwbGF5X3NkPWRpc3BsYXlfc2Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlhbG9nLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJkaXNwbGF5X3NkXCIsZGlzcGxheV9zZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuXHRcdGRpYWxvZy5kaXYuYXBwZW5kKFwiPGhyPlwiKTtcclxuICAgICAgICBsZXQgY29sb3JfZGl2PSQoXCI8ZGl2IGNsYXNzPSd0LWQtZGl2Jz48L2Rpdj5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcbiAgICAgICAgY29sb3JfZGl2LmFwcGVuZChcIjxsYWJlbD5TYW1wbGUgQ29sb3JzPC9sYWJlbD48YnI+XCIpO1xyXG4gICAgICAgXHJcblx0XHRmb3IgKGxldCB4PTA7eDx0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDt4Kyspe1xyXG5cdFx0XHRsZXQgZD0gJChcIjxkaXY+XCIpO1xyXG5cdFx0XHRsZXQgY29sb3JfaW5wdXQ9JChcIjxpbnB1dD5cIikuYXR0cih7dHlwZTpcImNvbG9yXCJ9KS5kYXRhKFwiaW5kZXhcIix4KS52YWwodGhpcy5jb25maWcuY29sb3JzW3hdKS5oZWlnaHQoMjApLndpZHRoKDIwKVxyXG5cdFx0XHQuY3NzKHtcIm1hcmdpbi1yaWdodFwiOlwiM3B4XCIsXCJwYWRkaW5nXCI6XCIwcHhcIn0pXHJcbiAgICAgICAgXHQuY2hhbmdlKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICBcdGxldCBjb2xvciA9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgIFx0ZGlhbG9nLmNvbmZpZy5jb2xvcnNbJCh0aGlzKS5kYXRhKFwiaW5kZXhcIildPWNvbG9yO1xyXG4gICAgICAgICAgICBcdGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoc2VsZi5jb25maWcudHJhY2tfaWQsXCJjb2xvcnNcIixkaWFsb2cuY29uZmlnLmNvbG9ycyk7XHJcbiAgICAgICAgICAgICAgICBcdGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICBcdCBcdH0pO1xyXG4gICAgICAgXHQgXHRkLmFwcGVuZChjb2xvcl9pbnB1dCkuYXBwZW5kKCQoXCI8c3Bhbj5cIikudGV4dCh0aGlzLmNvbmZpZy5jb25kaXRpb25zW3hdKSkuYXBwZW5kVG8oY29sb3JfZGl2KVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQgIGlmIChkaWFsb2cuY29uZmlnLmR5bmFtaWNfc2NhbGUpe1xyXG4gICAgICAgICAgICBcdGRpYWxvZy5zY2FsZV9zbGlkZXIuc2xpZGVyKFwiZGlzYWJsZVwiKTtcclxuICAgICAgICAgICAgXHRkaWFsb2cubWF4X3lfaW5wdXQuc2xpZGVyKFwiZGlzYWJsZVwiKVxyXG4gICAgICAgICAgICB9XHJcblx0XHRcclxuXHRcdFx0XHRcclxuXHR9XHJcblxyXG5cclxuXHRjYWxjdWxhdGVNYXhZKG9wdGlvbnMpe1xyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgeV9tYXg9MDtcclxuXHRcdGxldCBzX3MgPSB0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDtcclxuXHRcdGZvciAobGV0IGZlYXR1cmUgb2Ygb3B0aW9ucy5mZWF0dXJlcyl7XHJcblx0XHRcdGxldCBsZW4gPSBmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0XHJcblx0XHRcdGxldCB4X3BvcyA9IChmZWF0dXJlLnN0YXJ0KyhsZW4vMiktb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdGlmICh4X3Bvcz5jb3VudCl7XHJcblx0XHRcdFx0Y291bnQ9TWF0aC5mbG9vcih4X3BvcykrMTtcclxuXHRcdFx0XHRmb3IgKGxldCBpPTA7aTxzX3M7aSsrKXtcclxuXHRcdFx0XHRcdGxldCB5PWZlYXR1cmUuZGF0YVtpXVswXStmZWF0dXJlLmRhdGFbaV1bMV07XHJcblx0XHRcdFx0XHRpZiAoeT55X21heCl7XHJcblx0XHRcdFx0XHRcdHlfbWF4PXk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geV9tYXg7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKXtcclxuXHRcdGxldCBmZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XHJcblx0XHRsZXQgc3BhcnNlPWZhbHNlO1xyXG5cdFx0bGV0IGludGVydmFsPTFcclxuXHRcdC8qaWYgKGZlYXR1cmVzLmxlbmd0aD4gMS41Km9wdGlvbnMucGl4ZWxXaWR0aCl7XHJcblx0XHRcdGludGVydmFsICs9IE1hdGguZmxvb3IoZmVhdHVyZXMubGVuZ3RoL29wdGlvbnMucGl4ZWxXaWR0aClcclxuXHRcdH0qL1xyXG5cclxuXHRcdFxyXG5cdFx0XHJcblx0XHRsZXQgdG9wID0gdGhpcy5jb25maWcuZGlzY3JldGU/b3B0aW9ucy50b3A6MDtcclxuXHRcdGxldCBib3QgPXRoaXMuY29uZmlnLmRpc2NyZXRlP3BhcnNlSW50KHRvcCkrcGFyc2VJbnQodGhpcy5jb25maWcuaGVpZ2h0KTpvcHRpb25zLnBpeGVsSGVpZ2h0O1xyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmRpc3BsYXlfZGlmZmVyZW5jZSl7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0dGhpcy50b3A9dG9wO1xyXG5cdFx0dGhpcy5ib3R0b209Ym90O1xyXG5cdFx0bGV0IGN0eD1vcHRpb25zLmNvbnRleHQ7XHJcblx0XHRsZXQgcHJldl94PW51bGw7XHJcblx0XHRsZXQgcHJldl95PVtdO1xyXG5cdFx0bGV0IGNvbG9ycz0gdGhpcy5jb25maWcuY29sb3JzXHJcblx0XHRsZXQgeV9tYXggPXRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRpZiAodGhpcy5jb25maWcuZHluYW1pY19zY2FsZSl7XHJcblx0XHRcdHlfbWF4PXRoaXMuY2FsY3VsYXRlTWF4WShvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGxldCB3aWdfaGVpZ2h0ID0gdGhpcy5jb25maWcuZGlzY3JldGU/dGhpcy5jb25maWcuaGVpZ2h0Om9wdGlvbnMucGl4ZWxIZWlnaHQ7XHJcblx0XHRsZXQgc19zID0gdGhpcy5jb25maWcuY29uZGl0aW9ucy5sZW5ndGg7XHJcblx0XHRsZXQgZGlzcGxheV9iYXI9ZmFsc2U7XHJcblx0XHRsZXQgZGlzcGxheV9ib3g9IHRydWU7XHJcblx0XHRpZiAodGhpcy5jb25maWcuZGlzcGxheV9zZCA9PT0gXCJiYXJcIil7XHJcblx0XHRcdGRpc3BsYXlfYm94PWZhbHNlO1xyXG5cdFx0XHRpZiAob3B0aW9ucy5icFBlclBpeGVsPDEwMCl7XHJcblx0XHRcdFx0ZGlzcGxheV9iYXI9dHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHRcdGxldCBjb3VudD0wO1xyXG5cdFx0bGV0IGRyYXduPTA7XHJcblxyXG5cdFx0XHJcblx0XHJcblx0XHRmb3IgKGxldCB4PTA7eDxmZWF0dXJlcy5sZW5ndGg7eCs9aW50ZXJ2YWwpe1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IGZlYXR1cmUgPWZlYXR1cmVzW3hdO1xyXG5cdFx0XHJcblx0XHRcdGxldCBsZW4gPSBmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0XHJcblx0XHRcdGxldCB4X3BvcyA9IChmZWF0dXJlLnN0YXJ0KyhsZW4vMiktb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdGlmICh4X3Bvcz5jb3VudCl7XHJcblx0XHRcdFx0Y291bnQ9TWF0aC5mbG9vcih4X3BvcykrMTtcclxuXHRcdFx0XHRkcmF3bisrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGVuID0gbGVuL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHRcdFx0aWYgKGxlbjwxKXtcclxuXHRcdFx0XHRsZW4gPSAxO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCB0X3k9W107XHJcblx0XHRcdGZvciAobGV0IGk9MDtpPHNfcztpKyspe1xyXG5cdFx0XHRcdGxldCB5X3Bvcz13aWdfaGVpZ2h0LSgoZmVhdHVyZS5kYXRhW2ldWzBdL3lfbWF4KSp3aWdfaGVpZ2h0KSt0b3A7XHJcblx0XHRcdFx0eV9wb3M9eV9wb3NcclxuXHRcdFx0XHRpZiAodGhpcy5jb25maWcuYXNsaW5lICYmIHByZXZfeCE9bnVsbCl7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGU9Y29sb3JzW2ldO1xyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1jb2xvcnNbaV07XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHByZXZfeCxwcmV2X3lbaV0pO1xyXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aD0xXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHhfcG9zLHlfcG9zKTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2V7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPWNvbG9yc1tpXTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZT1jb2xvcnNbaV07XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC40O1x0XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeF9wb3MtKGxlbi8yKSx5X3BvcyxsZW4sdGhpcy5ib3R0b20teV9wb3MpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBzZCA9IChmZWF0dXJlLmRhdGFbaV1bMV0veV9tYXgpKndpZ19oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGlmIChkaXNwbGF5X2JveCl7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MC40O1x0XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeF9wb3MtKGxlbi8yKSx5X3Bvcy1zZCxsZW4sMipzZCk7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGE9MS4wO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoZGlzcGxheV9iYXIpe1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcy00LHlfcG9zLXNkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MrNCx5X3Bvcy1zZCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHhfcG9zLHlfcG9zLXNkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MseV9wb3Mrc2QpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcy00LHlfcG9zK3NkKTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8oeF9wb3MrNCx5X3BvcytzZCk7XHJcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRfeS5wdXNoKHlfcG9zKVxyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfeT10X3k7XHJcblx0XHRcdHByZXZfeD14X3BvcztcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmV4Y2x1c2lvbl96b25lKXtcclxuXHRcdFx0bGV0IGJwU3RhcnQgPSBvcHRpb25zLmJwU3RhcnQ7XHJcblx0XHRcdGxldCBicEVuZD0gb3B0aW9ucy5icFN0YXJ0KyhvcHRpb25zLmJwUGVyUGl4ZWwqb3B0aW9ucy5waXhlbFdpZHRoKTtcclxuXHRcdFx0bGV0IGV4ID0gdGhpcy5jb25maWcuZXhjbHVzaW9uX3pvbmU7XHJcblx0XHRcclxuXHRcdFx0aWYgKChleFswXT5icFN0YXJ0ICYmIGV4WzBdPGJwRW5kKSB8fCAoZXhbMV0+YnBTdGFydCAmJiBleFsxXTxicEVuZCkpe1xyXG5cdFx0XHRcdGxldCBleF9zdD0oZXhbMF0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdGV4X3N0PWV4X3N0PDA/MDpleF9zdDtcclxuXHRcdFx0XHRsZXQgZXhfZW49IChleFsxXS1icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFx0ZXhfZW49IGV4X2VuPm9wdGlvbnMucGl4ZWxXaWR0aD9vcHRpb25zLnBpeGVsV2lkdGg6ZXhfZW47XHJcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1cIndoaXRlXCI7XHJcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlPVwiZ3JleVwiO1xyXG5cclxuXHRcdFx0XHRjdHgucmVjdChleF9zdCx0aGlzLnRvcCsxLGV4X2VuLWV4X3N0LHRoaXMuY29uZmlnLmhlaWdodC0xKTtcclxuXHRcdFx0XHRjdHguZmlsbCgpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRleD0gdGhpcy5jb25maWcudmlld3BvaW50O1xyXG5cdFx0XHRpZiAoZXgpe1xyXG5cdFx0XHRcdGlmICgoZXhbMF0+YnBTdGFydCAmJiBleFswXTxicEVuZCkgfHwgKGV4WzFdPmJwU3RhcnQgJiYgZXhbMV08YnBFbmQpKXtcclxuXHRcdFx0XHRcdGxldCBleF9zdD0oZXhbMF0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdFx0ZXhfc3Q9ZXhfc3Q8MD8wOmV4X3N0O1xyXG5cdFx0XHRcdFx0bGV0IGV4X2VuPSAoZXhbMV0tYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcdFx0ZXhfZW49IGV4X2VuPm9wdGlvbnMucGl4ZWxXaWR0aD9vcHRpb25zLnBpeGVsV2lkdGg6ZXhfZW47XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlPVwiZ3JleVwiO1xyXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGV4X3N0LHRoaXMudG9wKzEsZXhfZW4tZXhfc3QsdGhpcy5jb25maWcuaGVpZ2h0LTEpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0XHJcblx0XHRcdFx0XHJcblxyXG5cdFx0dGhpcy5tYXhfeT15X21heDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZGlzY3JldGU/Ym90Om51bGxcclxuXHRcdFx0XHRcclxuXHR9XHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGxldCBib3Q9IHRoaXMuYm90dG9tO1xyXG5cdFx0bGV0IHRvcCA9IHRoaXMudG9wO1xyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5yZWN0KDAsdG9wLDEyMCxib3QtdG9wKTtcclxuXHRcdGN0eC5jbGlwKCk7XHJcblx0XHRsZXQgbWF4X3k9IHRoaXMubWF4X3k7XHJcblx0XHRsZXQgbWluX3k9MDtcclxuXHRcdGxldCByYW5nZT1tYXhfeS1taW5feTtcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCx0b3ApO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLGJvdCk7XHJcblx0XHRjdHgubGluZVRvKDIwLGJvdCk7XHJcblx0XHRjdHguZm9udD1cIjEycHggQXJpYWxcIjtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdGN0eC5maWxsVGV4dChtYXhfeS50b0ZpeGVkKDIpLDIwLHRvcCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KG1pbl95LDIwLGJvdCk7XHJcblx0XHRjdHguZm9udD1cIjE0cHggQXJpYWxcIjtcclxuXHRcdGxldCB0ZXh0PSB0aGlzLmNvbmZpZy5sZWdlbmRfbGFiZWw/dGhpcy5jb25maWcubGVnZW5kX2xhYmVsOlwiQ29uZGl0aW9uXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LDEwLHRvcCszMCk7XHJcblx0XHRjdHguZm9udD1cIjEycHggQXJpYWxcIjtcclxuXHRcdGxldCBjb2xvcnMgPSB0aGlzLmNvbmZpZy5jb2xvcnM7XHJcblx0XHRmb3IgKGxldCBpPTA7aTx0aGlzLmNvbmZpZy5jb25kaXRpb25zLmxlbmd0aDtpKyspe1xyXG5cdFx0XHRjdHguZmlsbFN0eWxlPSBjb2xvcnNbaV07XHJcblx0XHRcdGN0eC5nbG9iYWxBbHBoYT0wLjQ7XHJcblx0XHRcdGN0eC5maWxsUmVjdCgxMCx0b3ArNDArKGkqMzApLDIwLDIwKTtcclxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KDEwLHRvcCs0OSsoaSozMCksMjAsMik7XHJcblx0XHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0XHRjdHguZmlsbFRleHQodGhpcy5jb25maWcuY29uZGl0aW9uc1tpXSwzMSx0b3ArNTUrKGkqMzApKTtcclxuXHRcdH1cclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0fVxyXG5cclxuXHRcclxufVxyXG5cclxuTUxWVHJhY2suY3VzdG9tX3RyYWNrc1tcImNhcHR1cmVfY29tcGFyZVwiXT1DYXB0dXJlQ29tcGFyZVRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1tcImNhcHR1cmVfY29tcGFyZVwiXT17XHJcblx0XCJjbGFzc1wiOkNhcHR1cmVDb21wYXJlVHJhY2tcclxufVxyXG5cclxuXHJcbmV4cG9ydCB7Q2FwdHVyZUNvbXBhcmVUcmFja307XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVRBO0FBQ0E7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE3V0E7QUFDQTtBQWlYQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/capture_compare_track.js\n");

/***/ }),

/***/ "./lanceotron/src/custom_annotation_track.js":
/*!***************************************************!*\
  !*** ./lanceotron/src/custom_annotation_track.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.CustomAnnotationTrack = exports.PeakModelTrack = exports.MLVSmoothWigTrack = undefined;\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CustomGeneFeatureSource = function (_FeatureSource) {\n\t_inherits(CustomGeneFeatureSource, _FeatureSource);\n\n\tfunction CustomGeneFeatureSource(config) {\n\t\t_classCallCheck(this, CustomGeneFeatureSource);\n\n\t\tconfig.sourceType = \"custom\";\n\t\tconfig.featureHeight = config.featureHeight ? config.featureHeight : 12;\n\n\t\tvar _this = _possibleConstructorReturn(this, (CustomGeneFeatureSource.__proto__ || Object.getPrototypeOf(CustomGeneFeatureSource)).call(this, config));\n\n\t\t_this.header = true;\n\t\treturn _this;\n\t}\n\n\t_createClass(CustomGeneFeatureSource, [{\n\t\tkey: \"retrieveFeatures\",\n\t\tvalue: function retrieveFeatures(chr, bpStart, bpEnd, force, data) {\n\t\t\tvar self = this;\n\t\t\treturn new Promise(function (fulfill, reject) {\n\t\t\t\tvar url = self.config.url + \"/\" + chr + \"/\" + bpStart + \"/\" + bpEnd;\n\t\t\t\t$.ajax({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdataType: \"json\"\n\t\t\t\t}).done(function (features) {\n\t\t\t\t\tfulfill(features);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn CustomGeneFeatureSource;\n}(_feature.FeatureSource);\n\nvar CustomAnnotationTrack = function (_MLVBedTrack) {\n\t_inherits(CustomAnnotationTrack, _MLVBedTrack);\n\n\tfunction CustomAnnotationTrack(config) {\n\t\t_classCallCheck(this, CustomAnnotationTrack);\n\n\t\tconfig.format = \"feature\";\n\t\treturn _possibleConstructorReturn(this, (CustomAnnotationTrack.__proto__ || Object.getPrototypeOf(CustomAnnotationTrack)).call(this, config));\n\t}\n\n\t_createClass(CustomAnnotationTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tthis.feature_source = new CustomGeneFeatureSource(this.config);\n\t\t}\n\t}]);\n\n\treturn CustomAnnotationTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks['custom_annotation'] = CustomAnnotationTrack;\n_tracks.MLVTrack.track_types['custom_annotation'] = {\n\t\"class\": CustomAnnotationTrack\n};\n\nvar decode_function = function decode_function(tokens, feature) {\n\tfeature.id = parseInt(tokens[0]);\n};\n\nvar PeakModelTrack = function (_MLVBedTrack2) {\n\t_inherits(PeakModelTrack, _MLVBedTrack2);\n\n\tfunction PeakModelTrack(config) {\n\t\t_classCallCheck(this, PeakModelTrack);\n\n\t\tconfig.format = \"feature\";\n\t\treturn _possibleConstructorReturn(this, (PeakModelTrack.__proto__ || Object.getPrototypeOf(PeakModelTrack)).call(this, config));\n\t}\n\n\t_createClass(PeakModelTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t}\n\t}]);\n\n\treturn PeakModelTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"peak_model_track\"] = PeakModelTrack;\n_tracks.MLVTrack.track_types[\"peak_model_track\"] = {\n\t\"class\": PeakModelTrack\n};\n\nvar MLVFeatureTrack = function (_MLVBedTrack3) {\n\t_inherits(MLVFeatureTrack, _MLVBedTrack3);\n\n\tfunction MLVFeatureTrack() {\n\t\t_classCallCheck(this, MLVFeatureTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVFeatureTrack.__proto__ || Object.getPrototypeOf(MLVFeatureTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVFeatureTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tvar url = this.config.url;\n\t\t\tif (url.endsWith(\".bb\") || url.endsWith(\".bigbed\")) {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, decode_function);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"setYField\",\n\t\tvalue: function setYField(view, y_field) {\n\t\t\tthis.data_view = view;\n\t\t\tthis.config.featureHeight = 5;\n\t\t\tthis.config.displayMode = \"EXPANDED\";\n\t\t\tthis.y_field = y_field;\n\t\t\tif (view) {\n\t\t\t\tthis.min_max = view.getMinMax(y_field.field);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn _get(MLVFeatureTrack.prototype.__proto__ || Object.getPrototypeOf(MLVFeatureTrack.prototype), \"getFeatureAt\", this).call(this, genomicLocation, chr, coord, bpPerPixel, ctx);\n\t\t\t}\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tvar height = this.config.height - 12;\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = bot - (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tif (coord.y >= y_val && coord.y <= y_val + 5) {\n\t\t\t\t\t\treturn feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar top = this.top;\n\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(20, top);\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillText(this.min_max[1].toFixed(2), 20, this.top);\n\n\t\t\tctx.moveTo(0, bot);\n\t\t\tctx.lineTo(20, bot);\n\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(this.min_max[0], 20, bot);\n\n\t\t\tctx.textBaseLine = \"middle\";\n\t\t\tctx.fillText(this.y_field.name, 3, top + this.config.height / 2);\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\n\t\t\tif (!this.y_field) {\n\t\t\t\t_get(MLVFeatureTrack.prototype.__proto__ || Object.getPrototypeOf(MLVFeatureTrack.prototype), \"drawFeatures\", this).call(this, options);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\n\t\t\tthis.bottom = this.top + this.config.height;\n\t\t\tvar bottom = this.bottom - 12;\n\t\t\tvar height = bottom - this.top;\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar feature = _step2.value;\n\n\t\t\t\t\tif (this.filter_function && !this.filter_function(feature)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar x_pos = (feature.start - options.bpStart) / options.bpPerPixel;\n\n\t\t\t\t\tvar len = (feature.end - feature.start) / options.bpPerPixel;\n\n\t\t\t\t\tif (len < 2) {\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t}\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tfeature.color = this.config.color;\n\t\t\t\t\tif (this.color_function) {\n\t\t\t\t\t\tfeature.color = this.color_function(feature);\n\t\t\t\t\t}\n\t\t\t\t\tvar y_pos = bottom - y_val;\n\t\t\t\t\tctx.fillStyle = feature.color;\n\t\t\t\t\tctx.fillRect(x_pos, y_pos, len, 4);\n\t\t\t\t\tthis.renderFeatureLabel(ctx, feature, x_pos, x_pos + len, y_pos, 0, options.pixelWidth);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn MLVFeatureTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_feature_track\"] = {\n\t\"class\": MLVFeatureTrack\n};\n\nvar MLVSmoothWigTrack = function (_MLVWigTrack) {\n\t_inherits(MLVSmoothWigTrack, _MLVWigTrack);\n\n\tfunction MLVSmoothWigTrack() {\n\t\t_classCallCheck(this, MLVSmoothWigTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVSmoothWigTrack.__proto__ || Object.getPrototypeOf(MLVSmoothWigTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVSmoothWigTrack, [{\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar self = this,\n\t\t\t    features = options.features,\n\t\t\t    color = self.config.color,\n\t\t\t    ctx = options.context,\n\t\t\t    bpPerPixel = options.bpPerPixel,\n\t\t\t    bpStart = options.bpStart,\n\t\t\t    pixelWidth = options.pixelWidth,\n\t\t\t    pixelHeight = options.pixelHeight,\n\t\t\t    y_offset = this.config.discrete ? options.top : 0,\n\t\t\t    bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\n\t\t\t    featureValueMinimum = void 0,\n\t\t\t    featureValueMaximum = void 0,\n\t\t\t    featureValueRange = void 0,\n\t\t\t    $dataRangeTrackLabel = void 0,\n\t\t\t    str = void 0,\n\t\t\t    min = void 0,\n\t\t\t    max = void 0;\n\t\t\tif (this.config.group) {\n\t\t\t\tpixelHeight = options.height;\n\t\t\t} else if (this.config.discrete) {\n\t\t\t\tpixelHeight = this.config.height;\n\t\t\t}\n\n\t\t\tif (!color) {\n\t\t\t\tcolor = \"black\";\n\t\t\t}\n\t\t\tself.prev_coords = { x: 0, y: 0 };\n\n\t\t\tif (features) {\n\t\t\t\tif (self.scale_link_to) {\n\t\t\t\t\tvar t = self.scale_link_to.config;\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tself.config.scale = t.scale;\n\t\t\t\t\t\tself.max_y = self.scale_link_to.max_y;\n\t\t\t\t\t\tself.min_y = self.scale_link_to.min_y;\n\t\t\t\t\t}\n\t\t\t\t} else if (self.set_scale) {\n\t\t\t\t\tself.min_y = self.set_scale.min;\n\t\t\t\t\tself.max_y = self.set_scale.max;\n\t\t\t\t} else if (self.max_y === undefined && self.config.scale === \"automatic\" || self.config.scale === \"dynamic\") {\n\t\t\t\t\tvar s = autoscale(features);\n\t\t\t\t\tself.min_y = s.min;\n\t\t\t\t\tself.max_y = s.max;\n\t\t\t\t} else if (self.config.scale === \"fixed\") {\n\t\t\t\t\tself.min_y = self.config.min_y;\n\t\t\t\t\tself.max_y = self.config.max_y;\n\t\t\t\t}\n\n\t\t\t\tfeatureValueRange = self.max_y - self.min_y;\n\n\t\t\t\t//$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\n\t\t\t\t//\n\t\t\t\t//min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\n\t\t\t\t//max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\n\t\t\t\t//str = '[' + min + ' - ' + max + ']';\n\t\t\t\t//\n\t\t\t\t//$dataRangeTrackLabel.text(str);\n\t\t\t\tvar prev_x = 0;\n\t\t\t\tvar prev_y = 0;\n\t\t\t\tctx.globalAlpha = this.config.opacity ? this.config.opacity : 1;\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tvar b = y_offset + pixelHeight;\n\t\t\t\t\tself.smooths = Array(pixelWidth).fill(b);\n\t\t\t\t}\n\t\t\t\tif (self.is_line) {\n\t\t\t\t\tvar y = (1.0 - self.config.value / featureValueRange) * pixelHeight;\n\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, 0, y, pixelWidth, y, { \"strokeStyle\": self.config.color, \"lineWidth\": self.config.width ? self.config.width : 1 });\n\t\t\t\t} else {\n\t\t\t\t\tfeatures.forEach(renderFeature);\n\t\t\t\t}\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tvar win_pixels = Math.round(self.config.smooth / bpPerPixel);\n\t\t\t\t\tvar h_win = win_pixels / 2;\n\t\t\t\t\tvar total = 0;\n\t\t\t\t\tfor (var n = 0; n < win_pixels; n++) {\n\t\t\t\t\t\ttotal = total + self.smooths[n];\n\t\t\t\t\t}\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(h_win, total / win_pixels);\n\t\t\t\t\tfor (var _n = h_win + 1; _n < pixelWidth - h_win; _n++) {\n\t\t\t\t\t\ttotal = total - self.smooths[_n - h_win - 1] + self.smooths[_n + h_win];\n\t\t\t\t\t\t//console.log(n+\":\"+self.smooths[n]);\n\t\t\t\t\t\tctx.lineTo(_n, total / win_pixels);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.strokeStyle = \"red\";\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\tif (self.config.thresholds) {\n\t\t\t\t\tvar _y = y_offset + (1.0 - self.config.thresholds[options.chr] / featureValueRange) * pixelHeight;\n\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, 0, _y, pixelWidth, _y, { \"strokeStyle\": \"black\", \"lineWidth\": 1 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction renderFeature(feature, index, featureList) {\n\n\t\t\t\tvar yUnitless, heightUnitLess, x, y, width, height, rectEnd, rectBaseline;\n\n\t\t\t\tif (feature.end < bpStart) return;\n\t\t\t\tif (feature.start > bpEnd) return;\n\n\t\t\t\tx = Math.floor((feature.start - bpStart) / bpPerPixel);\n\t\t\t\trectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\n\t\t\t\twidth = Math.max(0, rectEnd - x);\n\n\t\t\t\t//height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\n\t\t\t\t//rectBaseline = pixelHeight - height;\n\t\t\t\t//canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\n\n\t\t\t\tif (signsDiffer(self.min_y, self.max_y)) {\n\n\t\t\t\t\tif (feature.value < 0) {\n\t\t\t\t\t\tyUnitless = self.max_y / featureValueRange;\n\t\t\t\t\t\theightUnitLess = -feature.value / featureValueRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyUnitless = (self.max_y - feature.value) / featureValueRange;\n\t\t\t\t\t\theightUnitLess = feature.value / featureValueRange;\n\t\t\t\t\t}\n\t\t\t\t} else if (self.min_y < 0) {\n\t\t\t\t\tyUnitless = 0;\n\t\t\t\t\theightUnitLess = -feature.value / featureValueRange;\n\t\t\t\t} else {\n\t\t\t\t\tyUnitless = 1.0 - (feature.value - self.min_y) / featureValueRange;\n\t\t\t\t\theightUnitLess = (feature.value + self.min_y) / featureValueRange;\n\t\t\t\t}\n\n\t\t\t\ty = yUnitless * pixelHeight + y_offset;\n\t\t\t\ty = y < y_offset ? y_offset : y;\n\t\t\t\theight = heightUnitLess * pixelHeight;\n\t\t\t\theight = height > pixelHeight ? pixelHeight : height;\n\n\t\t\t\t//canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\n\t\t\t\tif (self.config.display === 'line') {\n\t\t\t\t\tif (self.prev_coords.x) {\n\t\t\t\t\t\t_tracks.Graphics.strokeLine(ctx, x, y, self.prev_coords.x, self.prev_coords.y, { \"strokeStyle\": color, \"lineWidth\": 3 });\n\t\t\t\t\t}\n\t\t\t\t\tself.prev_coords.x = x;\n\t\t\t\t\tself.prev_coords.y = y;\n\t\t\t\t} else {\n\t\t\t\t\t_tracks.Graphics.fillRect(ctx, x, y, width, height, { fillStyle: color });\n\t\t\t\t}\n\n\t\t\t\tif (self.config.smooth) {\n\t\t\t\t\tfor (var a = x; a < x + width; a++) {\n\t\t\t\t\t\tself.smooths[a] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction autoscale(features) {\n\t\t\t\tvar min = 0,\n\t\t\t\t    max = -Number.MAX_VALUE;\n\t\t\t\tfeatures.forEach(function (f) {\n\t\t\t\t\tmin = Math.min(min, f.value);\n\t\t\t\t\tmax = Math.max(max, f.value);\n\t\t\t\t});\n\t\t\t\treturn { min: min, max: max };\n\t\t\t}\n\n\t\t\tfunction signsDiffer(a, b) {\n\t\t\t\treturn a > 0 && b < 0 || a < 0 && b > 0;\n\t\t\t}\n\t\t\tthis.top = y_offset;\n\t\t\tthis.bottom = y_offset + pixelHeight;\n\t\t\tif (this.config.discrete) {\n\t\t\t\treturn this.bottom;\n\t\t\t} else {\n\t\t\t\tthis.top = 0;\n\t\t\t\tthis.bottom = 0;\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn MLVSmoothWigTrack;\n}(_tracks.MLVWigTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_smooth_wig_track\"] = {\n\t\"class\": MLVSmoothWigTrack\n};\n\nexports.MLVSmoothWigTrack = MLVSmoothWigTrack;\nexports.PeakModelTrack = PeakModelTrack;\nexports.CustomAnnotationTrack = CustomAnnotationTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9jdXN0b21fYW5ub3RhdGlvbl90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9jdXN0b21fYW5ub3RhdGlvbl90cmFjay5qcz84NTEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RmVhdHVyZVNvdXJjZSxCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2ssTUxWV2lnVHJhY2ssR3JhcGhpY3N9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQ3VzdG9tR2VuZUZlYXR1cmVTb3VyY2UgZXh0ZW5kcyBGZWF0dXJlU291cmNle1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRjb25maWcuc291cmNlVHlwZT1cImN1c3RvbVwiO1xyXG5cdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9Y29uZmlnLmZlYXR1cmVIZWlnaHQ/Y29uZmlnLmZlYXR1cmVIZWlnaHQ6MTI7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5oZWFkZXI9dHJ1ZTtcclxuXHR9XHJcblxyXG5cdHJldHJpZXZlRmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cdFx0XHRsZXQgdXJsID0gc2VsZi5jb25maWcudXJsK1wiL1wiK2NocitcIi9cIiticFN0YXJ0K1wiL1wiK2JwRW5kO1xyXG5cdFx0XHQgJC5hamF4KHtcclxuXHQgICAgICAgICAgICB1cmw6dXJsLFxyXG5cdCAgICAgICAgICAgIGRhdGFUeXBlOlwianNvblwiXHJcblx0ICAgICAgICB9KVxyXG5cdCAgICAgICAgLmRvbmUoZmVhdHVyZXM9PntcclxuXHQgICAgICAgIFx0ZnVsZmlsbChmZWF0dXJlcyk7XHJcblx0ICAgICAgICBcdH0pXHQgICAgICAgICAgIFxyXG5cdCAgICAgIH0pOyAgIFx0XHJcblx0fVxyXG5cdFxyXG59XHJcblxyXG5jbGFzcyBDdXN0b21Bbm5vdGF0aW9uVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIjtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0fVxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPSBuZXcgQ3VzdG9tR2VuZUZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpXHJcblx0fVxyXG5cdFx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3NbJ2N1c3RvbV9hbm5vdGF0aW9uJ109Q3VzdG9tQW5ub3RhdGlvblRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1snY3VzdG9tX2Fubm90YXRpb24nXT17XHJcblx0XCJjbGFzc1wiOkN1c3RvbUFubm90YXRpb25UcmFja1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5sZXQgZGVjb2RlX2Z1bmN0aW9uPSBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0ZmVhdHVyZS5pZD1wYXJzZUludCh0b2tlbnNbMF0pO1xyXG59O1xyXG5cclxuXHJcbmNsYXNzIFBlYWtNb2RlbFRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG4gICAgXHRjb25maWcuZm9ybWF0PVwiZmVhdHVyZVwiO1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcdFxyXG5cdH1cdFxyXG59XHJcblxyXG5NTFZUcmFjay5jdXN0b21fdHJhY2tzW1wicGVha19tb2RlbF90cmFja1wiXT1QZWFrTW9kZWxUcmFjaztcclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJwZWFrX21vZGVsX3RyYWNrXCJdPXtcclxuXHRcImNsYXNzXCI6UGVha01vZGVsVHJhY2tcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVkZlYXR1cmVUcmFjayBleHRlbmRzIE1MVkJlZFRyYWNre1xyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRsZXQgdXJsID0gdGhpcy5jb25maWcudXJsO1xyXG5cdFx0aWYgKHVybC5lbmRzV2l0aChcIi5iYlwiKSB8fCB1cmwuZW5kc1dpdGgoXCIuYmlnYmVkXCIpKXtcclxuXHRcdFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBCaWdCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGRlY29kZV9mdW5jdGlvbik7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBUYWJpeEJlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRzZXRZRmllbGQodmlldyx5X2ZpZWxkKXtcclxuXHRcdHRoaXMuZGF0YV92aWV3PXZpZXc7XHJcblx0XHR0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0PTU7XHJcblx0XHR0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZT1cIkVYUEFOREVEXCI7XHJcblx0XHR0aGlzLnlfZmllbGQ9eV9maWVsZDtcclxuXHRcdGlmICh2aWV3KXtcclxuXHRcdFx0dGhpcy5taW5fbWF4PXZpZXcuZ2V0TWluTWF4KHlfZmllbGQuZmllbGQpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCl7XHJcblx0XHRpZiAoIXRoaXMueV9maWVsZCl7XHJcblx0XHRcdHJldHVybiBzdXBlci5nZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCk7XHJcblx0XHR9XHJcblx0XHRcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMiAqIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgbGV0IGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmNvbmZpZy5oZWlnaHQtMTI7XHJcblx0XHRsZXQgcmFuZ2UgPSB0aGlzLm1pbl9tYXhbMV0tdGhpcy5taW5fbWF4WzBdO1xyXG5cdFx0bGV0IGZpZWxkID0gdGhpcy55X2ZpZWxkLmZpZWxkO1xyXG5cdFx0bGV0IGJvdCA9dGhpcy5ib3R0b20tMTI7XHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIGZlYXR1cmVMaXN0KXtcclxuXHRcdFx0bGV0IGl0ZW0gPSB0aGlzLmRhdGFfdmlldy5nZXRJdGVtQnlJZChmZWF0dXJlLmlkKTtcclxuXHRcdFx0aWYgKCFpdGVtKXtcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPWJvdC0oKChpdGVtW2ZpZWxkXS10aGlzLm1pbl9tYXhbMF0pL3JhbmdlKSpoZWlnaHQpO1xyXG5cdFx0XHRpZiAoY29vcmQueSA+PXlfdmFsICYmIGNvb3JkLnk8PXlfdmFsKzUpe1xyXG5cdFx0XHRcdHJldHVybiBmZWF0dXJlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGlmICghdGhpcy55X2ZpZWxkKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGJvdD0gdGhpcy5ib3R0b20tMTI7XHJcblx0XHRsZXQgdG9wID0gdGhpcy50b3A7XHJcblx0XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4LnJlY3QoMCx0b3AsMTIwLGJvdC10b3ApO1xyXG5cdFx0Y3R4LmNsaXAoKTtcclxuXHRcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Y3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdFxyXG5cdFx0XHRcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCx0b3ApO1xyXG5cdFx0Y3R4LnRleHRCYXNlbGluZT1cInRvcFwiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWluX21heFsxXS50b0ZpeGVkKDIpLDIwLHRoaXMudG9wKTtcclxuXHJcblx0XHRjdHgubW92ZVRvKDAsYm90KTtcclxuXHRcdGN0eC5saW5lVG8oMjAsYm90KTtcclxuXHJcblx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0aGlzLm1pbl9tYXhbMF0sMjAsYm90KTtcclxuXHJcblx0XHRjdHgudGV4dEJhc2VMaW5lPVwibWlkZGxlXCJcclxuXHRcdGN0eC5maWxsVGV4dCh0aGlzLnlfZmllbGQubmFtZSwzLHRvcCsodGhpcy5jb25maWcuaGVpZ2h0LzIpKTtcclxuXHRcdFxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHJcblx0fVxyXG5cclxuXHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpe1xyXG5cdFxyXG5cdFx0aWYgKCF0aGlzLnlfZmllbGQpe1xyXG5cdFx0XHRzdXBlci5kcmF3RmVhdHVyZXMob3B0aW9ucyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGxldCByYW5nZSA9IHRoaXMubWluX21heFsxXS10aGlzLm1pbl9tYXhbMF07XHJcblx0XHRsZXQgZmllbGQgPSB0aGlzLnlfZmllbGQuZmllbGQ7XHJcblx0XHRsZXQgY3R4PW9wdGlvbnMuY29udGV4dDtcclxuXHRcdHRoaXMudG9wPW9wdGlvbnMudG9wO1xyXG5cdFxyXG5cclxuXHRcdHRoaXMuYm90dG9tPXRoaXMudG9wK3RoaXMuY29uZmlnLmhlaWdodDtcclxuXHRcdGxldCBib3R0b20gPSB0aGlzLmJvdHRvbS0xMjtcclxuXHRcdGxldCBoZWlnaHQgPWJvdHRvbS10aGlzLnRvcDtcclxuXHRcdGZvciAobGV0IGZlYXR1cmUgb2Ygb3B0aW9ucy5mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZmVhdHVyZSkpe1xyXG4gICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9wb3MgPSAoZmVhdHVyZS5zdGFydC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHJcblx0XHRcdGxldCBsZW4gPSAoZmVhdHVyZS5lbmQtZmVhdHVyZS5zdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGxlbjwyKXtcclxuXHRcdFx0XHRsZW4gPSAyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBpdGVtID0gdGhpcy5kYXRhX3ZpZXcuZ2V0SXRlbUJ5SWQoZmVhdHVyZS5pZCk7XHJcblx0XHRcdGlmICghaXRlbSl7XHJcblx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0bGV0IHlfdmFsID0oKGl0ZW1bZmllbGRdLXRoaXMubWluX21heFswXSkvcmFuZ2UpKmhlaWdodDtcclxuXHRcdFx0ZmVhdHVyZS5jb2xvciA9IHRoaXMuY29uZmlnLmNvbG9yO1xyXG5cdFx0XHRpZiAodGhpcy5jb2xvcl9mdW5jdGlvbil7XHJcbiAgICBcdFx0XHRmZWF0dXJlLmNvbG9yPXRoaXMuY29sb3JfZnVuY3Rpb24oZmVhdHVyZSk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGxldCB5X3Bvcz1ib3R0b20teV92YWw7XHJcblx0XHRcdGN0eC5maWxsU3R5bGU9ZmVhdHVyZS5jb2xvcjtcclxuXHRcdFx0Y3R4LmZpbGxSZWN0KHhfcG9zLHlfcG9zLGxlbiw0KVxyXG5cdFx0XHR0aGlzLnJlbmRlckZlYXR1cmVMYWJlbChjdHgsIGZlYXR1cmUsIHhfcG9zLCB4X3BvcytsZW4seV9wb3MgLCAwLCBvcHRpb25zLnBpeGVsV2lkdGgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcblx0fVx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLnRyYWNrX3R5cGVzW1wibWx2X2ZlYXR1cmVfdHJhY2tcIl09e1xyXG5cdFwiY2xhc3NcIjpNTFZGZWF0dXJlVHJhY2tcclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVlNtb290aFdpZ1RyYWNrIGV4dGVuZHMgIE1MVldpZ1RyYWNre1xyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXMsXHJcblx0ICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuXHQgICAgY29sb3I9c2VsZi5jb25maWcuY29sb3IsXHJcblx0ICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuXHQgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuXHQgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuXHQgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuXHQgICAgcGl4ZWxIZWlnaHQgPW9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcblx0ICAgIHlfb2Zmc2V0PXRoaXMuY29uZmlnLmRpc2NyZXRlP29wdGlvbnMudG9wOjAsXHJcblx0ICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWluaW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWF4aW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlUmFuZ2UsXHJcblx0ICAgICRkYXRhUmFuZ2VUcmFja0xhYmVsLFxyXG5cdCAgICBzdHIsXHJcblx0ICAgIG1pbixcclxuXHQgICAgbWF4O1xyXG5cdCAgICBpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZih0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0ICAgIFx0XHRwaXhlbEhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ7XHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYoc2VsZi5zZXRfc2NhbGUpe1xyXG5cdCAgICAgICBcdFx0c2VsZi5taW5feT1zZWxmLnNldF9zY2FsZS5taW47XHJcblx0ICAgICAgIFx0XHRzZWxmLm1heF95PXNlbGYuc2V0X3NjYWxlLm1heDtcclxuXHQgICAgICAgfVxyXG5cdCAgICAgICBlbHNlIGlmICggKHNlbGYubWF4X3kgPT09IHVuZGVmaW5lZCAmJiBzZWxmLmNvbmZpZy5zY2FsZT09PVwiYXV0b21hdGljXCIpIHx8IHNlbGYuY29uZmlnLnNjYWxlPT09XCJkeW5hbWljXCIpe1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcyA9IGF1dG9zY2FsZShmZWF0dXJlcyk7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzLm1pbjtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeSA9IHMubWF4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5zY2FsZT09PVwiZml4ZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1pbl95ID0gc2VsZi5jb25maWcubWluX3k7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWF4X3k9c2VsZi5jb25maWcubWF4X3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgICAgICAgICBmZWF0dXJlVmFsdWVSYW5nZSA9IHNlbGYubWF4X3kgLSBzZWxmLm1pbl95O1xyXG5cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsID0gJCh0aGlzLnRyYWNrVmlldy50cmFja0RpdikuZmluZCgnLmlndi1kYXRhLXJhbmdlLXRyYWNrLWxhYmVsJyk7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvL21pbiA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5taW4pID09PSB0cmFjay5kYXRhUmFuZ2UubWluKSA/IHRyYWNrLmRhdGFSYW5nZS5taW4gOiB0cmFjay5kYXRhUmFuZ2UubWluLnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9tYXggPSAoTWF0aC5mbG9vcih0cmFjay5kYXRhUmFuZ2UubWF4KSA9PT0gdHJhY2suZGF0YVJhbmdlLm1heCkgPyB0cmFjay5kYXRhUmFuZ2UubWF4IDogdHJhY2suZGF0YVJhbmdlLm1heC50b0ZpeGVkKDIpO1xyXG5cdCAgICAgICAgICAgIC8vc3RyID0gJ1snICsgbWluICsgJyAtICcgKyBtYXggKyAnXSc7XHJcblx0ICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAvLyRkYXRhUmFuZ2VUcmFja0xhYmVsLnRleHQoc3RyKTtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl94PTA7XHJcblx0ICAgICAgICAgICAgbGV0IHByZXZfeT0wO1xyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAgID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNtb290aCl7XHJcblx0ICAgICAgICAgICAgXHRsZXQgYj0geV9vZmZzZXQrcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLnNtb290aHM9QXJyYXkocGl4ZWxXaWR0aCkuZmlsbChiKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuaXNfbGluZSl7ICBcclxuXHQgICAgICAgICAgICAgICAgbGV0IHkgPSAoMS4wIC0gc2VsZi5jb25maWcudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZSkqcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LDAseSxwaXhlbFdpZHRoLHkse1wic3Ryb2tlU3R5bGVcIjpzZWxmLmNvbmZpZy5jb2xvcixcImxpbmVXaWR0aFwiOnNlbGYuY29uZmlnLndpZHRoP3NlbGYuY29uZmlnLndpZHRoOjF9KTtcclxuXHQgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHRmZWF0dXJlcy5mb3JFYWNoKHJlbmRlckZlYXR1cmUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc21vb3RoKXtcclxuXHQgICAgICAgICAgICBcdGxldCB3aW5fcGl4ZWxzPSBNYXRoLnJvdW5kKHNlbGYuY29uZmlnLnNtb290aC9icFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICBcdGxldCBoX3dpbiA9IHdpbl9waXhlbHMvMjtcclxuXHQgICAgICAgICAgICBcdGxldCB0b3RhbD0wO1xyXG5cdCAgICAgICAgICAgIFx0Zm9yIChsZXQgbj0wO248d2luX3BpeGVscztuKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbD10b3RhbCtzZWxmLnNtb290aHNbbl07XHJcblx0ICAgICAgICAgICAgXHR9XHJcblx0ICAgICAgICAgICAgXHRjdHguYmVnaW5QYXRoKCk7XHJcblx0ICAgICAgICAgICAgXHRjdHgubW92ZVRvKGhfd2luLHRvdGFsL3dpbl9waXhlbHMpXHJcblx0ICAgICAgICAgICAgXHRmb3IgKGxldCBuPWhfd2luKzE7bjxwaXhlbFdpZHRoLWhfd2luO24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsPXRvdGFsLXNlbGYuc21vb3Roc1tuLWhfd2luLTFdK3NlbGYuc21vb3Roc1tuK2hfd2luXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuK1wiOlwiK3NlbGYuc21vb3Roc1tuXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8obix0b3RhbC93aW5fcGl4ZWxzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBcdH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgIFx0Y3R4LnN0cm9rZVN0eWxlPVwicmVkXCI7XHJcblx0ICAgICAgICAgICAgXHRjdHguc3Ryb2tlKClcclxuXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xXHJcblx0ICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy50aHJlc2hvbGRzKXtcclxuXHQgICAgICAgICAgICAgXHQgICAgbGV0IHkgPSB5X29mZnNldCsoMS4wIC0gc2VsZi5jb25maWcudGhyZXNob2xkc1tvcHRpb25zLmNocl0vIGZlYXR1cmVWYWx1ZVJhbmdlKSpwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICAgXHQgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsMCx5LHBpeGVsV2lkdGgseSx7XCJzdHJva2VTdHlsZVwiOlwiYmxhY2tcIixcImxpbmVXaWR0aFwiOjF9KTtcclxuXHQgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgICBcclxuXHQgICAgICAgIGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgaW5kZXgsIGZlYXR1cmVMaXN0KSB7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciB5VW5pdGxlc3MsXHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzLFxyXG5cdCAgICAgICAgICAgICAgICB4LFxyXG5cdCAgICAgICAgICAgICAgICB5LFxyXG5cdCAgICAgICAgICAgICAgICB3aWR0aCxcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG5cdCAgICAgICAgICAgICAgICByZWN0RW5kLFxyXG5cdCAgICAgICAgICAgICAgICByZWN0QmFzZWxpbmU7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZCA8IGJwU3RhcnQpIHJldHVybjtcclxuXHQgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdGFydCA+IGJwRW5kKSByZXR1cm47XHJcblxyXG5cdCAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICByZWN0RW5kID0gTWF0aC5mbG9vcigoZmVhdHVyZS5lbmQgLSBicFN0YXJ0KSAvIGJwUGVyUGl4ZWwpO1xyXG5cdCAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgcmVjdEVuZCAtIHgpO1xyXG5cclxuXHQgICAgICAgICAgICAvL2hlaWdodCA9ICgoZmVhdHVyZS52YWx1ZSAtIGZlYXR1cmVWYWx1ZU1pbmltdW0pIC8gZmVhdHVyZVZhbHVlUmFuZ2UpICogcGl4ZWxIZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9yZWN0QmFzZWxpbmUgPSBwaXhlbEhlaWdodCAtIGhlaWdodDtcclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdChyZWN0T3JpZ2luLCByZWN0QmFzZWxpbmUsIHJlY3RXaWR0aCwgcmVjdEhlaWdodCwge2ZpbGxTdHlsZTogdHJhY2suY29sb3J9KTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHNpZ25zRGlmZmVyKHNlbGYubWluX3ksIHNlbGYubWF4X3kpKSB7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS52YWx1ZSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IHNlbGYubWF4X3kvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gKChzZWxmLm1heF95IC0gZmVhdHVyZS52YWx1ZSkgLyBmZWF0dXJlVmFsdWVSYW5nZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IGZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5taW5feSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMDtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAtZmVhdHVyZS52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgeVVuaXRsZXNzID0gMS4wIC0gKChmZWF0dXJlLnZhbHVlLXNlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyA9IChmZWF0dXJlLnZhbHVlK3NlbGYubWluX3kpIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgIFx0eSA9ICh5VW5pdGxlc3MqcGl4ZWxIZWlnaHQpK3lfb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIHk9eTx5X29mZnNldD95X29mZnNldDp5O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHRVbml0TGVzcyAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIGhlaWdodD1oZWlnaHQ+cGl4ZWxIZWlnaHQ/cGl4ZWxIZWlnaHQ6aGVpZ2h0XHJcblxyXG5cdCAgICAgICAgICAgIC8vY2FudmFzLmZpbGxSZWN0KHgsIHlVbml0bGVzcyAqIHBpeGVsSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodCwgeyBmaWxsU3R5bGU6IGlndi5yYW5kb21SR0IoNjQsIDI1NSkgfSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRpc3BsYXk9PT0nbGluZScpe1xyXG5cdCAgICAgICAgICAgICAgICAgaWYgKHNlbGYucHJldl9jb29yZHMueCl7XHJcblx0ICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCx4LHksc2VsZi5wcmV2X2Nvb3Jkcy54LHNlbGYucHJldl9jb29yZHMueSx7XCJzdHJva2VTdHlsZVwiOmNvbG9yLFwibGluZVdpZHRoXCI6M30pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzZWxmLnByZXZfY29vcmRzLng9eDtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy55PXk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2V7XHJcblx0ICAgICAgICAgICAgXHQgR3JhcGhpY3MuZmlsbFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB7ZmlsbFN0eWxlOiBjb2xvcn0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIFx0XHJcblxyXG5cdCAgICAgICAgICAgIFx0XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNtb290aCl7XHJcblx0ICAgICAgICAgICBcdCAgICBmb3IgKGxldCBhPXg7YTx4K3dpZHRoO2ErKyl7XHJcblx0ICAgICAgICAgICBcdCAgICBcdHNlbGYuc21vb3Roc1thXT15O1xyXG5cdCAgICAgICAgICAgXHQgICAgfVxyXG5cdCAgICAgICAgICAgXHJcblx0ICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmdW5jdGlvbiBhdXRvc2NhbGUoZmVhdHVyZXMpIHtcclxuICAgICAgICBcdFx0dmFyIG1pbiA9IDAsXHJcbiAgICAgICAgICAgIFx0bWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgXHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgZi52YWx1ZSk7XHJcbiAgICAgICAgICAgXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBmLnZhbHVlKTtcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHRcdHJldHVybiB7bWluOiBtaW4sIG1heDogbWF4fTtcclxuICAgIFx0XHR9XHJcblxyXG4gICAgXHRcdGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIChhID4gMCAmJiBiIDwgMCB8fCBhIDwgMCAmJiBiID4gMCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgXHRcdHRoaXMuYm90dG9tPXlfb2Zmc2V0K3BpeGVsSGVpZ2h0O1xyXG4gICAgXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGVsc2V7XHJcbiAgICBcdFx0XHR0aGlzLnRvcD0wO1xyXG4gICAgXHRcdFx0dGhpcy5ib3R0b209MDtcclxuICAgXHRcdFx0fVx0ICAgIFxyXG5cdH1cclxufVxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJtbHZfc21vb3RoX3dpZ190cmFja1wiXT17XHJcblx0XCJjbGFzc1wiOk1MVlNtb290aFdpZ1RyYWNrXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtNTFZTbW9vdGhXaWdUcmFja31cclxuZXhwb3J0IHtQZWFrTW9kZWxUcmFja307IFxyXG5leHBvcnQge0N1c3RvbUFubm90YXRpb25UcmFja307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBUUE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFHQTtBQUpBO0FBS0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBcEJBO0FBQ0E7QUF1QkE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFQQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUlBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQXZCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1QkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFkQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBZUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEwQ0E7QUFDQTs7OztBQXZJQTtBQUNBO0FBeUlBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBeE1BO0FBQ0E7QUEwTUE7QUFDQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/custom_annotation_track.js\n");

/***/ }),

/***/ "./lanceotron/src/deseq_track.js":
/*!***************************************!*\
  !*** ./lanceotron/src/deseq_track.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.DESeqTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DESeqTrack = function (_MLVBigBedTrack) {\n\t_inherits(DESeqTrack, _MLVBigBedTrack);\n\n\tfunction DESeqTrack(config) {\n\t\t_classCallCheck(this, DESeqTrack);\n\n\t\tif (!config.featureHeight) {\n\t\t\tconfig.featureHeight = 12;\n\t\t}\n\t\tconfig.height = 5 + config.deseq_labels.length * (config.featureHeight + 1);\n\t\treturn _possibleConstructorReturn(this, (DESeqTrack.__proto__ || Object.getPrototypeOf(DESeqTrack)).call(this, config));\n\t}\n\n\t_createClass(DESeqTrack, [{\n\t\tkey: \"renderFeature\",\n\t\tvalue: function renderFeature(feature, coord, tc, info) {\n\t\t\tcoord.py = coord.py + (feature.score - 1) * (this.config.featureHeight + 1);\n\t\t\t_get(DESeqTrack.prototype.__proto__ || Object.getPrototypeOf(DESeqTrack.prototype), \"renderFeature\", this).call(this, feature, coord, tc, info);\n\t\t}\n\t}, {\n\t\tkey: \"renderFeatureLabel\",\n\t\tvalue: function renderFeatureLabel() {}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\n\t\t\tvar yOffset = coord.y - this.top - 5;\n\t\t\tif (this.feature_source.featureCache) {\n\t\t\t\tvar tolerance = 2 * bpPerPixel,\n\t\t\t\t    featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\t\tvar row = Math.floor(yOffset / this.config.featureHeight);\n\t\t\t\tif (featureList && featureList.length > 0) {\n\t\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\t\tvar _didIteratorError = false;\n\t\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\t\t\tif (feature.end >= genomicLocation - tolerance && !feature.start <= genomicLocation + tolerance) {\n\t\t\t\t\t\t\t\tif (row == feature.score - 1 && feature.display) {\n\t\t\t\t\t\t\t\t\treturn feature;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t_iteratorError = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixelHeight, ctx) {\n\t\t\tvar y = this.top + 5;\n\t\t\tctx.font = \"12px Arial\";\n\n\t\t\tctx.textBaseline = \"top\";\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = this.config.deseq_labels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar text = _step2.value;\n\n\n\t\t\t\t\tctx.fillText(text, 3, y);\n\t\t\t\t\ty += this.config.featureHeight + 1;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn DESeqTrack;\n}(_tracks.MLVBigBedTrack);\n\n_tracks.MLVTrack.custom_tracks[\"deseq_track\"] = DESeqTrack;\n_tracks.MLVTrack.track_types[\"deseq_track\"] = {\n\t\"class\": DESeqTrack\n};\n\nexports.DESeqTrack = DESeqTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9kZXNlcV90cmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9kZXNlcV90cmFjay5qcz81NGY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWQmlnQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5jbGFzcyBERVNlcVRyYWNrIGV4dGVuZHMgTUxWQmlnQmVkVHJhY2t7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRpZiAoIWNvbmZpZy5mZWF0dXJlSGVpZ2h0KXtcclxuXHRcdFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9MTI7XHJcblx0XHR9XHJcblx0XHRjb25maWcuaGVpZ2h0PTUrKGNvbmZpZy5kZXNlcV9sYWJlbHMubGVuZ3RoKihjb25maWcuZmVhdHVyZUhlaWdodCsxKSk7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdH1cclxuXHJcblxyXG5cdHJlbmRlckZlYXR1cmUoZmVhdHVyZSxjb29yZCx0YyxpbmZvKXtcclxuXHRcdGNvb3JkLnB5ID0gY29vcmQucHkrKChmZWF0dXJlLnNjb3JlLTEpKih0aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KzEpKTtcclxuXHRcdHN1cGVyLnJlbmRlckZlYXR1cmUoZmVhdHVyZSxjb29yZCx0YyxpbmZvKTtcclxuXHR9XHJcblx0cmVuZGVyRmVhdHVyZUxhYmVsKCl7XHJcblx0XHRcclxuXHR9XHJcblxyXG5cdGdldEZlYXR1cmVBdChnZW5vbWljTG9jYXRpb24sIGNociwgY29vcmQsIGJwUGVyUGl4ZWwpIHtcclxuXHRcdGxldCB5T2Zmc2V0PWNvb3JkLnktdGhpcy50b3AtNTtcclxuXHRcdGlmICh0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZSkge1xyXG4gICAgICAgXHRcdHZhciB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbCwgIFxyXG4gICAgICAgIFx0ZmVhdHVyZUxpc3QgPSB0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZS5xdWVyeUZlYXR1cmVzKGNociwgZ2Vub21pY0xvY2F0aW9uIC0gdG9sZXJhbmNlLCBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpO1xyXG4gICAgICAgIFx0bGV0IHJvdyA9IE1hdGguZmxvb3IoeU9mZnNldC90aGlzLmNvbmZpZy5mZWF0dXJlSGVpZ2h0KTtcclxuICAgIFx0XHRpZiAoZmVhdHVyZUxpc3QgJiYgZmVhdHVyZUxpc3QubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGZvciAobGV0IGZlYXR1cmUgb2YgZmVhdHVyZUxpc3Qpe1xyXG4gICAgICAgICAgICBcdFx0aWYgKGZlYXR1cmUuZW5kID49IGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSAmJiAhXHJcbiAgICAgICAgICAgICAgICBcdFx0ZmVhdHVyZS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgICAgIFx0XHRcdGlmIChyb3c9PWZlYXR1cmUuc2NvcmUtMSAmJiBmZWF0dXJlLmRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRyZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgIFx0XHRcdH1cclxuICAgICAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0fVxyXG5cclxuICAgIFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxIZWlnaHQsY3R4KXtcclxuXHRcdGxldCB5ID0gdGhpcy50b3ArNTtcclxuXHRcdGN0eC5mb250PVwiMTJweCBBcmlhbFwiO1xyXG5cdFx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdGN0eC5maWxsU3R5bGU9XCJibGFja1wiO1xyXG5cdFx0Zm9yIChsZXQgdGV4dCBvZiB0aGlzLmNvbmZpZy5kZXNlcV9sYWJlbHMpe1xyXG5cdFx0XHRcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsMyx5KTtcclxuXHRcdFx0eSs9dGhpcy5jb25maWcuZmVhdHVyZUhlaWdodCsxO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG59XHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3NbXCJkZXNlcV90cmFja1wiXT1ERVNlcVRyYWNrO1xyXG5NTFZUcmFjay50cmFja190eXBlc1tcImRlc2VxX3RyYWNrXCJdPXtcclxuXHRcImNsYXNzXCI6REVTZXFUcmFja1xyXG59XHJcblxyXG5leHBvcnQge0RFU2VxVHJhY2t9OyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVlBOzs7O0FBckRBO0FBQ0E7QUFzREE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lanceotron/src/deseq_track.js\n");

/***/ }),

/***/ "./lanceotron/src/lanceotron_tracks_index.js":
/*!***************************************************!*\
  !*** ./lanceotron/src/lanceotron_tracks_index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _panel = __webpack_require__(/*! ../../../MLVPanel/src/panel.js */ \"../MLVPanel/src/panel.js\");\n\nvar _simple_browser = __webpack_require__(/*! ../../../MLVPanel/src/extra/simple_browser.js */ \"../MLVPanel/src/extra/simple_browser.js\");\n\n__webpack_require__(/*! ./custom_annotation_track.js */ \"./lanceotron/src/custom_annotation_track.js\");\n\n__webpack_require__(/*! ./capture_compare_track.js */ \"./lanceotron/src/capture_compare_track.js\");\n\n__webpack_require__(/*! ./mlv_deseq_track.js */ \"./lanceotron/src/mlv_deseq_track.js\");\n\n__webpack_require__(/*! ./deseq_track.js */ \"./lanceotron/src/deseq_track.js\");\n\n__webpack_require__(/*! ./mlv_peaky_track.js */ \"./lanceotron/src/mlv_peaky_track.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/extra/ucsc_track.js */ \"../MLVPanel/src/extra/ucsc_track.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/extra/tiled_image_track.js */ \"../MLVPanel/src/extra/tiled_image_track.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/css/mlv_panel.css */ \"../MLVPanel/css/mlv_panel.css\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/bam_track.js */ \"../MLVPanel/src/bam_track.js\");\n\n__webpack_require__(/*! ../../../MLVPanel/src/extra/sca_bam_track.js */ \"../MLVPanel/src/extra/sca_bam_track.js\");\n\nwindow.MLVPanel = _panel.MLVPanel;\nwindow.SimpleBrowser = _simple_browser.SimpleBrowser;\nwindow.SinglePanelBrowser = _simple_browser.SinglePanelBrowser;\nwindow.MLVTrack = _tracks.MLVTrack;\nwindow.MLVBedTrack = _tracks.MLVBedTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9sYW5jZW90cm9uX3RyYWNrc19pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9sYW5jZW90cm9uL3NyYy9sYW5jZW90cm9uX3RyYWNrc19pbmRleC5qcz8xMjFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TUxWUGFuZWx9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvcGFuZWwuanNcIjtcclxuaW1wb3J0IHtTaW1wbGVCcm93c2VyLFNpbmdsZVBhbmVsQnJvd3Nlcn0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9leHRyYS9zaW1wbGVfYnJvd3Nlci5qc1wiO1xyXG5pbXBvcnQgXCIuL2N1c3RvbV9hbm5vdGF0aW9uX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vY2FwdHVyZV9jb21wYXJlX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vbWx2X2Rlc2VxX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4vZGVzZXFfdHJhY2suanNcIjtcclxuaW1wb3J0IFwiLi9tbHZfcGVha3lfdHJhY2suanNcIjtcclxuaW1wb3J0IHtNTFZUcmFjayxNTFZCZWRUcmFja30gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy90cmFja3MuanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3Vjc2NfdHJhY2suanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3RpbGVkX2ltYWdlX3RyYWNrLmpzXCI7XHJcbmltcG9ydCBcIi4uLy4uLy4uL01MVlBhbmVsL2Nzcy9tbHZfcGFuZWwuY3NzXCI7XHJcbmltcG9ydCBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9iYW1fdHJhY2suanNcIjtcclxuaW1wb3J0IFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2V4dHJhL3NjYV9iYW1fdHJhY2suanNcIjtcclxuXHJcbndpbmRvdy5NTFZQYW5lbD1NTFZQYW5lbDtcclxud2luZG93LlNpbXBsZUJyb3dzZXI9U2ltcGxlQnJvd3Nlcjtcclxud2luZG93LlNpbmdsZVBhbmVsQnJvd3NlciA9IFNpbmdsZVBhbmVsQnJvd3Nlcjtcclxud2luZG93Lk1MVlRyYWNrPU1MVlRyYWNrO1xyXG53aW5kb3cuTUxWQmVkVHJhY2sgPSBNTFZCZWRUcmFjazsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/lanceotron_tracks_index.js\n");

/***/ }),

/***/ "./lanceotron/src/mlv_deseq_track.js":
/*!*******************************************!*\
  !*** ./lanceotron/src/mlv_deseq_track.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.MLVDESeqTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _feature2 = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction getDecodeFunction(sample_size) {\n\tvar max = sample_size * 3;\n\treturn function (tokens, feature) {\n\t\tfeature.data = [];\n\t\tfor (var i = 0; i < max; i += 3) {\n\t\t\tfeature.data.push([parseFloat(tokens[i]), parseFloat(tokens[i + 1]), parseFloat(tokens[i + 2])]);\n\t\t}\n\t};\n}\n\nvar MLVDESeqTrack = function (_MLVBedTrack) {\n\t_inherits(MLVDESeqTrack, _MLVBedTrack);\n\n\tfunction MLVDESeqTrack(config) {\n\t\t_classCallCheck(this, MLVDESeqTrack);\n\n\t\tconfig.format = \"feature\";\n\t\tif (!config.colors) {\n\t\t\tconfig.colors = [\"#FF0000\", \"#0000FF\", \"#008000\"];\n\t\t}\n\t\tif (!config.pvalue_cutoff) {\n\t\t\tconfig.pvalue_cutoff = 0.05;\n\t\t}\n\t\treturn _possibleConstructorReturn(this, (MLVDESeqTrack.__proto__ || Object.getPrototypeOf(MLVDESeqTrack)).call(this, config));\n\t}\n\n\t_createClass(MLVDESeqTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tif (this.config.url && this.config.url.endsWith(\".gz\")) {\n\t\t\t\tthis.feature_source = new _feature2.TabixBedFeatureSource(this.config, getDecodeFunction(this.config.samples.length));\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature2.BigBedFeatureSource(this.config, getDecodeFunction(this.config.samples.length));\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tvar pval_div = $(\"<div class='t-d-div'></div>\").append(\"<label>pValue:</label>\").appendTo(dialog.div);\n\t\t\tdialog.pval_slider = $(\"<div>\").slider({\n\t\t\t\tmax: 1,\n\t\t\t\tmin: 0,\n\t\t\t\tstep: 0.01,\n\t\t\t\tvalue: dialog.config.pvalue_cutoff,\n\t\t\t\tslide: function slide(e, ui) {\n\t\t\t\t\tdialog.config.pvalue_cutoff = ui.value;\n\t\t\t\t\tif (dialog.panel) {\n\t\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"pvalue_cutoff\", ui.value);\n\t\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\t}\n\t\t\t\t\tdialog.pval_input.val(ui.value);\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" }).appendTo(pval_div);\n\t\t\tdialog.pval_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar y = dialog.pval_input.val();\n\t\t\t\ty = parseFloat(y);\n\t\t\t\tif (isNaN(y) || y < 0 || y > 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar s = dialog.pval_slider;\n\n\t\t\t\ts.slider(\"option\", \"value\", y);\n\t\t\t\tif (dialog.panel) {\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"pvalue_cutoff\", y);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).width(50).val(dialog.config.pvalue_cutoff).appendTo(pval_div);\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\t\t\tvar features = options.features;\n\t\t\tvar pval = this.config.pvalue_cutoff;\n\n\t\t\tvar top = options.top;\n\t\t\tvar bot = parseInt(top) + parseInt(this.config.height);\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bot;\n\t\t\tvar ctx = options.context;\n\t\t\tvar colors = this.config.colors;\n\t\t\tvar y_max = this.config.y_max ? this.config.y_max : this.config.initial_y_max;\n\t\t\tvar wig_height = this.config.height;\n\t\t\tvar s_s = this.config.samples.length;\n\t\t\tvar count = 0;\n\t\t\tvar drawn = 0;\n\n\t\t\tvar display_features = [];\n\t\t\tthis.max_y_vals = [];\n\t\t\tthis.min_y_vals = [];\n\t\t\tfor (var n = 0; n < s_s; n++) {\n\t\t\t\tthis.max_y_vals.push(0);\n\t\t\t\tthis.min_y_vals.push(0);\n\t\t\t}\n\t\t\t//first parse collecting info\n\t\t\tfor (var x = 0; x < features.length; x++) {\n\t\t\t\tvar feature = features[x];\n\n\t\t\t\tvar len = feature.end - feature.start;\n\t\t\t\tvar x_pos = (feature.start + len / 2 - options.bpStart) / options.bpPerPixel;\n\t\t\t\tif (x_pos > count) {\n\t\t\t\t\tcount = Math.floor(x_pos) + 1;\n\t\t\t\t\tdrawn++;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlen = len / options.bpPerPixel;\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tlen = 1;\n\t\t\t\t}\n\t\t\t\tvar t_y = [];\n\t\t\t\tvar filtered_vals = 0;\n\t\t\t\tvar disp_feature = { x_pos: x_pos, len: len, y_vals: [], pvals: [] };\n\t\t\t\tfor (var i = 0; i < s_s; i++) {\n\t\t\t\t\tif (this.filter_function) {\n\t\t\t\t\t\tfeature.id = feature.data[i][0];\n\t\t\t\t\t\tif (!this.filter_function(feature)) {\n\t\t\t\t\t\t\tfiltered_vals++;\n\t\t\t\t\t\t\tdisp_feature.y_vals.push(false);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar y_val = feature.data[i][1];\n\n\t\t\t\t\tif (y_val > this.max_y_vals[i]) {\n\t\t\t\t\t\tthis.max_y_vals[i] = y_val;\n\t\t\t\t\t} else if (y_val < this.min_y_vals[i]) {\n\t\t\t\t\t\tthis.min_y_vals[i] = y_val;\n\t\t\t\t\t}\n\t\t\t\t\tdisp_feature.y_vals.push(y_val);\n\t\t\t\t\tdisp_feature.pvals.push(feature.data[i][2]);\n\t\t\t\t}\n\t\t\t\tif (filtered_vals !== s_s) {\n\t\t\t\t\tdisplay_features.push(disp_feature);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.centers = [];\n\t\t\tvar y_tops = [];\n\t\t\tvar scale_factors = [];\n\t\t\tvar each = wig_height / s_s;\n\t\t\tfor (var _i = 0; _i < s_s; _i++) {\n\t\t\t\tvar center = this.max_y_vals[_i] / (this.max_y_vals[_i] - this.min_y_vals[_i]) * each + _i * each;\n\t\t\t\tthis.centers.push(center + top);\n\t\t\t\ty_tops.push(top + each * _i);\n\t\t\t\tscale_factors.push(each / (this.max_y_vals[_i] - this.min_y_vals[_i]));\n\t\t\t}\n\t\t\t//ctx.fillStyle=colors[i];\n\t\t\t//ctx.strokeStyle=colors[i];\n\t\t\t//ctx.globalAlpha=0.4;\n\t\t\tctx.globalAlpha = 1.0;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = display_features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar _feature = _step.value;\n\n\n\t\t\t\t\tfor (var _i2 = 0; _i2 < s_s; _i2++) {\n\t\t\t\t\t\tvar _y_val = _feature.y_vals[_i2];\n\t\t\t\t\t\tif (_y_val === false) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_y_val = _y_val * scale_factors[_i2];\n\t\t\t\t\t\tctx.fillStyle = this.colorScale(_feature.pvals[_i2]);\n\t\t\t\t\t\tif (_y_val > 0) {\n\t\t\t\t\t\t\tvar y_pos = this.centers[_i2] - _y_val;\n\t\t\t\t\t\t\tvar color = this.config.sample_colors[_i2][0];\n\t\t\t\t\t\t\tif (_feature.pvals[_i2] > pval) {\n\t\t\t\t\t\t\t\tcolor = \"lightgray\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\t\t\tctx.fillRect(_feature.x_pos - _feature.len / 2, y_pos, _feature.len, _y_val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar _color = this.config.sample_colors[_i2][1];\n\t\t\t\t\t\t\tif (_feature.pvals[_i2] > pval) {\n\t\t\t\t\t\t\t\t_color = \"lightgray\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx.fillStyle = _color;\n\t\t\t\t\t\t\tctx.fillRect(_feature.x_pos - _feature.len / 2, this.centers[_i2], _feature.len, -_y_val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bot;\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx, offset) {\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tif (featureList[0]) {\n\t\t\t\tvar p = ctx.getImageData(coord.x, coord.y + offset, 1, 1).data;\n\t\t\t\tif (p[0] === 0 && p[1] === 0 && p[2] === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar feature = featureList[0];\n\t\t\t\tvar each = this.config.height / this.config.samples.length;\n\t\t\t\tvar sample = Math.floor((coord.y - this.top) / each);\n\t\t\t\tvar id = feature.data[sample][0];\n\t\t\t\tfeature.id = id;\n\t\t\t\treturn feature;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"colorScale\",\n\t\tvalue: function colorScale(val, max) {\n\t\t\tvar perc = val / 40 * 100;\n\t\t\tperc = perc > 100 ? 100 : perc;\n\t\t\tvar r,\n\t\t\t    g,\n\t\t\t    b = 0;\n\t\t\tif (perc < 50) {\n\t\t\t\tg = 255;\n\t\t\t\tr = Math.round(5.1 * perc);\n\t\t\t} else {\n\t\t\t\tr = 255;\n\t\t\t\tg = Math.round(510 - 5.10 * perc);\n\t\t\t}\n\t\t\tvar h = r * 0x10000 + g * 0x100 + b * 0x1;\n\t\t\treturn '#' + ('000000' + h.toString(16)).slice(-6);\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\t\t\tvar bot = this.bottom;\n\t\t\tvar top = this.top;\n\t\t\tvar each = (bot - top) / this.config.samples.length;\n\t\t\tctx.save();\n\t\t\tctx.rect(0, top, 120, bot - top);\n\t\t\tctx.clip();\n\n\t\t\tctx.fillStyle = \"black\";\n\t\t\tctx.textAlign = \"left\";\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(0, top);\n\t\t\tctx.lineTo(0, bot);\n\t\t\tfor (var x = 0; x < this.config.samples.length; x++) {\n\t\t\t\tif (!this.max_y_vals[x]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar y_pos = top + x * each;\n\t\t\t\tctx.moveTo(0, y_pos);\n\t\t\t\tctx.lineTo(20, y_pos);\n\t\t\t\tctx.textBaseline = \"top\";\n\t\t\t\tctx.fillText(this.max_y_vals[x].toFixed(2), 20, y_pos);\n\n\t\t\t\tctx.moveTo(0, this.centers[x]);\n\t\t\t\tctx.lineTo(20, this.centers[x]);\n\t\t\t\tctx.textBaseLine = \"middle\";\n\t\t\t\tctx.fillText(this.config.samples[x], 3, y_pos + each / 2);\n\n\t\t\t\ty_pos = y_pos + each;\n\t\t\t\tctx.moveTo(0, y_pos);\n\t\t\t\tctx.lineTo(20, y_pos);\n\t\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\t\tctx.fillText(this.min_y_vals[x], 20, y_pos);\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t}]);\n\n\treturn MLVDESeqTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_deseq_track\"] = {\n\t\"class\": MLVDESeqTrack\n};\n\nexports.MLVDESeqTrack = MLVDESeqTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9tbHZfZGVzZXFfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvbWx2X2Rlc2VxX3RyYWNrLmpzPzBjMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtCaWdCZWRGZWF0dXJlU291cmNlLFRhYml4QmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy9mZWF0dXJlLmpzXCI7XHJcbmltcG9ydCB7TUxWQmVkVHJhY2ssTUxWVHJhY2t9IGZyb20gXCIuLi8uLi8uLi9NTFZQYW5lbC9zcmMvdHJhY2tzLmpzXCI7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldERlY29kZUZ1bmN0aW9uKHNhbXBsZV9zaXplKXtcclxuXHRsZXQgbWF4ID0gc2FtcGxlX3NpemUqM1xyXG5cdHJldHVybiBmdW5jdGlvbih0b2tlbnMsZmVhdHVyZSl7XHJcblx0XHRmZWF0dXJlLmRhdGE9W107XHJcblx0XHRmb3IgKGxldCBpPTA7aTxtYXg7aSs9Myl7XHJcblx0XHRcdGZlYXR1cmUuZGF0YS5wdXNoKFtwYXJzZUZsb2F0KHRva2Vuc1tpXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsxXSkscGFyc2VGbG9hdCh0b2tlbnNbaSsyXSldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIE1MVkRFU2VxVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcbiAgICBcdGNvbmZpZy5mb3JtYXQ9XCJmZWF0dXJlXCI7XHJcbiAgICBcdGlmICghY29uZmlnLmNvbG9ycyl7XHJcbiAgICBcdFx0Y29uZmlnLmNvbG9ycz1bXCIjRkYwMDAwXCIsXCIjMDAwMEZGXCIsXCIjMDA4MDAwXCJdXHJcbiAgICBcdH1cclxuICAgIFx0aWYgKCFjb25maWcucHZhbHVlX2N1dG9mZil7XHJcbiAgICBcdFx0Y29uZmlnLnB2YWx1ZV9jdXRvZmY9MC4wNTtcclxuICAgIFx0fVxyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHRpZiAodGhpcy5jb25maWcudXJsICYmIHRoaXMuY29uZmlnLnVybC5lbmRzV2l0aChcIi5nelwiKSl7XHJcblx0XHRcdHRoaXMuZmVhdHVyZV9zb3VyY2UgPSBuZXcgVGFiaXhCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnLGdldERlY29kZUZ1bmN0aW9uKHRoaXMuY29uZmlnLnNhbXBsZXMubGVuZ3RoKSk7XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZ2V0RGVjb2RlRnVuY3Rpb24odGhpcy5jb25maWcuc2FtcGxlcy5sZW5ndGgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGlhbG9nKXtcclxuXHRcdGxldCBzZWxmID0gdGhpcztcclxuXHRcdGRpYWxvZy5kaXYuZW1wdHkoKTtcclxuXHRcdFxyXG5cdFx0bGV0IGhlaWdodF9kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuXHJcblx0XHRoZWlnaHRfZGl2LmFwcGVuZChcIjxsYWJlbD5oZWlnaHQ6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcblxyXG5cdFx0bGV0IGhlaWdodF9zbGlkZXIgPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG5cdFx0XHRtaW46IDEwLFxyXG5cdFx0XHRtYXg6IDUwMCxcclxuXHRcdFx0dmFsdWU6ZGlhbG9nLmNvbmZpZy5oZWlnaHQsXHJcblx0XHRcdHNsaWRlOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xyXG5cdFx0XHRcdGRpYWxvZy5jb25maWcuaGVpZ2h0PSB1aS52YWx1ZTtcclxuXHRcdFx0XHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcImhlaWdodFwiLGRpYWxvZy5jb25maWcuaGVpZ2h0KTtcclxuXHRcdFx0XHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9KS5jc3Moe1wibWFyZ2luXCI6XCI1cHggM3B4XCJ9KTtcclxuXHRcdGhlaWdodF9zbGlkZXIuYXBwZW5kVG8oaGVpZ2h0X2Rpdik7XHJcblxyXG4gICAgICAgIGxldCBwdmFsX2Rpdj0kKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpLmFwcGVuZChcIjxsYWJlbD5wVmFsdWU6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcbiAgICAgICAgZGlhbG9nLnB2YWxfc2xpZGVyPSQoXCI8ZGl2PlwiKS5zbGlkZXIoe1xyXG4gICAgICAgXHRcdG1heDoxLFxyXG4gICAgICAgXHRcdG1pbjowLFxyXG4gICAgICAgXHRcdHN0ZXA6MC4wMSxcclxuICAgICAgIFx0XHR2YWx1ZTpkaWFsb2cuY29uZmlnLnB2YWx1ZV9jdXRvZmYsXHJcbiAgICAgICBcdFx0c2xpZGU6ZnVuY3Rpb24oZSx1aSl7XHJcbiAgICAgICAgICAgXHRcdGRpYWxvZy5jb25maWcucHZhbHVlX2N1dG9mZj11aS52YWx1ZVxyXG4gICAgICAgICAgIFx0XHRpZiAoZGlhbG9nLnBhbmVsKXtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnNldFRyYWNrQXR0cmlidXRlKGRpYWxvZy5jb25maWcudHJhY2tfaWQsXCJwdmFsdWVfY3V0b2ZmXCIsdWkudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwudXBkYXRlKCk7XHJcbiAgICAgICAgICAgXHRcdH1cclxuICAgICAgICAgICBcdFx0ZGlhbG9nLnB2YWxfaW5wdXQudmFsKHVpLnZhbHVlKVxyXG4gICAgICAgXHRcdH0gXHJcbiAgICBcdH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pLmFwcGVuZFRvKHB2YWxfZGl2KTtcclxuICAgIFx0ZGlhbG9nLnB2YWxfaW5wdXQ9JChcIjxpbnB1dD5cIikub24oXCJibHVyIGtleXByZXNzXCIsZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB5ID1kaWFsb2cucHZhbF9pbnB1dC52YWwoKTtcclxuICAgICAgICAgICAgICAgIHk9cGFyc2VGbG9hdCh5KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTih5KSAgfHwgeTwwIHx8IHk+MSl7XHJcbiAgICAgICAgICAgICAgICBcdHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzID0gZGlhbG9nLnB2YWxfc2xpZGVyO1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzLnNsaWRlcihcIm9wdGlvblwiLFwidmFsdWVcIix5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWFsb2cucGFuZWwpe1xyXG4gICAgICAgICAgICAgICAgXHRkaWFsb2cucGFuZWwuc2V0VHJhY2tBdHRyaWJ1dGUoZGlhbG9nLmNvbmZpZy50cmFja19pZCxcInB2YWx1ZV9jdXRvZmZcIix5KTtcclxuICAgICAgICAgICAgICAgIFx0ZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgIFx0XHR9XHJcbiAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pLndpZHRoKDUwKS52YWwoZGlhbG9nLmNvbmZpZy5wdmFsdWVfY3V0b2ZmKS5hcHBlbmRUbyhwdmFsX2Rpdik7XHJcbiAgICAgICAgICBcclxuXHRcdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKXtcclxuXHRcdGxldCBmZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XHJcblx0XHRsZXQgcHZhbD0gdGhpcy5jb25maWcucHZhbHVlX2N1dG9mZjtcclxuXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0bGV0IHRvcCA9IG9wdGlvbnMudG9wXHJcblx0XHRsZXQgYm90ID1wYXJzZUludCh0b3ApK3BhcnNlSW50KHRoaXMuY29uZmlnLmhlaWdodClcclxuXHRcdHRoaXMudG9wPXRvcDtcclxuXHRcdHRoaXMuYm90dG9tPWJvdDtcclxuXHRcdGxldCBjdHg9b3B0aW9ucy5jb250ZXh0O1xyXG5cdFx0bGV0IGNvbG9ycz0gdGhpcy5jb25maWcuY29sb3JzXHJcblx0XHRsZXQgeV9tYXggPXRoaXMuY29uZmlnLnlfbWF4P3RoaXMuY29uZmlnLnlfbWF4OnRoaXMuY29uZmlnLmluaXRpYWxfeV9tYXg7XHJcblx0XHRsZXQgd2lnX2hlaWdodCA9IHRoaXMuY29uZmlnLmhlaWdodFxyXG5cdFx0bGV0IHNfcyA9IHRoaXMuY29uZmlnLnNhbXBsZXMubGVuZ3RoO1xyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgZHJhd249MDtcclxuXHJcblx0XHRsZXQgZGlzcGxheV9mZWF0dXJlcz1bXTtcclxuXHRcdHRoaXMubWF4X3lfdmFscz1bXTtcclxuXHRcdHRoaXMubWluX3lfdmFscz1bXTtcclxuXHRcdGZvciAobGV0IG49MDtuPHNfcztuKyspe1xyXG5cdFx0XHR0aGlzLm1heF95X3ZhbHMucHVzaCgwKTtcclxuXHRcdFx0dGhpcy5taW5feV92YWxzLnB1c2goMCk7XHJcblx0XHR9XHJcblx0XHQvL2ZpcnN0IHBhcnNlIGNvbGxlY3RpbmcgaW5mb1xyXG5cdFx0Zm9yIChsZXQgeD0wO3g8ZmVhdHVyZXMubGVuZ3RoO3grKyl7XHJcblx0XHRcdGxldCBmZWF0dXJlID1mZWF0dXJlc1t4XTtcclxuXHRcdFxyXG5cdFx0XHRsZXQgbGVuID0gZmVhdHVyZS5lbmQtZmVhdHVyZS5zdGFydFxyXG5cdFx0XHRsZXQgeF9wb3MgPSAoZmVhdHVyZS5zdGFydCsobGVuLzIpLW9wdGlvbnMuYnBTdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG5cdFx0XHRpZiAoeF9wb3M+Y291bnQpe1xyXG5cdFx0XHRcdGNvdW50PU1hdGguZmxvb3IoeF9wb3MpKzE7XHJcblx0XHRcdFx0ZHJhd24rKztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNle1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxlbiA9IGxlbi9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdGlmIChsZW48MSl7XHJcblx0XHRcdFx0bGVuID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgdF95PVtdO1xyXG5cdFx0XHRsZXQgZmlsdGVyZWRfdmFscz0wO1xyXG5cdFx0XHRsZXQgZGlzcF9mZWF0dXJlPXt4X3Bvczp4X3BvcyxsZW46bGVuLHlfdmFsczpbXSxwdmFsczpbXX1cclxuXHRcdFx0Zm9yIChsZXQgaT0wO2k8c19zO2krKyl7XHJcblx0XHRcdFx0aWYgKHRoaXMuZmlsdGVyX2Z1bmN0aW9uKXtcclxuXHRcdFx0XHRcdGZlYXR1cmUuaWQ9ZmVhdHVyZS5kYXRhW2ldWzBdO1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmZpbHRlcl9mdW5jdGlvbihmZWF0dXJlKSl7XHJcblx0XHRcdFx0XHRcdGZpbHRlcmVkX3ZhbHMrKztcclxuXHRcdFx0XHRcdFx0ZGlzcF9mZWF0dXJlLnlfdmFscy5wdXNoKGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgeV92YWw9IGZlYXR1cmUuZGF0YVtpXVsxXTtcclxuXHRcdFx0XHJcblx0XHRcdFx0aWYgKHlfdmFsPnRoaXMubWF4X3lfdmFsc1tpXSl7XHJcblx0XHRcdFx0XHR0aGlzLm1heF95X3ZhbHNbaV09eV92YWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHlfdmFsPHRoaXMubWluX3lfdmFsc1tpXSl7XHJcblx0XHRcdFx0XHR0aGlzLm1pbl95X3ZhbHNbaV09eV92YWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRpc3BfZmVhdHVyZS55X3ZhbHMucHVzaCh5X3ZhbCk7XHJcblx0XHRcdFx0ZGlzcF9mZWF0dXJlLnB2YWxzLnB1c2goZmVhdHVyZS5kYXRhW2ldWzJdKVxyXG5cdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZmlsdGVyZWRfdmFscyE9PXNfcyl7XHJcblx0XHRcdFx0ZGlzcGxheV9mZWF0dXJlcy5wdXNoKGRpc3BfZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFxyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFxyXG5cdFx0dGhpcy5jZW50ZXJzPVtdO1xyXG5cdFx0bGV0IHlfdG9wcz1bXTtcclxuXHRcdGxldCBzY2FsZV9mYWN0b3JzPVtdO1xyXG5cdFx0bGV0IGVhY2ggPSB3aWdfaGVpZ2h0L3NfcztcclxuXHRcdGZvciAobGV0IGk9MDtpPHNfcztpKyspe1xyXG5cdFx0XHRsZXQgY2VudGVyPSgodGhpcy5tYXhfeV92YWxzW2ldLyh0aGlzLm1heF95X3ZhbHNbaV0tdGhpcy5taW5feV92YWxzW2ldKSkqZWFjaCkrKGkqZWFjaCk7XHJcblx0XHRcdHRoaXMuY2VudGVycy5wdXNoKGNlbnRlcit0b3ApO1xyXG5cdFx0XHR5X3RvcHMucHVzaCh0b3ArKGVhY2gqaSkpO1xyXG5cdFx0XHRzY2FsZV9mYWN0b3JzLnB1c2goZWFjaC8odGhpcy5tYXhfeV92YWxzW2ldLXRoaXMubWluX3lfdmFsc1tpXSkpO1xyXG5cdFx0fVxyXG5cdFx0Ly9jdHguZmlsbFN0eWxlPWNvbG9yc1tpXTtcclxuXHRcdC8vY3R4LnN0cm9rZVN0eWxlPWNvbG9yc1tpXTtcclxuXHRcdC8vY3R4Lmdsb2JhbEFscGhhPTAuNDtcclxuXHRcdGN0eC5nbG9iYWxBbHBoYT0xLjA7XHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIGRpc3BsYXlfZmVhdHVyZXMpe1xyXG5cdFx0XHRcclxuXHRcdFx0Zm9yIChsZXQgaT0wO2k8c19zO2krKyl7XHJcblx0XHRcdFx0bGV0IHlfdmFsPSBmZWF0dXJlLnlfdmFsc1tpXTtcclxuXHRcdFx0XHRpZiAoeV92YWw9PT1mYWxzZSl7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0eV92YWw9eV92YWwqc2NhbGVfZmFjdG9yc1tpXTtcclxuXHRcdFx0XHRjdHguZmlsbFN0eWxlPXRoaXMuY29sb3JTY2FsZShmZWF0dXJlLnB2YWxzW2ldKVxyXG5cdFx0XHRcdGlmICh5X3ZhbD4wKXtcclxuXHRcdFx0XHRcdGxldCB5X3BvcyA9dGhpcy5jZW50ZXJzW2ldLXlfdmFsO1xyXG5cdFx0XHRcdFx0bGV0IGNvbG9yID0gdGhpcy5jb25maWcuc2FtcGxlX2NvbG9yc1tpXVswXTtcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnB2YWxzW2ldPnB2YWwpe1xyXG5cdFx0XHRcdFx0XHRjb2xvcj1cImxpZ2h0Z3JheVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1jb2xvcjtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChmZWF0dXJlLnhfcG9zLShmZWF0dXJlLmxlbi8yKSx5X3BvcyxmZWF0dXJlLmxlbix5X3ZhbCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0bGV0IGNvbG9yID0gdGhpcy5jb25maWcuc2FtcGxlX2NvbG9yc1tpXVsxXTtcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnB2YWxzW2ldPnB2YWwpe1xyXG5cdFx0XHRcdFx0XHRjb2xvcj1cImxpZ2h0Z3JheVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZT1jb2xvcjtcclxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChmZWF0dXJlLnhfcG9zLShmZWF0dXJlLmxlbi8yKSx0aGlzLmNlbnRlcnNbaV0sZmVhdHVyZS5sZW4sLXlfdmFsKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblx0XHRcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0cmV0dXJuIGJvdFxyXG5cdFx0XHRcdFxyXG5cdH1cclxuXHJcblx0Z2V0RmVhdHVyZUF0KGdlbm9taWNMb2NhdGlvbiwgY2hyLCBjb29yZCwgYnBQZXJQaXhlbCxjdHgsb2Zmc2V0KXtcclxuXHRcdFxyXG4gICAgICAgIGxldCB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbDtcclxuICAgICAgICBsZXQgZmVhdHVyZUxpc3QgPSB0aGlzLmZlYXR1cmVfc291cmNlLmZlYXR1cmVDYWNoZS5xdWVyeUZlYXR1cmVzKGNociwgZ2Vub21pY0xvY2F0aW9uIC0gdG9sZXJhbmNlLCBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpXHJcblx0XHRpZiAoZmVhdHVyZUxpc3RbMF0pe1xyXG5cdFx0XHRsZXQgcCA9IGN0eC5nZXRJbWFnZURhdGEoY29vcmQueCwgY29vcmQueStvZmZzZXQsIDEsIDEpLmRhdGE7XHJcblx0XHRcdGlmKHBbMF09PT0wICYmIHBbMV09PT0wICYmIHBbMl09PT0wKXtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgZmVhdHVyZSA9IGZlYXR1cmVMaXN0WzBdO1xyXG5cdFx0XHRsZXQgZWFjaCA9IHRoaXMuY29uZmlnLmhlaWdodC90aGlzLmNvbmZpZy5zYW1wbGVzLmxlbmd0aDtcclxuXHRcdFx0bGV0IHNhbXBsZSA9IE1hdGguZmxvb3IoKGNvb3JkLnktdGhpcy50b3ApL2VhY2gpO1xyXG5cdFx0XHRsZXQgaWQgPWZlYXR1cmUuZGF0YVtzYW1wbGVdWzBdO1xyXG5cdFx0XHRmZWF0dXJlLmlkPWlkXHJcblx0XHRcdHJldHVybiBmZWF0dXJlO1xyXG5cclxuXHJcblxyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHRjb2xvclNjYWxlKHZhbCxtYXgpe1xyXG5cdFx0bGV0IHBlcmMgPSh2YWwvNDApKjEwMDtcclxuXHRcdHBlcmM9cGVyYz4xMDA/MTAwOnBlcmM7XHJcblx0dmFyIHIsIGcsIGIgPSAwO1xyXG5cdGlmKHBlcmMgPCA1MCl7XHJcblx0XHRnID0gMjU1O1xyXG5cdFx0ciA9IE1hdGgucm91bmQoNS4xICogcGVyYyk7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0ciA9IDI1NTtcclxuXHRcdGcgPSBNYXRoLnJvdW5kKDUxMCAtIDUuMTAgKiBwZXJjKTtcclxuXHR9XHJcblx0dmFyIGggPSByICogMHgxMDAwMCArIGcgKiAweDEwMCArIGIgKiAweDE7XHJcblx0cmV0dXJuICcjJyArICgnMDAwMDAwJyArIGgudG9TdHJpbmcoMTYpKS5zbGljZSgtNik7XHJcblxyXG5cdH1cclxuXHJcblx0ZHJhd1NjYWxlKHBpeGVsX2hlaWdodCxjdHgpe1xyXG5cdFx0bGV0IGJvdD0gdGhpcy5ib3R0b207XHJcblx0XHRsZXQgdG9wID0gdGhpcy50b3A7XHJcblx0XHRsZXQgZWFjaCA9IChib3QtdG9wKS90aGlzLmNvbmZpZy5zYW1wbGVzLmxlbmd0aDtcclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHgucmVjdCgwLHRvcCwxMjAsYm90LXRvcCk7XHJcblx0XHRjdHguY2xpcCgpO1xyXG5cdFxyXG5cdFx0Y3R4LmZpbGxTdHlsZT1cImJsYWNrXCI7XHJcblx0XHRjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcblx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdGN0eC5saW5lVG8oMCxib3QpO1xyXG5cdFx0Zm9yIChsZXQgeD0wO3g8dGhpcy5jb25maWcuc2FtcGxlcy5sZW5ndGg7eCsrKXtcclxuXHRcdFx0aWYgKCF0aGlzLm1heF95X3ZhbHNbeF0pe1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCB5X3BvcyA9IHRvcCsoeCplYWNoKTtcclxuXHRcdFx0Y3R4Lm1vdmVUbygwLHlfcG9zKTtcclxuXHRcdFx0Y3R4LmxpbmVUbygyMCx5X3Bvcyk7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWF4X3lfdmFsc1t4XS50b0ZpeGVkKDIpLDIwLHlfcG9zKTtcclxuXHJcblx0XHRcdGN0eC5tb3ZlVG8oMCx0aGlzLmNlbnRlcnNbeF0pO1xyXG5cdFx0XHRjdHgubGluZVRvKDIwLHRoaXMuY2VudGVyc1t4XSk7XHJcblx0XHRcdGN0eC50ZXh0QmFzZUxpbmU9XCJtaWRkbGVcIlxyXG5cdFx0XHRjdHguZmlsbFRleHQodGhpcy5jb25maWcuc2FtcGxlc1t4XSwzLHlfcG9zKyhlYWNoLzIpKTtcclxuXHJcblx0XHRcdHlfcG9zPXlfcG9zK2VhY2g7XHJcblx0XHRcdGN0eC5tb3ZlVG8oMCx5X3Bvcyk7XHJcblx0XHRcdGN0eC5saW5lVG8oMjAseV9wb3MpO1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiXHJcblx0XHRcdGN0eC5maWxsVGV4dCh0aGlzLm1pbl95X3ZhbHNbeF0sMjAseV9wb3MpO1xyXG5cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHJcblxyXG5cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y3R4LnN0cm9rZSgpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHJcblx0XHJcblx0fVxyXG5cclxuXHRcclxufVxyXG5cclxuTUxWVHJhY2sudHJhY2tfdHlwZXNbXCJtbHZfZGVzZXFfdHJhY2tcIl09e1xyXG5cdFwiY2xhc3NcIjpNTFZERVNlcVRyYWNrXHJcbn1cclxuXHJcblxyXG5leHBvcnQge01MVkRFU2VxVHJhY2t9O1xyXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEyRkE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQXpIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEySEE7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OztBQTNTQTtBQUNBO0FBK1NBO0FBQ0E7QUFEQTtBQUNBO0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lanceotron/src/mlv_deseq_track.js\n");

/***/ }),

/***/ "./lanceotron/src/mlv_peaky_track.js":
/*!*******************************************!*\
  !*** ./lanceotron/src/mlv_peaky_track.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.MLVPeakyTrack = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _feature = __webpack_require__(/*! ../../../MLVPanel/src/feature.js */ \"../MLVPanel/src/feature.js\");\n\nvar _tracks = __webpack_require__(/*! ../../../MLVPanel/src/tracks.js */ \"../MLVPanel/src/tracks.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar decode_function = function decode_function(tokens, feature) {\n\tfeature.rjmcmc = parseFloat(tokens[0]);\n\tfeature.id = parseInt(tokens[1]);\n};\n\nvar MLVPeakyTrack = function (_MLVBedTrack) {\n\t_inherits(MLVPeakyTrack, _MLVBedTrack);\n\n\tfunction MLVPeakyTrack() {\n\t\t_classCallCheck(this, MLVPeakyTrack);\n\n\t\treturn _possibleConstructorReturn(this, (MLVPeakyTrack.__proto__ || Object.getPrototypeOf(MLVPeakyTrack)).apply(this, arguments));\n\t}\n\n\t_createClass(MLVPeakyTrack, [{\n\t\tkey: \"_setFeatureSource\",\n\t\tvalue: function _setFeatureSource() {\n\t\t\tvar url = this.config.url;\n\t\t\tif (url.endsWith(\".bb\") || url.endsWith(\".bigbed\")) {\n\t\t\t\tthis.feature_source = new _feature.BigBedFeatureSource(this.config, decode_function);\n\t\t\t} else {\n\t\t\t\tthis.feature_source = new _feature.TabixBedFeatureSource(this.config, decode_function);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getFeatureAt\",\n\t\tvalue: function getFeatureAt(genomicLocation, chr, coord, bpPerPixel, ctx) {\n\t\t\tif (!this.y_field) {\n\t\t\t\treturn _get(MLVPeakyTrack.prototype.__proto__ || Object.getPrototypeOf(MLVPeakyTrack.prototype), \"getFeatureAt\", this).call(this, genomicLocation, chr, coord, bpPerPixel, ctx);\n\t\t\t}\n\n\t\t\tvar tolerance = 2 * bpPerPixel;\n\t\t\tvar featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance);\n\t\t\tvar height = this.config.height - 12;\n\t\t\tvar range = this.min_max[1] - this.min_max[0];\n\t\t\tvar field = this.y_field.field;\n\t\t\tvar bot = this.bottom - 12;\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = featureList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar feature = _step.value;\n\n\t\t\t\t\tvar item = this.data_view.getItemById(feature.id);\n\t\t\t\t\tif (!item) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = bot - (item[field] - this.min_max[0]) / range * height;\n\t\t\t\t\tif (coord.y >= y_val && coord.y <= y_val + 5) {\n\t\t\t\t\t\treturn feature;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}, {\n\t\tkey: \"addExtraControls\",\n\t\tvalue: function addExtraControls(dialog) {\n\t\t\tvar self = this;\n\t\t\tdialog.div.empty();\n\n\t\t\tvar height_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\theight_div.append(\"<label>Track Height:</label>\").appendTo(dialog.div);\n\n\t\t\tvar height_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 10,\n\t\t\t\tmax: 500,\n\t\t\t\tvalue: dialog.config.height,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.height = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"height\", dialog.config.height);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\theight_slider.appendTo(height_div);\n\n\t\t\tvar sig_div = $(\"<div class='t-d-div'></div>\");\n\n\t\t\tsig_div.append(\"<label>Significance Level:</label>\").appendTo(dialog.div);\n\n\t\t\tthis.sig_slider = $(\"<div>\").slider({\n\t\t\t\tmin: 0,\n\t\t\t\tmax: 1,\n\t\t\t\tstep: 0.01,\n\t\t\t\tvalue: dialog.config.sig_val,\n\t\t\t\tslide: function slide(event, ui) {\n\t\t\t\t\tdialog.config.sig_val = ui.value;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"sig_val\", dialog.config.sig_val);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\tself.sig_input.val(ui.value);\n\t\t\t\t}\n\t\t\t}).css({ \"margin\": \"5px 3px\" });\n\t\t\tthis.sig_slider.appendTo(sig_div);\n\t\t\tself.sig_input = $(\"<input>\").on(\"blur keypress\", function (e) {\n\t\t\t\tif (e.type === \"keypress\" && !(e.which === 13)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar sig = $(this).val();\n\t\t\t\tsig = parseFloat(sig);\n\t\t\t\tif (sig >= 0 && sig <= 1) {\n\t\t\t\t\tdialog.config.sig_val = sig;\n\t\t\t\t\tdialog.panel.setTrackAttribute(dialog.config.track_id, \"sig_val\", sig);\n\t\t\t\t\tdialog.panel.update();\n\t\t\t\t\tself.sig_slider.slider(\"option\", \"value\", sig);\n\t\t\t\t}\n\t\t\t}).appendTo(sig_div).width(40).val(self.config.sig_val);\n\t\t}\n\t}, {\n\t\tkey: \"drawScale\",\n\t\tvalue: function drawScale(pixel_height, ctx) {\n\n\t\t\t//ctx.save();\n\t\t\t//ctx.rect(0,top,120,this.bottom-this.top);\n\t\t\t//ctx.clip();\n\n\t\t\tvar sig_val = this.config.sig_val || this.config.sig_val === 0 ? this.config.sig_val : 0.1;\n\n\t\t\tvar bottom = this.bottom - 3;\n\t\t\tvar height = this.config.height / 2;\n\n\t\t\tvar sig_line_y = bottom - (sig_val - 0) / 1 * height;\n\n\t\t\tctx.textBaseline = \"alphabetic\";\n\t\t\tctx.fillText(sig_val, 20, sig_line_y - 2);\n\n\t\t\t//ctx.restore();\n\n\t\t}\n\t}, {\n\t\tkey: \"drawFeatures\",\n\t\tvalue: function drawFeatures(options) {\n\n\t\t\t/*if (!this.y_field){\r\n   \tsuper.drawFeatures(options);\r\n   \treturn;\r\n   */\n\t\t\tvar range = 1;\n\t\t\tvar ctx = options.context;\n\t\t\tthis.top = options.top;\n\t\t\tvar sig_val = this.config.sig_val || this.config.sig_val === 0 ? this.config.sig_val : 0.1;\n\n\t\t\tthis.bottom = this.top + this.config.height;\n\t\t\tvar bottom = this.bottom - 3;\n\t\t\tvar height = this.config.height / 2;\n\t\t\tvar bottom2 = this.bottom - height - 3;\n\n\t\t\tvar count = 0;\n\t\t\tvar vp_pos = (this.config.viewpoint - options.bpStart) / options.bpPerPixel;\n\t\t\tvar sig_line_y = bottom - (sig_val - 0) / range * height;\n\t\t\tctx.moveTo(0, sig_line_y);\n\t\t\tctx.strokeStyle = \"gray\";\n\t\t\tctx.lineTo(options.pixelWidth, sig_line_y);\n\t\t\tctx.stroke();\n\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = options.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar feature = _step2.value;\n\n\t\t\t\t\tvar sig = feature.rjmcmc >= sig_val;\n\t\t\t\t\tif (this.filter_function && !this.filter_function(feature)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar x_pos = (feature.start - options.bpStart) / options.bpPerPixel;\n\t\t\t\t\t/*if (x_pos>count){\r\n     count=Math.floor(x_pos)+1;\r\n     }\r\n     else{\r\n     continue;\r\n     }*/\n\n\t\t\t\t\tvar len = (feature.end - feature.start) / options.bpPerPixel;\n\n\t\t\t\t\tif (len < 2) {\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar y_val = (feature.rjmcmc - 0) / range * height;\n\n\t\t\t\t\tvar y_pos = bottom - y_val;\n\t\t\t\t\tvar color = sig ? \"red\" : \"gray\";\n\t\t\t\t\tctx.fillStyle = color;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(x_pos, y_pos, 3, 0, 2 * Math.PI, false);\n\t\t\t\t\tctx.fill();\n\n\t\t\t\t\t//remember any features drawn\n\n\t\t\t\t\t//draw the curve\n\n\t\t\t\t\tif (sig) {\n\t\t\t\t\t\tctx.moveTo(x_pos, bottom2);\n\t\t\t\t\t\tctx.bezierCurveTo(x_pos, bottom2 - height, vp_pos, bottom2 - height, vp_pos, bottom2);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\n\t\t\t\t\t//this.renderFeatureLabel(ctx, feature, x_pos, x_pos+len,y_pos , 0, options.pixelWidth);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.bottom;\n\t\t}\n\t}]);\n\n\treturn MLVPeakyTrack;\n}(_tracks.MLVBedTrack);\n\n_tracks.MLVTrack.track_types[\"mlv_peaky_track\"] = {\n\t\"class\": MLVPeakyTrack\n};\nexports.MLVPeakyTrack = MLVPeakyTrack;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5jZW90cm9uL3NyYy9tbHZfcGVha3lfdHJhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbGFuY2VvdHJvbi9zcmMvbWx2X3BlYWt5X3RyYWNrLmpzP2MzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtGZWF0dXJlU291cmNlLEJpZ0JlZEZlYXR1cmVTb3VyY2UsVGFiaXhCZWRGZWF0dXJlU291cmNlfSBmcm9tIFwiLi4vLi4vLi4vTUxWUGFuZWwvc3JjL2ZlYXR1cmUuanNcIjtcclxuaW1wb3J0IHtNTFZCZWRUcmFjayxNTFZUcmFja30gZnJvbSBcIi4uLy4uLy4uL01MVlBhbmVsL3NyYy90cmFja3MuanNcIjtcclxuXHJcbmxldCBkZWNvZGVfZnVuY3Rpb249IGZ1bmN0aW9uKHRva2VucyxmZWF0dXJlKXtcclxuXHRmZWF0dXJlLnJqbWNtYz1wYXJzZUZsb2F0KHRva2Vuc1swXSk7XHJcblx0ZmVhdHVyZS5pZD0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxufTtcclxuXHJcblxyXG5jbGFzcyBNTFZQZWFreVRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdGxldCB1cmwgPSB0aGlzLmNvbmZpZy51cmw7XHJcblx0XHRpZiAodXJsLmVuZHNXaXRoKFwiLmJiXCIpIHx8IHVybC5lbmRzV2l0aChcIi5iaWdiZWRcIikpe1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRlbHNle1xyXG5cdFx0XHR0aGlzLmZlYXR1cmVfc291cmNlID0gbmV3IFRhYml4QmVkRmVhdHVyZVNvdXJjZSh0aGlzLmNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCl7XHJcblx0XHRpZiAoIXRoaXMueV9maWVsZCl7XHJcblx0XHRcdHJldHVybiBzdXBlci5nZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsLGN0eCk7XHJcblx0XHR9XHJcblx0XHRcclxuICAgICAgICBsZXQgdG9sZXJhbmNlID0gMiAqIGJwUGVyUGl4ZWw7XHJcbiAgICAgICAgbGV0IGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmNvbmZpZy5oZWlnaHQtMTI7XHJcblx0XHRsZXQgcmFuZ2UgPSB0aGlzLm1pbl9tYXhbMV0tdGhpcy5taW5fbWF4WzBdO1xyXG5cdFx0bGV0IGZpZWxkID0gdGhpcy55X2ZpZWxkLmZpZWxkO1xyXG5cdFx0bGV0IGJvdCA9dGhpcy5ib3R0b20tMTI7XHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIGZlYXR1cmVMaXN0KXtcclxuXHRcdFx0bGV0IGl0ZW0gPSB0aGlzLmRhdGFfdmlldy5nZXRJdGVtQnlJZChmZWF0dXJlLmlkKTtcclxuXHRcdFx0aWYgKCFpdGVtKXtcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPWJvdC0oKChpdGVtW2ZpZWxkXS10aGlzLm1pbl9tYXhbMF0pL3JhbmdlKSpoZWlnaHQpO1xyXG5cdFx0XHRpZiAoY29vcmQueSA+PXlfdmFsICYmIGNvb3JkLnk8PXlfdmFsKzUpe1xyXG5cdFx0XHRcdHJldHVybiBmZWF0dXJlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHRhZGRFeHRyYUNvbnRyb2xzKGRpYWxvZyl7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcblx0XHRkaWFsb2cuZGl2LmVtcHR5KCk7XHJcblx0XHRcclxuICAgIFx0XHRsZXQgaGVpZ2h0X2Rpdj0kKFwiPGRpdiBjbGFzcz0ndC1kLWRpdic+PC9kaXY+XCIpO1xyXG4gICAgICAgIFx0XHJcblx0XHRcdGhlaWdodF9kaXYuYXBwZW5kKFwiPGxhYmVsPlRyYWNrIEhlaWdodDo8L2xhYmVsPlwiKS5hcHBlbmRUbyhkaWFsb2cuZGl2KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoZWlnaHRfc2xpZGVyID0kKFwiPGRpdj5cIikuc2xpZGVyKHtcclxuICAgICAgICAgICAgICAgIG1pbjogMTAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IDUwMCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOmRpYWxvZy5jb25maWcuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmNvbmZpZy5oZWlnaHQ9IHVpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwiaGVpZ2h0XCIsZGlhbG9nLmNvbmZpZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgICAgICBoZWlnaHRfc2xpZGVyLmFwcGVuZFRvKGhlaWdodF9kaXYpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNpZ19kaXY9JChcIjxkaXYgY2xhc3M9J3QtZC1kaXYnPjwvZGl2PlwiKTtcclxuICAgICAgICBcdFxyXG5cdFx0XHRzaWdfZGl2LmFwcGVuZChcIjxsYWJlbD5TaWduaWZpY2FuY2UgTGV2ZWw6PC9sYWJlbD5cIikuYXBwZW5kVG8oZGlhbG9nLmRpdik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2lnX3NsaWRlciA9JChcIjxkaXY+XCIpLnNsaWRlcih7XHJcbiAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IDEsXHJcbiAgICAgICAgICAgICAgICBzdGVwOjAuMDEsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTpkaWFsb2cuY29uZmlnLnNpZ192YWwsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29uZmlnLnNpZ192YWw9IHVpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwic2lnX3ZhbFwiLGRpYWxvZy5jb25maWcuc2lnX3ZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2lnX2lucHV0LnZhbCh1aS52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNzcyh7XCJtYXJnaW5cIjpcIjVweCAzcHhcIn0pO1xyXG4gICAgICAgICAgICB0aGlzLnNpZ19zbGlkZXIuYXBwZW5kVG8oc2lnX2Rpdik7XHJcbiAgICAgICAgICAgIHNlbGYuc2lnX2lucHV0PSQoXCI8aW5wdXQ+XCIpLm9uKFwiYmx1ciBrZXlwcmVzc1wiLGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZT09PVwia2V5cHJlc3NcIiAmJiAhKGUud2hpY2g9PT0xMykpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzaWc9ICQodGhpcykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBzaWc9cGFyc2VGbG9hdChzaWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZz49MCAmJiBzaWc8PTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jb25maWcuc2lnX3ZhbD0gc2lnO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5wYW5lbC5zZXRUcmFja0F0dHJpYnV0ZShkaWFsb2cuY29uZmlnLnRyYWNrX2lkLFwic2lnX3ZhbFwiLHNpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhbmVsLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2lnX3NsaWRlci5zbGlkZXIoXCJvcHRpb25cIixcInZhbHVlXCIsc2lnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSkuYXBwZW5kVG8oc2lnX2Rpdikud2lkdGgoNDApLnZhbChzZWxmLmNvbmZpZy5zaWdfdmFsKTtcclxuXHJcbiAgICAgICAgIFxyXG4gICBcclxuIFx0XHJcblx0XHRcdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5cclxuXHRkcmF3U2NhbGUocGl4ZWxfaGVpZ2h0LGN0eCl7XHJcblx0XHJcblx0XHJcblx0XHQvL2N0eC5zYXZlKCk7XHJcblx0XHQvL2N0eC5yZWN0KDAsdG9wLDEyMCx0aGlzLmJvdHRvbS10aGlzLnRvcCk7XHJcblx0XHQvL2N0eC5jbGlwKCk7XHJcblxyXG5cdFx0bGV0IHNpZ192YWwgPSB0aGlzLmNvbmZpZy5zaWdfdmFsIHx8IHRoaXMuY29uZmlnLnNpZ192YWw9PT0wP3RoaXMuY29uZmlnLnNpZ192YWw6MC4xXHJcblxyXG5cdFxyXG5cclxuXHRcdFxyXG5cdFx0bGV0IGJvdHRvbSA9dGhpcy5ib3R0b20tM1xyXG5cdFx0bGV0IGhlaWdodCA9dGhpcy5jb25maWcuaGVpZ2h0LzI7XHJcblx0XHRcclxuXHJcblx0XHRcclxuXHRcdGxldCBzaWdfbGluZV95ID0gYm90dG9tLSgoKHNpZ192YWwtMCkvMSkqaGVpZ2h0KTtcclxuXHRcclxuXHRcclxuXHJcblx0XHRcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCJcclxuXHRcdGN0eC5maWxsVGV4dChzaWdfdmFsLDIwLHNpZ19saW5lX3ktMik7XHJcblxyXG5cdFx0Ly9jdHgucmVzdG9yZSgpO1xyXG5cclxuXHRcclxuXHR9XHJcblxyXG5cclxuXHRkcmF3RmVhdHVyZXMob3B0aW9ucyl7XHJcblx0XHJcblx0XHQvKmlmICghdGhpcy55X2ZpZWxkKXtcclxuXHRcdFx0c3VwZXIuZHJhd0ZlYXR1cmVzKG9wdGlvbnMpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHQqL1xyXG5cdFx0bGV0IHJhbmdlID0gMTtcclxuXHRcdGxldCBjdHg9b3B0aW9ucy5jb250ZXh0O1xyXG5cdFx0dGhpcy50b3A9b3B0aW9ucy50b3A7XHJcblx0XHRsZXQgc2lnX3ZhbCA9IHRoaXMuY29uZmlnLnNpZ192YWwgfHwgdGhpcy5jb25maWcuc2lnX3ZhbD09PTA/dGhpcy5jb25maWcuc2lnX3ZhbDowLjFcclxuXHJcblx0XHJcblxyXG5cdFx0dGhpcy5ib3R0b209dGhpcy50b3ArdGhpcy5jb25maWcuaGVpZ2h0O1xyXG5cdFx0bGV0IGJvdHRvbSA9dGhpcy5ib3R0b20tM1xyXG5cdFx0bGV0IGhlaWdodCA9dGhpcy5jb25maWcuaGVpZ2h0LzI7XHJcblx0XHRsZXQgYm90dG9tMj0gdGhpcy5ib3R0b20taGVpZ2h0LTM7XHJcblxyXG5cdFx0bGV0IGNvdW50PTA7XHJcblx0XHRsZXQgdnBfcG9zID0gKHRoaXMuY29uZmlnLnZpZXdwb2ludC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuXHRcdGxldCBzaWdfbGluZV95ID0gYm90dG9tLSgoKHNpZ192YWwtMCkvcmFuZ2UpKmhlaWdodCk7XHJcblx0XHRjdHgubW92ZVRvKDAsc2lnX2xpbmVfeSk7XHJcblx0XHRjdHguc3Ryb2tlU3R5bGU9XCJncmF5XCI7XHJcblx0XHRjdHgubGluZVRvKG9wdGlvbnMucGl4ZWxXaWR0aCxzaWdfbGluZV95KTtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHJcblx0XHRmb3IgKGxldCBmZWF0dXJlIG9mIG9wdGlvbnMuZmVhdHVyZXMpe1xyXG5cdFx0XHRsZXQgc2lnID0gZmVhdHVyZS5yam1jbWM+PXNpZ192YWw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl9mdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJfZnVuY3Rpb24oZmVhdHVyZSkpe1xyXG4gICAgICAgICAgICBcdGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeF9wb3MgPSAoZmVhdHVyZS5zdGFydC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuICAgICAgICAgICAgLyppZiAoeF9wb3M+Y291bnQpe1xyXG5cdFx0XHRcdGNvdW50PU1hdGguZmxvb3IoeF9wb3MpKzE7XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fSovXHJcblxyXG5cclxuXHRcdFx0bGV0IGxlbiA9IChmZWF0dXJlLmVuZC1mZWF0dXJlLnN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobGVuPDIpe1xyXG5cdFx0XHRcdGxlbiA9IDI7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgeV92YWwgPSgoZmVhdHVyZS5yam1jbWMtMCkvcmFuZ2UpKmhlaWdodDtcclxuXHRcdFxyXG4gICAgXHRcdGxldCB5X3Bvcz1ib3R0b20teV92YWw7XHJcbiAgICBcdFx0bGV0IGNvbG9yICA9IHNpZz9cInJlZFwiOlwiZ3JheVwiXHJcblx0XHRcdGN0eC5maWxsU3R5bGU9Y29sb3I7XHJcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgXHRcdGN0eC5hcmMoeF9wb3MsIHlfcG9zLCAzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICBcdFx0Y3R4LmZpbGwoKVxyXG5cclxuICAgICAgXHRcdFxyXG5cdFx0XHQvL3JlbWVtYmVyIGFueSBmZWF0dXJlcyBkcmF3blxyXG5cdFx0XHRcclxuXHRcdFx0Ly9kcmF3IHRoZSBjdXJ2ZVxyXG5cclxuXHRcdFx0aWYgKHNpZyl7XHJcblx0XHRcdFx0Y3R4Lm1vdmVUbyh4X3Bvcyxib3R0b20yKTtcclxuXHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyh4X3Bvcyxib3R0b20yLWhlaWdodCx2cF9wb3MsYm90dG9tMi1oZWlnaHQsdnBfcG9zLGJvdHRvbTIpO1xyXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdFx0fVxyXG4gICAgXHJcblx0XHRcdC8vdGhpcy5yZW5kZXJGZWF0dXJlTGFiZWwoY3R4LCBmZWF0dXJlLCB4X3BvcywgeF9wb3MrbGVuLHlfcG9zICwgMCwgb3B0aW9ucy5waXhlbFdpZHRoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xyXG5cdH1cdFxyXG59XHJcblxyXG5NTFZUcmFjay50cmFja190eXBlc1tcIm1sdl9wZWFreV90cmFja1wiXT17XHJcblx0XCJjbGFzc1wiOk1MVlBlYWt5VHJhY2tcclxufVxyXG5leHBvcnQge01MVlBlYWt5VHJhY2t9OyBcclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXVCQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBTUE7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQTBCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1RUE7QUFDQTs7OztBQXROQTtBQUNBO0FBd05BO0FBQ0E7QUFEQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lanceotron/src/mlv_peaky_track.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css":
/*!**********************************************************!*\
  !*** ./node_modules/css-loader!.Panel/css/mlv_panel.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../MLV/node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".mlv-track-legend{\\r\\n\\tposition:absolute !important;\\r\\n\\ttop:0px;\\r\\n\\tleft:calc(100% - 155px);\\r\\n\\tborder:0.5px solid black;\\r\\n\\tfont-size:14px;\\r\\n\\tz-index:90;\\r\\n}\\r\\n\\r\\n\\r\\n.mlv-track-legend span{\\r\\n\\tdisplay:inline-block;\\r\\n\\tcursor:pointer;\\r\\n\\tmargin-right:2px;\\r\\n}\\r\\n\\r\\n.mlv-track-legend li{\\r\\n\\twhite-space:nowrap;\\r\\n}\\r\\n\\r\\n.mlv-track-legend-text {\\r\\n\\twhite-space:nowrap;\\r\\n\\toverflow:hidden;\\r\\n\\ttext-overflow:ellipsis;\\r\\n\\twidth: 100px;\\r\\n}\\r\\n\\r\\n\\r\\n.mlv-track-dialog label {\\r\\n\\tfont-weight:bold;\\r\\n\\tmargin-bottom:4px;\\r\\n\\tmargin-top:0px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog input[type=checkbox] {\\r\\n\\theight: 17px;\\r\\n\\twidth: 17px;\\r\\n\\t vertical-align: bottom;\\r\\n  position: relative;\\r\\n  margin-left:2px;\\r\\n  margin-bottom:2px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog span{\\r\\n\\tmargin-right:4px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog .fas{\\r\\n\\tcursor:pointer;\\r\\n\\tfont-size:16px;\\r\\n}\\r\\n\\r\\n.mlv-track-dialog hr {\\r\\n\\tmargin-top:10px;\\r\\n\\tmargin-bottom:2px;\\r\\n\\r\\n}\\r\\n\\r\\n.add-track-dialog label{\\r\\n\\tdisplay:block;\\r\\n\\tfont-weight:bold;\\r\\n\\tmargin-top:5px;\\r\\n\\r\\n}\\r\\n\\r\\n.browser-menu-panel button{\\r\\n\\tpadding-top: 2px;\\r\\n    padding-bottom: 2px;\\r\\n    margin-left: 2px;\\r\\n    margin-right: 2px;\\r\\n\\r\\n}\\r\\n\\r\\n.browser-menu-panel{\\r\\n\\toverflow:hidden;\\r\\n\\twhite-space:nowrap;\\r\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9NTFZQYW5lbC9jc3MvbWx2X3BhbmVsLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uUGFuZWwvY3NzL21sdl9wYW5lbC5jc3M/YWY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vTUxWL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubWx2LXRyYWNrLWxlZ2VuZHtcXHJcXG5cXHRwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O1xcclxcblxcdHRvcDowcHg7XFxyXFxuXFx0bGVmdDpjYWxjKDEwMCUgLSAxNTVweCk7XFxyXFxuXFx0Ym9yZGVyOjAuNXB4IHNvbGlkIGJsYWNrO1xcclxcblxcdGZvbnQtc2l6ZToxNHB4O1xcclxcblxcdHotaW5kZXg6OTA7XFxyXFxufVxcclxcblxcclxcblxcclxcbi5tbHYtdHJhY2stbGVnZW5kIHNwYW57XFxyXFxuXFx0ZGlzcGxheTppbmxpbmUtYmxvY2s7XFxyXFxuXFx0Y3Vyc29yOnBvaW50ZXI7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OjJweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1sdi10cmFjay1sZWdlbmQgbGl7XFxyXFxuXFx0d2hpdGUtc3BhY2U6bm93cmFwO1xcclxcbn1cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWxlZ2VuZC10ZXh0IHtcXHJcXG5cXHR3aGl0ZS1zcGFjZTpub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6aGlkZGVuO1xcclxcblxcdHRleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7XFxyXFxuXFx0d2lkdGg6IDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWRpYWxvZyBsYWJlbCB7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6Ym9sZDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOjRweDtcXHJcXG5cXHRtYXJnaW4tdG9wOjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1sdi10cmFjay1kaWFsb2cgaW5wdXRbdHlwZT1jaGVja2JveF0ge1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHR3aWR0aDogMTdweDtcXHJcXG5cXHQgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIG1hcmdpbi1sZWZ0OjJweDtcXHJcXG4gIG1hcmdpbi1ib3R0b206MnB4O1xcclxcbn1cXHJcXG5cXHJcXG4ubWx2LXRyYWNrLWRpYWxvZyBzcGFue1xcclxcblxcdG1hcmdpbi1yaWdodDo0cHg7XFxyXFxufVxcclxcblxcclxcbi5tbHYtdHJhY2stZGlhbG9nIC5mYXN7XFxyXFxuXFx0Y3Vyc29yOnBvaW50ZXI7XFxyXFxuXFx0Zm9udC1zaXplOjE2cHg7XFxyXFxufVxcclxcblxcclxcbi5tbHYtdHJhY2stZGlhbG9nIGhyIHtcXHJcXG5cXHRtYXJnaW4tdG9wOjEwcHg7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbToycHg7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5hZGQtdHJhY2stZGlhbG9nIGxhYmVse1xcclxcblxcdGRpc3BsYXk6YmxvY2s7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6Ym9sZDtcXHJcXG5cXHRtYXJnaW4tdG9wOjVweDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLmJyb3dzZXItbWVudS1wYW5lbCBidXR0b257XFxyXFxuXFx0cGFkZGluZy10b3A6IDJweDtcXHJcXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5icm93c2VyLW1lbnUtcGFuZWx7XFxyXFxuXFx0b3ZlcmZsb3c6aGlkZGVuO1xcclxcblxcdHdoaXRlLXNwYWNlOm5vd3JhcDtcXHJcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!../MLVPanel/css/mlv_panel.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif (item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function (modules, mediaQuery) {\n\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t}\n\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzPzRkYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n\t// get current location\n\tvar location = typeof window !== \"undefined\" && window.location;\n\n\tif (!location) {\n\t\tthrow new Error(\"fixUrls requires window.location\");\n\t}\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t\treturn css;\n\t}\n\n\tvar baseUrl = location.protocol + \"//\" + location.host;\n\tvar currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n This regular expression is just a way to recursively match brackets within\n a string.\n \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n    (  = Start a capturing group\n      (?:  = Start a non-capturing group\n          [^)(]  = Match anything that isn't a parentheses\n          |  = OR\n          \\(  = Match a start parentheses\n              (?:  = Start another non-capturing groups\n                  [^)(]+  = Match anything that isn't a parentheses\n                  |  = OR\n                  \\(  = Match a start parentheses\n                      [^)(]*  = Match anything that isn't a parentheses\n                  \\)  = Match a end parentheses\n              )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n  \\)  = Match a close parens\n \t /gi  = Get all matches, not the first.  Be case insensitive.\n  */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t}).replace(/^'(.*)'$/, function (o, $1) {\n\t\t\treturn $1;\n\t\t});\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t\treturn fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t\t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanM/NmFmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ })

/******/ });